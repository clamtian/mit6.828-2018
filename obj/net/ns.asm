
obj/net/ns:     file format elf32-i386


Disassembly of section .text:

00800020 <_start>:
// starts us running when we are initially loaded into a new environment.
.text
.globl _start
_start:
	// See if we were started with arguments on the stack
	cmpl $USTACKTOP, %esp
  800020:	81 fc 00 e0 bf ee    	cmp    $0xeebfe000,%esp
	jne args_exist
  800026:	75 04                	jne    80002c <args_exist>

	// If not, push dummy argc/argv arguments.
	// This happens when we are loaded by the kernel,
	// because the kernel does not know about passing arguments.
	pushl $0
  800028:	6a 00                	push   $0x0
	pushl $0
  80002a:	6a 00                	push   $0x0

0080002c <args_exist>:

args_exist:
	call libmain
  80002c:	e8 ae e7 00 00       	call   80e7df <libmain>
1:	jmp 1b
  800031:	eb fe                	jmp    800031 <args_exist+0x5>

00800033 <tcpip_init_done>:
		panic("cannot create timer thread: %s", e2s(r));
}

static void
tcpip_init_done(void *arg)
{
  800033:	f3 0f 1e fb          	endbr32 
  800037:	55                   	push   %ebp
  800038:	89 e5                	mov    %esp,%ebp
  80003a:	83 ec 14             	sub    $0x14,%esp
  80003d:	8b 45 08             	mov    0x8(%ebp),%eax
	uint32_t *done = arg;
	*done = 1;
  800040:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
	thread_wakeup(done);
  800046:	50                   	push   %eax
  800047:	e8 6c a7 00 00       	call   80a7b8 <thread_wakeup>
}
  80004c:	83 c4 10             	add    $0x10,%esp
  80004f:	c9                   	leave  
  800050:	c3                   	ret    

00800051 <start_timer>:
{
  800051:	55                   	push   %ebp
  800052:	89 e5                	mov    %esp,%ebp
  800054:	53                   	push   %ebx
  800055:	83 ec 04             	sub    $0x4,%esp
	t->msec = msec;
  800058:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80005b:	89 18                	mov    %ebx,(%eax)
	t->func = func;
  80005d:	89 50 04             	mov    %edx,0x4(%eax)
	t->name = name;
  800060:	89 48 08             	mov    %ecx,0x8(%eax)
	int r = thread_create(0, name, &net_timer, (uint32_t)t);
  800063:	50                   	push   %eax
  800064:	68 98 00 80 00       	push   $0x800098
  800069:	51                   	push   %ecx
  80006a:	6a 00                	push   $0x0
  80006c:	e8 be a7 00 00       	call   80a82f <thread_create>
	if (r < 0)
  800071:	83 c4 10             	add    $0x10,%esp
  800074:	85 c0                	test   %eax,%eax
  800076:	78 05                	js     80007d <start_timer+0x2c>
}
  800078:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80007b:	c9                   	leave  
  80007c:	c3                   	ret    
		panic("cannot create timer thread: %s", e2s(r));
  80007d:	83 ec 0c             	sub    $0xc,%esp
  800080:	50                   	push   %eax
  800081:	e8 f7 aa 00 00       	call   80ab7d <e2s>
  800086:	50                   	push   %eax
  800087:	68 00 12 81 00       	push   $0x811200
  80008c:	6a 7a                	push   $0x7a
  80008e:	68 35 13 81 00       	push   $0x811335
  800093:	e8 af e7 00 00       	call   80e847 <_panic>

00800098 <net_timer>:
{
  800098:	f3 0f 1e fb          	endbr32 
  80009c:	55                   	push   %ebp
  80009d:	89 e5                	mov    %esp,%ebp
  80009f:	56                   	push   %esi
  8000a0:	53                   	push   %ebx
	struct timer_thread *t = (struct timer_thread *) arg;
  8000a1:	8b 75 08             	mov    0x8(%ebp),%esi
		uint32_t cur = sys_time_msec();
  8000a4:	e8 e2 f4 00 00       	call   80f58b <sys_time_msec>
  8000a9:	89 c3                	mov    %eax,%ebx
		lwip_core_lock();
  8000ab:	e8 cf a6 00 00       	call   80a77f <lwip_core_lock>
		t->func();
  8000b0:	ff 56 04             	call   *0x4(%esi)
		lwip_core_unlock();
  8000b3:	e8 cc a6 00 00       	call   80a784 <lwip_core_unlock>
		thread_wait(0, 0, cur + t->msec);
  8000b8:	83 ec 04             	sub    $0x4,%esp
  8000bb:	03 1e                	add    (%esi),%ebx
  8000bd:	53                   	push   %ebx
  8000be:	6a 00                	push   $0x0
  8000c0:	6a 00                	push   $0x0
  8000c2:	e8 1c a9 00 00       	call   80a9e3 <thread_wait>
  8000c7:	83 c4 10             	add    $0x10,%esp
  8000ca:	eb d8                	jmp    8000a4 <net_timer+0xc>

008000cc <serve_thread>:
	uint32_t whom;
	union Nsipc *req;
};

static void
serve_thread(uint32_t a) {
  8000cc:	f3 0f 1e fb          	endbr32 
  8000d0:	55                   	push   %ebp
  8000d1:	89 e5                	mov    %esp,%ebp
  8000d3:	57                   	push   %edi
  8000d4:	56                   	push   %esi
  8000d5:	53                   	push   %ebx
  8000d6:	83 ec 7c             	sub    $0x7c,%esp
  8000d9:	8b 5d 08             	mov    0x8(%ebp),%ebx
	struct st_args *args = (struct st_args *)a;
	union Nsipc *req = args->req;
  8000dc:	8b 7b 08             	mov    0x8(%ebx),%edi
  8000df:	83 3b 0a             	cmpl   $0xa,(%ebx)
  8000e2:	0f 87 50 01 00 00    	ja     800238 <serve_thread+0x16c>
  8000e8:	8b 03                	mov    (%ebx),%eax
  8000ea:	3e ff 24 85 e0 13 81 	notrack jmp *0x8113e0(,%eax,4)
  8000f1:	00 

	switch (args->reqno) {
	case NSREQ_ACCEPT:
	{
		struct Nsret_accept ret;
		ret.ret_addrlen = req->accept.req_addrlen;
  8000f2:	8b 47 04             	mov    0x4(%edi),%eax
  8000f5:	89 45 94             	mov    %eax,-0x6c(%ebp)
		r = lwip_accept(req->accept.req_s, &ret.ret_addr,
  8000f8:	83 ec 04             	sub    $0x4,%esp
  8000fb:	8d 45 94             	lea    -0x6c(%ebp),%eax
  8000fe:	50                   	push   %eax
  8000ff:	8d 45 84             	lea    -0x7c(%ebp),%eax
  800102:	50                   	push   %eax
  800103:	ff 37                	pushl  (%edi)
  800105:	e8 2f 0d 00 00       	call   800e39 <lwip_accept>
  80010a:	89 c6                	mov    %eax,%esi
				&ret.ret_addrlen);
		memmove(req, &ret, sizeof ret);
  80010c:	83 c4 0c             	add    $0xc,%esp
  80010f:	6a 14                	push   $0x14
  800111:	8d 45 84             	lea    -0x7c(%ebp),%eax
  800114:	50                   	push   %eax
  800115:	57                   	push   %edi
  800116:	e8 d3 ef 00 00       	call   80f0ee <memmove>
  80011b:	83 c4 10             	add    $0x10,%esp
		cprintf("Invalid request code %d from %08x\n", args->whom, args->req);
		r = -E_INVAL;
		break;
	}

	if (r == -1) {
  80011e:	83 fe ff             	cmp    $0xffffffff,%esi
  800121:	0f 84 2f 01 00 00    	je     800256 <serve_thread+0x18a>
		char buf[100];
		snprintf(buf, sizeof buf, "ns req type %d", args->reqno);
		perror(buf);
	}

	if (args->reqno != NSREQ_INPUT)
  800127:	83 3b 0a             	cmpl   $0xa,(%ebx)
  80012a:	0f 85 48 01 00 00    	jne    800278 <serve_thread+0x1ac>
		ipc_send(args->whom, r, 0, 0);

	put_buffer(args->req);
  800130:	8b 53 08             	mov    0x8(%ebx),%edx
	int i = ((uint32_t)va - REQVA) / PGSIZE;
  800133:	8d 82 00 50 01 f0    	lea    -0xffeb000(%edx),%eax
  800139:	c1 e8 0c             	shr    $0xc,%eax
	buse[i] = 0;
  80013c:	c6 80 00 50 81 00 00 	movb   $0x0,0x815000(%eax)
	sys_page_unmap(0, (void*) args->req);
  800143:	83 ec 08             	sub    $0x8,%esp
  800146:	52                   	push   %edx
  800147:	6a 00                	push   $0x0
  800149:	e8 b9 f2 00 00       	call   80f407 <sys_page_unmap>
	free(args);
  80014e:	89 1c 24             	mov    %ebx,(%esp)
  800151:	e8 a6 05 01 00       	call   8106fc <free>
}
  800156:	83 c4 10             	add    $0x10,%esp
  800159:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80015c:	5b                   	pop    %ebx
  80015d:	5e                   	pop    %esi
  80015e:	5f                   	pop    %edi
  80015f:	5d                   	pop    %ebp
  800160:	c3                   	ret    
		r = lwip_bind(req->bind.req_s, &req->bind.req_name,
  800161:	83 ec 04             	sub    $0x4,%esp
  800164:	ff 77 14             	pushl  0x14(%edi)
  800167:	8d 47 04             	lea    0x4(%edi),%eax
  80016a:	50                   	push   %eax
  80016b:	ff 37                	pushl  (%edi)
  80016d:	e8 7d 0e 00 00       	call   800fef <lwip_bind>
  800172:	89 c6                	mov    %eax,%esi
		break;
  800174:	83 c4 10             	add    $0x10,%esp
  800177:	eb a5                	jmp    80011e <serve_thread+0x52>
		r = lwip_shutdown(req->shutdown.req_s, req->shutdown.req_how);
  800179:	83 ec 08             	sub    $0x8,%esp
  80017c:	ff 77 04             	pushl  0x4(%edi)
  80017f:	ff 37                	pushl  (%edi)
  800181:	e8 f4 19 00 00       	call   801b7a <lwip_shutdown>
  800186:	89 c6                	mov    %eax,%esi
		break;
  800188:	83 c4 10             	add    $0x10,%esp
  80018b:	eb 91                	jmp    80011e <serve_thread+0x52>
		r = lwip_close(req->close.req_s);
  80018d:	83 ec 0c             	sub    $0xc,%esp
  800190:	ff 37                	pushl  (%edi)
  800192:	e8 12 0f 00 00       	call   8010a9 <lwip_close>
  800197:	89 c6                	mov    %eax,%esi
		break;
  800199:	83 c4 10             	add    $0x10,%esp
  80019c:	eb 80                	jmp    80011e <serve_thread+0x52>
		r = lwip_connect(req->connect.req_s, &req->connect.req_name,
  80019e:	83 ec 04             	sub    $0x4,%esp
  8001a1:	ff 77 14             	pushl  0x14(%edi)
  8001a4:	8d 47 04             	lea    0x4(%edi),%eax
  8001a7:	50                   	push   %eax
  8001a8:	ff 37                	pushl  (%edi)
  8001aa:	e8 87 0f 00 00       	call   801136 <lwip_connect>
  8001af:	89 c6                	mov    %eax,%esi
		break;
  8001b1:	83 c4 10             	add    $0x10,%esp
  8001b4:	e9 65 ff ff ff       	jmp    80011e <serve_thread+0x52>
		r = lwip_listen(req->listen.req_s, req->listen.req_backlog);
  8001b9:	83 ec 08             	sub    $0x8,%esp
  8001bc:	ff 77 04             	pushl  0x4(%edi)
  8001bf:	ff 37                	pushl  (%edi)
  8001c1:	e8 2a 10 00 00       	call   8011f0 <lwip_listen>
  8001c6:	89 c6                	mov    %eax,%esi
		break;
  8001c8:	83 c4 10             	add    $0x10,%esp
  8001cb:	e9 4e ff ff ff       	jmp    80011e <serve_thread+0x52>
		r = lwip_recv(req->recv.req_s, req->recvRet.ret_buf,
  8001d0:	ff 77 08             	pushl  0x8(%edi)
  8001d3:	ff 77 04             	pushl  0x4(%edi)
  8001d6:	57                   	push   %edi
  8001d7:	ff 37                	pushl  (%edi)
  8001d9:	e8 09 13 00 00       	call   8014e7 <lwip_recv>
  8001de:	89 c6                	mov    %eax,%esi
		break;
  8001e0:	83 c4 10             	add    $0x10,%esp
  8001e3:	e9 36 ff ff ff       	jmp    80011e <serve_thread+0x52>
		r = lwip_send(req->send.req_s, &req->send.req_buf,
  8001e8:	ff 77 08             	pushl  0x8(%edi)
  8001eb:	ff 77 04             	pushl  0x4(%edi)
  8001ee:	8d 47 0c             	lea    0xc(%edi),%eax
  8001f1:	50                   	push   %eax
  8001f2:	ff 37                	pushl  (%edi)
  8001f4:	e8 88 14 00 00       	call   801681 <lwip_send>
  8001f9:	89 c6                	mov    %eax,%esi
		break;
  8001fb:	83 c4 10             	add    $0x10,%esp
  8001fe:	e9 1b ff ff ff       	jmp    80011e <serve_thread+0x52>
		r = lwip_socket(req->socket.req_domain, req->socket.req_type,
  800203:	83 ec 04             	sub    $0x4,%esp
  800206:	ff 77 08             	pushl  0x8(%edi)
  800209:	ff 77 04             	pushl  0x4(%edi)
  80020c:	ff 37                	pushl  (%edi)
  80020e:	e8 03 15 00 00       	call   801716 <lwip_socket>
  800213:	89 c6                	mov    %eax,%esi
		break;
  800215:	83 c4 10             	add    $0x10,%esp
  800218:	e9 01 ff ff ff       	jmp    80011e <serve_thread+0x52>
		jif_input(&nif, (void *)&req->pkt);
  80021d:	83 ec 08             	sub    $0x8,%esp
  800220:	57                   	push   %edi
  800221:	68 00 b2 b3 00       	push   $0xb3b200
  800226:	e8 4d aa 00 00       	call   80ac78 <jif_input>
  80022b:	83 c4 10             	add    $0x10,%esp
		r = 0;
  80022e:	be 00 00 00 00       	mov    $0x0,%esi
  800233:	e9 ef fe ff ff       	jmp    800127 <serve_thread+0x5b>
		cprintf("Invalid request code %d from %08x\n", args->whom, args->req);
  800238:	83 ec 04             	sub    $0x4,%esp
  80023b:	57                   	push   %edi
  80023c:	ff 73 04             	pushl  0x4(%ebx)
  80023f:	68 20 12 81 00       	push   $0x811220
  800244:	e8 e5 e6 00 00       	call   80e92e <cprintf>
  800249:	83 c4 10             	add    $0x10,%esp
		r = -E_INVAL;
  80024c:	be fd ff ff ff       	mov    $0xfffffffd,%esi
  800251:	e9 d1 fe ff ff       	jmp    800127 <serve_thread+0x5b>
		snprintf(buf, sizeof buf, "ns req type %d", args->reqno);
  800256:	ff 33                	pushl  (%ebx)
  800258:	68 40 13 81 00       	push   $0x811340
  80025d:	6a 64                	push   $0x64
  80025f:	8d 7d 84             	lea    -0x7c(%ebp),%edi
  800262:	57                   	push   %edi
  800263:	e8 6f ec 00 00       	call   80eed7 <snprintf>
		perror(buf);
  800268:	89 3c 24             	mov    %edi,(%esp)
  80026b:	e8 e5 a8 00 00       	call   80ab55 <perror>
  800270:	83 c4 10             	add    $0x10,%esp
  800273:	e9 af fe ff ff       	jmp    800127 <serve_thread+0x5b>
		ipc_send(args->whom, r, 0, 0);
  800278:	6a 00                	push   $0x0
  80027a:	6a 00                	push   $0x0
  80027c:	56                   	push   %esi
  80027d:	ff 73 04             	pushl  0x4(%ebx)
  800280:	e8 db f6 00 00       	call   80f960 <ipc_send>
  800285:	83 c4 10             	add    $0x10,%esp
  800288:	e9 a3 fe ff ff       	jmp    800130 <serve_thread+0x64>

0080028d <serve_init>:
{
  80028d:	f3 0f 1e fb          	endbr32 
  800291:	55                   	push   %ebp
  800292:	89 e5                	mov    %esp,%ebp
  800294:	56                   	push   %esi
  800295:	53                   	push   %ebx
  800296:	83 ec 10             	sub    $0x10,%esp
  800299:	8b 75 08             	mov    0x8(%ebp),%esi
	lwip_core_lock();
  80029c:	e8 de a4 00 00       	call   80a77f <lwip_core_lock>
	uint32_t done = 0;
  8002a1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	tcpip_init(&tcpip_init_done, &done);
  8002a8:	83 ec 08             	sub    $0x8,%esp
  8002ab:	8d 5d f4             	lea    -0xc(%ebp),%ebx
  8002ae:	53                   	push   %ebx
  8002af:	68 33 00 80 00       	push   $0x800033
  8002b4:	e8 9e 21 00 00       	call   802457 <tcpip_init>
	lwip_core_unlock();
  8002b9:	e8 c6 a4 00 00       	call   80a784 <lwip_core_unlock>
	thread_wait(&done, 0, (uint32_t)~0);
  8002be:	83 c4 0c             	add    $0xc,%esp
  8002c1:	6a ff                	push   $0xffffffff
  8002c3:	6a 00                	push   $0x0
  8002c5:	53                   	push   %ebx
  8002c6:	e8 18 a7 00 00       	call   80a9e3 <thread_wait>
	lwip_core_lock();
  8002cb:	e8 af a4 00 00       	call   80a77f <lwip_core_lock>
	ipaddr.addr  = init_addr;
  8002d0:	89 75 e8             	mov    %esi,-0x18(%ebp)
	netmask.addr = init_mask;
  8002d3:	8b 45 0c             	mov    0xc(%ebp),%eax
  8002d6:	89 45 ec             	mov    %eax,-0x14(%ebp)
	gateway.addr = init_gw;
  8002d9:	8b 45 10             	mov    0x10(%ebp),%eax
  8002dc:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (0 == netif_add(nif, &ipaddr, &netmask, &gateway,
  8002df:	83 c4 0c             	add    $0xc,%esp
  8002e2:	68 8c 66 80 00       	push   $0x80668c
  8002e7:	68 67 ad 80 00       	push   $0x80ad67
  8002ec:	68 14 50 81 00       	push   $0x815014
  8002f1:	8d 45 f0             	lea    -0x10(%ebp),%eax
  8002f4:	50                   	push   %eax
  8002f5:	8d 45 ec             	lea    -0x14(%ebp),%eax
  8002f8:	50                   	push   %eax
  8002f9:	8d 45 e8             	lea    -0x18(%ebp),%eax
  8002fc:	50                   	push   %eax
  8002fd:	68 00 b2 b3 00       	push   $0xb3b200
  800302:	e8 1b 44 00 00       	call   804722 <netif_add>
  800307:	83 c4 20             	add    $0x20,%esp
  80030a:	85 c0                	test   %eax,%eax
  80030c:	0f 84 cc 00 00 00    	je     8003de <serve_init+0x151>
	netif_set_default(nif);
  800312:	83 ec 0c             	sub    $0xc,%esp
  800315:	68 00 b2 b3 00       	push   $0xb3b200
  80031a:	e8 c1 44 00 00       	call   8047e0 <netif_set_default>
	netif_set_up(nif);
  80031f:	c7 04 24 00 b2 b3 00 	movl   $0xb3b200,(%esp)
  800326:	e8 c6 44 00 00       	call   8047f1 <netif_set_up>
	start_timer(&t_arp, &etharp_tmr, "arp timer", ARP_TMR_INTERVAL);
  80032b:	c7 04 24 88 13 00 00 	movl   $0x1388,(%esp)
  800332:	b9 4f 13 81 00       	mov    $0x81134f,%ecx
  800337:	ba a4 96 80 00       	mov    $0x8096a4,%edx
  80033c:	b8 34 50 81 00       	mov    $0x815034,%eax
  800341:	e8 0b fd ff ff       	call   800051 <start_timer>
	start_timer(&t_tcpf, &tcp_fasttmr, "tcp f timer", TCP_FAST_INTERVAL);
  800346:	c7 04 24 fa 00 00 00 	movl   $0xfa,(%esp)
  80034d:	b9 59 13 81 00       	mov    $0x811359,%ecx
  800352:	ba 03 58 80 00       	mov    $0x805803,%edx
  800357:	b8 28 50 81 00       	mov    $0x815028,%eax
  80035c:	e8 f0 fc ff ff       	call   800051 <start_timer>
	start_timer(&t_tcps, &tcp_slowtmr, "tcp s timer", TCP_SLOW_INTERVAL);
  800361:	c7 04 24 f4 01 00 00 	movl   $0x1f4,(%esp)
  800368:	b9 65 13 81 00       	mov    $0x811365,%ecx
  80036d:	ba da 5d 80 00       	mov    $0x805dda,%edx
  800372:	b8 1c 50 81 00       	mov    $0x81501c,%eax
  800377:	e8 d5 fc ff ff       	call   800051 <start_timer>
	cprintf("ns: %02x:%02x:%02x:%02x:%02x:%02x"
  80037c:	89 34 24             	mov    %esi,(%esp)
  80037f:	e8 38 74 00 00       	call   8077bc <inet_ntoa>
  800384:	50                   	push   %eax
  800385:	0f b6 05 2a b2 b3 00 	movzbl 0xb3b22a,%eax
  80038c:	50                   	push   %eax
  80038d:	0f b6 05 29 b2 b3 00 	movzbl 0xb3b229,%eax
  800394:	50                   	push   %eax
  800395:	0f b6 05 28 b2 b3 00 	movzbl 0xb3b228,%eax
  80039c:	50                   	push   %eax
  80039d:	0f b6 05 27 b2 b3 00 	movzbl 0xb3b227,%eax
  8003a4:	50                   	push   %eax
  8003a5:	0f b6 05 26 b2 b3 00 	movzbl 0xb3b226,%eax
  8003ac:	50                   	push   %eax
  8003ad:	0f b6 05 25 b2 b3 00 	movzbl 0xb3b225,%eax
  8003b4:	50                   	push   %eax
  8003b5:	68 64 12 81 00       	push   $0x811264
  8003ba:	e8 6f e5 00 00       	call   80e92e <cprintf>
	lwip_core_unlock();
  8003bf:	83 c4 30             	add    $0x30,%esp
  8003c2:	e8 bd a3 00 00       	call   80a784 <lwip_core_unlock>
	cprintf("NS: TCP/IP initialized.\n");
  8003c7:	83 ec 0c             	sub    $0xc,%esp
  8003ca:	68 71 13 81 00       	push   $0x811371
  8003cf:	e8 5a e5 00 00       	call   80e92e <cprintf>
}
  8003d4:	83 c4 10             	add    $0x10,%esp
  8003d7:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8003da:	5b                   	pop    %ebx
  8003db:	5e                   	pop    %esi
  8003dc:	5d                   	pop    %ebp
  8003dd:	c3                   	ret    
		panic("lwip_init: error in netif_add\n");
  8003de:	83 ec 04             	sub    $0x4,%esp
  8003e1:	68 44 12 81 00       	push   $0x811244
  8003e6:	6a 5c                	push   $0x5c
  8003e8:	68 35 13 81 00       	push   $0x811335
  8003ed:	e8 55 e4 00 00       	call   80e847 <_panic>

008003f2 <serve>:

void
serve(void) {
  8003f2:	f3 0f 1e fb          	endbr32 
  8003f6:	55                   	push   %ebp
  8003f7:	89 e5                	mov    %esp,%ebp
  8003f9:	57                   	push   %edi
  8003fa:	56                   	push   %esi
  8003fb:	53                   	push   %ebx
  8003fc:	83 ec 2c             	sub    $0x2c,%esp
		for (i = 0; thread_wakeups_pending() && i < 32; ++i)
			thread_yield();

		perm = 0;
		va = get_buffer();
		reqno = ipc_recv((int32_t *) &whom, (void *) va, &perm);
  8003ff:	8d 7d e0             	lea    -0x20(%ebp),%edi
  800402:	e9 9d 00 00 00       	jmp    8004a4 <serve+0xb2>
		perm = 0;
  800407:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	for (i = 0; i < QUEUE_SIZE; i++)
  80040e:	b8 00 00 00 00       	mov    $0x0,%eax
		if (!buse[i]) break;
  800413:	80 b8 00 50 81 00 00 	cmpb   $0x0,0x815000(%eax)
  80041a:	74 1c                	je     800438 <serve+0x46>
	for (i = 0; i < QUEUE_SIZE; i++)
  80041c:	83 c0 01             	add    $0x1,%eax
  80041f:	83 f8 14             	cmp    $0x14,%eax
  800422:	75 ef                	jne    800413 <serve+0x21>
		panic("NS: buffer overflow");
  800424:	83 ec 04             	sub    $0x4,%esp
  800427:	68 8a 13 81 00       	push   $0x81138a
  80042c:	6a 3f                	push   $0x3f
  80042e:	68 35 13 81 00       	push   $0x811335
  800433:	e8 0f e4 00 00       	call   80e847 <_panic>
	va = (void *)(REQVA + i * PGSIZE);
  800438:	8d 98 eb ff 00 00    	lea    0xffeb(%eax),%ebx
  80043e:	c1 e3 0c             	shl    $0xc,%ebx
	buse[i] = 1;
  800441:	c6 80 00 50 81 00 01 	movb   $0x1,0x815000(%eax)
		reqno = ipc_recv((int32_t *) &whom, (void *) va, &perm);
  800448:	83 ec 04             	sub    $0x4,%esp
  80044b:	57                   	push   %edi
  80044c:	53                   	push   %ebx
  80044d:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  800450:	50                   	push   %eax
  800451:	e8 96 f4 00 00       	call   80f8ec <ipc_recv>
  800456:	89 c6                	mov    %eax,%esi
		if (debug) {
			cprintf("ns req %d from %08x\n", reqno, whom);
		}

		// first take care of requests that do not contain an argument page
		if (reqno == NSREQ_TIMER) {
  800458:	83 c4 10             	add    $0x10,%esp
  80045b:	83 f8 0c             	cmp    $0xc,%eax
  80045e:	74 69                	je     8004c9 <serve+0xd7>
			put_buffer(va);
			continue;
		}

		// All remaining requests must contain an argument page
		if (!(perm & PTE_P)) {
  800460:	f6 45 e0 01          	testb  $0x1,-0x20(%ebp)
  800464:	0f 84 bb 00 00 00    	je     800525 <serve+0x133>
			continue; // just leave it hanging...
		}

		// Since some lwIP socket calls will block, create a thread and
		// process the rest of the request in the thread.
		struct st_args *args = malloc(sizeof(struct st_args));
  80046a:	83 ec 0c             	sub    $0xc,%esp
  80046d:	6a 0c                	push   $0xc
  80046f:	e8 38 03 01 00       	call   8107ac <malloc>
		if (!args)
  800474:	83 c4 10             	add    $0x10,%esp
  800477:	85 c0                	test   %eax,%eax
  800479:	0f 84 be 00 00 00    	je     80053d <serve+0x14b>
			panic("could not allocate thread args structure");

		args->reqno = reqno;
  80047f:	89 30                	mov    %esi,(%eax)
		args->whom = whom;
  800481:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  800484:	89 50 04             	mov    %edx,0x4(%eax)
		args->req = va;
  800487:	89 58 08             	mov    %ebx,0x8(%eax)

		thread_create(0, "serve_thread", serve_thread, (uint32_t)args);
  80048a:	50                   	push   %eax
  80048b:	68 cc 00 80 00       	push   $0x8000cc
  800490:	68 9e 13 81 00       	push   $0x81139e
  800495:	6a 00                	push   $0x0
  800497:	e8 93 a3 00 00       	call   80a82f <thread_create>
		thread_yield(); // let the thread created run
  80049c:	e8 bb a4 00 00       	call   80a95c <thread_yield>
  8004a1:	83 c4 10             	add    $0x10,%esp
		for (i = 0; thread_wakeups_pending() && i < 32; ++i)
  8004a4:	bb 00 00 00 00       	mov    $0x0,%ebx
  8004a9:	e8 2f a3 00 00       	call   80a7dd <thread_wakeups_pending>
  8004ae:	85 c0                	test   %eax,%eax
  8004b0:	0f 84 51 ff ff ff    	je     800407 <serve+0x15>
  8004b6:	83 fb 1f             	cmp    $0x1f,%ebx
  8004b9:	0f 8f 48 ff ff ff    	jg     800407 <serve+0x15>
			thread_yield();
  8004bf:	e8 98 a4 00 00       	call   80a95c <thread_yield>
		for (i = 0; thread_wakeups_pending() && i < 32; ++i)
  8004c4:	83 c3 01             	add    $0x1,%ebx
  8004c7:	eb e0                	jmp    8004a9 <serve+0xb7>
			process_timer(whom);
  8004c9:	8b 75 e4             	mov    -0x1c(%ebp),%esi
	if (envid != timer_envid) {
  8004cc:	3b 35 18 50 81 00    	cmp    0x815018,%esi
  8004d2:	74 23                	je     8004f7 <serve+0x105>
		cprintf("NS: received timer interrupt from envid %x not timer env\n", envid);
  8004d4:	83 ec 08             	sub    $0x8,%esp
  8004d7:	56                   	push   %esi
  8004d8:	68 a0 12 81 00       	push   $0x8112a0
  8004dd:	e8 4c e4 00 00       	call   80e92e <cprintf>
		return;
  8004e2:	83 c4 10             	add    $0x10,%esp
	int i = ((uint32_t)va - REQVA) / PGSIZE;
  8004e5:	81 eb 00 b0 fe 0f    	sub    $0xffeb000,%ebx
  8004eb:	c1 eb 0c             	shr    $0xc,%ebx
	buse[i] = 0;
  8004ee:	c6 83 00 50 81 00 00 	movb   $0x0,0x815000(%ebx)
			continue;
  8004f5:	eb ad                	jmp    8004a4 <serve+0xb2>
	start = sys_time_msec();
  8004f7:	e8 8f f0 00 00       	call   80f58b <sys_time_msec>
  8004fc:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	thread_yield();
  8004ff:	e8 58 a4 00 00       	call   80a95c <thread_yield>
	now = sys_time_msec();
  800504:	e8 82 f0 00 00       	call   80f58b <sys_time_msec>
  800509:	89 c2                	mov    %eax,%edx
	ipc_send(envid, to, 0, 0);
  80050b:	6a 00                	push   $0x0
  80050d:	6a 00                	push   $0x0
	to = TIMER_INTERVAL - (now - start);
  80050f:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  800512:	05 fa 00 00 00       	add    $0xfa,%eax
  800517:	29 d0                	sub    %edx,%eax
	ipc_send(envid, to, 0, 0);
  800519:	50                   	push   %eax
  80051a:	56                   	push   %esi
  80051b:	e8 40 f4 00 00       	call   80f960 <ipc_send>
  800520:	83 c4 10             	add    $0x10,%esp
  800523:	eb c0                	jmp    8004e5 <serve+0xf3>
			cprintf("Invalid request from %08x: no argument page\n", whom);
  800525:	83 ec 08             	sub    $0x8,%esp
  800528:	ff 75 e4             	pushl  -0x1c(%ebp)
  80052b:	68 dc 12 81 00       	push   $0x8112dc
  800530:	e8 f9 e3 00 00       	call   80e92e <cprintf>
			continue; // just leave it hanging...
  800535:	83 c4 10             	add    $0x10,%esp
  800538:	e9 67 ff ff ff       	jmp    8004a4 <serve+0xb2>
			panic("could not allocate thread args structure");
  80053d:	83 ec 04             	sub    $0x4,%esp
  800540:	68 0c 13 81 00       	push   $0x81130c
  800545:	68 27 01 00 00       	push   $0x127
  80054a:	68 35 13 81 00       	push   $0x811335
  80054f:	e8 f3 e2 00 00       	call   80e847 <_panic>

00800554 <tmain>:
	}
}

static void
tmain(uint32_t arg) {
  800554:	f3 0f 1e fb          	endbr32 
  800558:	55                   	push   %ebp
  800559:	89 e5                	mov    %esp,%ebp
  80055b:	56                   	push   %esi
  80055c:	53                   	push   %ebx
	serve_init(inet_addr(IP),
  80055d:	83 ec 0c             	sub    $0xc,%esp
  800560:	68 ab 13 81 00       	push   $0x8113ab
  800565:	e8 1f 75 00 00       	call   807a89 <inet_addr>
  80056a:	89 c6                	mov    %eax,%esi
  80056c:	c7 04 24 b4 13 81 00 	movl   $0x8113b4,(%esp)
  800573:	e8 11 75 00 00       	call   807a89 <inet_addr>
  800578:	89 c3                	mov    %eax,%ebx
  80057a:	c7 04 24 c2 13 81 00 	movl   $0x8113c2,(%esp)
  800581:	e8 03 75 00 00       	call   807a89 <inet_addr>
  800586:	83 c4 0c             	add    $0xc,%esp
  800589:	56                   	push   %esi
  80058a:	53                   	push   %ebx
  80058b:	50                   	push   %eax
  80058c:	e8 fc fc ff ff       	call   80028d <serve_init>
		   inet_addr(MASK),
		   inet_addr(DEFAULT));
	serve();
  800591:	e8 5c fe ff ff       	call   8003f2 <serve>

00800596 <umain>:
}

void
umain(int argc, char **argv)
{
  800596:	f3 0f 1e fb          	endbr32 
  80059a:	55                   	push   %ebp
  80059b:	89 e5                	mov    %esp,%ebp
  80059d:	53                   	push   %ebx
  80059e:	83 ec 04             	sub    $0x4,%esp
	envid_t ns_envid = sys_getenvid();
  8005a1:	e8 8e ed 00 00       	call   80f334 <sys_getenvid>
  8005a6:	89 c3                	mov    %eax,%ebx

	binaryname = "ns";
  8005a8:	c7 05 e8 42 81 00 8b 	movl   $0x813d8b,0x8142e8
  8005af:	3d 81 00 

	// fork off the timer thread which will send us periodic messages
	timer_envid = fork();
  8005b2:	e8 f7 f1 00 00       	call   80f7ae <fork>
  8005b7:	a3 18 50 81 00       	mov    %eax,0x815018
	if (timer_envid < 0)
  8005bc:	85 c0                	test   %eax,%eax
  8005be:	78 43                	js     800603 <umain+0x6d>
		panic("error forking");
	else if (timer_envid == 0) {
  8005c0:	74 58                	je     80061a <umain+0x84>
		return;
	}

	// fork off the input thread which will poll the NIC driver for input
	// packets
	input_envid = fork();
  8005c2:	e8 e7 f1 00 00       	call   80f7ae <fork>
	if (input_envid < 0)
  8005c7:	85 c0                	test   %eax,%eax
  8005c9:	78 65                	js     800630 <umain+0x9a>
		panic("error forking");
	else if (input_envid == 0) {
  8005cb:	74 7a                	je     800647 <umain+0xb1>
		return;
	}

	// fork off the output thread that will send the packets to the NIC
	// driver
	output_envid = fork();
  8005cd:	e8 dc f1 00 00       	call   80f7ae <fork>
  8005d2:	a3 14 50 81 00       	mov    %eax,0x815014
	if (output_envid < 0)
  8005d7:	85 c0                	test   %eax,%eax
  8005d9:	78 7a                	js     800655 <umain+0xbf>
		panic("error forking");
	else if (output_envid == 0) {
  8005db:	0f 84 8b 00 00 00    	je     80066c <umain+0xd6>
		return;
	}

	// lwIP requires a user threading library; start the library and jump
	// into a thread to continue initialization.
	thread_init();
  8005e1:	e8 a3 a1 00 00       	call   80a789 <thread_init>
	thread_create(0, "main", tmain, 0);
  8005e6:	6a 00                	push   $0x0
  8005e8:	68 54 05 80 00       	push   $0x800554
  8005ed:	68 da 13 81 00       	push   $0x8113da
  8005f2:	6a 00                	push   $0x0
  8005f4:	e8 36 a2 00 00       	call   80a82f <thread_create>
	thread_yield();
  8005f9:	e8 5e a3 00 00       	call   80a95c <thread_yield>
  8005fe:	83 c4 10             	add    $0x10,%esp
  800601:	eb 28                	jmp    80062b <umain+0x95>
		panic("error forking");
  800603:	83 ec 04             	sub    $0x4,%esp
  800606:	68 cc 13 81 00       	push   $0x8113cc
  80060b:	68 44 01 00 00       	push   $0x144
  800610:	68 35 13 81 00       	push   $0x811335
  800615:	e8 2d e2 00 00       	call   80e847 <_panic>
		timer(ns_envid, TIMER_INTERVAL);
  80061a:	83 ec 08             	sub    $0x8,%esp
  80061d:	68 fa 00 00 00       	push   $0xfa
  800622:	53                   	push   %ebx
  800623:	e8 52 00 00 00       	call   80067a <timer>
		return;
  800628:	83 c4 10             	add    $0x10,%esp
	// never coming here!
}
  80062b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80062e:	c9                   	leave  
  80062f:	c3                   	ret    
		panic("error forking");
  800630:	83 ec 04             	sub    $0x4,%esp
  800633:	68 cc 13 81 00       	push   $0x8113cc
  800638:	68 4e 01 00 00       	push   $0x14e
  80063d:	68 35 13 81 00       	push   $0x811335
  800642:	e8 00 e2 00 00       	call   80e847 <_panic>
		input(ns_envid);
  800647:	83 ec 0c             	sub    $0xc,%esp
  80064a:	53                   	push   %ebx
  80064b:	e8 c1 00 00 00       	call   800711 <input>
		return;
  800650:	83 c4 10             	add    $0x10,%esp
  800653:	eb d6                	jmp    80062b <umain+0x95>
		panic("error forking");
  800655:	83 ec 04             	sub    $0x4,%esp
  800658:	68 cc 13 81 00       	push   $0x8113cc
  80065d:	68 58 01 00 00       	push   $0x158
  800662:	68 35 13 81 00       	push   $0x811335
  800667:	e8 db e1 00 00       	call   80e847 <_panic>
		output(ns_envid);
  80066c:	83 ec 0c             	sub    $0xc,%esp
  80066f:	53                   	push   %ebx
  800670:	e8 ab 00 00 00       	call   800720 <output>
		return;
  800675:	83 c4 10             	add    $0x10,%esp
  800678:	eb b1                	jmp    80062b <umain+0x95>

0080067a <timer>:
#include "ns.h"

void
timer(envid_t ns_envid, uint32_t initial_to) {
  80067a:	f3 0f 1e fb          	endbr32 
  80067e:	55                   	push   %ebp
  80067f:	89 e5                	mov    %esp,%ebp
  800681:	57                   	push   %edi
  800682:	56                   	push   %esi
  800683:	53                   	push   %ebx
  800684:	83 ec 1c             	sub    $0x1c,%esp
  800687:	8b 75 08             	mov    0x8(%ebp),%esi
	int r;
	uint32_t stop = sys_time_msec() + initial_to;
  80068a:	e8 fc ee 00 00       	call   80f58b <sys_time_msec>
  80068f:	03 45 0c             	add    0xc(%ebp),%eax
  800692:	89 c3                	mov    %eax,%ebx

	binaryname = "ns_timer";
  800694:	c7 05 e8 42 81 00 0c 	movl   $0x81140c,0x8142e8
  80069b:	14 81 00 

		ipc_send(ns_envid, NSREQ_TIMER, 0, 0);

		while (1) {
			uint32_t to, whom;
			to = ipc_recv((int32_t *) &whom, 0, 0);
  80069e:	8d 7d e4             	lea    -0x1c(%ebp),%edi
  8006a1:	eb 33                	jmp    8006d6 <timer+0x5c>
		if (r < 0)
  8006a3:	85 c0                	test   %eax,%eax
  8006a5:	78 45                	js     8006ec <timer+0x72>
		ipc_send(ns_envid, NSREQ_TIMER, 0, 0);
  8006a7:	6a 00                	push   $0x0
  8006a9:	6a 00                	push   $0x0
  8006ab:	6a 0c                	push   $0xc
  8006ad:	56                   	push   %esi
  8006ae:	e8 ad f2 00 00       	call   80f960 <ipc_send>
  8006b3:	83 c4 10             	add    $0x10,%esp
			to = ipc_recv((int32_t *) &whom, 0, 0);
  8006b6:	83 ec 04             	sub    $0x4,%esp
  8006b9:	6a 00                	push   $0x0
  8006bb:	6a 00                	push   $0x0
  8006bd:	57                   	push   %edi
  8006be:	e8 29 f2 00 00       	call   80f8ec <ipc_recv>
  8006c3:	89 c3                	mov    %eax,%ebx

			if (whom != ns_envid) {
  8006c5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8006c8:	83 c4 10             	add    $0x10,%esp
  8006cb:	39 f0                	cmp    %esi,%eax
  8006cd:	75 2f                	jne    8006fe <timer+0x84>
				cprintf("NS TIMER: timer thread got IPC message from env %x not NS\n", whom);
				continue;
			}

			stop = sys_time_msec() + to;
  8006cf:	e8 b7 ee 00 00       	call   80f58b <sys_time_msec>
  8006d4:	01 c3                	add    %eax,%ebx
		while((r = sys_time_msec()) < stop && r >= 0) {
  8006d6:	e8 b0 ee 00 00       	call   80f58b <sys_time_msec>
  8006db:	89 c2                	mov    %eax,%edx
  8006dd:	85 c0                	test   %eax,%eax
  8006df:	78 c2                	js     8006a3 <timer+0x29>
  8006e1:	39 d8                	cmp    %ebx,%eax
  8006e3:	73 be                	jae    8006a3 <timer+0x29>
			sys_yield();
  8006e5:	e8 6d ec 00 00       	call   80f357 <sys_yield>
  8006ea:	eb ea                	jmp    8006d6 <timer+0x5c>
			panic("sys_time_msec: %e", r);
  8006ec:	52                   	push   %edx
  8006ed:	68 15 14 81 00       	push   $0x811415
  8006f2:	6a 0f                	push   $0xf
  8006f4:	68 27 14 81 00       	push   $0x811427
  8006f9:	e8 49 e1 00 00       	call   80e847 <_panic>
				cprintf("NS TIMER: timer thread got IPC message from env %x not NS\n", whom);
  8006fe:	83 ec 08             	sub    $0x8,%esp
  800701:	50                   	push   %eax
  800702:	68 34 14 81 00       	push   $0x811434
  800707:	e8 22 e2 00 00       	call   80e92e <cprintf>
				continue;
  80070c:	83 c4 10             	add    $0x10,%esp
  80070f:	eb a5                	jmp    8006b6 <timer+0x3c>

00800711 <input>:

extern union Nsipc nsipcbuf;

void
input(envid_t ns_envid)
{
  800711:	f3 0f 1e fb          	endbr32 
	binaryname = "ns_input";
  800715:	c7 05 e8 42 81 00 6f 	movl   $0x81146f,0x8142e8
  80071c:	14 81 00 
	// 	- read a packet from the device driver
	//	- send it to the network server
	// Hint: When you IPC a page to the network server, it will be
	// reading from it for a while, so don't immediately receive
	// another packet in to the same physical page.
}
  80071f:	c3                   	ret    

00800720 <output>:

extern union Nsipc nsipcbuf;

void
output(envid_t ns_envid)
{
  800720:	f3 0f 1e fb          	endbr32 
	binaryname = "ns_output";
  800724:	c7 05 e8 42 81 00 78 	movl   $0x811478,0x8142e8
  80072b:	14 81 00 

	// LAB 6: Your code here:
	// 	- read a packet from the network server
	//	- send the packet to the device driver
}
  80072e:	c3                   	ret    

0080072f <get_socket>:
static struct lwip_socket *
get_socket(int s)
{
  struct lwip_socket *sock;

  if ((s < 0) || (s >= NUM_SOCKETS)) {
  80072f:	83 f8 1f             	cmp    $0x1f,%eax
  800732:	77 1b                	ja     80074f <get_socket+0x20>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("get_socket(%d): invalid\n", s));
    set_errno(EBADF);
    return NULL;
  }

  sock = &sockets[s];
  800734:	8d 14 80             	lea    (%eax,%eax,4),%edx
  800737:	8d 14 95 60 50 81 00 	lea    0x815060(,%edx,4),%edx

  if (!sock->conn) {
  80073e:	8d 04 80             	lea    (%eax,%eax,4),%eax
  800741:	8b 04 85 60 50 81 00 	mov    0x815060(,%eax,4),%eax
  800748:	85 c0                	test   %eax,%eax
  80074a:	74 14                	je     800760 <get_socket+0x31>
    set_errno(EBADF);
    return NULL;
  }

  return sock;
}
  80074c:	89 d0                	mov    %edx,%eax
  80074e:	c3                   	ret    
    set_errno(EBADF);
  80074f:	c7 05 e0 b1 b3 00 09 	movl   $0x9,0xb3b1e0
  800756:	00 00 00 
    return NULL;
  800759:	ba 00 00 00 00       	mov    $0x0,%edx
  80075e:	eb ec                	jmp    80074c <get_socket+0x1d>
    set_errno(EBADF);
  800760:	c7 05 e0 b1 b3 00 09 	movl   $0x9,0xb3b1e0
  800767:	00 00 00 
    return NULL;
  80076a:	89 c2                	mov    %eax,%edx
  80076c:	eb de                	jmp    80074c <get_socket+0x1d>

0080076e <lwip_selscan>:
 * @param exceptset not yet implemented
 * @return number of sockets that had events (read+write)
 */
static int
lwip_selscan(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset)
{
  80076e:	55                   	push   %ebp
  80076f:	89 e5                	mov    %esp,%ebp
  800771:	57                   	push   %edi
  800772:	56                   	push   %esi
  800773:	53                   	push   %ebx
  800774:	83 ec 40             	sub    $0x40,%esp
  800777:	89 45 d0             	mov    %eax,-0x30(%ebp)
  80077a:	89 55 cc             	mov    %edx,-0x34(%ebp)
  80077d:	89 4d c8             	mov    %ecx,-0x38(%ebp)
  int i, nready = 0;
  fd_set lreadset, lwriteset, lexceptset;
  struct lwip_socket *p_sock;
  
  FD_ZERO(&lreadset);
  800780:	6a 04                	push   $0x4
  800782:	6a 00                	push   $0x0
  800784:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  800787:	50                   	push   %eax
  800788:	e8 15 e9 00 00       	call   80f0a2 <memset>
  FD_ZERO(&lwriteset);
  80078d:	83 c4 0c             	add    $0xc,%esp
  800790:	6a 04                	push   $0x4
  800792:	6a 00                	push   $0x0
  800794:	8d 45 e0             	lea    -0x20(%ebp),%eax
  800797:	50                   	push   %eax
  800798:	e8 05 e9 00 00       	call   80f0a2 <memset>
  FD_ZERO(&lexceptset);
  80079d:	83 c4 0c             	add    $0xc,%esp
  8007a0:	6a 04                	push   $0x4
  8007a2:	6a 00                	push   $0x0
  8007a4:	8d 45 dc             	lea    -0x24(%ebp),%eax
  8007a7:	50                   	push   %eax
  8007a8:	e8 f5 e8 00 00       	call   80f0a2 <memset>
  
  /* Go through each socket in each list to count number of sockets which
  currently match */
  for(i = 0; i < maxfdp1; i++) {
  8007ad:	83 c4 10             	add    $0x10,%esp
  int i, nready = 0;
  8007b0:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
  for(i = 0; i < maxfdp1; i++) {
  8007b7:	bf 00 00 00 00       	mov    $0x0,%edi
  8007bc:	eb 33                	jmp    8007f1 <lwip_selscan+0x83>
    if (FD_ISSET(i, readset)) {
      /* See if netconn of this socket is ready for read */
      p_sock = get_socket(i);
  8007be:	89 f8                	mov    %edi,%eax
  8007c0:	e8 6a ff ff ff       	call   80072f <get_socket>
      if (p_sock && (p_sock->lastdata || p_sock->rcvevent)) {
  8007c5:	85 c0                	test   %eax,%eax
  8007c7:	74 4c                	je     800815 <lwip_selscan+0xa7>
  8007c9:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
  8007cd:	74 16                	je     8007e5 <lwip_selscan+0x77>
        FD_SET(i, &lreadset);
  8007cf:	b8 01 00 00 00       	mov    $0x1,%eax
  8007d4:	89 f1                	mov    %esi,%ecx
  8007d6:	d3 e0                	shl    %cl,%eax
  8007d8:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  8007db:	08 44 15 e4          	or     %al,-0x1c(%ebp,%edx,1)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for reading\n", i));
        nready++;
  8007df:	83 45 c4 01          	addl   $0x1,-0x3c(%ebp)
  8007e3:	eb 30                	jmp    800815 <lwip_selscan+0xa7>
      if (p_sock && (p_sock->lastdata || p_sock->rcvevent)) {
  8007e5:	66 83 78 0a 00       	cmpw   $0x0,0xa(%eax)
  8007ea:	74 29                	je     800815 <lwip_selscan+0xa7>
  8007ec:	eb e1                	jmp    8007cf <lwip_selscan+0x61>
  for(i = 0; i < maxfdp1; i++) {
  8007ee:	83 c7 01             	add    $0x1,%edi
  8007f1:	3b 7d d0             	cmp    -0x30(%ebp),%edi
  8007f4:	7d 53                	jge    800849 <lwip_selscan+0xdb>
    if (FD_ISSET(i, readset)) {
  8007f6:	8d 5f 07             	lea    0x7(%edi),%ebx
  8007f9:	85 ff                	test   %edi,%edi
  8007fb:	0f 49 df             	cmovns %edi,%ebx
  8007fe:	c1 fb 03             	sar    $0x3,%ebx
  800801:	89 5d d4             	mov    %ebx,-0x2c(%ebp)
  800804:	89 fe                	mov    %edi,%esi
  800806:	83 e6 07             	and    $0x7,%esi
  800809:	8b 45 cc             	mov    -0x34(%ebp),%eax
  80080c:	0f b6 04 18          	movzbl (%eax,%ebx,1),%eax
  800810:	0f a3 f0             	bt     %esi,%eax
  800813:	72 a9                	jb     8007be <lwip_selscan+0x50>
      }
    }
    if (FD_ISSET(i, writeset)) {
  800815:	8b 45 c8             	mov    -0x38(%ebp),%eax
  800818:	0f b6 04 18          	movzbl (%eax,%ebx,1),%eax
  80081c:	0f a3 f0             	bt     %esi,%eax
  80081f:	73 cd                	jae    8007ee <lwip_selscan+0x80>
      /* See if netconn of this socket is ready for write */
      p_sock = get_socket(i);
  800821:	89 f8                	mov    %edi,%eax
  800823:	e8 07 ff ff ff       	call   80072f <get_socket>
      if (p_sock && p_sock->sendevent) {
  800828:	85 c0                	test   %eax,%eax
  80082a:	74 c2                	je     8007ee <lwip_selscan+0x80>
  80082c:	66 83 78 0c 00       	cmpw   $0x0,0xc(%eax)
  800831:	74 bb                	je     8007ee <lwip_selscan+0x80>
        FD_SET(i, &lwriteset);
  800833:	b8 01 00 00 00       	mov    $0x1,%eax
  800838:	89 f1                	mov    %esi,%ecx
  80083a:	d3 e0                	shl    %cl,%eax
  80083c:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  80083f:	08 44 15 e0          	or     %al,-0x20(%ebp,%edx,1)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for writing\n", i));
        nready++;
  800843:	83 45 c4 01          	addl   $0x1,-0x3c(%ebp)
  800847:	eb a5                	jmp    8007ee <lwip_selscan+0x80>
      }
    }
  }
  *readset = lreadset;
  800849:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80084c:	8b 55 cc             	mov    -0x34(%ebp),%edx
  80084f:	89 02                	mov    %eax,(%edx)
  *writeset = lwriteset;
  800851:	8b 45 e0             	mov    -0x20(%ebp),%eax
  800854:	8b 4d c8             	mov    -0x38(%ebp),%ecx
  800857:	89 01                	mov    %eax,(%ecx)
  FD_ZERO(exceptset);
  800859:	83 ec 04             	sub    $0x4,%esp
  80085c:	6a 04                	push   $0x4
  80085e:	6a 00                	push   $0x0
  800860:	ff 75 08             	pushl  0x8(%ebp)
  800863:	e8 3a e8 00 00       	call   80f0a2 <memset>
  
  return nready;
}
  800868:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  80086b:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80086e:	5b                   	pop    %ebx
  80086f:	5e                   	pop    %esi
  800870:	5f                   	pop    %edi
  800871:	5d                   	pop    %ebp
  800872:	c3                   	ret    

00800873 <lwip_getaddrname>:
  return lwip_close(s); /* XXX temporary hack until proper implementation */
}

static int
lwip_getaddrname(int s, struct sockaddr *name, socklen_t *namelen, u8_t local)
{
  800873:	55                   	push   %ebp
  800874:	89 e5                	mov    %esp,%ebp
  800876:	57                   	push   %edi
  800877:	56                   	push   %esi
  800878:	53                   	push   %ebx
  800879:	83 ec 3c             	sub    $0x3c,%esp
  80087c:	89 55 c4             	mov    %edx,-0x3c(%ebp)
  80087f:	89 ce                	mov    %ecx,%esi
  800881:	8b 7d 08             	mov    0x8(%ebp),%edi
  struct lwip_socket *sock;
  struct sockaddr_in sin;
  struct ip_addr naddr;

  sock = get_socket(s);
  800884:	e8 a6 fe ff ff       	call   80072f <get_socket>
  if (!sock)
  800889:	85 c0                	test   %eax,%eax
  80088b:	0f 84 86 00 00 00    	je     800917 <lwip_getaddrname+0xa4>
  800891:	89 c3                	mov    %eax,%ebx
    return -1;

  memset(&sin, 0, sizeof(sin));
  800893:	83 ec 04             	sub    $0x4,%esp
  800896:	6a 10                	push   $0x10
  800898:	6a 00                	push   $0x0
  80089a:	8d 45 d8             	lea    -0x28(%ebp),%eax
  80089d:	50                   	push   %eax
  80089e:	e8 ff e7 00 00       	call   80f0a2 <memset>
  sin.sin_len = sizeof(sin);
  8008a3:	c6 45 d8 10          	movb   $0x10,-0x28(%ebp)
  sin.sin_family = AF_INET;
  8008a7:	c6 45 d9 02          	movb   $0x2,-0x27(%ebp)

  /* get the IP address and port */
  netconn_getaddr(sock->conn, &naddr, &sin.sin_port, local);
  8008ab:	89 f8                	mov    %edi,%eax
  8008ad:	0f b6 f8             	movzbl %al,%edi
  8008b0:	57                   	push   %edi
  8008b1:	8d 45 da             	lea    -0x26(%ebp),%eax
  8008b4:	50                   	push   %eax
  8008b5:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  8008b8:	50                   	push   %eax
  8008b9:	ff 33                	pushl  (%ebx)
  8008bb:	e8 a6 a6 00 00       	call   80af66 <netconn_getaddr>

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getaddrname(%d, addr=", s));
  //ip_addr_debug_print(SOCKETS_DEBUG, &naddr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%d)\n", sin.sin_port));

  sin.sin_port = htons(sin.sin_port);
  8008c0:	83 c4 14             	add    $0x14,%esp
  8008c3:	0f b7 45 da          	movzwl -0x26(%ebp),%eax
  8008c7:	50                   	push   %eax
  8008c8:	e8 93 6f 00 00       	call   807860 <htons>
  8008cd:	66 89 45 da          	mov    %ax,-0x26(%ebp)
  sin.sin_addr.s_addr = naddr.addr;
  8008d1:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  8008d4:	89 45 dc             	mov    %eax,-0x24(%ebp)

  if (*namelen > sizeof(sin))
  8008d7:	83 c4 10             	add    $0x10,%esp
  8008da:	83 3e 10             	cmpl   $0x10,(%esi)
  8008dd:	76 06                	jbe    8008e5 <lwip_getaddrname+0x72>
    *namelen = sizeof(sin);
  8008df:	c7 06 10 00 00 00    	movl   $0x10,(%esi)

  SMEMCPY(name, &sin, *namelen);
  8008e5:	83 ec 04             	sub    $0x4,%esp
  8008e8:	ff 36                	pushl  (%esi)
  8008ea:	8d 45 d8             	lea    -0x28(%ebp),%eax
  8008ed:	50                   	push   %eax
  8008ee:	ff 75 c4             	pushl  -0x3c(%ebp)
  8008f1:	e8 5e e8 00 00       	call   80f154 <memcpy>
  sock_set_errno(sock, 0);
  8008f6:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  8008fd:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  800904:	00 00 00 
  return 0;
  800907:	83 c4 10             	add    $0x10,%esp
  80090a:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80090f:	8d 65 f4             	lea    -0xc(%ebp),%esp
  800912:	5b                   	pop    %ebx
  800913:	5e                   	pop    %esi
  800914:	5f                   	pop    %edi
  800915:	5d                   	pop    %ebp
  800916:	c3                   	ret    
    return -1;
  800917:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80091c:	eb f1                	jmp    80090f <lwip_getaddrname+0x9c>

0080091e <event_callback>:
{
  80091e:	f3 0f 1e fb          	endbr32 
  800922:	55                   	push   %ebp
  800923:	89 e5                	mov    %esp,%ebp
  800925:	57                   	push   %edi
  800926:	56                   	push   %esi
  800927:	53                   	push   %ebx
  800928:	83 ec 1c             	sub    $0x1c,%esp
  80092b:	8b 7d 08             	mov    0x8(%ebp),%edi
  80092e:	8b 75 0c             	mov    0xc(%ebp),%esi
  if (conn) {
  800931:	85 ff                	test   %edi,%edi
  800933:	0f 84 80 01 00 00    	je     800ab9 <event_callback+0x19b>
    s = conn->socket;
  800939:	8b 5f 1c             	mov    0x1c(%edi),%ebx
    if (s < 0) {
  80093c:	85 db                	test   %ebx,%ebx
  80093e:	78 3c                	js     80097c <event_callback+0x5e>
    sock = get_socket(s);
  800940:	89 d8                	mov    %ebx,%eax
  800942:	e8 e8 fd ff ff       	call   80072f <get_socket>
  800947:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if (!sock) {
  80094a:	85 c0                	test   %eax,%eax
  80094c:	0f 84 67 01 00 00    	je     800ab9 <event_callback+0x19b>
  sys_sem_wait(selectsem);
  800952:	83 ec 0c             	sub    $0xc,%esp
  800955:	ff 35 40 50 81 00    	pushl  0x815040
  80095b:	e8 cd 48 00 00       	call   80522d <sys_sem_wait>
  switch (evt) {
  800960:	83 c4 10             	add    $0x10,%esp
  800963:	83 fe 02             	cmp    $0x2,%esi
  800966:	0f 84 a0 00 00 00    	je     800a0c <event_callback+0xee>
  80096c:	77 59                	ja     8009c7 <event_callback+0xa9>
  80096e:	85 f6                	test   %esi,%esi
  800970:	74 65                	je     8009d7 <event_callback+0xb9>
      sock->rcvevent--;
  800972:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800975:	66 83 68 0a 01       	subw   $0x1,0xa(%eax)
      break;
  80097a:	eb 63                	jmp    8009df <event_callback+0xc1>
      sys_sem_wait(socksem);
  80097c:	83 ec 0c             	sub    $0xc,%esp
  80097f:	ff 35 44 50 81 00    	pushl  0x815044
  800985:	e8 a3 48 00 00       	call   80522d <sys_sem_wait>
      if (conn->socket < 0) {
  80098a:	8b 47 1c             	mov    0x1c(%edi),%eax
  80098d:	83 c4 10             	add    $0x10,%esp
  800990:	85 c0                	test   %eax,%eax
  800992:	78 13                	js     8009a7 <event_callback+0x89>
      sys_sem_signal(socksem);
  800994:	83 ec 0c             	sub    $0xc,%esp
  800997:	ff 35 44 50 81 00    	pushl  0x815044
  80099d:	e8 d8 98 00 00       	call   80a27a <sys_sem_signal>
  8009a2:	83 c4 10             	add    $0x10,%esp
  8009a5:	eb 99                	jmp    800940 <event_callback+0x22>
        if (evt == NETCONN_EVT_RCVPLUS) {
  8009a7:	85 f6                	test   %esi,%esi
  8009a9:	75 06                	jne    8009b1 <event_callback+0x93>
          conn->socket--;
  8009ab:	83 e8 01             	sub    $0x1,%eax
  8009ae:	89 47 1c             	mov    %eax,0x1c(%edi)
        sys_sem_signal(socksem);
  8009b1:	83 ec 0c             	sub    $0xc,%esp
  8009b4:	ff 35 44 50 81 00    	pushl  0x815044
  8009ba:	e8 bb 98 00 00       	call   80a27a <sys_sem_signal>
        return;
  8009bf:	83 c4 10             	add    $0x10,%esp
  8009c2:	e9 f2 00 00 00       	jmp    800ab9 <event_callback+0x19b>
  switch (evt) {
  8009c7:	83 fe 03             	cmp    $0x3,%esi
  8009ca:	75 4b                	jne    800a17 <event_callback+0xf9>
      sock->sendevent = 0;
  8009cc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8009cf:	66 c7 40 0c 00 00    	movw   $0x0,0xc(%eax)
      break;
  8009d5:	eb 08                	jmp    8009df <event_callback+0xc1>
      sock->rcvevent++;
  8009d7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8009da:	66 83 40 0a 01       	addw   $0x1,0xa(%eax)
  sys_sem_signal(selectsem);
  8009df:	83 ec 0c             	sub    $0xc,%esp
  8009e2:	ff 35 40 50 81 00    	pushl  0x815040
  8009e8:	e8 8d 98 00 00       	call   80a27a <sys_sem_signal>
        if (scb->readset && FD_ISSET(s, scb->readset))
  8009ed:	8d 73 07             	lea    0x7(%ebx),%esi
  8009f0:	83 c4 10             	add    $0x10,%esp
  8009f3:	85 db                	test   %ebx,%ebx
  8009f5:	0f 49 f3             	cmovns %ebx,%esi
  8009f8:	c1 fe 03             	sar    $0x3,%esi
  8009fb:	89 d9                	mov    %ebx,%ecx
  8009fd:	83 e1 07             	and    $0x7,%ecx
  800a00:	bf 01 00 00 00       	mov    $0x1,%edi
  800a05:	d3 e7                	shl    %cl,%edi
  800a07:	e9 83 00 00 00       	jmp    800a8f <event_callback+0x171>
      sock->sendevent = 1;
  800a0c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800a0f:	66 c7 40 0c 01 00    	movw   $0x1,0xc(%eax)
      break;
  800a15:	eb c8                	jmp    8009df <event_callback+0xc1>
      LWIP_ASSERT("unknown event", 0);
  800a17:	83 ec 04             	sub    $0x4,%esp
  800a1a:	68 82 14 81 00       	push   $0x811482
  800a1f:	68 17 04 00 00       	push   $0x417
  800a24:	68 90 14 81 00       	push   $0x811490
  800a29:	e8 19 de 00 00       	call   80e847 <_panic>
    for (scb = select_cb_list; scb; scb = scb->next) {
  800a2e:	8b 1b                	mov    (%ebx),%ebx
  800a30:	85 db                	test   %ebx,%ebx
  800a32:	74 74                	je     800aa8 <event_callback+0x18a>
      if (scb->sem_signalled == 0) {
  800a34:	83 7b 10 00          	cmpl   $0x0,0x10(%ebx)
  800a38:	75 f4                	jne    800a2e <event_callback+0x110>
        if (scb->readset && FD_ISSET(s, scb->readset))
  800a3a:	8b 43 04             	mov    0x4(%ebx),%eax
  800a3d:	85 c0                	test   %eax,%eax
  800a3f:	74 12                	je     800a53 <event_callback+0x135>
  800a41:	0f b6 04 30          	movzbl (%eax,%esi,1),%eax
  800a45:	85 f8                	test   %edi,%eax
  800a47:	74 0a                	je     800a53 <event_callback+0x135>
          if (sock->rcvevent)
  800a49:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800a4c:	66 83 78 0a 00       	cmpw   $0x0,0xa(%eax)
  800a51:	75 19                	jne    800a6c <event_callback+0x14e>
        if (scb->writeset && FD_ISSET(s, scb->writeset))
  800a53:	8b 43 08             	mov    0x8(%ebx),%eax
  800a56:	85 c0                	test   %eax,%eax
  800a58:	74 d4                	je     800a2e <event_callback+0x110>
  800a5a:	0f b6 04 30          	movzbl (%eax,%esi,1),%eax
  800a5e:	85 f8                	test   %edi,%eax
  800a60:	74 cc                	je     800a2e <event_callback+0x110>
          if (sock->sendevent)
  800a62:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800a65:	66 83 78 0c 00       	cmpw   $0x0,0xc(%eax)
  800a6a:	74 c2                	je     800a2e <event_callback+0x110>
      scb->sem_signalled = 1;
  800a6c:	c7 43 10 01 00 00 00 	movl   $0x1,0x10(%ebx)
      sys_sem_signal(selectsem);
  800a73:	83 ec 0c             	sub    $0xc,%esp
  800a76:	ff 35 40 50 81 00    	pushl  0x815040
  800a7c:	e8 f9 97 00 00       	call   80a27a <sys_sem_signal>
      sys_sem_signal(scb->sem);
  800a81:	83 c4 04             	add    $0x4,%esp
  800a84:	ff 73 14             	pushl  0x14(%ebx)
  800a87:	e8 ee 97 00 00       	call   80a27a <sys_sem_signal>
    sys_sem_wait(selectsem);
  800a8c:	83 c4 10             	add    $0x10,%esp
  800a8f:	83 ec 0c             	sub    $0xc,%esp
  800a92:	ff 35 40 50 81 00    	pushl  0x815040
  800a98:	e8 90 47 00 00       	call   80522d <sys_sem_wait>
    for (scb = select_cb_list; scb; scb = scb->next) {
  800a9d:	8b 1d 48 50 81 00    	mov    0x815048,%ebx
  800aa3:	83 c4 10             	add    $0x10,%esp
  800aa6:	eb 88                	jmp    800a30 <event_callback+0x112>
      sys_sem_signal(selectsem);
  800aa8:	83 ec 0c             	sub    $0xc,%esp
  800aab:	ff 35 40 50 81 00    	pushl  0x815040
  800ab1:	e8 c4 97 00 00       	call   80a27a <sys_sem_signal>
      break;
  800ab6:	83 c4 10             	add    $0x10,%esp
}
  800ab9:	8d 65 f4             	lea    -0xc(%ebp),%esp
  800abc:	5b                   	pop    %ebx
  800abd:	5e                   	pop    %esi
  800abe:	5f                   	pop    %edi
  800abf:	5d                   	pop    %ebp
  800ac0:	c3                   	ret    

00800ac1 <alloc_socket>:
{
  800ac1:	55                   	push   %ebp
  800ac2:	89 e5                	mov    %esp,%ebp
  800ac4:	56                   	push   %esi
  800ac5:	53                   	push   %ebx
  800ac6:	89 c6                	mov    %eax,%esi
  sys_sem_wait(socksem);
  800ac8:	83 ec 0c             	sub    $0xc,%esp
  800acb:	ff 35 44 50 81 00    	pushl  0x815044
  800ad1:	e8 57 47 00 00       	call   80522d <sys_sem_wait>
  800ad6:	b8 60 50 81 00       	mov    $0x815060,%eax
  800adb:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < NUM_SOCKETS; ++i) {
  800ade:	bb 00 00 00 00       	mov    $0x0,%ebx
    if (!sockets[i].conn) {
  800ae3:	83 38 00             	cmpl   $0x0,(%eax)
  800ae6:	74 23                	je     800b0b <alloc_socket+0x4a>
  for (i = 0; i < NUM_SOCKETS; ++i) {
  800ae8:	83 c3 01             	add    $0x1,%ebx
  800aeb:	83 c0 14             	add    $0x14,%eax
  800aee:	83 fb 20             	cmp    $0x20,%ebx
  800af1:	75 f0                	jne    800ae3 <alloc_socket+0x22>
  sys_sem_signal(socksem);
  800af3:	83 ec 0c             	sub    $0xc,%esp
  800af6:	ff 35 44 50 81 00    	pushl  0x815044
  800afc:	e8 79 97 00 00       	call   80a27a <sys_sem_signal>
  return -1;
  800b01:	83 c4 10             	add    $0x10,%esp
  800b04:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
  800b09:	eb 55                	jmp    800b60 <alloc_socket+0x9f>
      sockets[i].conn       = newconn;
  800b0b:	8d 14 9b             	lea    (%ebx,%ebx,4),%edx
  800b0e:	c1 e2 02             	shl    $0x2,%edx
  800b11:	89 b2 60 50 81 00    	mov    %esi,0x815060(%edx)
      sockets[i].lastdata   = NULL;
  800b17:	c7 82 64 50 81 00 00 	movl   $0x0,0x815064(%edx)
  800b1e:	00 00 00 
      sockets[i].lastoffset = 0;
  800b21:	66 c7 82 68 50 81 00 	movw   $0x0,0x815068(%edx)
  800b28:	00 00 
      sockets[i].rcvevent   = 0;
  800b2a:	66 c7 82 6a 50 81 00 	movw   $0x0,0x81506a(%edx)
  800b31:	00 00 
      sockets[i].sendevent  = 1; /* TCP send buf is empty */
  800b33:	66 c7 82 6c 50 81 00 	movw   $0x1,0x81506c(%edx)
  800b3a:	01 00 
      sockets[i].flags      = 0;
  800b3c:	66 c7 82 6e 50 81 00 	movw   $0x0,0x81506e(%edx)
  800b43:	00 00 
      sockets[i].err        = 0;
  800b45:	c7 82 70 50 81 00 00 	movl   $0x0,0x815070(%edx)
  800b4c:	00 00 00 
      sys_sem_signal(socksem);
  800b4f:	83 ec 0c             	sub    $0xc,%esp
  800b52:	ff 35 44 50 81 00    	pushl  0x815044
  800b58:	e8 1d 97 00 00       	call   80a27a <sys_sem_signal>
      return i;
  800b5d:	83 c4 10             	add    $0x10,%esp
}
  800b60:	89 d8                	mov    %ebx,%eax
  800b62:	8d 65 f8             	lea    -0x8(%ebp),%esp
  800b65:	5b                   	pop    %ebx
  800b66:	5e                   	pop    %esi
  800b67:	5d                   	pop    %ebp
  800b68:	c3                   	ret    

00800b69 <lwip_getsockopt_internal>:
  return err ? -1 : 0;
}

static void
lwip_getsockopt_internal(void *arg)
{
  800b69:	f3 0f 1e fb          	endbr32 
  800b6d:	55                   	push   %ebp
  800b6e:	89 e5                	mov    %esp,%ebp
  800b70:	56                   	push   %esi
  800b71:	53                   	push   %ebx
  800b72:	8b 45 08             	mov    0x8(%ebp),%eax
#endif /* LWIP_DEBUG */
  int level, optname;
  void *optval;
  struct lwip_setgetsockopt_data *data;

  LWIP_ASSERT("arg != NULL", arg != NULL);
  800b75:	85 c0                	test   %eax,%eax
  800b77:	74 3b                	je     800bb4 <lwip_getsockopt_internal+0x4b>

  data = (struct lwip_setgetsockopt_data*)arg;
  sock = data->sock;
  800b79:	8b 18                	mov    (%eax),%ebx
#ifdef LWIP_DEBUG
  s = data->s;
#endif /* LWIP_DEBUG */
  level = data->level;
  800b7b:	8b 48 08             	mov    0x8(%eax),%ecx
  optname = data->optname;
  800b7e:	8b 50 0c             	mov    0xc(%eax),%edx
  optval = data->optval;
  800b81:	8b 70 10             	mov    0x10(%eax),%esi

  switch (level) {
  800b84:	83 f9 06             	cmp    $0x6,%ecx
  800b87:	0f 84 39 01 00 00    	je     800cc6 <lwip_getsockopt_internal+0x15d>
  800b8d:	81 f9 ff 0f 00 00    	cmp    $0xfff,%ecx
  800b93:	74 36                	je     800bcb <lwip_getsockopt_internal+0x62>
  800b95:	85 c9                	test   %ecx,%ecx
  800b97:	0f 84 fb 00 00 00    	je     800c98 <lwip_getsockopt_internal+0x12f>
      break;
    }  /* switch (optname) */
    break;
#endif /* LWIP_UDP */
  } /* switch (level) */
  sys_sem_signal(sock->conn->op_completed);
  800b9d:	83 ec 0c             	sub    $0xc,%esp
  800ba0:	8b 03                	mov    (%ebx),%eax
  800ba2:	ff 70 10             	pushl  0x10(%eax)
  800ba5:	e8 d0 96 00 00       	call   80a27a <sys_sem_signal>
}
  800baa:	83 c4 10             	add    $0x10,%esp
  800bad:	8d 65 f8             	lea    -0x8(%ebp),%esp
  800bb0:	5b                   	pop    %ebx
  800bb1:	5e                   	pop    %esi
  800bb2:	5d                   	pop    %ebp
  800bb3:	c3                   	ret    
  LWIP_ASSERT("arg != NULL", arg != NULL);
  800bb4:	83 ec 04             	sub    $0x4,%esp
  800bb7:	68 a7 14 81 00       	push   $0x8114a7
  800bbc:	68 38 05 00 00       	push   $0x538
  800bc1:	68 90 14 81 00       	push   $0x811490
  800bc6:	e8 7c dc 00 00       	call   80e847 <_panic>
  800bcb:	81 fa 07 10 00 00    	cmp    $0x1007,%edx
  800bd1:	0f 84 88 00 00 00    	je     800c5f <lwip_getsockopt_internal+0xf6>
  800bd7:	7e 20                	jle    800bf9 <lwip_getsockopt_internal+0x90>
  800bd9:	81 fa 08 10 00 00    	cmp    $0x1008,%edx
  800bdf:	74 40                	je     800c21 <lwip_getsockopt_internal+0xb8>
  800be1:	81 fa 0a 10 00 00    	cmp    $0x100a,%edx
  800be7:	75 b4                	jne    800b9d <lwip_getsockopt_internal+0x34>
      *(int*)optval = (udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_NOCHKSUM) ? 1 : 0;
  800be9:	8b 03                	mov    (%ebx),%eax
  800beb:	8b 40 08             	mov    0x8(%eax),%eax
  800bee:	0f b6 40 10          	movzbl 0x10(%eax),%eax
  800bf2:	83 e0 01             	and    $0x1,%eax
  800bf5:	89 06                	mov    %eax,(%esi)
      break;
  800bf7:	eb a4                	jmp    800b9d <lwip_getsockopt_internal+0x34>
  800bf9:	8d 4a fe             	lea    -0x2(%edx),%ecx
  800bfc:	83 f9 1e             	cmp    $0x1e,%ecx
  800bff:	77 9c                	ja     800b9d <lwip_getsockopt_internal+0x34>
  800c01:	b8 01 00 00 00       	mov    $0x1,%eax
  800c06:	d3 e0                	shl    %cl,%eax
  800c08:	a9 41 00 00 40       	test   $0x40000041,%eax
  800c0d:	74 8e                	je     800b9d <lwip_getsockopt_internal+0x34>
      *(int*)optval = sock->conn->pcb.ip->so_options & optname;
  800c0f:	8b 03                	mov    (%ebx),%eax
  800c11:	8b 40 08             	mov    0x8(%eax),%eax
  800c14:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  800c18:	21 c2                	and    %eax,%edx
  800c1a:	89 16                	mov    %edx,(%esi)
      break;
  800c1c:	e9 7c ff ff ff       	jmp    800b9d <lwip_getsockopt_internal+0x34>
      switch (NETCONNTYPE_GROUP(sock->conn->type)) {
  800c21:	8b 03                	mov    (%ebx),%eax
  800c23:	8b 00                	mov    (%eax),%eax
  800c25:	89 c2                	mov    %eax,%edx
  800c27:	81 e2 f0 00 00 00    	and    $0xf0,%edx
  800c2d:	83 fa 20             	cmp    $0x20,%edx
  800c30:	74 22                	je     800c54 <lwip_getsockopt_internal+0xeb>
  800c32:	83 fa 40             	cmp    $0x40,%edx
  800c35:	74 12                	je     800c49 <lwip_getsockopt_internal+0xe0>
        *(int*)optval = sock->conn->type;
  800c37:	83 fa 10             	cmp    $0x10,%edx
  800c3a:	ba 01 00 00 00       	mov    $0x1,%edx
  800c3f:	0f 44 c2             	cmove  %edx,%eax
  800c42:	89 06                	mov    %eax,(%esi)
  800c44:	e9 54 ff ff ff       	jmp    800b9d <lwip_getsockopt_internal+0x34>
        *(int*)optval = SOCK_RAW;
  800c49:	c7 06 03 00 00 00    	movl   $0x3,(%esi)
        break;
  800c4f:	e9 49 ff ff ff       	jmp    800b9d <lwip_getsockopt_internal+0x34>
        *(int*)optval = SOCK_DGRAM;
  800c54:	c7 06 02 00 00 00    	movl   $0x2,(%esi)
        break;
  800c5a:	e9 3e ff ff ff       	jmp    800b9d <lwip_getsockopt_internal+0x34>
      if (sock->err == 0) {
  800c5f:	83 7b 10 00          	cmpl   $0x0,0x10(%ebx)
  800c63:	75 22                	jne    800c87 <lwip_getsockopt_internal+0x11e>
        sock_set_errno(sock, err_to_errno(sock->conn->err));
  800c65:	8b 03                	mov    (%ebx),%eax
  800c67:	0f be 40 0c          	movsbl 0xc(%eax),%eax
  800c6b:	f7 d8                	neg    %eax
  800c6d:	ba 05 00 00 00       	mov    $0x5,%edx
  800c72:	83 f8 0e             	cmp    $0xe,%eax
  800c75:	77 07                	ja     800c7e <lwip_getsockopt_internal+0x115>
  800c77:	8b 14 85 60 15 81 00 	mov    0x811560(,%eax,4),%edx
  800c7e:	89 53 10             	mov    %edx,0x10(%ebx)
  800c81:	89 15 e0 b1 b3 00    	mov    %edx,0xb3b1e0
      *(int *)optval = sock->err;
  800c87:	8b 43 10             	mov    0x10(%ebx),%eax
  800c8a:	89 06                	mov    %eax,(%esi)
      sock->err = 0;
  800c8c:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
      break;
  800c93:	e9 05 ff ff ff       	jmp    800b9d <lwip_getsockopt_internal+0x34>
  800c98:	83 fa 01             	cmp    $0x1,%edx
  800c9b:	74 19                	je     800cb6 <lwip_getsockopt_internal+0x14d>
  800c9d:	83 fa 02             	cmp    $0x2,%edx
  800ca0:	0f 85 f7 fe ff ff    	jne    800b9d <lwip_getsockopt_internal+0x34>
      *(int*)optval = sock->conn->pcb.ip->ttl;
  800ca6:	8b 03                	mov    (%ebx),%eax
  800ca8:	8b 40 08             	mov    0x8(%eax),%eax
  800cab:	0f b6 40 0b          	movzbl 0xb(%eax),%eax
  800caf:	89 06                	mov    %eax,(%esi)
      break;
  800cb1:	e9 e7 fe ff ff       	jmp    800b9d <lwip_getsockopt_internal+0x34>
      *(int*)optval = sock->conn->pcb.ip->tos;
  800cb6:	8b 03                	mov    (%ebx),%eax
  800cb8:	8b 40 08             	mov    0x8(%eax),%eax
  800cbb:	0f b6 40 0a          	movzbl 0xa(%eax),%eax
  800cbf:	89 06                	mov    %eax,(%esi)
      break;
  800cc1:	e9 d7 fe ff ff       	jmp    800b9d <lwip_getsockopt_internal+0x34>
  800cc6:	83 fa 01             	cmp    $0x1,%edx
  800cc9:	74 1b                	je     800ce6 <lwip_getsockopt_internal+0x17d>
  800ccb:	83 fa 02             	cmp    $0x2,%edx
  800cce:	0f 85 c9 fe ff ff    	jne    800b9d <lwip_getsockopt_internal+0x34>
      *(int*)optval = (int)sock->conn->pcb.tcp->keep_idle;
  800cd4:	8b 03                	mov    (%ebx),%eax
  800cd6:	8b 40 08             	mov    0x8(%eax),%eax
  800cd9:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
  800cdf:	89 06                	mov    %eax,(%esi)
      break;
  800ce1:	e9 b7 fe ff ff       	jmp    800b9d <lwip_getsockopt_internal+0x34>
      *(int*)optval = (sock->conn->pcb.tcp->flags & TF_NODELAY);
  800ce6:	8b 03                	mov    (%ebx),%eax
  800ce8:	8b 40 08             	mov    0x8(%eax),%eax
  800ceb:	0f b6 40 20          	movzbl 0x20(%eax),%eax
  800cef:	83 e0 40             	and    $0x40,%eax
  800cf2:	0f b6 c0             	movzbl %al,%eax
  800cf5:	89 06                	mov    %eax,(%esi)
      break;
  800cf7:	e9 a1 fe ff ff       	jmp    800b9d <lwip_getsockopt_internal+0x34>

00800cfc <lwip_setsockopt_internal>:
  return err ? -1 : 0;
}

static void
lwip_setsockopt_internal(void *arg)
{
  800cfc:	f3 0f 1e fb          	endbr32 
  800d00:	55                   	push   %ebp
  800d01:	89 e5                	mov    %esp,%ebp
  800d03:	53                   	push   %ebx
  800d04:	83 ec 04             	sub    $0x4,%esp
  800d07:	8b 45 08             	mov    0x8(%ebp),%eax
#endif /* LWIP_DEBUG */
  int level, optname;
  const void *optval;
  struct lwip_setgetsockopt_data *data;

  LWIP_ASSERT("arg != NULL", arg != NULL);
  800d0a:	85 c0                	test   %eax,%eax
  800d0c:	74 35                	je     800d43 <lwip_setsockopt_internal+0x47>

  data = (struct lwip_setgetsockopt_data*)arg;
  sock = data->sock;
  800d0e:	8b 18                	mov    (%eax),%ebx
#ifdef LWIP_DEBUG
  s = data->s;
#endif /* LWIP_DEBUG */
  level = data->level;
  800d10:	8b 50 08             	mov    0x8(%eax),%edx
  optname = data->optname;
  800d13:	8b 48 0c             	mov    0xc(%eax),%ecx
  optval = data->optval;
  800d16:	8b 40 10             	mov    0x10(%eax),%eax

  switch (level) {
  800d19:	83 fa 06             	cmp    $0x6,%edx
  800d1c:	0f 84 aa 00 00 00    	je     800dcc <lwip_setsockopt_internal+0xd0>
  800d22:	81 fa ff 0f 00 00    	cmp    $0xfff,%edx
  800d28:	74 30                	je     800d5a <lwip_setsockopt_internal+0x5e>
  800d2a:	85 d2                	test   %edx,%edx
  800d2c:	74 76                	je     800da4 <lwip_setsockopt_internal+0xa8>
      break;
    }  /* switch (optname) */
    break;
#endif /* LWIP_UDP */
  }  /* switch (level) */
  sys_sem_signal(sock->conn->op_completed);
  800d2e:	83 ec 0c             	sub    $0xc,%esp
  800d31:	8b 03                	mov    (%ebx),%eax
  800d33:	ff 70 10             	pushl  0x10(%eax)
  800d36:	e8 3f 95 00 00       	call   80a27a <sys_sem_signal>
}
  800d3b:	83 c4 10             	add    $0x10,%esp
  800d3e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  800d41:	c9                   	leave  
  800d42:	c3                   	ret    
  LWIP_ASSERT("arg != NULL", arg != NULL);
  800d43:	83 ec 04             	sub    $0x4,%esp
  800d46:	68 a7 14 81 00       	push   $0x8114a7
  800d4b:	68 ae 06 00 00       	push   $0x6ae
  800d50:	68 90 14 81 00       	push   $0x811490
  800d55:	e8 ed da 00 00       	call   80e847 <_panic>
  800d5a:	83 f9 20             	cmp    $0x20,%ecx
  800d5d:	74 0d                	je     800d6c <lwip_setsockopt_internal+0x70>
  800d5f:	81 f9 0a 10 00 00    	cmp    $0x100a,%ecx
  800d65:	74 22                	je     800d89 <lwip_setsockopt_internal+0x8d>
  800d67:	83 f9 08             	cmp    $0x8,%ecx
  800d6a:	75 c2                	jne    800d2e <lwip_setsockopt_internal+0x32>
      if (*(int*)optval) {
  800d6c:	83 38 00             	cmpl   $0x0,(%eax)
  800d6f:	74 0b                	je     800d7c <lwip_setsockopt_internal+0x80>
        sock->conn->pcb.ip->so_options |= optname;
  800d71:	8b 03                	mov    (%ebx),%eax
  800d73:	8b 40 08             	mov    0x8(%eax),%eax
  800d76:	66 09 48 08          	or     %cx,0x8(%eax)
  800d7a:	eb b2                	jmp    800d2e <lwip_setsockopt_internal+0x32>
        sock->conn->pcb.ip->so_options &= ~optname;
  800d7c:	8b 03                	mov    (%ebx),%eax
  800d7e:	8b 40 08             	mov    0x8(%eax),%eax
  800d81:	f7 d1                	not    %ecx
  800d83:	66 21 48 08          	and    %cx,0x8(%eax)
  800d87:	eb a5                	jmp    800d2e <lwip_setsockopt_internal+0x32>
      if (*(int*)optval) {
  800d89:	83 38 00             	cmpl   $0x0,(%eax)
  800d8c:	74 0b                	je     800d99 <lwip_setsockopt_internal+0x9d>
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) | UDP_FLAGS_NOCHKSUM);
  800d8e:	8b 03                	mov    (%ebx),%eax
  800d90:	8b 40 08             	mov    0x8(%eax),%eax
  800d93:	80 48 10 01          	orb    $0x1,0x10(%eax)
  800d97:	eb 95                	jmp    800d2e <lwip_setsockopt_internal+0x32>
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) & ~UDP_FLAGS_NOCHKSUM);
  800d99:	8b 03                	mov    (%ebx),%eax
  800d9b:	8b 40 08             	mov    0x8(%eax),%eax
  800d9e:	80 60 10 fe          	andb   $0xfe,0x10(%eax)
  800da2:	eb 8a                	jmp    800d2e <lwip_setsockopt_internal+0x32>
  800da4:	83 f9 01             	cmp    $0x1,%ecx
  800da7:	74 14                	je     800dbd <lwip_setsockopt_internal+0xc1>
  800da9:	83 f9 02             	cmp    $0x2,%ecx
  800dac:	75 80                	jne    800d2e <lwip_setsockopt_internal+0x32>
      sock->conn->pcb.ip->ttl = (u8_t)(*(int*)optval);
  800dae:	8b 13                	mov    (%ebx),%edx
  800db0:	8b 52 08             	mov    0x8(%edx),%edx
  800db3:	8b 00                	mov    (%eax),%eax
  800db5:	88 42 0b             	mov    %al,0xb(%edx)
      break;
  800db8:	e9 71 ff ff ff       	jmp    800d2e <lwip_setsockopt_internal+0x32>
      sock->conn->pcb.ip->tos = (u8_t)(*(int*)optval);
  800dbd:	8b 13                	mov    (%ebx),%edx
  800dbf:	8b 52 08             	mov    0x8(%edx),%edx
  800dc2:	8b 00                	mov    (%eax),%eax
  800dc4:	88 42 0a             	mov    %al,0xa(%edx)
      break;
  800dc7:	e9 62 ff ff ff       	jmp    800d2e <lwip_setsockopt_internal+0x32>
  800dcc:	83 f9 01             	cmp    $0x1,%ecx
  800dcf:	74 1b                	je     800dec <lwip_setsockopt_internal+0xf0>
  800dd1:	83 f9 02             	cmp    $0x2,%ecx
  800dd4:	0f 85 54 ff ff ff    	jne    800d2e <lwip_setsockopt_internal+0x32>
      sock->conn->pcb.tcp->keep_idle = (u32_t)(*(int*)optval);
  800dda:	8b 13                	mov    (%ebx),%edx
  800ddc:	8b 52 08             	mov    0x8(%edx),%edx
  800ddf:	8b 00                	mov    (%eax),%eax
  800de1:	89 82 9c 00 00 00    	mov    %eax,0x9c(%edx)
      break;
  800de7:	e9 42 ff ff ff       	jmp    800d2e <lwip_setsockopt_internal+0x32>
      if (*(int*)optval) {
  800dec:	83 38 00             	cmpl   $0x0,(%eax)
  800def:	74 0e                	je     800dff <lwip_setsockopt_internal+0x103>
        sock->conn->pcb.tcp->flags |= TF_NODELAY;
  800df1:	8b 03                	mov    (%ebx),%eax
  800df3:	8b 40 08             	mov    0x8(%eax),%eax
  800df6:	80 48 20 40          	orb    $0x40,0x20(%eax)
  800dfa:	e9 2f ff ff ff       	jmp    800d2e <lwip_setsockopt_internal+0x32>
        sock->conn->pcb.tcp->flags &= ~TF_NODELAY;
  800dff:	8b 03                	mov    (%ebx),%eax
  800e01:	8b 40 08             	mov    0x8(%eax),%eax
  800e04:	80 60 20 bf          	andb   $0xbf,0x20(%eax)
  800e08:	e9 21 ff ff ff       	jmp    800d2e <lwip_setsockopt_internal+0x32>

00800e0d <lwip_socket_init>:
{
  800e0d:	f3 0f 1e fb          	endbr32 
  800e11:	55                   	push   %ebp
  800e12:	89 e5                	mov    %esp,%ebp
  800e14:	83 ec 14             	sub    $0x14,%esp
  socksem   = sys_sem_new(1);
  800e17:	6a 01                	push   $0x1
  800e19:	e8 8f 91 00 00       	call   809fad <sys_sem_new>
  800e1e:	a3 44 50 81 00       	mov    %eax,0x815044
  selectsem = sys_sem_new(1);
  800e23:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  800e2a:	e8 7e 91 00 00       	call   809fad <sys_sem_new>
  800e2f:	a3 40 50 81 00       	mov    %eax,0x815040
}
  800e34:	83 c4 10             	add    $0x10,%esp
  800e37:	c9                   	leave  
  800e38:	c3                   	ret    

00800e39 <lwip_accept>:
{
  800e39:	f3 0f 1e fb          	endbr32 
  800e3d:	55                   	push   %ebp
  800e3e:	89 e5                	mov    %esp,%ebp
  800e40:	57                   	push   %edi
  800e41:	56                   	push   %esi
  800e42:	53                   	push   %ebx
  800e43:	83 ec 3c             	sub    $0x3c,%esp
  800e46:	8b 7d 10             	mov    0x10(%ebp),%edi
  sock = get_socket(s);
  800e49:	8b 45 08             	mov    0x8(%ebp),%eax
  800e4c:	e8 de f8 ff ff       	call   80072f <get_socket>
  if (!sock)
  800e51:	85 c0                	test   %eax,%eax
  800e53:	0f 84 8c 01 00 00    	je     800fe5 <lwip_accept+0x1ac>
  800e59:	89 c6                	mov    %eax,%esi
  newconn = netconn_accept(sock->conn);
  800e5b:	83 ec 0c             	sub    $0xc,%esp
  800e5e:	ff 30                	pushl  (%eax)
  800e60:	e8 cb a2 00 00       	call   80b130 <netconn_accept>
  800e65:	89 c3                	mov    %eax,%ebx
  if (!newconn) {
  800e67:	83 c4 10             	add    $0x10,%esp
  800e6a:	85 c0                	test   %eax,%eax
  800e6c:	0f 84 de 00 00 00    	je     800f50 <lwip_accept+0x117>
  err = netconn_peer(newconn, &naddr, &port);
  800e72:	6a 00                	push   $0x0
  800e74:	8d 45 e2             	lea    -0x1e(%ebp),%eax
  800e77:	50                   	push   %eax
  800e78:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  800e7b:	50                   	push   %eax
  800e7c:	53                   	push   %ebx
  800e7d:	e8 e4 a0 00 00       	call   80af66 <netconn_getaddr>
  800e82:	88 45 c7             	mov    %al,-0x39(%ebp)
  if (err != ERR_OK) {
  800e85:	83 c4 10             	add    $0x10,%esp
  800e88:	84 c0                	test   %al,%al
  800e8a:	0f 85 e9 00 00 00    	jne    800f79 <lwip_accept+0x140>
  memset(&sin, 0, sizeof(sin));
  800e90:	83 ec 04             	sub    $0x4,%esp
  800e93:	6a 10                	push   $0x10
  800e95:	6a 00                	push   $0x0
  800e97:	8d 45 d0             	lea    -0x30(%ebp),%eax
  800e9a:	50                   	push   %eax
  800e9b:	e8 02 e2 00 00       	call   80f0a2 <memset>
  sin.sin_len = sizeof(sin);
  800ea0:	c6 45 d0 10          	movb   $0x10,-0x30(%ebp)
  sin.sin_family = AF_INET;
  800ea4:	c6 45 d1 02          	movb   $0x2,-0x2f(%ebp)
  sin.sin_port = htons(port);
  800ea8:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
  800eac:	89 04 24             	mov    %eax,(%esp)
  800eaf:	e8 ac 69 00 00       	call   807860 <htons>
  800eb4:	66 89 45 d2          	mov    %ax,-0x2e(%ebp)
  sin.sin_addr.s_addr = naddr.addr;
  800eb8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800ebb:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  if (*addrlen > sizeof(sin))
  800ebe:	83 c4 10             	add    $0x10,%esp
  800ec1:	83 3f 10             	cmpl   $0x10,(%edi)
  800ec4:	76 06                	jbe    800ecc <lwip_accept+0x93>
    *addrlen = sizeof(sin);
  800ec6:	c7 07 10 00 00 00    	movl   $0x10,(%edi)
  SMEMCPY(addr, &sin, *addrlen);
  800ecc:	83 ec 04             	sub    $0x4,%esp
  800ecf:	ff 37                	pushl  (%edi)
  800ed1:	8d 45 d0             	lea    -0x30(%ebp),%eax
  800ed4:	50                   	push   %eax
  800ed5:	ff 75 0c             	pushl  0xc(%ebp)
  800ed8:	e8 77 e2 00 00       	call   80f154 <memcpy>
  newsock = alloc_socket(newconn);
  800edd:	89 d8                	mov    %ebx,%eax
  800edf:	e8 dd fb ff ff       	call   800ac1 <alloc_socket>
  800ee4:	89 c7                	mov    %eax,%edi
  if (newsock == -1) {
  800ee6:	83 c4 10             	add    $0x10,%esp
  800ee9:	83 f8 ff             	cmp    $0xffffffff,%eax
  800eec:	0f 84 ba 00 00 00    	je     800fac <lwip_accept+0x173>
  LWIP_ASSERT("invalid socket index", (newsock >= 0) && (newsock < NUM_SOCKETS));
  800ef2:	83 f8 1f             	cmp    $0x1f,%eax
  800ef5:	0f 87 d3 00 00 00    	ja     800fce <lwip_accept+0x195>
  newconn->callback = event_callback;
  800efb:	c7 43 2c 1e 09 80 00 	movl   $0x80091e,0x2c(%ebx)
  sys_sem_wait(socksem);
  800f02:	83 ec 0c             	sub    $0xc,%esp
  800f05:	ff 35 44 50 81 00    	pushl  0x815044
  800f0b:	e8 1d 43 00 00       	call   80522d <sys_sem_wait>
  nsock->rcvevent += -1 - newconn->socket;
  800f10:	8d 04 bf             	lea    (%edi,%edi,4),%eax
  800f13:	0f b7 53 1c          	movzwl 0x1c(%ebx),%edx
  800f17:	f7 d2                	not    %edx
  800f19:	66 01 14 85 6a 50 81 	add    %dx,0x81506a(,%eax,4)
  800f20:	00 
  newconn->socket = newsock;
  800f21:	89 7b 1c             	mov    %edi,0x1c(%ebx)
  sys_sem_signal(socksem);
  800f24:	83 c4 04             	add    $0x4,%esp
  800f27:	ff 35 44 50 81 00    	pushl  0x815044
  800f2d:	e8 48 93 00 00       	call   80a27a <sys_sem_signal>
  sock_set_errno(sock, 0);
  800f32:	c7 46 10 00 00 00 00 	movl   $0x0,0x10(%esi)
  800f39:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  800f40:	00 00 00 
  return newsock;
  800f43:	83 c4 10             	add    $0x10,%esp
}
  800f46:	89 f8                	mov    %edi,%eax
  800f48:	8d 65 f4             	lea    -0xc(%ebp),%esp
  800f4b:	5b                   	pop    %ebx
  800f4c:	5e                   	pop    %esi
  800f4d:	5f                   	pop    %edi
  800f4e:	5d                   	pop    %ebp
  800f4f:	c3                   	ret    
    sock_set_errno(sock, err_to_errno(sock->conn->err));
  800f50:	8b 06                	mov    (%esi),%eax
  800f52:	0f be 40 0c          	movsbl 0xc(%eax),%eax
  800f56:	f7 d8                	neg    %eax
  800f58:	ba 05 00 00 00       	mov    $0x5,%edx
  800f5d:	83 f8 0e             	cmp    $0xe,%eax
  800f60:	77 07                	ja     800f69 <lwip_accept+0x130>
  800f62:	8b 14 85 60 15 81 00 	mov    0x811560(,%eax,4),%edx
  800f69:	89 56 10             	mov    %edx,0x10(%esi)
  800f6c:	89 15 e0 b1 b3 00    	mov    %edx,0xb3b1e0
    return -1;
  800f72:	bf ff ff ff ff       	mov    $0xffffffff,%edi
  800f77:	eb cd                	jmp    800f46 <lwip_accept+0x10d>
    netconn_delete(newconn);
  800f79:	83 ec 0c             	sub    $0xc,%esp
  800f7c:	53                   	push   %ebx
  800f7d:	e8 74 9f 00 00       	call   80aef6 <netconn_delete>
    sock_set_errno(sock, err_to_errno(err));
  800f82:	0f be 45 c7          	movsbl -0x39(%ebp),%eax
  800f86:	f7 d8                	neg    %eax
  800f88:	83 c4 10             	add    $0x10,%esp
  800f8b:	ba 05 00 00 00       	mov    $0x5,%edx
  800f90:	83 f8 0e             	cmp    $0xe,%eax
  800f93:	77 07                	ja     800f9c <lwip_accept+0x163>
  800f95:	8b 14 85 60 15 81 00 	mov    0x811560(,%eax,4),%edx
  800f9c:	89 56 10             	mov    %edx,0x10(%esi)
  800f9f:	89 15 e0 b1 b3 00    	mov    %edx,0xb3b1e0
    return -1;
  800fa5:	bf ff ff ff ff       	mov    $0xffffffff,%edi
  800faa:	eb 9a                	jmp    800f46 <lwip_accept+0x10d>
    netconn_delete(newconn);
  800fac:	83 ec 0c             	sub    $0xc,%esp
  800faf:	53                   	push   %ebx
  800fb0:	e8 41 9f 00 00       	call   80aef6 <netconn_delete>
    sock_set_errno(sock, ENFILE);
  800fb5:	c7 46 10 17 00 00 00 	movl   $0x17,0x10(%esi)
  800fbc:	c7 05 e0 b1 b3 00 17 	movl   $0x17,0xb3b1e0
  800fc3:	00 00 00 
    return -1;
  800fc6:	83 c4 10             	add    $0x10,%esp
  800fc9:	e9 78 ff ff ff       	jmp    800f46 <lwip_accept+0x10d>
  LWIP_ASSERT("invalid socket index", (newsock >= 0) && (newsock < NUM_SOCKETS));
  800fce:	83 ec 04             	sub    $0x4,%esp
  800fd1:	68 b3 14 81 00       	push   $0x8114b3
  800fd6:	68 25 01 00 00       	push   $0x125
  800fdb:	68 90 14 81 00       	push   $0x811490
  800fe0:	e8 62 d8 00 00       	call   80e847 <_panic>
    return -1;
  800fe5:	bf ff ff ff ff       	mov    $0xffffffff,%edi
  800fea:	e9 57 ff ff ff       	jmp    800f46 <lwip_accept+0x10d>

00800fef <lwip_bind>:
{
  800fef:	f3 0f 1e fb          	endbr32 
  800ff3:	55                   	push   %ebp
  800ff4:	89 e5                	mov    %esp,%ebp
  800ff6:	56                   	push   %esi
  800ff7:	53                   	push   %ebx
  800ff8:	83 ec 10             	sub    $0x10,%esp
  800ffb:	8b 75 0c             	mov    0xc(%ebp),%esi
  sock = get_socket(s);
  800ffe:	8b 45 08             	mov    0x8(%ebp),%eax
  801001:	e8 29 f7 ff ff       	call   80072f <get_socket>
  if (!sock)
  801006:	85 c0                	test   %eax,%eax
  801008:	0f 84 94 00 00 00    	je     8010a2 <lwip_bind+0xb3>
  80100e:	89 c3                	mov    %eax,%ebx
  LWIP_ERROR("lwip_bind: invalid address", ((namelen == sizeof(struct sockaddr_in)) &&
  801010:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
  801014:	75 4f                	jne    801065 <lwip_bind+0x76>
  801016:	80 7e 01 02          	cmpb   $0x2,0x1(%esi)
  80101a:	75 49                	jne    801065 <lwip_bind+0x76>
  local_addr.addr = ((struct sockaddr_in *)name)->sin_addr.s_addr;
  80101c:	8b 46 04             	mov    0x4(%esi),%eax
  80101f:	89 45 f4             	mov    %eax,-0xc(%ebp)
  err = netconn_bind(sock->conn, &local_addr, ntohs(local_port));
  801022:	83 ec 0c             	sub    $0xc,%esp
  801025:	0f b7 46 02          	movzwl 0x2(%esi),%eax
  801029:	50                   	push   %eax
  80102a:	e8 42 68 00 00       	call   807871 <ntohs>
  80102f:	83 c4 0c             	add    $0xc,%esp
  801032:	0f b7 c0             	movzwl %ax,%eax
  801035:	50                   	push   %eax
  801036:	8d 45 f4             	lea    -0xc(%ebp),%eax
  801039:	50                   	push   %eax
  80103a:	ff 33                	pushl  (%ebx)
  80103c:	e8 b5 9f 00 00       	call   80aff6 <netconn_bind>
  if (err != ERR_OK) {
  801041:	83 c4 10             	add    $0x10,%esp
  801044:	84 c0                	test   %al,%al
  801046:	75 34                	jne    80107c <lwip_bind+0x8d>
  sock_set_errno(sock, 0);
  801048:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  80104f:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  801056:	00 00 00 
  return 0;
  801059:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80105e:	8d 65 f8             	lea    -0x8(%ebp),%esp
  801061:	5b                   	pop    %ebx
  801062:	5e                   	pop    %esi
  801063:	5d                   	pop    %ebp
  801064:	c3                   	ret    
  LWIP_ERROR("lwip_bind: invalid address", ((namelen == sizeof(struct sockaddr_in)) &&
  801065:	83 ec 04             	sub    $0x4,%esp
  801068:	68 c8 14 81 00       	push   $0x8114c8
  80106d:	68 48 01 00 00       	push   $0x148
  801072:	68 90 14 81 00       	push   $0x811490
  801077:	e8 cb d7 00 00       	call   80e847 <_panic>
    sock_set_errno(sock, err_to_errno(err));
  80107c:	0f be c0             	movsbl %al,%eax
  80107f:	f7 d8                	neg    %eax
  801081:	ba 05 00 00 00       	mov    $0x5,%edx
  801086:	83 f8 0e             	cmp    $0xe,%eax
  801089:	77 07                	ja     801092 <lwip_bind+0xa3>
  80108b:	8b 14 85 60 15 81 00 	mov    0x811560(,%eax,4),%edx
  801092:	89 53 10             	mov    %edx,0x10(%ebx)
  801095:	89 15 e0 b1 b3 00    	mov    %edx,0xb3b1e0
    return -1;
  80109b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8010a0:	eb bc                	jmp    80105e <lwip_bind+0x6f>
    return -1;
  8010a2:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8010a7:	eb b5                	jmp    80105e <lwip_bind+0x6f>

008010a9 <lwip_close>:
{
  8010a9:	f3 0f 1e fb          	endbr32 
  8010ad:	55                   	push   %ebp
  8010ae:	89 e5                	mov    %esp,%ebp
  8010b0:	53                   	push   %ebx
  8010b1:	83 ec 04             	sub    $0x4,%esp
  sock = get_socket(s);
  8010b4:	8b 45 08             	mov    0x8(%ebp),%eax
  8010b7:	e8 73 f6 ff ff       	call   80072f <get_socket>
  if (!sock) {
  8010bc:	85 c0                	test   %eax,%eax
  8010be:	74 6f                	je     80112f <lwip_close+0x86>
  8010c0:	89 c3                	mov    %eax,%ebx
  netconn_delete(sock->conn);
  8010c2:	83 ec 0c             	sub    $0xc,%esp
  8010c5:	ff 30                	pushl  (%eax)
  8010c7:	e8 2a 9e 00 00       	call   80aef6 <netconn_delete>
  sys_sem_wait(socksem);
  8010cc:	83 c4 04             	add    $0x4,%esp
  8010cf:	ff 35 44 50 81 00    	pushl  0x815044
  8010d5:	e8 53 41 00 00       	call   80522d <sys_sem_wait>
  if (sock->lastdata) {
  8010da:	8b 43 04             	mov    0x4(%ebx),%eax
  8010dd:	83 c4 10             	add    $0x10,%esp
  8010e0:	85 c0                	test   %eax,%eax
  8010e2:	74 0c                	je     8010f0 <lwip_close+0x47>
    netbuf_delete(sock->lastdata);
  8010e4:	83 ec 0c             	sub    $0xc,%esp
  8010e7:	50                   	push   %eax
  8010e8:	e8 1b 14 00 00       	call   802508 <netbuf_delete>
  8010ed:	83 c4 10             	add    $0x10,%esp
  sock->lastdata   = NULL;
  8010f0:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  sock->lastoffset = 0;
  8010f7:	66 c7 43 08 00 00    	movw   $0x0,0x8(%ebx)
  sock->conn       = NULL;
  8010fd:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
  sock_set_errno(sock, 0);
  801103:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  80110a:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  801111:	00 00 00 
  sys_sem_signal(socksem);
  801114:	83 ec 0c             	sub    $0xc,%esp
  801117:	ff 35 44 50 81 00    	pushl  0x815044
  80111d:	e8 58 91 00 00       	call   80a27a <sys_sem_signal>
  return 0;
  801122:	83 c4 10             	add    $0x10,%esp
  801125:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80112a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80112d:	c9                   	leave  
  80112e:	c3                   	ret    
    return -1;
  80112f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801134:	eb f4                	jmp    80112a <lwip_close+0x81>

00801136 <lwip_connect>:
{
  801136:	f3 0f 1e fb          	endbr32 
  80113a:	55                   	push   %ebp
  80113b:	89 e5                	mov    %esp,%ebp
  80113d:	56                   	push   %esi
  80113e:	53                   	push   %ebx
  80113f:	83 ec 10             	sub    $0x10,%esp
  801142:	8b 75 0c             	mov    0xc(%ebp),%esi
  sock = get_socket(s);
  801145:	8b 45 08             	mov    0x8(%ebp),%eax
  801148:	e8 e2 f5 ff ff       	call   80072f <get_socket>
  if (!sock)
  80114d:	85 c0                	test   %eax,%eax
  80114f:	0f 84 94 00 00 00    	je     8011e9 <lwip_connect+0xb3>
  801155:	89 c3                	mov    %eax,%ebx
  LWIP_ERROR("lwip_connect: invalid address", ((namelen == sizeof(struct sockaddr_in)) &&
  801157:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
  80115b:	75 4f                	jne    8011ac <lwip_connect+0x76>
  80115d:	80 7e 01 02          	cmpb   $0x2,0x1(%esi)
  801161:	75 49                	jne    8011ac <lwip_connect+0x76>
    remote_addr.addr = ((struct sockaddr_in *)name)->sin_addr.s_addr;
  801163:	8b 46 04             	mov    0x4(%esi),%eax
  801166:	89 45 f4             	mov    %eax,-0xc(%ebp)
    err = netconn_connect(sock->conn, &remote_addr, ntohs(remote_port));
  801169:	83 ec 0c             	sub    $0xc,%esp
  80116c:	0f b7 46 02          	movzwl 0x2(%esi),%eax
  801170:	50                   	push   %eax
  801171:	e8 fb 66 00 00       	call   807871 <ntohs>
  801176:	83 c4 0c             	add    $0xc,%esp
  801179:	0f b7 c0             	movzwl %ax,%eax
  80117c:	50                   	push   %eax
  80117d:	8d 45 f4             	lea    -0xc(%ebp),%eax
  801180:	50                   	push   %eax
  801181:	ff 33                	pushl  (%ebx)
  801183:	e8 c3 9e 00 00       	call   80b04b <netconn_connect>
  if (err != ERR_OK) {
  801188:	83 c4 10             	add    $0x10,%esp
  80118b:	84 c0                	test   %al,%al
  80118d:	75 34                	jne    8011c3 <lwip_connect+0x8d>
  sock_set_errno(sock, 0);
  80118f:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  801196:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  80119d:	00 00 00 
  return 0;
  8011a0:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8011a5:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8011a8:	5b                   	pop    %ebx
  8011a9:	5e                   	pop    %esi
  8011aa:	5d                   	pop    %ebp
  8011ab:	c3                   	ret    
  LWIP_ERROR("lwip_connect: invalid address", ((namelen == sizeof(struct sockaddr_in)) &&
  8011ac:	83 ec 04             	sub    $0x4,%esp
  8011af:	68 e3 14 81 00       	push   $0x8114e3
  8011b4:	68 84 01 00 00       	push   $0x184
  8011b9:	68 90 14 81 00       	push   $0x811490
  8011be:	e8 84 d6 00 00       	call   80e847 <_panic>
    sock_set_errno(sock, err_to_errno(err));
  8011c3:	0f be c0             	movsbl %al,%eax
  8011c6:	f7 d8                	neg    %eax
  8011c8:	ba 05 00 00 00       	mov    $0x5,%edx
  8011cd:	83 f8 0e             	cmp    $0xe,%eax
  8011d0:	77 07                	ja     8011d9 <lwip_connect+0xa3>
  8011d2:	8b 14 85 60 15 81 00 	mov    0x811560(,%eax,4),%edx
  8011d9:	89 53 10             	mov    %edx,0x10(%ebx)
  8011dc:	89 15 e0 b1 b3 00    	mov    %edx,0xb3b1e0
    return -1;
  8011e2:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8011e7:	eb bc                	jmp    8011a5 <lwip_connect+0x6f>
    return -1;
  8011e9:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8011ee:	eb b5                	jmp    8011a5 <lwip_connect+0x6f>

008011f0 <lwip_listen>:
{
  8011f0:	f3 0f 1e fb          	endbr32 
  8011f4:	55                   	push   %ebp
  8011f5:	89 e5                	mov    %esp,%ebp
  8011f7:	56                   	push   %esi
  8011f8:	53                   	push   %ebx
  8011f9:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  sock = get_socket(s);
  8011fc:	8b 45 08             	mov    0x8(%ebp),%eax
  8011ff:	e8 2b f5 ff ff       	call   80072f <get_socket>
  if (!sock)
  801204:	85 c0                	test   %eax,%eax
  801206:	74 6f                	je     801277 <lwip_listen+0x87>
  801208:	89 c6                	mov    %eax,%esi
  80120a:	81 fb ff 00 00 00    	cmp    $0xff,%ebx
  801210:	b8 ff 00 00 00       	mov    $0xff,%eax
  801215:	0f 4f d8             	cmovg  %eax,%ebx
  err = netconn_listen_with_backlog(sock->conn, backlog);
  801218:	83 ec 08             	sub    $0x8,%esp
  80121b:	85 db                	test   %ebx,%ebx
  80121d:	b8 00 00 00 00       	mov    $0x0,%eax
  801222:	0f 48 d8             	cmovs  %eax,%ebx
  801225:	53                   	push   %ebx
  801226:	ff 36                	pushl  (%esi)
  801228:	e8 bb 9e 00 00       	call   80b0e8 <netconn_listen_with_backlog>
  if (err != ERR_OK) {
  80122d:	83 c4 10             	add    $0x10,%esp
  801230:	84 c0                	test   %al,%al
  801232:	75 1d                	jne    801251 <lwip_listen+0x61>
  sock_set_errno(sock, 0);
  801234:	c7 46 10 00 00 00 00 	movl   $0x0,0x10(%esi)
  80123b:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  801242:	00 00 00 
  return 0;
  801245:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80124a:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80124d:	5b                   	pop    %ebx
  80124e:	5e                   	pop    %esi
  80124f:	5d                   	pop    %ebp
  801250:	c3                   	ret    
    sock_set_errno(sock, err_to_errno(err));
  801251:	0f be c0             	movsbl %al,%eax
  801254:	f7 d8                	neg    %eax
  801256:	ba 05 00 00 00       	mov    $0x5,%edx
  80125b:	83 f8 0e             	cmp    $0xe,%eax
  80125e:	77 07                	ja     801267 <lwip_listen+0x77>
  801260:	8b 14 85 60 15 81 00 	mov    0x811560(,%eax,4),%edx
  801267:	89 56 10             	mov    %edx,0x10(%esi)
  80126a:	89 15 e0 b1 b3 00    	mov    %edx,0xb3b1e0
    return -1;
  801270:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801275:	eb d3                	jmp    80124a <lwip_listen+0x5a>
    return -1;
  801277:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80127c:	eb cc                	jmp    80124a <lwip_listen+0x5a>

0080127e <lwip_recvfrom>:
{
  80127e:	f3 0f 1e fb          	endbr32 
  801282:	55                   	push   %ebp
  801283:	89 e5                	mov    %esp,%ebp
  801285:	57                   	push   %edi
  801286:	56                   	push   %esi
  801287:	53                   	push   %ebx
  801288:	83 ec 3c             	sub    $0x3c,%esp
  sock = get_socket(s);
  80128b:	8b 45 08             	mov    0x8(%ebp),%eax
  80128e:	e8 9c f4 ff ff       	call   80072f <get_socket>
  if (!sock)
  801293:	85 c0                	test   %eax,%eax
  801295:	0f 84 22 02 00 00    	je     8014bd <lwip_recvfrom+0x23f>
  80129b:	89 c7                	mov    %eax,%edi
  u16_t               buflen, copylen, off = 0;
  80129d:	66 c7 45 c4 00 00    	movw   $0x0,-0x3c(%ebp)
      if (((flags & MSG_DONTWAIT) || (sock->flags & O_NONBLOCK)) && !sock->rcvevent) {
  8012a3:	8b 45 14             	mov    0x14(%ebp),%eax
  8012a6:	83 e0 08             	and    $0x8,%eax
  8012a9:	89 45 b8             	mov    %eax,-0x48(%ebp)
  8012ac:	e9 a7 00 00 00       	jmp    801358 <lwip_recvfrom+0xda>
  8012b1:	83 7d b8 00          	cmpl   $0x0,-0x48(%ebp)
  8012b5:	75 06                	jne    8012bd <lwip_recvfrom+0x3f>
  8012b7:	f6 47 0f 08          	testb  $0x8,0xf(%edi)
  8012bb:	74 07                	je     8012c4 <lwip_recvfrom+0x46>
  8012bd:	66 83 7f 0a 00       	cmpw   $0x0,0xa(%edi)
  8012c2:	74 56                	je     80131a <lwip_recvfrom+0x9c>
      sock->lastdata = buf = netconn_recv(sock->conn);
  8012c4:	83 ec 0c             	sub    $0xc,%esp
  8012c7:	ff 37                	pushl  (%edi)
  8012c9:	e8 d8 9e 00 00       	call   80b1a6 <netconn_recv>
  8012ce:	89 c6                	mov    %eax,%esi
  8012d0:	89 47 04             	mov    %eax,0x4(%edi)
      if (!buf) {
  8012d3:	83 c4 10             	add    $0x10,%esp
  8012d6:	85 c0                	test   %eax,%eax
  8012d8:	0f 85 85 00 00 00    	jne    801363 <lwip_recvfrom+0xe5>
        sock_set_errno(sock, (((sock->conn->pcb.ip!=NULL) && (sock->conn->err==ERR_OK))?ETIMEDOUT:err_to_errno(sock->conn->err)));
  8012de:	8b 17                	mov    (%edi),%edx
  8012e0:	83 7a 08 00          	cmpl   $0x0,0x8(%edx)
  8012e4:	74 0b                	je     8012f1 <lwip_recvfrom+0x73>
  8012e6:	b8 6e 00 00 00       	mov    $0x6e,%eax
  8012eb:	80 7a 0c 00          	cmpb   $0x0,0xc(%edx)
  8012ef:	74 17                	je     801308 <lwip_recvfrom+0x8a>
  8012f1:	0f be 52 0c          	movsbl 0xc(%edx),%edx
  8012f5:	f7 da                	neg    %edx
  8012f7:	b8 05 00 00 00       	mov    $0x5,%eax
  8012fc:	83 fa 0e             	cmp    $0xe,%edx
  8012ff:	77 07                	ja     801308 <lwip_recvfrom+0x8a>
  801301:	8b 04 95 60 15 81 00 	mov    0x811560(,%edx,4),%eax
  801308:	89 47 10             	mov    %eax,0x10(%edi)
  80130b:	a3 e0 b1 b3 00       	mov    %eax,0xb3b1e0
        return 0;
  801310:	b8 00 00 00 00       	mov    $0x0,%eax
  801315:	e9 0b 01 00 00       	jmp    801425 <lwip_recvfrom+0x1a7>
        sock_set_errno(sock, EWOULDBLOCK);
  80131a:	c7 47 10 0b 00 00 00 	movl   $0xb,0x10(%edi)
  801321:	c7 05 e0 b1 b3 00 0b 	movl   $0xb,0xb3b1e0
  801328:	00 00 00 
        return -1;
  80132b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801330:	e9 f0 00 00 00       	jmp    801425 <lwip_recvfrom+0x1a7>
        sock->lastdata = NULL;
  801335:	c7 47 04 00 00 00 00 	movl   $0x0,0x4(%edi)
        sock->lastoffset = 0;
  80133c:	66 c7 47 08 00 00    	movw   $0x0,0x8(%edi)
        netbuf_delete(buf);
  801342:	83 ec 0c             	sub    $0xc,%esp
  801345:	56                   	push   %esi
  801346:	e8 bd 11 00 00       	call   802508 <netbuf_delete>
  80134b:	83 c4 10             	add    $0x10,%esp
  } while (!done);
  80134e:	80 7d c7 00          	cmpb   $0x0,-0x39(%ebp)
  801352:	0f 85 ac 00 00 00    	jne    801404 <lwip_recvfrom+0x186>
    if (sock->lastdata) {
  801358:	8b 77 04             	mov    0x4(%edi),%esi
  80135b:	85 f6                	test   %esi,%esi
  80135d:	0f 84 4e ff ff ff    	je     8012b1 <lwip_recvfrom+0x33>
    buflen = netbuf_len(buf);
  801363:	8b 16                	mov    (%esi),%edx
  801365:	0f b7 4a 08          	movzwl 0x8(%edx),%ecx
    buflen -= sock->lastoffset;
  801369:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  80136d:	89 cb                	mov    %ecx,%ebx
  80136f:	29 c3                	sub    %eax,%ebx
    if (len > buflen) {
  801371:	0f b7 db             	movzwl %bx,%ebx
  801374:	89 5d bc             	mov    %ebx,-0x44(%ebp)
      copylen = len;
  801377:	29 c1                	sub    %eax,%ecx
  801379:	3b 5d 10             	cmp    0x10(%ebp),%ebx
  80137c:	66 0f 4d 4d 10       	cmovge 0x10(%ebp),%cx
  801381:	89 cb                	mov    %ecx,%ebx
    netbuf_copy_partial(buf, (u8_t*)mem + off, copylen, sock->lastoffset);
  801383:	0f b7 c9             	movzwl %cx,%ecx
  801386:	0f b7 c0             	movzwl %ax,%eax
  801389:	50                   	push   %eax
  80138a:	89 4d c0             	mov    %ecx,-0x40(%ebp)
  80138d:	51                   	push   %ecx
  80138e:	0f b7 45 c4          	movzwl -0x3c(%ebp),%eax
  801392:	03 45 0c             	add    0xc(%ebp),%eax
  801395:	50                   	push   %eax
  801396:	52                   	push   %edx
  801397:	e8 15 3d 00 00       	call   8050b1 <pbuf_copy_partial>
    off += copylen;
  80139c:	66 01 5d c4          	add    %bx,-0x3c(%ebp)
    if (netconn_type(sock->conn) == NETCONN_TCP) {
  8013a0:	83 c4 04             	add    $0x4,%esp
  8013a3:	ff 37                	pushl  (%edi)
  8013a5:	e8 90 9b 00 00       	call   80af3a <netconn_type>
  8013aa:	83 c4 10             	add    $0x10,%esp
      done = 1;
  8013ad:	c6 45 c7 01          	movb   $0x1,-0x39(%ebp)
    if (netconn_type(sock->conn) == NETCONN_TCP) {
  8013b1:	83 f8 10             	cmp    $0x10,%eax
  8013b4:	75 23                	jne    8013d9 <lwip_recvfrom+0x15b>
      len -= copylen;
  8013b6:	8b 4d c0             	mov    -0x40(%ebp),%ecx
  8013b9:	29 4d 10             	sub    %ecx,0x10(%ebp)
      if ( (len <= 0) || (buf->p->flags & PBUF_FLAG_PUSH) || !sock->rcvevent) {
  8013bc:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  8013c0:	7e 17                	jle    8013d9 <lwip_recvfrom+0x15b>
  8013c2:	8b 06                	mov    (%esi),%eax
  8013c4:	0f b6 40 0d          	movzbl 0xd(%eax),%eax
  8013c8:	83 e0 01             	and    $0x1,%eax
  8013cb:	88 45 c7             	mov    %al,-0x39(%ebp)
  8013ce:	75 09                	jne    8013d9 <lwip_recvfrom+0x15b>
  8013d0:	66 83 7f 0a 00       	cmpw   $0x0,0xa(%edi)
  8013d5:	0f 94 45 c7          	sete   -0x39(%ebp)
    if ((flags & MSG_PEEK)==0) {
  8013d9:	f6 45 14 01          	testb  $0x1,0x14(%ebp)
  8013dd:	75 25                	jne    801404 <lwip_recvfrom+0x186>
      if ((sock->conn->type == NETCONN_TCP) && (buflen - copylen > 0)) {
  8013df:	8b 07                	mov    (%edi),%eax
  8013e1:	83 38 10             	cmpl   $0x10,(%eax)
  8013e4:	0f 85 4b ff ff ff    	jne    801335 <lwip_recvfrom+0xb7>
  8013ea:	8b 45 bc             	mov    -0x44(%ebp),%eax
  8013ed:	2b 45 c0             	sub    -0x40(%ebp),%eax
  8013f0:	85 c0                	test   %eax,%eax
  8013f2:	0f 8e 3d ff ff ff    	jle    801335 <lwip_recvfrom+0xb7>
        sock->lastdata = buf;
  8013f8:	89 77 04             	mov    %esi,0x4(%edi)
        sock->lastoffset += copylen;
  8013fb:	66 01 5f 08          	add    %bx,0x8(%edi)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: lastdata now netbuf=%p\n", (void*)buf));
  8013ff:	e9 4a ff ff ff       	jmp    80134e <lwip_recvfrom+0xd0>
  if (from && fromlen) {
  801404:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
  801408:	74 06                	je     801410 <lwip_recvfrom+0x192>
  80140a:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  80140e:	75 1d                	jne    80142d <lwip_recvfrom+0x1af>
  sock_set_errno(sock, 0);
  801410:	c7 47 10 00 00 00 00 	movl   $0x0,0x10(%edi)
  801417:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  80141e:	00 00 00 
  return off;
  801421:	0f b7 45 c4          	movzwl -0x3c(%ebp),%eax
}
  801425:	8d 65 f4             	lea    -0xc(%ebp),%esp
  801428:	5b                   	pop    %ebx
  801429:	5e                   	pop    %esi
  80142a:	5f                   	pop    %edi
  80142b:	5d                   	pop    %ebp
  80142c:	c3                   	ret    
    if (netconn_type(sock->conn) == NETCONN_TCP) {
  80142d:	83 ec 0c             	sub    $0xc,%esp
  801430:	ff 37                	pushl  (%edi)
  801432:	e8 03 9b 00 00       	call   80af3a <netconn_type>
  801437:	83 c4 10             	add    $0x10,%esp
  80143a:	83 f8 10             	cmp    $0x10,%eax
  80143d:	74 65                	je     8014a4 <lwip_recvfrom+0x226>
      addr = netbuf_fromaddr(buf);
  80143f:	8b 5e 08             	mov    0x8(%esi),%ebx
      port = netbuf_fromport(buf);
  801442:	0f b7 46 0c          	movzwl 0xc(%esi),%eax
  801446:	66 89 45 e6          	mov    %ax,-0x1a(%ebp)
    memset(&sin, 0, sizeof(sin));
  80144a:	83 ec 04             	sub    $0x4,%esp
  80144d:	6a 10                	push   $0x10
  80144f:	6a 00                	push   $0x0
  801451:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  801454:	50                   	push   %eax
  801455:	e8 48 dc 00 00       	call   80f0a2 <memset>
    sin.sin_len = sizeof(sin);
  80145a:	c6 45 d4 10          	movb   $0x10,-0x2c(%ebp)
    sin.sin_family = AF_INET;
  80145e:	c6 45 d5 02          	movb   $0x2,-0x2b(%ebp)
    sin.sin_port = htons(port);
  801462:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  801466:	89 04 24             	mov    %eax,(%esp)
  801469:	e8 f2 63 00 00       	call   807860 <htons>
  80146e:	66 89 45 d6          	mov    %ax,-0x2a(%ebp)
    sin.sin_addr.s_addr = addr->addr;
  801472:	8b 03                	mov    (%ebx),%eax
  801474:	89 45 d8             	mov    %eax,-0x28(%ebp)
    if (*fromlen > sizeof(sin))
  801477:	83 c4 10             	add    $0x10,%esp
  80147a:	8b 45 1c             	mov    0x1c(%ebp),%eax
  80147d:	83 38 10             	cmpl   $0x10,(%eax)
  801480:	76 06                	jbe    801488 <lwip_recvfrom+0x20a>
      *fromlen = sizeof(sin);
  801482:	c7 00 10 00 00 00    	movl   $0x10,(%eax)
    SMEMCPY(from, &sin, *fromlen);
  801488:	83 ec 04             	sub    $0x4,%esp
  80148b:	8b 45 1c             	mov    0x1c(%ebp),%eax
  80148e:	ff 30                	pushl  (%eax)
  801490:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  801493:	50                   	push   %eax
  801494:	ff 75 18             	pushl  0x18(%ebp)
  801497:	e8 b8 dc 00 00       	call   80f154 <memcpy>
  80149c:	83 c4 10             	add    $0x10,%esp
  80149f:	e9 6c ff ff ff       	jmp    801410 <lwip_recvfrom+0x192>
      netconn_getaddr(sock->conn, addr, &port, 0);
  8014a4:	6a 00                	push   $0x0
  8014a6:	8d 45 e6             	lea    -0x1a(%ebp),%eax
  8014a9:	50                   	push   %eax
  8014aa:	8d 45 d8             	lea    -0x28(%ebp),%eax
  8014ad:	50                   	push   %eax
  8014ae:	ff 37                	pushl  (%edi)
  8014b0:	e8 b1 9a 00 00       	call   80af66 <netconn_getaddr>
  8014b5:	83 c4 10             	add    $0x10,%esp
      addr = (struct ip_addr*)&(sin.sin_addr.s_addr);
  8014b8:	8d 5d d8             	lea    -0x28(%ebp),%ebx
  8014bb:	eb 8d                	jmp    80144a <lwip_recvfrom+0x1cc>
    return -1;
  8014bd:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8014c2:	e9 5e ff ff ff       	jmp    801425 <lwip_recvfrom+0x1a7>

008014c7 <lwip_read>:
{
  8014c7:	f3 0f 1e fb          	endbr32 
  8014cb:	55                   	push   %ebp
  8014cc:	89 e5                	mov    %esp,%ebp
  8014ce:	83 ec 10             	sub    $0x10,%esp
  return lwip_recvfrom(s, mem, len, 0, NULL, NULL);
  8014d1:	6a 00                	push   $0x0
  8014d3:	6a 00                	push   $0x0
  8014d5:	6a 00                	push   $0x0
  8014d7:	ff 75 10             	pushl  0x10(%ebp)
  8014da:	ff 75 0c             	pushl  0xc(%ebp)
  8014dd:	ff 75 08             	pushl  0x8(%ebp)
  8014e0:	e8 99 fd ff ff       	call   80127e <lwip_recvfrom>
}
  8014e5:	c9                   	leave  
  8014e6:	c3                   	ret    

008014e7 <lwip_recv>:
{
  8014e7:	f3 0f 1e fb          	endbr32 
  8014eb:	55                   	push   %ebp
  8014ec:	89 e5                	mov    %esp,%ebp
  8014ee:	83 ec 10             	sub    $0x10,%esp
  return lwip_recvfrom(s, mem, len, flags, NULL, NULL);
  8014f1:	6a 00                	push   $0x0
  8014f3:	6a 00                	push   $0x0
  8014f5:	ff 75 14             	pushl  0x14(%ebp)
  8014f8:	ff 75 10             	pushl  0x10(%ebp)
  8014fb:	ff 75 0c             	pushl  0xc(%ebp)
  8014fe:	ff 75 08             	pushl  0x8(%ebp)
  801501:	e8 78 fd ff ff       	call   80127e <lwip_recvfrom>
}
  801506:	c9                   	leave  
  801507:	c3                   	ret    

00801508 <lwip_sendto>:
{
  801508:	f3 0f 1e fb          	endbr32 
  80150c:	55                   	push   %ebp
  80150d:	89 e5                	mov    %esp,%ebp
  80150f:	57                   	push   %edi
  801510:	56                   	push   %esi
  801511:	53                   	push   %ebx
  801512:	83 ec 2c             	sub    $0x2c,%esp
  801515:	8b 75 10             	mov    0x10(%ebp),%esi
  801518:	8b 7d 18             	mov    0x18(%ebp),%edi
  sock = get_socket(s);
  80151b:	8b 45 08             	mov    0x8(%ebp),%eax
  80151e:	e8 0c f2 ff ff       	call   80072f <get_socket>
  if (!sock)
  801523:	85 c0                	test   %eax,%eax
  801525:	0f 84 28 01 00 00    	je     801653 <lwip_sendto+0x14b>
  80152b:	89 c3                	mov    %eax,%ebx
  if (sock->conn->type==NETCONN_TCP) {
  80152d:	8b 00                	mov    (%eax),%eax
  80152f:	83 38 10             	cmpl   $0x10,(%eax)
  801532:	0f 84 be 00 00 00    	je     8015f6 <lwip_sendto+0xee>
  LWIP_ASSERT("lwip_sendto: size must fit in u16_t",
  801538:	81 fe ff ff 00 00    	cmp    $0xffff,%esi
  80153e:	0f 87 c8 00 00 00    	ja     80160c <lwip_sendto+0x104>
  LWIP_ERROR("lwip_sendto: invalid address", (((to == NULL) && (tolen == 0)) ||
  801544:	89 f8                	mov    %edi,%eax
  801546:	0b 45 1c             	or     0x1c(%ebp),%eax
  801549:	0f 84 0b 01 00 00    	je     80165a <lwip_sendto+0x152>
  80154f:	83 7d 1c 10          	cmpl   $0x10,0x1c(%ebp)
  801553:	0f 85 ca 00 00 00    	jne    801623 <lwip_sendto+0x11b>
  801559:	80 7f 01 02          	cmpb   $0x2,0x1(%edi)
  80155d:	0f 85 c0 00 00 00    	jne    801623 <lwip_sendto+0x11b>
  buf.p = buf.ptr = NULL;
  801563:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
  80156a:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
    remote_addr.addr = ((struct sockaddr_in *)to)->sin_addr.s_addr;
  801571:	8b 47 04             	mov    0x4(%edi),%eax
  801574:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    remote_port      = ntohs(((struct sockaddr_in *)to)->sin_port);
  801577:	83 ec 0c             	sub    $0xc,%esp
  80157a:	0f b7 47 02          	movzwl 0x2(%edi),%eax
  80157e:	50                   	push   %eax
  80157f:	e8 ed 62 00 00       	call   807871 <ntohs>
    buf.addr         = &remote_addr;
  801584:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  801587:	89 55 dc             	mov    %edx,-0x24(%ebp)
    buf.port         = remote_port;
  80158a:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
  80158e:	83 c4 10             	add    $0x10,%esp
  if ((err = netbuf_ref(&buf, data, size)) == ERR_OK) {
  801591:	83 ec 04             	sub    $0x4,%esp
  801594:	0f b7 c6             	movzwl %si,%eax
  801597:	50                   	push   %eax
  801598:	ff 75 0c             	pushl  0xc(%ebp)
  80159b:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  80159e:	50                   	push   %eax
  80159f:	e8 6b 10 00 00       	call   80260f <netbuf_ref>
  8015a4:	0f be f8             	movsbl %al,%edi
  8015a7:	83 c4 10             	add    $0x10,%esp
  8015aa:	85 ff                	test   %edi,%edi
  8015ac:	0f 84 88 00 00 00    	je     80163a <lwip_sendto+0x132>
  if (buf.p != NULL) {
  8015b2:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  8015b5:	85 c0                	test   %eax,%eax
  8015b7:	74 0c                	je     8015c5 <lwip_sendto+0xbd>
    pbuf_free(buf.p);
  8015b9:	83 ec 0c             	sub    $0xc,%esp
  8015bc:	50                   	push   %eax
  8015bd:	e8 66 33 00 00       	call   804928 <pbuf_free>
  8015c2:	83 c4 10             	add    $0x10,%esp
  sock_set_errno(sock, err_to_errno(err));
  8015c5:	89 fa                	mov    %edi,%edx
  8015c7:	f7 da                	neg    %edx
  8015c9:	b8 05 00 00 00       	mov    $0x5,%eax
  8015ce:	83 fa 0e             	cmp    $0xe,%edx
  8015d1:	77 07                	ja     8015da <lwip_sendto+0xd2>
  8015d3:	8b 04 95 60 15 81 00 	mov    0x811560(,%edx,4),%eax
  8015da:	89 43 10             	mov    %eax,0x10(%ebx)
  8015dd:	a3 e0 b1 b3 00       	mov    %eax,0xb3b1e0
  return (err==ERR_OK?size:-1);
  8015e2:	85 ff                	test   %edi,%edi
  8015e4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8015e9:	0f 45 f0             	cmovne %eax,%esi
}
  8015ec:	89 f0                	mov    %esi,%eax
  8015ee:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8015f1:	5b                   	pop    %ebx
  8015f2:	5e                   	pop    %esi
  8015f3:	5f                   	pop    %edi
  8015f4:	5d                   	pop    %ebp
  8015f5:	c3                   	ret    
    return lwip_send(s, data, size, flags);
  8015f6:	ff 75 14             	pushl  0x14(%ebp)
  8015f9:	56                   	push   %esi
  8015fa:	ff 75 0c             	pushl  0xc(%ebp)
  8015fd:	ff 75 08             	pushl  0x8(%ebp)
  801600:	e8 7c 00 00 00       	call   801681 <lwip_send>
  801605:	89 c6                	mov    %eax,%esi
  801607:	83 c4 10             	add    $0x10,%esp
  80160a:	eb e0                	jmp    8015ec <lwip_sendto+0xe4>
  LWIP_ASSERT("lwip_sendto: size must fit in u16_t",
  80160c:	83 ec 04             	sub    $0x4,%esp
  80160f:	68 20 15 81 00       	push   $0x811520
  801614:	68 96 02 00 00       	push   $0x296
  801619:	68 90 14 81 00       	push   $0x811490
  80161e:	e8 24 d2 00 00       	call   80e847 <_panic>
  LWIP_ERROR("lwip_sendto: invalid address", (((to == NULL) && (tolen == 0)) ||
  801623:	83 ec 04             	sub    $0x4,%esp
  801626:	68 01 15 81 00       	push   $0x811501
  80162b:	68 98 02 00 00       	push   $0x298
  801630:	68 90 14 81 00       	push   $0x811490
  801635:	e8 0d d2 00 00       	call   80e847 <_panic>
    err = netconn_send(sock->conn, &buf);
  80163a:	83 ec 08             	sub    $0x8,%esp
  80163d:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  801640:	50                   	push   %eax
  801641:	ff 33                	pushl  (%ebx)
  801643:	e8 f7 9c 00 00       	call   80b33f <netconn_send>
  801648:	0f be f8             	movsbl %al,%edi
  80164b:	83 c4 10             	add    $0x10,%esp
  80164e:	e9 5f ff ff ff       	jmp    8015b2 <lwip_sendto+0xaa>
    return -1;
  801653:	be ff ff ff ff       	mov    $0xffffffff,%esi
  801658:	eb 92                	jmp    8015ec <lwip_sendto+0xe4>
  buf.p = buf.ptr = NULL;
  80165a:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
  801661:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
    remote_addr.addr = 0;
  801668:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    buf.addr         = NULL;
  80166f:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
    buf.port         = 0;
  801676:	66 c7 45 e0 00 00    	movw   $0x0,-0x20(%ebp)
  80167c:	e9 10 ff ff ff       	jmp    801591 <lwip_sendto+0x89>

00801681 <lwip_send>:
{
  801681:	f3 0f 1e fb          	endbr32 
  801685:	55                   	push   %ebp
  801686:	89 e5                	mov    %esp,%ebp
  801688:	57                   	push   %edi
  801689:	56                   	push   %esi
  80168a:	53                   	push   %ebx
  80168b:	83 ec 0c             	sub    $0xc,%esp
  80168e:	8b 7d 08             	mov    0x8(%ebp),%edi
  801691:	8b 75 10             	mov    0x10(%ebp),%esi
  sock = get_socket(s);
  801694:	89 f8                	mov    %edi,%eax
  801696:	e8 94 f0 ff ff       	call   80072f <get_socket>
  if (!sock)
  80169b:	85 c0                	test   %eax,%eax
  80169d:	74 70                	je     80170f <lwip_send+0x8e>
  80169f:	89 c3                	mov    %eax,%ebx
  if (sock->conn->type!=NETCONN_TCP) {
  8016a1:	8b 10                	mov    (%eax),%edx
  8016a3:	83 3a 10             	cmpl   $0x10,(%edx)
  8016a6:	74 1f                	je     8016c7 <lwip_send+0x46>
    return lwip_sendto(s, data, size, flags, NULL, 0);
  8016a8:	83 ec 08             	sub    $0x8,%esp
  8016ab:	6a 00                	push   $0x0
  8016ad:	6a 00                	push   $0x0
  8016af:	ff 75 14             	pushl  0x14(%ebp)
  8016b2:	56                   	push   %esi
  8016b3:	ff 75 0c             	pushl  0xc(%ebp)
  8016b6:	57                   	push   %edi
  8016b7:	e8 4c fe ff ff       	call   801508 <lwip_sendto>
  8016bc:	83 c4 20             	add    $0x20,%esp
}
  8016bf:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8016c2:	5b                   	pop    %ebx
  8016c3:	5e                   	pop    %esi
  8016c4:	5f                   	pop    %edi
  8016c5:	5d                   	pop    %ebp
  8016c6:	c3                   	ret    
  err = netconn_write(sock->conn, data, size, NETCONN_COPY | ((flags & MSG_MORE)?NETCONN_MORE:0));
  8016c7:	8b 45 14             	mov    0x14(%ebp),%eax
  8016ca:	c1 e8 03             	shr    $0x3,%eax
  8016cd:	83 e0 02             	and    $0x2,%eax
  8016d0:	83 c8 01             	or     $0x1,%eax
  8016d3:	0f b6 c0             	movzbl %al,%eax
  8016d6:	50                   	push   %eax
  8016d7:	56                   	push   %esi
  8016d8:	ff 75 0c             	pushl  0xc(%ebp)
  8016db:	52                   	push   %edx
  8016dc:	e8 e2 9c 00 00       	call   80b3c3 <netconn_write>
  sock_set_errno(sock, err_to_errno(err));
  8016e1:	0f be d0             	movsbl %al,%edx
  8016e4:	f7 da                	neg    %edx
  8016e6:	83 c4 10             	add    $0x10,%esp
  8016e9:	b9 05 00 00 00       	mov    $0x5,%ecx
  8016ee:	83 fa 0e             	cmp    $0xe,%edx
  8016f1:	77 07                	ja     8016fa <lwip_send+0x79>
  8016f3:	8b 0c 95 60 15 81 00 	mov    0x811560(,%edx,4),%ecx
  8016fa:	89 4b 10             	mov    %ecx,0x10(%ebx)
  8016fd:	89 0d e0 b1 b3 00    	mov    %ecx,0xb3b1e0
  return (err==ERR_OK?size:-1);
  801703:	84 c0                	test   %al,%al
  801705:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80170a:	0f 44 c6             	cmove  %esi,%eax
  80170d:	eb b0                	jmp    8016bf <lwip_send+0x3e>
    return -1;
  80170f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801714:	eb a9                	jmp    8016bf <lwip_send+0x3e>

00801716 <lwip_socket>:
{
  801716:	f3 0f 1e fb          	endbr32 
  80171a:	55                   	push   %ebp
  80171b:	89 e5                	mov    %esp,%ebp
  80171d:	56                   	push   %esi
  80171e:	53                   	push   %ebx
  80171f:	8b 45 0c             	mov    0xc(%ebp),%eax
  switch (type) {
  801722:	83 f8 02             	cmp    $0x2,%eax
  801725:	74 5c                	je     801783 <lwip_socket+0x6d>
  801727:	83 f8 03             	cmp    $0x3,%eax
  80172a:	74 16                	je     801742 <lwip_socket+0x2c>
  80172c:	83 f8 01             	cmp    $0x1,%eax
  80172f:	74 79                	je     8017aa <lwip_socket+0x94>
    set_errno(EINVAL);
  801731:	c7 05 e0 b1 b3 00 16 	movl   $0x16,0xb3b1e0
  801738:	00 00 00 
    return -1;
  80173b:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
  801740:	eb 38                	jmp    80177a <lwip_socket+0x64>
    conn = netconn_new_with_proto_and_callback(NETCONN_RAW, (u8_t)protocol, event_callback);
  801742:	83 ec 04             	sub    $0x4,%esp
  801745:	68 1e 09 80 00       	push   $0x80091e
  80174a:	0f b6 45 10          	movzbl 0x10(%ebp),%eax
  80174e:	50                   	push   %eax
  80174f:	6a 40                	push   $0x40
  801751:	e8 c1 96 00 00       	call   80ae17 <netconn_new_with_proto_and_callback>
  801756:	89 c6                	mov    %eax,%esi
    break;
  801758:	83 c4 10             	add    $0x10,%esp
  if (!conn) {
  80175b:	85 f6                	test   %esi,%esi
  80175d:	74 63                	je     8017c2 <lwip_socket+0xac>
  i = alloc_socket(conn);
  80175f:	89 f0                	mov    %esi,%eax
  801761:	e8 5b f3 ff ff       	call   800ac1 <alloc_socket>
  801766:	89 c3                	mov    %eax,%ebx
  if (i == -1) {
  801768:	83 f8 ff             	cmp    $0xffffffff,%eax
  80176b:	74 66                	je     8017d3 <lwip_socket+0xbd>
  conn->socket = i;
  80176d:	89 46 1c             	mov    %eax,0x1c(%esi)
  set_errno(0);
  801770:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  801777:	00 00 00 
}
  80177a:	89 d8                	mov    %ebx,%eax
  80177c:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80177f:	5b                   	pop    %ebx
  801780:	5e                   	pop    %esi
  801781:	5d                   	pop    %ebp
  801782:	c3                   	ret    
    conn = netconn_new_with_callback( (protocol == IPPROTO_UDPLITE) ?
  801783:	81 7d 10 88 00 00 00 	cmpl   $0x88,0x10(%ebp)
  80178a:	0f 94 c0             	sete   %al
  80178d:	0f b6 c0             	movzbl %al,%eax
  801790:	83 c0 20             	add    $0x20,%eax
  801793:	83 ec 04             	sub    $0x4,%esp
  801796:	68 1e 09 80 00       	push   $0x80091e
  80179b:	6a 00                	push   $0x0
  80179d:	50                   	push   %eax
  80179e:	e8 74 96 00 00       	call   80ae17 <netconn_new_with_proto_and_callback>
  8017a3:	89 c6                	mov    %eax,%esi
    break;
  8017a5:	83 c4 10             	add    $0x10,%esp
  8017a8:	eb b1                	jmp    80175b <lwip_socket+0x45>
    conn = netconn_new_with_callback(NETCONN_TCP, event_callback);
  8017aa:	83 ec 04             	sub    $0x4,%esp
  8017ad:	68 1e 09 80 00       	push   $0x80091e
  8017b2:	6a 00                	push   $0x0
  8017b4:	6a 10                	push   $0x10
  8017b6:	e8 5c 96 00 00       	call   80ae17 <netconn_new_with_proto_and_callback>
  8017bb:	89 c6                	mov    %eax,%esi
    break;
  8017bd:	83 c4 10             	add    $0x10,%esp
  8017c0:	eb 99                	jmp    80175b <lwip_socket+0x45>
    set_errno(ENOBUFS);
  8017c2:	c7 05 e0 b1 b3 00 69 	movl   $0x69,0xb3b1e0
  8017c9:	00 00 00 
    return -1;
  8017cc:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
  8017d1:	eb a7                	jmp    80177a <lwip_socket+0x64>
    netconn_delete(conn);
  8017d3:	83 ec 0c             	sub    $0xc,%esp
  8017d6:	56                   	push   %esi
  8017d7:	e8 1a 97 00 00       	call   80aef6 <netconn_delete>
    set_errno(ENFILE);
  8017dc:	c7 05 e0 b1 b3 00 17 	movl   $0x17,0xb3b1e0
  8017e3:	00 00 00 
    return -1;
  8017e6:	83 c4 10             	add    $0x10,%esp
  8017e9:	eb 8f                	jmp    80177a <lwip_socket+0x64>

008017eb <lwip_write>:
{
  8017eb:	f3 0f 1e fb          	endbr32 
  8017ef:	55                   	push   %ebp
  8017f0:	89 e5                	mov    %esp,%ebp
  8017f2:	83 ec 08             	sub    $0x8,%esp
  return lwip_send(s, data, size, 0);
  8017f5:	6a 00                	push   $0x0
  8017f7:	ff 75 10             	pushl  0x10(%ebp)
  8017fa:	ff 75 0c             	pushl  0xc(%ebp)
  8017fd:	ff 75 08             	pushl  0x8(%ebp)
  801800:	e8 7c fe ff ff       	call   801681 <lwip_send>
}
  801805:	c9                   	leave  
  801806:	c3                   	ret    

00801807 <lwip_select>:
{
  801807:	f3 0f 1e fb          	endbr32 
  80180b:	55                   	push   %ebp
  80180c:	89 e5                	mov    %esp,%ebp
  80180e:	57                   	push   %edi
  80180f:	56                   	push   %esi
  801810:	53                   	push   %ebx
  801811:	83 ec 58             	sub    $0x58,%esp
  801814:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  801817:	8b 75 10             	mov    0x10(%ebp),%esi
  80181a:	8b 7d 14             	mov    0x14(%ebp),%edi
  select_cb.next = 0;
  80181d:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
  select_cb.readset = readset;
  801824:	89 5d c8             	mov    %ebx,-0x38(%ebp)
  select_cb.writeset = writeset;
  801827:	89 75 cc             	mov    %esi,-0x34(%ebp)
  select_cb.exceptset = exceptset;
  80182a:	89 7d d0             	mov    %edi,-0x30(%ebp)
  select_cb.sem_signalled = 0;
  80182d:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
  sys_sem_wait(selectsem);
  801834:	ff 35 40 50 81 00    	pushl  0x815040
  80183a:	e8 ee 39 00 00       	call   80522d <sys_sem_wait>
  if (readset)
  80183f:	83 c4 10             	add    $0x10,%esp
  801842:	85 db                	test   %ebx,%ebx
  801844:	0f 84 0b 01 00 00    	je     801955 <lwip_select+0x14e>
    lreadset = *readset;
  80184a:	8b 03                	mov    (%ebx),%eax
  80184c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  if (writeset)
  80184f:	85 f6                	test   %esi,%esi
  801851:	0f 84 16 01 00 00    	je     80196d <lwip_select+0x166>
    lwriteset = *writeset;
  801857:	8b 06                	mov    (%esi),%eax
  801859:	89 45 e0             	mov    %eax,-0x20(%ebp)
  if (exceptset)
  80185c:	85 ff                	test   %edi,%edi
  80185e:	0f 84 21 01 00 00    	je     801985 <lwip_select+0x17e>
    lexceptset = *exceptset;
  801864:	8b 07                	mov    (%edi),%eax
  801866:	89 45 dc             	mov    %eax,-0x24(%ebp)
  nready = lwip_selscan(maxfdp1, &lreadset, &lwriteset, &lexceptset);
  801869:	83 ec 0c             	sub    $0xc,%esp
  80186c:	8d 45 dc             	lea    -0x24(%ebp),%eax
  80186f:	50                   	push   %eax
  801870:	8d 4d e0             	lea    -0x20(%ebp),%ecx
  801873:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  801876:	8b 45 08             	mov    0x8(%ebp),%eax
  801879:	e8 f0 ee ff ff       	call   80076e <lwip_selscan>
  80187e:	89 45 b4             	mov    %eax,-0x4c(%ebp)
  if (!nready) {
  801881:	83 c4 10             	add    $0x10,%esp
  801884:	85 c0                	test   %eax,%eax
  801886:	0f 85 a0 02 00 00    	jne    801b2c <lwip_select+0x325>
    if (timeout && timeout->tv_sec == 0 && timeout->tv_usec == 0) {
  80188c:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
  801890:	0f 84 ac 02 00 00    	je     801b42 <lwip_select+0x33b>
  801896:	8b 45 18             	mov    0x18(%ebp),%eax
  801899:	83 38 00             	cmpl   $0x0,(%eax)
  80189c:	75 0e                	jne    8018ac <lwip_select+0xa5>
  80189e:	8b 40 04             	mov    0x4(%eax),%eax
  8018a1:	89 45 b4             	mov    %eax,-0x4c(%ebp)
  8018a4:	85 c0                	test   %eax,%eax
  8018a6:	0f 84 f1 00 00 00    	je     80199d <lwip_select+0x196>
    select_cb.sem = sys_sem_new(0);
  8018ac:	83 ec 0c             	sub    $0xc,%esp
  8018af:	6a 00                	push   $0x0
  8018b1:	e8 f7 86 00 00       	call   809fad <sys_sem_new>
  8018b6:	89 45 d8             	mov    %eax,-0x28(%ebp)
    select_cb.next = select_cb_list;
  8018b9:	a1 48 50 81 00       	mov    0x815048,%eax
  8018be:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    select_cb_list = &select_cb;
  8018c1:	8d 45 c4             	lea    -0x3c(%ebp),%eax
  8018c4:	a3 48 50 81 00       	mov    %eax,0x815048
    sys_sem_signal(selectsem);
  8018c9:	83 c4 04             	add    $0x4,%esp
  8018cc:	ff 35 40 50 81 00    	pushl  0x815040
  8018d2:	e8 a3 89 00 00       	call   80a27a <sys_sem_signal>
      msectimeout =  ((timeout->tv_sec * 1000) + ((timeout->tv_usec + 500)/1000));
  8018d7:	8b 45 18             	mov    0x18(%ebp),%eax
  8018da:	8b 40 04             	mov    0x4(%eax),%eax
  8018dd:	89 45 b4             	mov    %eax,-0x4c(%ebp)
  8018e0:	8d 88 f4 01 00 00    	lea    0x1f4(%eax),%ecx
  8018e6:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
  8018eb:	89 c8                	mov    %ecx,%eax
  8018ed:	f7 ea                	imul   %edx
  8018ef:	c1 fa 06             	sar    $0x6,%edx
  8018f2:	c1 f9 1f             	sar    $0x1f,%ecx
  8018f5:	29 ca                	sub    %ecx,%edx
  8018f7:	8b 45 18             	mov    0x18(%ebp),%eax
  8018fa:	69 00 e8 03 00 00    	imul   $0x3e8,(%eax),%eax
  801900:	83 c4 10             	add    $0x10,%esp
  801903:	01 d0                	add    %edx,%eax
  801905:	ba 01 00 00 00       	mov    $0x1,%edx
  80190a:	0f 44 c2             	cmove  %edx,%eax
    i = sys_sem_wait_timeout(select_cb.sem, msectimeout);
  80190d:	83 ec 08             	sub    $0x8,%esp
  801910:	50                   	push   %eax
  801911:	ff 75 d8             	pushl  -0x28(%ebp)
  801914:	e8 ee 3a 00 00       	call   805407 <sys_sem_wait_timeout>
  801919:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    sys_sem_wait(selectsem);
  80191c:	83 c4 04             	add    $0x4,%esp
  80191f:	ff 35 40 50 81 00    	pushl  0x815040
  801925:	e8 03 39 00 00       	call   80522d <sys_sem_wait>
    if (select_cb_list == &select_cb)
  80192a:	a1 48 50 81 00       	mov    0x815048,%eax
  80192f:	8d 55 c4             	lea    -0x3c(%ebp),%edx
  801932:	83 c4 10             	add    $0x10,%esp
        if (p_selcb->next == &select_cb) {
  801935:	89 d1                	mov    %edx,%ecx
    if (select_cb_list == &select_cb)
  801937:	39 d0                	cmp    %edx,%eax
  801939:	0f 84 ba 00 00 00    	je     8019f9 <lwip_select+0x1f2>
      for (p_selcb = select_cb_list; p_selcb; p_selcb = p_selcb->next) {
  80193f:	85 c0                	test   %eax,%eax
  801941:	0f 84 c1 00 00 00    	je     801a08 <lwip_select+0x201>
        if (p_selcb->next == &select_cb) {
  801947:	8b 10                	mov    (%eax),%edx
  801949:	39 ca                	cmp    %ecx,%edx
  80194b:	0f 84 b2 00 00 00    	je     801a03 <lwip_select+0x1fc>
      for (p_selcb = select_cb_list; p_selcb; p_selcb = p_selcb->next) {
  801951:	89 d0                	mov    %edx,%eax
  801953:	eb ea                	jmp    80193f <lwip_select+0x138>
    FD_ZERO(&lreadset);
  801955:	83 ec 04             	sub    $0x4,%esp
  801958:	6a 04                	push   $0x4
  80195a:	6a 00                	push   $0x0
  80195c:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80195f:	50                   	push   %eax
  801960:	e8 3d d7 00 00       	call   80f0a2 <memset>
  801965:	83 c4 10             	add    $0x10,%esp
  801968:	e9 e2 fe ff ff       	jmp    80184f <lwip_select+0x48>
    FD_ZERO(&lwriteset);
  80196d:	83 ec 04             	sub    $0x4,%esp
  801970:	6a 04                	push   $0x4
  801972:	6a 00                	push   $0x0
  801974:	8d 45 e0             	lea    -0x20(%ebp),%eax
  801977:	50                   	push   %eax
  801978:	e8 25 d7 00 00       	call   80f0a2 <memset>
  80197d:	83 c4 10             	add    $0x10,%esp
  801980:	e9 d7 fe ff ff       	jmp    80185c <lwip_select+0x55>
    FD_ZERO(&lexceptset);
  801985:	83 ec 04             	sub    $0x4,%esp
  801988:	6a 04                	push   $0x4
  80198a:	6a 00                	push   $0x0
  80198c:	8d 45 dc             	lea    -0x24(%ebp),%eax
  80198f:	50                   	push   %eax
  801990:	e8 0d d7 00 00       	call   80f0a2 <memset>
  801995:	83 c4 10             	add    $0x10,%esp
  801998:	e9 cc fe ff ff       	jmp    801869 <lwip_select+0x62>
      sys_sem_signal(selectsem);
  80199d:	83 ec 0c             	sub    $0xc,%esp
  8019a0:	ff 35 40 50 81 00    	pushl  0x815040
  8019a6:	e8 cf 88 00 00       	call   80a27a <sys_sem_signal>
      if (readset)
  8019ab:	83 c4 10             	add    $0x10,%esp
  8019ae:	85 db                	test   %ebx,%ebx
  8019b0:	74 10                	je     8019c2 <lwip_select+0x1bb>
        FD_ZERO(readset);
  8019b2:	83 ec 04             	sub    $0x4,%esp
  8019b5:	6a 04                	push   $0x4
  8019b7:	6a 00                	push   $0x0
  8019b9:	53                   	push   %ebx
  8019ba:	e8 e3 d6 00 00       	call   80f0a2 <memset>
  8019bf:	83 c4 10             	add    $0x10,%esp
      if (writeset)
  8019c2:	85 f6                	test   %esi,%esi
  8019c4:	74 10                	je     8019d6 <lwip_select+0x1cf>
        FD_ZERO(writeset);
  8019c6:	83 ec 04             	sub    $0x4,%esp
  8019c9:	6a 04                	push   $0x4
  8019cb:	6a 00                	push   $0x0
  8019cd:	56                   	push   %esi
  8019ce:	e8 cf d6 00 00       	call   80f0a2 <memset>
  8019d3:	83 c4 10             	add    $0x10,%esp
      if (exceptset)
  8019d6:	85 ff                	test   %edi,%edi
  8019d8:	74 10                	je     8019ea <lwip_select+0x1e3>
        FD_ZERO(exceptset);
  8019da:	83 ec 04             	sub    $0x4,%esp
  8019dd:	6a 04                	push   $0x4
  8019df:	6a 00                	push   $0x0
  8019e1:	57                   	push   %edi
  8019e2:	e8 bb d6 00 00       	call   80f0a2 <memset>
  8019e7:	83 c4 10             	add    $0x10,%esp
      set_errno(0);
  8019ea:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  8019f1:	00 00 00 
      return 0;
  8019f4:	e9 98 00 00 00       	jmp    801a91 <lwip_select+0x28a>
      select_cb_list = select_cb.next;
  8019f9:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  8019fc:	a3 48 50 81 00       	mov    %eax,0x815048
  801a01:	eb 05                	jmp    801a08 <lwip_select+0x201>
          p_selcb->next = select_cb.next;
  801a03:	8b 55 c4             	mov    -0x3c(%ebp),%edx
  801a06:	89 10                	mov    %edx,(%eax)
    sys_sem_signal(selectsem);
  801a08:	83 ec 0c             	sub    $0xc,%esp
  801a0b:	ff 35 40 50 81 00    	pushl  0x815040
  801a11:	e8 64 88 00 00       	call   80a27a <sys_sem_signal>
    sys_sem_free(select_cb.sem);
  801a16:	83 c4 04             	add    $0x4,%esp
  801a19:	ff 75 d8             	pushl  -0x28(%ebp)
  801a1c:	e8 11 86 00 00       	call   80a032 <sys_sem_free>
    if (i == 0)  {
  801a21:	83 c4 10             	add    $0x10,%esp
  801a24:	83 7d b4 00          	cmpl   $0x0,-0x4c(%ebp)
  801a28:	74 72                	je     801a9c <lwip_select+0x295>
    if (readset)
  801a2a:	85 db                	test   %ebx,%ebx
  801a2c:	0f 84 b2 00 00 00    	je     801ae4 <lwip_select+0x2dd>
      lreadset = *readset;
  801a32:	8b 03                	mov    (%ebx),%eax
  801a34:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if (writeset)
  801a37:	85 f6                	test   %esi,%esi
  801a39:	0f 84 bd 00 00 00    	je     801afc <lwip_select+0x2f5>
      lwriteset = *writeset;
  801a3f:	8b 06                	mov    (%esi),%eax
  801a41:	89 45 e0             	mov    %eax,-0x20(%ebp)
    if (exceptset)
  801a44:	85 ff                	test   %edi,%edi
  801a46:	0f 84 c8 00 00 00    	je     801b14 <lwip_select+0x30d>
      lexceptset = *exceptset;
  801a4c:	8b 07                	mov    (%edi),%eax
  801a4e:	89 45 dc             	mov    %eax,-0x24(%ebp)
    nready = lwip_selscan(maxfdp1, &lreadset, &lwriteset, &lexceptset);
  801a51:	83 ec 0c             	sub    $0xc,%esp
  801a54:	8d 45 dc             	lea    -0x24(%ebp),%eax
  801a57:	50                   	push   %eax
  801a58:	8d 4d e0             	lea    -0x20(%ebp),%ecx
  801a5b:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  801a5e:	8b 45 08             	mov    0x8(%ebp),%eax
  801a61:	e8 08 ed ff ff       	call   80076e <lwip_selscan>
  801a66:	89 45 b4             	mov    %eax,-0x4c(%ebp)
  801a69:	83 c4 10             	add    $0x10,%esp
  if (readset)
  801a6c:	85 db                	test   %ebx,%ebx
  801a6e:	74 05                	je     801a75 <lwip_select+0x26e>
    *readset = lreadset;
  801a70:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  801a73:	89 03                	mov    %eax,(%ebx)
  if (writeset)
  801a75:	85 f6                	test   %esi,%esi
  801a77:	74 05                	je     801a7e <lwip_select+0x277>
    *writeset = lwriteset;
  801a79:	8b 45 e0             	mov    -0x20(%ebp),%eax
  801a7c:	89 06                	mov    %eax,(%esi)
  if (exceptset)
  801a7e:	85 ff                	test   %edi,%edi
  801a80:	74 05                	je     801a87 <lwip_select+0x280>
    *exceptset = lexceptset;
  801a82:	8b 45 dc             	mov    -0x24(%ebp),%eax
  801a85:	89 07                	mov    %eax,(%edi)
  set_errno(0);
  801a87:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  801a8e:	00 00 00 
}
  801a91:	8b 45 b4             	mov    -0x4c(%ebp),%eax
  801a94:	8d 65 f4             	lea    -0xc(%ebp),%esp
  801a97:	5b                   	pop    %ebx
  801a98:	5e                   	pop    %esi
  801a99:	5f                   	pop    %edi
  801a9a:	5d                   	pop    %ebp
  801a9b:	c3                   	ret    
      if (readset)
  801a9c:	85 db                	test   %ebx,%ebx
  801a9e:	74 10                	je     801ab0 <lwip_select+0x2a9>
        FD_ZERO(readset);
  801aa0:	83 ec 04             	sub    $0x4,%esp
  801aa3:	6a 04                	push   $0x4
  801aa5:	6a 00                	push   $0x0
  801aa7:	53                   	push   %ebx
  801aa8:	e8 f5 d5 00 00       	call   80f0a2 <memset>
  801aad:	83 c4 10             	add    $0x10,%esp
      if (writeset)
  801ab0:	85 f6                	test   %esi,%esi
  801ab2:	74 10                	je     801ac4 <lwip_select+0x2bd>
        FD_ZERO(writeset);
  801ab4:	83 ec 04             	sub    $0x4,%esp
  801ab7:	6a 04                	push   $0x4
  801ab9:	6a 00                	push   $0x0
  801abb:	56                   	push   %esi
  801abc:	e8 e1 d5 00 00       	call   80f0a2 <memset>
  801ac1:	83 c4 10             	add    $0x10,%esp
      if (exceptset)
  801ac4:	85 ff                	test   %edi,%edi
  801ac6:	74 10                	je     801ad8 <lwip_select+0x2d1>
        FD_ZERO(exceptset);
  801ac8:	83 ec 04             	sub    $0x4,%esp
  801acb:	6a 04                	push   $0x4
  801acd:	6a 00                	push   $0x0
  801acf:	57                   	push   %edi
  801ad0:	e8 cd d5 00 00       	call   80f0a2 <memset>
  801ad5:	83 c4 10             	add    $0x10,%esp
      set_errno(0);
  801ad8:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  801adf:	00 00 00 
      return 0;
  801ae2:	eb ad                	jmp    801a91 <lwip_select+0x28a>
      FD_ZERO(&lreadset);
  801ae4:	83 ec 04             	sub    $0x4,%esp
  801ae7:	6a 04                	push   $0x4
  801ae9:	6a 00                	push   $0x0
  801aeb:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  801aee:	50                   	push   %eax
  801aef:	e8 ae d5 00 00       	call   80f0a2 <memset>
  801af4:	83 c4 10             	add    $0x10,%esp
  801af7:	e9 3b ff ff ff       	jmp    801a37 <lwip_select+0x230>
      FD_ZERO(&lwriteset);
  801afc:	83 ec 04             	sub    $0x4,%esp
  801aff:	6a 04                	push   $0x4
  801b01:	6a 00                	push   $0x0
  801b03:	8d 45 e0             	lea    -0x20(%ebp),%eax
  801b06:	50                   	push   %eax
  801b07:	e8 96 d5 00 00       	call   80f0a2 <memset>
  801b0c:	83 c4 10             	add    $0x10,%esp
  801b0f:	e9 30 ff ff ff       	jmp    801a44 <lwip_select+0x23d>
      FD_ZERO(&lexceptset);
  801b14:	83 ec 04             	sub    $0x4,%esp
  801b17:	6a 04                	push   $0x4
  801b19:	6a 00                	push   $0x0
  801b1b:	8d 45 dc             	lea    -0x24(%ebp),%eax
  801b1e:	50                   	push   %eax
  801b1f:	e8 7e d5 00 00       	call   80f0a2 <memset>
  801b24:	83 c4 10             	add    $0x10,%esp
  801b27:	e9 25 ff ff ff       	jmp    801a51 <lwip_select+0x24a>
    sys_sem_signal(selectsem);
  801b2c:	83 ec 0c             	sub    $0xc,%esp
  801b2f:	ff 35 40 50 81 00    	pushl  0x815040
  801b35:	e8 40 87 00 00       	call   80a27a <sys_sem_signal>
  801b3a:	83 c4 10             	add    $0x10,%esp
  801b3d:	e9 2a ff ff ff       	jmp    801a6c <lwip_select+0x265>
    select_cb.sem = sys_sem_new(0);
  801b42:	83 ec 0c             	sub    $0xc,%esp
  801b45:	6a 00                	push   $0x0
  801b47:	e8 61 84 00 00       	call   809fad <sys_sem_new>
  801b4c:	89 45 d8             	mov    %eax,-0x28(%ebp)
    select_cb.next = select_cb_list;
  801b4f:	a1 48 50 81 00       	mov    0x815048,%eax
  801b54:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    select_cb_list = &select_cb;
  801b57:	8d 45 c4             	lea    -0x3c(%ebp),%eax
  801b5a:	a3 48 50 81 00       	mov    %eax,0x815048
    sys_sem_signal(selectsem);
  801b5f:	83 c4 04             	add    $0x4,%esp
  801b62:	ff 35 40 50 81 00    	pushl  0x815040
  801b68:	e8 0d 87 00 00       	call   80a27a <sys_sem_signal>
  801b6d:	83 c4 10             	add    $0x10,%esp
      msectimeout = 0;
  801b70:	b8 00 00 00 00       	mov    $0x0,%eax
  801b75:	e9 93 fd ff ff       	jmp    80190d <lwip_select+0x106>

00801b7a <lwip_shutdown>:
{
  801b7a:	f3 0f 1e fb          	endbr32 
  801b7e:	55                   	push   %ebp
  801b7f:	89 e5                	mov    %esp,%ebp
  801b81:	83 ec 14             	sub    $0x14,%esp
  return lwip_close(s); /* XXX temporary hack until proper implementation */
  801b84:	ff 75 08             	pushl  0x8(%ebp)
  801b87:	e8 1d f5 ff ff       	call   8010a9 <lwip_close>
}
  801b8c:	c9                   	leave  
  801b8d:	c3                   	ret    

00801b8e <lwip_getpeername>:
{
  801b8e:	f3 0f 1e fb          	endbr32 
  801b92:	55                   	push   %ebp
  801b93:	89 e5                	mov    %esp,%ebp
  801b95:	83 ec 14             	sub    $0x14,%esp
  return lwip_getaddrname(s, name, namelen, 0);
  801b98:	6a 00                	push   $0x0
  801b9a:	8b 4d 10             	mov    0x10(%ebp),%ecx
  801b9d:	8b 55 0c             	mov    0xc(%ebp),%edx
  801ba0:	8b 45 08             	mov    0x8(%ebp),%eax
  801ba3:	e8 cb ec ff ff       	call   800873 <lwip_getaddrname>
}
  801ba8:	c9                   	leave  
  801ba9:	c3                   	ret    

00801baa <lwip_getsockname>:
{
  801baa:	f3 0f 1e fb          	endbr32 
  801bae:	55                   	push   %ebp
  801baf:	89 e5                	mov    %esp,%ebp
  801bb1:	83 ec 14             	sub    $0x14,%esp
  return lwip_getaddrname(s, name, namelen, 1);
  801bb4:	6a 01                	push   $0x1
  801bb6:	8b 4d 10             	mov    0x10(%ebp),%ecx
  801bb9:	8b 55 0c             	mov    0xc(%ebp),%edx
  801bbc:	8b 45 08             	mov    0x8(%ebp),%eax
  801bbf:	e8 af ec ff ff       	call   800873 <lwip_getaddrname>
}
  801bc4:	c9                   	leave  
  801bc5:	c3                   	ret    

00801bc6 <lwip_getsockopt>:
{
  801bc6:	f3 0f 1e fb          	endbr32 
  801bca:	55                   	push   %ebp
  801bcb:	89 e5                	mov    %esp,%ebp
  801bcd:	57                   	push   %edi
  801bce:	56                   	push   %esi
  801bcf:	53                   	push   %ebx
  801bd0:	83 ec 2c             	sub    $0x2c,%esp
  801bd3:	8b 75 0c             	mov    0xc(%ebp),%esi
  801bd6:	8b 7d 18             	mov    0x18(%ebp),%edi
  struct lwip_socket *sock = get_socket(s);
  801bd9:	8b 45 08             	mov    0x8(%ebp),%eax
  801bdc:	e8 4e eb ff ff       	call   80072f <get_socket>
  if (!sock)
  801be1:	85 c0                	test   %eax,%eax
  801be3:	0f 84 b0 01 00 00    	je     801d99 <lwip_getsockopt+0x1d3>
  801be9:	89 c3                	mov    %eax,%ebx
  if ((NULL == optval) || (NULL == optlen)) {
  801beb:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
  801bef:	74 37                	je     801c28 <lwip_getsockopt+0x62>
  801bf1:	85 ff                	test   %edi,%edi
  801bf3:	74 33                	je     801c28 <lwip_getsockopt+0x62>
  switch (level) {
  801bf5:	83 fe 06             	cmp    $0x6,%esi
  801bf8:	0f 84 39 01 00 00    	je     801d37 <lwip_getsockopt+0x171>
  801bfe:	81 fe ff 0f 00 00    	cmp    $0xfff,%esi
  801c04:	74 3d                	je     801c43 <lwip_getsockopt+0x7d>
  801c06:	b8 5c 00 00 00       	mov    $0x5c,%eax
  801c0b:	85 f6                	test   %esi,%esi
  801c0d:	0f 84 ac 00 00 00    	je     801cbf <lwip_getsockopt+0xf9>
    sock_set_errno(sock, err);
  801c13:	0f be c0             	movsbl %al,%eax
  801c16:	89 43 10             	mov    %eax,0x10(%ebx)
  801c19:	a3 e0 b1 b3 00       	mov    %eax,0xb3b1e0
    return -1;
  801c1e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801c23:	e9 07 01 00 00       	jmp    801d2f <lwip_getsockopt+0x169>
    sock_set_errno(sock, EFAULT);
  801c28:	c7 43 10 0e 00 00 00 	movl   $0xe,0x10(%ebx)
  801c2f:	c7 05 e0 b1 b3 00 0e 	movl   $0xe,0xb3b1e0
  801c36:	00 00 00 
    return -1;
  801c39:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801c3e:	e9 ec 00 00 00       	jmp    801d2f <lwip_getsockopt+0x169>
  801c43:	81 7d 10 08 10 00 00 	cmpl   $0x1008,0x10(%ebp)
  801c4a:	7e 34                	jle    801c80 <lwip_getsockopt+0xba>
  801c4c:	b8 5c 00 00 00       	mov    $0x5c,%eax
  801c51:	81 7d 10 0a 10 00 00 	cmpl   $0x100a,0x10(%ebp)
  801c58:	75 b9                	jne    801c13 <lwip_getsockopt+0x4d>
        err = EINVAL;
  801c5a:	83 3f 04             	cmpl   $0x4,(%edi)
  801c5d:	19 c0                	sbb    %eax,%eax
  801c5f:	83 e0 16             	and    $0x16,%eax
      if ((sock->conn->type != NETCONN_UDP) ||
  801c62:	8b 13                	mov    (%ebx),%edx
  801c64:	83 3a 20             	cmpl   $0x20,(%edx)
  801c67:	0f 85 fa 00 00 00    	jne    801d67 <lwip_getsockopt+0x1a1>
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
  801c6d:	8b 52 08             	mov    0x8(%edx),%edx
      if ((sock->conn->type != NETCONN_UDP) ||
  801c70:	f6 42 10 02          	testb  $0x2,0x10(%edx)
  801c74:	0f 85 f7 00 00 00    	jne    801d71 <lwip_getsockopt+0x1ab>
  if (err != ERR_OK) {
  801c7a:	84 c0                	test   %al,%al
  801c7c:	74 59                	je     801cd7 <lwip_getsockopt+0x111>
  801c7e:	eb 93                	jmp    801c13 <lwip_getsockopt+0x4d>
  801c80:	81 7d 10 06 10 00 00 	cmpl   $0x1006,0x10(%ebp)
  801c87:	7f 27                	jg     801cb0 <lwip_getsockopt+0xea>
  801c89:	8b 45 10             	mov    0x10(%ebp),%eax
  801c8c:	8d 48 fe             	lea    -0x2(%eax),%ecx
  801c8f:	83 f9 1e             	cmp    $0x1e,%ecx
  801c92:	0f 87 c5 00 00 00    	ja     801d5d <lwip_getsockopt+0x197>
  801c98:	b8 01 00 00 00       	mov    $0x1,%eax
  801c9d:	d3 e0                	shl    %cl,%eax
  801c9f:	a9 41 00 00 40       	test   $0x40000041,%eax
  801ca4:	75 0a                	jne    801cb0 <lwip_getsockopt+0xea>
  801ca6:	b8 5c 00 00 00       	mov    $0x5c,%eax
  801cab:	e9 63 ff ff ff       	jmp    801c13 <lwip_getsockopt+0x4d>
      if (*optlen < sizeof(int)) {
  801cb0:	83 3f 03             	cmpl   $0x3,(%edi)
  801cb3:	77 22                	ja     801cd7 <lwip_getsockopt+0x111>
        err = EINVAL;
  801cb5:	b8 16 00 00 00       	mov    $0x16,%eax
  801cba:	e9 54 ff ff ff       	jmp    801c13 <lwip_getsockopt+0x4d>
  801cbf:	8b 45 10             	mov    0x10(%ebp),%eax
  801cc2:	83 e8 01             	sub    $0x1,%eax
  801cc5:	83 f8 01             	cmp    $0x1,%eax
  801cc8:	0f 87 ad 00 00 00    	ja     801d7b <lwip_getsockopt+0x1b5>
      if (*optlen < sizeof(int)) {
  801cce:	83 3f 03             	cmpl   $0x3,(%edi)
  801cd1:	0f 86 ae 00 00 00    	jbe    801d85 <lwip_getsockopt+0x1bf>
  data.sock = sock;
  801cd7:	89 5d cc             	mov    %ebx,-0x34(%ebp)
  data.level = level;
  801cda:	89 75 d4             	mov    %esi,-0x2c(%ebp)
  data.optname = optname;
  801cdd:	8b 45 10             	mov    0x10(%ebp),%eax
  801ce0:	89 45 d8             	mov    %eax,-0x28(%ebp)
  data.optval = optval;
  801ce3:	8b 45 14             	mov    0x14(%ebp),%eax
  801ce6:	89 45 dc             	mov    %eax,-0x24(%ebp)
  data.optlen = optlen;
  801ce9:	89 7d e0             	mov    %edi,-0x20(%ebp)
  data.err = err;
  801cec:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
  tcpip_callback(lwip_getsockopt_internal, &data);
  801cf0:	83 ec 04             	sub    $0x4,%esp
  801cf3:	6a 01                	push   $0x1
  801cf5:	8d 45 cc             	lea    -0x34(%ebp),%eax
  801cf8:	50                   	push   %eax
  801cf9:	68 69 0b 80 00       	push   $0x800b69
  801cfe:	e8 09 06 00 00       	call   80230c <tcpip_callback_with_block>
  sys_arch_sem_wait(sock->conn->op_completed, 0);
  801d03:	83 c4 08             	add    $0x8,%esp
  801d06:	6a 00                	push   $0x0
  801d08:	8b 03                	mov    (%ebx),%eax
  801d0a:	ff 70 10             	pushl  0x10(%eax)
  801d0d:	e8 dc 85 00 00       	call   80a2ee <sys_arch_sem_wait>
  err = data.err;
  801d12:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
  sock_set_errno(sock, err);
  801d16:	0f be d0             	movsbl %al,%edx
  801d19:	89 53 10             	mov    %edx,0x10(%ebx)
  801d1c:	89 15 e0 b1 b3 00    	mov    %edx,0xb3b1e0
  return err ? -1 : 0;
  801d22:	83 c4 10             	add    $0x10,%esp
  801d25:	84 c0                	test   %al,%al
  801d27:	0f 95 c0             	setne  %al
  801d2a:	0f b6 c0             	movzbl %al,%eax
  801d2d:	f7 d8                	neg    %eax
}
  801d2f:	8d 65 f4             	lea    -0xc(%ebp),%esp
  801d32:	5b                   	pop    %ebx
  801d33:	5e                   	pop    %esi
  801d34:	5f                   	pop    %edi
  801d35:	5d                   	pop    %ebp
  801d36:	c3                   	ret    
    if (*optlen < sizeof(int)) {
  801d37:	83 3f 03             	cmpl   $0x3,(%edi)
  801d3a:	76 53                	jbe    801d8f <lwip_getsockopt+0x1c9>
    if (sock->conn->type != NETCONN_TCP)
  801d3c:	8b 10                	mov    (%eax),%edx
      return 0;
  801d3e:	b8 00 00 00 00       	mov    $0x0,%eax
    if (sock->conn->type != NETCONN_TCP)
  801d43:	83 3a 10             	cmpl   $0x10,(%edx)
  801d46:	75 e7                	jne    801d2f <lwip_getsockopt+0x169>
  801d48:	8b 45 10             	mov    0x10(%ebp),%eax
  801d4b:	83 e8 01             	sub    $0x1,%eax
  801d4e:	83 f8 01             	cmp    $0x1,%eax
  801d51:	76 84                	jbe    801cd7 <lwip_getsockopt+0x111>
      err = ENOPROTOOPT;
  801d53:	b8 5c 00 00 00       	mov    $0x5c,%eax
  801d58:	e9 b6 fe ff ff       	jmp    801c13 <lwip_getsockopt+0x4d>
  801d5d:	b8 5c 00 00 00       	mov    $0x5c,%eax
  801d62:	e9 ac fe ff ff       	jmp    801c13 <lwip_getsockopt+0x4d>
        err = EAFNOSUPPORT;
  801d67:	b8 61 00 00 00       	mov    $0x61,%eax
  801d6c:	e9 a2 fe ff ff       	jmp    801c13 <lwip_getsockopt+0x4d>
  801d71:	b8 61 00 00 00       	mov    $0x61,%eax
  801d76:	e9 98 fe ff ff       	jmp    801c13 <lwip_getsockopt+0x4d>
      err = ENOPROTOOPT;
  801d7b:	b8 5c 00 00 00       	mov    $0x5c,%eax
  801d80:	e9 8e fe ff ff       	jmp    801c13 <lwip_getsockopt+0x4d>
        err = EINVAL;
  801d85:	b8 16 00 00 00       	mov    $0x16,%eax
  801d8a:	e9 84 fe ff ff       	jmp    801c13 <lwip_getsockopt+0x4d>
      err = EINVAL;
  801d8f:	b8 16 00 00 00       	mov    $0x16,%eax
  801d94:	e9 7a fe ff ff       	jmp    801c13 <lwip_getsockopt+0x4d>
    return -1;
  801d99:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801d9e:	eb 8f                	jmp    801d2f <lwip_getsockopt+0x169>

00801da0 <lwip_setsockopt>:
{
  801da0:	f3 0f 1e fb          	endbr32 
  801da4:	55                   	push   %ebp
  801da5:	89 e5                	mov    %esp,%ebp
  801da7:	57                   	push   %edi
  801da8:	56                   	push   %esi
  801da9:	53                   	push   %ebx
  801daa:	83 ec 2c             	sub    $0x2c,%esp
  801dad:	8b 75 0c             	mov    0xc(%ebp),%esi
  801db0:	8b 7d 14             	mov    0x14(%ebp),%edi
  struct lwip_socket *sock = get_socket(s);
  801db3:	8b 45 08             	mov    0x8(%ebp),%eax
  801db6:	e8 74 e9 ff ff       	call   80072f <get_socket>
  if (!sock)
  801dbb:	85 c0                	test   %eax,%eax
  801dbd:	0f 84 69 01 00 00    	je     801f2c <lwip_setsockopt+0x18c>
  801dc3:	89 c3                	mov    %eax,%ebx
  if (NULL == optval) {
  801dc5:	85 ff                	test   %edi,%edi
  801dc7:	74 2c                	je     801df5 <lwip_setsockopt+0x55>
  switch (level) {
  801dc9:	83 fe 06             	cmp    $0x6,%esi
  801dcc:	0f 84 01 01 00 00    	je     801ed3 <lwip_setsockopt+0x133>
  801dd2:	81 fe ff 0f 00 00    	cmp    $0xfff,%esi
  801dd8:	74 36                	je     801e10 <lwip_setsockopt+0x70>
  801dda:	b8 5c 00 00 00       	mov    $0x5c,%eax
  801ddf:	85 f6                	test   %esi,%esi
  801de1:	74 7b                	je     801e5e <lwip_setsockopt+0xbe>
    sock_set_errno(sock, err);
  801de3:	89 43 10             	mov    %eax,0x10(%ebx)
  801de6:	a3 e0 b1 b3 00       	mov    %eax,0xb3b1e0
    return -1;
  801deb:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801df0:	e9 d6 00 00 00       	jmp    801ecb <lwip_setsockopt+0x12b>
    sock_set_errno(sock, EFAULT);
  801df5:	c7 40 10 0e 00 00 00 	movl   $0xe,0x10(%eax)
  801dfc:	c7 05 e0 b1 b3 00 0e 	movl   $0xe,0xb3b1e0
  801e03:	00 00 00 
    return -1;
  801e06:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801e0b:	e9 bb 00 00 00       	jmp    801ecb <lwip_setsockopt+0x12b>
  801e10:	83 7d 10 20          	cmpl   $0x20,0x10(%ebp)
  801e14:	74 14                	je     801e2a <lwip_setsockopt+0x8a>
  801e16:	81 7d 10 0a 10 00 00 	cmpl   $0x100a,0x10(%ebp)
  801e1d:	74 18                	je     801e37 <lwip_setsockopt+0x97>
  801e1f:	b8 5c 00 00 00       	mov    $0x5c,%eax
  801e24:	83 7d 10 08          	cmpl   $0x8,0x10(%ebp)
  801e28:	75 b9                	jne    801de3 <lwip_setsockopt+0x43>
      if (optlen < sizeof(int)) {
  801e2a:	83 7d 18 03          	cmpl   $0x3,0x18(%ebp)
  801e2e:	77 47                	ja     801e77 <lwip_setsockopt+0xd7>
        err = EINVAL;
  801e30:	b8 16 00 00 00       	mov    $0x16,%eax
  801e35:	eb ac                	jmp    801de3 <lwip_setsockopt+0x43>
        err = EINVAL;
  801e37:	83 7d 18 04          	cmpl   $0x4,0x18(%ebp)
  801e3b:	19 c0                	sbb    %eax,%eax
  801e3d:	83 e0 16             	and    $0x16,%eax
      if ((sock->conn->type != NETCONN_UDP) ||
  801e40:	8b 13                	mov    (%ebx),%edx
  801e42:	83 3a 20             	cmpl   $0x20,(%edx)
  801e45:	0f 85 af 00 00 00    	jne    801efa <lwip_setsockopt+0x15a>
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
  801e4b:	8b 52 08             	mov    0x8(%edx),%edx
      if ((sock->conn->type != NETCONN_UDP) ||
  801e4e:	f6 42 10 02          	testb  $0x2,0x10(%edx)
  801e52:	0f 85 ac 00 00 00    	jne    801f04 <lwip_setsockopt+0x164>
  if (err != ERR_OK) {
  801e58:	85 c0                	test   %eax,%eax
  801e5a:	74 1b                	je     801e77 <lwip_setsockopt+0xd7>
  801e5c:	eb 85                	jmp    801de3 <lwip_setsockopt+0x43>
  801e5e:	8b 45 10             	mov    0x10(%ebp),%eax
  801e61:	83 e8 01             	sub    $0x1,%eax
  801e64:	83 f8 01             	cmp    $0x1,%eax
  801e67:	0f 87 a1 00 00 00    	ja     801f0e <lwip_setsockopt+0x16e>
      if (optlen < sizeof(int)) {
  801e6d:	83 7d 18 03          	cmpl   $0x3,0x18(%ebp)
  801e71:	0f 86 a1 00 00 00    	jbe    801f18 <lwip_setsockopt+0x178>
  data.sock = sock;
  801e77:	89 5d cc             	mov    %ebx,-0x34(%ebp)
  data.level = level;
  801e7a:	89 75 d4             	mov    %esi,-0x2c(%ebp)
  data.optname = optname;
  801e7d:	8b 45 10             	mov    0x10(%ebp),%eax
  801e80:	89 45 d8             	mov    %eax,-0x28(%ebp)
  data.optval = (void*)optval;
  801e83:	89 7d dc             	mov    %edi,-0x24(%ebp)
  data.optlen = &optlen;
  801e86:	8d 45 18             	lea    0x18(%ebp),%eax
  801e89:	89 45 e0             	mov    %eax,-0x20(%ebp)
  data.err = err;
  801e8c:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
  tcpip_callback(lwip_setsockopt_internal, &data);
  801e90:	83 ec 04             	sub    $0x4,%esp
  801e93:	6a 01                	push   $0x1
  801e95:	8d 45 cc             	lea    -0x34(%ebp),%eax
  801e98:	50                   	push   %eax
  801e99:	68 fc 0c 80 00       	push   $0x800cfc
  801e9e:	e8 69 04 00 00       	call   80230c <tcpip_callback_with_block>
  sys_arch_sem_wait(sock->conn->op_completed, 0);
  801ea3:	83 c4 08             	add    $0x8,%esp
  801ea6:	6a 00                	push   $0x0
  801ea8:	8b 03                	mov    (%ebx),%eax
  801eaa:	ff 70 10             	pushl  0x10(%eax)
  801ead:	e8 3c 84 00 00       	call   80a2ee <sys_arch_sem_wait>
  err = data.err;
  801eb2:	0f be 45 e4          	movsbl -0x1c(%ebp),%eax
  sock_set_errno(sock, err);
  801eb6:	89 43 10             	mov    %eax,0x10(%ebx)
  801eb9:	a3 e0 b1 b3 00       	mov    %eax,0xb3b1e0
  return err ? -1 : 0;
  801ebe:	83 c4 10             	add    $0x10,%esp
  801ec1:	85 c0                	test   %eax,%eax
  801ec3:	0f 95 c0             	setne  %al
  801ec6:	0f b6 c0             	movzbl %al,%eax
  801ec9:	f7 d8                	neg    %eax
}
  801ecb:	8d 65 f4             	lea    -0xc(%ebp),%esp
  801ece:	5b                   	pop    %ebx
  801ecf:	5e                   	pop    %esi
  801ed0:	5f                   	pop    %edi
  801ed1:	5d                   	pop    %ebp
  801ed2:	c3                   	ret    
    if (optlen < sizeof(int)) {
  801ed3:	83 7d 18 03          	cmpl   $0x3,0x18(%ebp)
  801ed7:	76 49                	jbe    801f22 <lwip_setsockopt+0x182>
    if (sock->conn->type != NETCONN_TCP)
  801ed9:	8b 10                	mov    (%eax),%edx
      return 0;
  801edb:	b8 00 00 00 00       	mov    $0x0,%eax
    if (sock->conn->type != NETCONN_TCP)
  801ee0:	83 3a 10             	cmpl   $0x10,(%edx)
  801ee3:	75 e6                	jne    801ecb <lwip_setsockopt+0x12b>
  801ee5:	8b 45 10             	mov    0x10(%ebp),%eax
  801ee8:	83 e8 01             	sub    $0x1,%eax
  801eeb:	83 f8 01             	cmp    $0x1,%eax
  801eee:	76 87                	jbe    801e77 <lwip_setsockopt+0xd7>
      err = ENOPROTOOPT;
  801ef0:	b8 5c 00 00 00       	mov    $0x5c,%eax
  801ef5:	e9 e9 fe ff ff       	jmp    801de3 <lwip_setsockopt+0x43>
        err = EAFNOSUPPORT;
  801efa:	b8 61 00 00 00       	mov    $0x61,%eax
  801eff:	e9 df fe ff ff       	jmp    801de3 <lwip_setsockopt+0x43>
  801f04:	b8 61 00 00 00       	mov    $0x61,%eax
  801f09:	e9 d5 fe ff ff       	jmp    801de3 <lwip_setsockopt+0x43>
        err = ENOPROTOOPT;
  801f0e:	b8 5c 00 00 00       	mov    $0x5c,%eax
  801f13:	e9 cb fe ff ff       	jmp    801de3 <lwip_setsockopt+0x43>
        err = EINVAL;
  801f18:	b8 16 00 00 00       	mov    $0x16,%eax
  801f1d:	e9 c1 fe ff ff       	jmp    801de3 <lwip_setsockopt+0x43>
      err = EINVAL;
  801f22:	b8 16 00 00 00       	mov    $0x16,%eax
  801f27:	e9 b7 fe ff ff       	jmp    801de3 <lwip_setsockopt+0x43>
    return -1;
  801f2c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801f31:	eb 98                	jmp    801ecb <lwip_setsockopt+0x12b>

00801f33 <lwip_ioctl>:

int
lwip_ioctl(int s, long cmd, void *argp)
{
  801f33:	f3 0f 1e fb          	endbr32 
  801f37:	55                   	push   %ebp
  801f38:	89 e5                	mov    %esp,%ebp
  801f3a:	56                   	push   %esi
  801f3b:	53                   	push   %ebx
  801f3c:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  801f3f:	8b 75 10             	mov    0x10(%ebp),%esi
  struct lwip_socket *sock = get_socket(s);
  801f42:	8b 45 08             	mov    0x8(%ebp),%eax
  801f45:	e8 e5 e7 ff ff       	call   80072f <get_socket>
  u16_t buflen = 0;

  if (!sock)
  801f4a:	85 c0                	test   %eax,%eax
  801f4c:	0f 84 b4 00 00 00    	je     802006 <lwip_ioctl+0xd3>
    return -1;

  switch (cmd) {
  801f52:	81 fb 7e 66 04 80    	cmp    $0x8004667e,%ebx
  801f58:	74 5d                	je     801fb7 <lwip_ioctl+0x84>
  801f5a:	81 fb 7f 66 04 40    	cmp    $0x4004667f,%ebx
  801f60:	0f 85 88 00 00 00    	jne    801fee <lwip_ioctl+0xbb>
  case FIONREAD:
    if (!argp) {
  801f66:	85 f6                	test   %esi,%esi
  801f68:	74 35                	je     801f9f <lwip_ioctl+0x6c>
      sock_set_errno(sock, EINVAL);
      return -1;
    }

    SYS_ARCH_GET(sock->conn->recv_avail, *((u16_t*)argp));
  801f6a:	8b 10                	mov    (%eax),%edx
  801f6c:	0f b7 52 20          	movzwl 0x20(%edx),%edx
  801f70:	66 89 16             	mov    %dx,(%esi)

    /* Check if there is data left from the last recv operation. /maq 041215 */
    if (sock->lastdata) {
  801f73:	8b 48 04             	mov    0x4(%eax),%ecx
  801f76:	85 c9                	test   %ecx,%ecx
  801f78:	74 0d                	je     801f87 <lwip_ioctl+0x54>
      buflen = netbuf_len(sock->lastdata);
  801f7a:	8b 09                	mov    (%ecx),%ecx
      buflen -= sock->lastoffset;

      *((u16_t*)argp) += buflen;
  801f7c:	66 2b 50 08          	sub    0x8(%eax),%dx
  801f80:	66 03 51 08          	add    0x8(%ecx),%dx
  801f84:	66 89 16             	mov    %dx,(%esi)
    }

    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, FIONREAD, %p) = %u\n", s, argp, *((u16_t*)argp)));
    sock_set_errno(sock, 0);
  801f87:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  801f8e:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  801f95:	00 00 00 
    return 0;
  801f98:	b8 00 00 00 00       	mov    $0x0,%eax
  801f9d:	eb 4b                	jmp    801fea <lwip_ioctl+0xb7>
      sock_set_errno(sock, EINVAL);
  801f9f:	c7 40 10 16 00 00 00 	movl   $0x16,0x10(%eax)
  801fa6:	c7 05 e0 b1 b3 00 16 	movl   $0x16,0xb3b1e0
  801fad:	00 00 00 
      return -1;
  801fb0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801fb5:	eb 33                	jmp    801fea <lwip_ioctl+0xb7>

  case FIONBIO:
    if (argp && *(u32_t*)argp)
  801fb7:	85 f6                	test   %esi,%esi
  801fb9:	74 0e                	je     801fc9 <lwip_ioctl+0x96>
  801fbb:	83 3e 00             	cmpl   $0x0,(%esi)
  801fbe:	74 09                	je     801fc9 <lwip_ioctl+0x96>
      sock->flags |= O_NONBLOCK;
  801fc0:	0f b7 50 0e          	movzwl 0xe(%eax),%edx
  801fc4:	80 ce 08             	or     $0x8,%dh
  801fc7:	eb 07                	jmp    801fd0 <lwip_ioctl+0x9d>
    else
      sock->flags &= ~O_NONBLOCK;
  801fc9:	0f b7 50 0e          	movzwl 0xe(%eax),%edx
  801fcd:	80 e6 f7             	and    $0xf7,%dh
  801fd0:	66 89 50 0e          	mov    %dx,0xe(%eax)
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, FIONBIO, %d)\n", s, !!(sock->flags & O_NONBLOCK)));
    sock_set_errno(sock, 0);
  801fd4:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  801fdb:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  801fe2:	00 00 00 
    return 0;
  801fe5:	b8 00 00 00 00       	mov    $0x0,%eax
  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, UNIMPL: 0x%lx, %p)\n", s, cmd, argp));
    sock_set_errno(sock, ENOSYS); /* not yet implemented */
    return -1;
  } /* switch (cmd) */
}
  801fea:	5b                   	pop    %ebx
  801feb:	5e                   	pop    %esi
  801fec:	5d                   	pop    %ebp
  801fed:	c3                   	ret    
    sock_set_errno(sock, ENOSYS); /* not yet implemented */
  801fee:	c7 40 10 26 00 00 00 	movl   $0x26,0x10(%eax)
  801ff5:	c7 05 e0 b1 b3 00 26 	movl   $0x26,0xb3b1e0
  801ffc:	00 00 00 
    return -1;
  801fff:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  802004:	eb e4                	jmp    801fea <lwip_ioctl+0xb7>
    return -1;
  802006:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80200b:	eb dd                	jmp    801fea <lwip_ioctl+0xb7>

0080200d <tcpip_tcp_timer>:
 *
 * @param arg unused argument
 */
static void
tcpip_tcp_timer(void *arg)
{
  80200d:	f3 0f 1e fb          	endbr32 
  802011:	55                   	push   %ebp
  802012:	89 e5                	mov    %esp,%ebp
  802014:	83 ec 08             	sub    $0x8,%esp
  LWIP_UNUSED_ARG(arg);

  /* call TCP timer handler */
  tcp_tmr();
  802017:	e8 26 42 00 00       	call   806242 <tcp_tmr>
  /* timer still needed? */
  if (tcp_active_pcbs || tcp_tw_pcbs) {
  80201c:	83 3d 3c b2 b3 00 00 	cmpl   $0x0,0xb3b23c
  802023:	74 19                	je     80203e <tcpip_tcp_timer+0x31>
    /* restart timer */
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
  802025:	83 ec 04             	sub    $0x4,%esp
  802028:	6a 00                	push   $0x0
  80202a:	68 0d 20 80 00       	push   $0x80200d
  80202f:	68 fa 00 00 00       	push   $0xfa
  802034:	e8 89 32 00 00       	call   8052c2 <sys_timeout>
  802039:	83 c4 10             	add    $0x10,%esp
  } else {
    /* disable timer */
    tcpip_tcp_timer_active = 0;
  }
}
  80203c:	c9                   	leave  
  80203d:	c3                   	ret    
  if (tcp_active_pcbs || tcp_tw_pcbs) {
  80203e:	83 3d 50 b2 b3 00 00 	cmpl   $0x0,0xb3b250
  802045:	75 de                	jne    802025 <tcpip_tcp_timer+0x18>
    tcpip_tcp_timer_active = 0;
  802047:	c7 05 e0 52 81 00 00 	movl   $0x0,0x8152e0
  80204e:	00 00 00 
}
  802051:	eb e9                	jmp    80203c <tcpip_tcp_timer+0x2f>

00802053 <tcpip_thread>:
 *
 * @param arg unused argument
 */
static void
tcpip_thread(void *arg)
{
  802053:	f3 0f 1e fb          	endbr32 
  802057:	55                   	push   %ebp
  802058:	89 e5                	mov    %esp,%ebp
  80205a:	53                   	push   %ebx
  80205b:	83 ec 18             	sub    $0x18,%esp
  struct tcpip_msg *msg;
  LWIP_UNUSED_ARG(arg);

#if IP_REASSEMBLY
  sys_timeout(IP_TMR_INTERVAL, ip_reass_timer, NULL);
  80205e:	6a 00                	push   $0x0
  802060:	68 14 22 80 00       	push   $0x802214
  802065:	68 e8 03 00 00       	push   $0x3e8
  80206a:	e8 53 32 00 00       	call   8052c2 <sys_timeout>
#endif /* IP_REASSEMBLY */
#if LWIP_ARP
  sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
  80206f:	83 c4 0c             	add    $0xc,%esp
  802072:	6a 00                	push   $0x0
  802074:	68 ec 21 80 00       	push   $0x8021ec
  802079:	68 88 13 00 00       	push   $0x1388
  80207e:	e8 3f 32 00 00       	call   8052c2 <sys_timeout>
#endif /* LWIP_ARP */
#if LWIP_DHCP
  sys_timeout(DHCP_COARSE_TIMER_MSECS, dhcp_timer_coarse, NULL);
  802083:	83 c4 0c             	add    $0xc,%esp
  802086:	6a 00                	push   $0x0
  802088:	68 c4 21 80 00       	push   $0x8021c4
  80208d:	68 60 ea 00 00       	push   $0xea60
  802092:	e8 2b 32 00 00       	call   8052c2 <sys_timeout>
  sys_timeout(DHCP_FINE_TIMER_MSECS, dhcp_timer_fine, NULL);
  802097:	83 c4 0c             	add    $0xc,%esp
  80209a:	6a 00                	push   $0x0
  80209c:	68 9c 21 80 00       	push   $0x80219c
  8020a1:	68 f4 01 00 00       	push   $0x1f4
  8020a6:	e8 17 32 00 00       	call   8052c2 <sys_timeout>
#endif /* LWIP_IGMP */
#if LWIP_DNS
  sys_timeout(DNS_TMR_INTERVAL, dns_timer, NULL);
#endif /* LWIP_DNS */

  if (tcpip_init_done != NULL) {
  8020ab:	a1 e8 52 81 00       	mov    0x8152e8,%eax
  8020b0:	83 c4 10             	add    $0x10,%esp
  8020b3:	85 c0                	test   %eax,%eax
  8020b5:	74 0e                	je     8020c5 <tcpip_thread+0x72>
    tcpip_init_done(tcpip_init_done_arg);
  8020b7:	83 ec 0c             	sub    $0xc,%esp
  8020ba:	ff 35 e4 52 81 00    	pushl  0x8152e4
  8020c0:	ff d0                	call   *%eax
  8020c2:	83 c4 10             	add    $0x10,%esp
  }

  LOCK_TCPIP_CORE();
  while (1) {                          /* MAIN Loop */
    sys_mbox_fetch(mbox, (void *)&msg);
  8020c5:	8d 5d f4             	lea    -0xc(%ebp),%ebx
  8020c8:	eb 44                	jmp    80210e <tcpip_thread+0xbb>
    switch (msg->type) {
  8020ca:	83 f8 03             	cmp    $0x3,%eax
  8020cd:	75 3f                	jne    80210e <tcpip_thread+0xbb>
      break;

    case TCPIP_MSG_TIMEOUT:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: TIMEOUT %p\n", (void *)msg));

      if(msg->msg.tmo.msecs != 0xffffffff)
  8020cf:	8b 42 08             	mov    0x8(%edx),%eax
  8020d2:	83 f8 ff             	cmp    $0xffffffff,%eax
  8020d5:	0f 84 ab 00 00 00    	je     802186 <tcpip_thread+0x133>
        sys_timeout (msg->msg.tmo.msecs, msg->msg.tmo.h, msg->msg.tmo.arg);
  8020db:	83 ec 04             	sub    $0x4,%esp
  8020de:	ff 72 10             	pushl  0x10(%edx)
  8020e1:	ff 72 0c             	pushl  0xc(%edx)
  8020e4:	50                   	push   %eax
  8020e5:	e8 d8 31 00 00       	call   8052c2 <sys_timeout>
  8020ea:	83 c4 10             	add    $0x10,%esp
      else
        sys_untimeout (msg->msg.tmo.h, msg->msg.tmo.arg);
      memp_free(MEMP_TCPIP_MSG_API, msg);
  8020ed:	83 ec 08             	sub    $0x8,%esp
  8020f0:	ff 75 f4             	pushl  -0xc(%ebp)
  8020f3:	6a 08                	push   $0x8
  8020f5:	e8 ab 24 00 00       	call   8045a5 <memp_free>
      break;
  8020fa:	83 c4 10             	add    $0x10,%esp
  8020fd:	eb 0f                	jmp    80210e <tcpip_thread+0xbb>
      msg->msg.apimsg->function(&(msg->msg.apimsg->msg));
  8020ff:	8b 42 08             	mov    0x8(%edx),%eax
  802102:	83 ec 0c             	sub    $0xc,%esp
  802105:	8d 50 04             	lea    0x4(%eax),%edx
  802108:	52                   	push   %edx
  802109:	ff 10                	call   *(%eax)
      break;
  80210b:	83 c4 10             	add    $0x10,%esp
    sys_mbox_fetch(mbox, (void *)&msg);
  80210e:	83 ec 08             	sub    $0x8,%esp
  802111:	53                   	push   %ebx
  802112:	ff 35 00 40 81 00    	pushl  0x814000
  802118:	e8 75 30 00 00       	call   805192 <sys_mbox_fetch>
    switch (msg->type) {
  80211d:	8b 55 f4             	mov    -0xc(%ebp),%edx
  802120:	8b 02                	mov    (%edx),%eax
  802122:	83 c4 10             	add    $0x10,%esp
  802125:	83 f8 02             	cmp    $0x2,%eax
  802128:	74 41                	je     80216b <tcpip_thread+0x118>
  80212a:	77 9e                	ja     8020ca <tcpip_thread+0x77>
  80212c:	85 c0                	test   %eax,%eax
  80212e:	74 cf                	je     8020ff <tcpip_thread+0xac>
      if (msg->msg.inp.netif->flags & NETIF_FLAG_ETHARP) {
  802130:	8b 42 0c             	mov    0xc(%edx),%eax
  802133:	f6 40 2e 20          	testb  $0x20,0x2e(%eax)
  802137:	74 21                	je     80215a <tcpip_thread+0x107>
        ethernet_input(msg->msg.inp.p, msg->msg.inp.netif);
  802139:	83 ec 08             	sub    $0x8,%esp
  80213c:	50                   	push   %eax
  80213d:	ff 72 08             	pushl  0x8(%edx)
  802140:	e8 af 7c 00 00       	call   809df4 <ethernet_input>
  802145:	83 c4 10             	add    $0x10,%esp
      memp_free(MEMP_TCPIP_MSG_INPKT, msg);
  802148:	83 ec 08             	sub    $0x8,%esp
  80214b:	ff 75 f4             	pushl  -0xc(%ebp)
  80214e:	6a 09                	push   $0x9
  802150:	e8 50 24 00 00       	call   8045a5 <memp_free>
      break;
  802155:	83 c4 10             	add    $0x10,%esp
  802158:	eb b4                	jmp    80210e <tcpip_thread+0xbb>
      { ip_input(msg->msg.inp.p, msg->msg.inp.netif);
  80215a:	83 ec 08             	sub    $0x8,%esp
  80215d:	50                   	push   %eax
  80215e:	ff 72 08             	pushl  0x8(%edx)
  802161:	e8 26 45 00 00       	call   80668c <ip_input>
  802166:	83 c4 10             	add    $0x10,%esp
  802169:	eb dd                	jmp    802148 <tcpip_thread+0xf5>
      msg->msg.cb.f(msg->msg.cb.ctx);
  80216b:	83 ec 0c             	sub    $0xc,%esp
  80216e:	ff 72 0c             	pushl  0xc(%edx)
  802171:	ff 52 08             	call   *0x8(%edx)
      memp_free(MEMP_TCPIP_MSG_API, msg);
  802174:	83 c4 08             	add    $0x8,%esp
  802177:	ff 75 f4             	pushl  -0xc(%ebp)
  80217a:	6a 08                	push   $0x8
  80217c:	e8 24 24 00 00       	call   8045a5 <memp_free>
      break;
  802181:	83 c4 10             	add    $0x10,%esp
  802184:	eb 88                	jmp    80210e <tcpip_thread+0xbb>
        sys_untimeout (msg->msg.tmo.h, msg->msg.tmo.arg);
  802186:	83 ec 08             	sub    $0x8,%esp
  802189:	ff 72 10             	pushl  0x10(%edx)
  80218c:	ff 72 0c             	pushl  0xc(%edx)
  80218f:	e8 ed 31 00 00       	call   805381 <sys_untimeout>
  802194:	83 c4 10             	add    $0x10,%esp
  802197:	e9 51 ff ff ff       	jmp    8020ed <tcpip_thread+0x9a>

0080219c <dhcp_timer_fine>:
{
  80219c:	f3 0f 1e fb          	endbr32 
  8021a0:	55                   	push   %ebp
  8021a1:	89 e5                	mov    %esp,%ebp
  8021a3:	83 ec 08             	sub    $0x8,%esp
  dhcp_fine_tmr();
  8021a6:	e8 a1 1b 00 00       	call   803d4c <dhcp_fine_tmr>
  sys_timeout(DHCP_FINE_TIMER_MSECS, dhcp_timer_fine, NULL);
  8021ab:	83 ec 04             	sub    $0x4,%esp
  8021ae:	6a 00                	push   $0x0
  8021b0:	68 9c 21 80 00       	push   $0x80219c
  8021b5:	68 f4 01 00 00       	push   $0x1f4
  8021ba:	e8 03 31 00 00       	call   8052c2 <sys_timeout>
}
  8021bf:	83 c4 10             	add    $0x10,%esp
  8021c2:	c9                   	leave  
  8021c3:	c3                   	ret    

008021c4 <dhcp_timer_coarse>:
{
  8021c4:	f3 0f 1e fb          	endbr32 
  8021c8:	55                   	push   %ebp
  8021c9:	89 e5                	mov    %esp,%ebp
  8021cb:	83 ec 08             	sub    $0x8,%esp
  dhcp_coarse_tmr();
  8021ce:	e8 a5 19 00 00       	call   803b78 <dhcp_coarse_tmr>
  sys_timeout(DHCP_COARSE_TIMER_MSECS, dhcp_timer_coarse, NULL);
  8021d3:	83 ec 04             	sub    $0x4,%esp
  8021d6:	6a 00                	push   $0x0
  8021d8:	68 c4 21 80 00       	push   $0x8021c4
  8021dd:	68 60 ea 00 00       	push   $0xea60
  8021e2:	e8 db 30 00 00       	call   8052c2 <sys_timeout>
}
  8021e7:	83 c4 10             	add    $0x10,%esp
  8021ea:	c9                   	leave  
  8021eb:	c3                   	ret    

008021ec <arp_timer>:
{
  8021ec:	f3 0f 1e fb          	endbr32 
  8021f0:	55                   	push   %ebp
  8021f1:	89 e5                	mov    %esp,%ebp
  8021f3:	83 ec 08             	sub    $0x8,%esp
  etharp_tmr();
  8021f6:	e8 a9 74 00 00       	call   8096a4 <etharp_tmr>
  sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
  8021fb:	83 ec 04             	sub    $0x4,%esp
  8021fe:	6a 00                	push   $0x0
  802200:	68 ec 21 80 00       	push   $0x8021ec
  802205:	68 88 13 00 00       	push   $0x1388
  80220a:	e8 b3 30 00 00       	call   8052c2 <sys_timeout>
}
  80220f:	83 c4 10             	add    $0x10,%esp
  802212:	c9                   	leave  
  802213:	c3                   	ret    

00802214 <ip_reass_timer>:
{
  802214:	f3 0f 1e fb          	endbr32 
  802218:	55                   	push   %ebp
  802219:	89 e5                	mov    %esp,%ebp
  80221b:	83 ec 08             	sub    $0x8,%esp
  ip_reass_tmr();
  80221e:	e8 59 4b 00 00       	call   806d7c <ip_reass_tmr>
  sys_timeout(IP_TMR_INTERVAL, ip_reass_timer, NULL);
  802223:	83 ec 04             	sub    $0x4,%esp
  802226:	6a 00                	push   $0x0
  802228:	68 14 22 80 00       	push   $0x802214
  80222d:	68 e8 03 00 00       	push   $0x3e8
  802232:	e8 8b 30 00 00       	call   8052c2 <sys_timeout>
}
  802237:	83 c4 10             	add    $0x10,%esp
  80223a:	c9                   	leave  
  80223b:	c3                   	ret    

0080223c <pbuf_free_int>:
 *
 * @param p The pbuf (chain) to be dereferenced.
 */
static void
pbuf_free_int(void *p)
{
  80223c:	f3 0f 1e fb          	endbr32 
  802240:	55                   	push   %ebp
  802241:	89 e5                	mov    %esp,%ebp
  802243:	83 ec 14             	sub    $0x14,%esp
  struct pbuf *q = p;
  pbuf_free(q);
  802246:	ff 75 08             	pushl  0x8(%ebp)
  802249:	e8 da 26 00 00       	call   804928 <pbuf_free>
}
  80224e:	83 c4 10             	add    $0x10,%esp
  802251:	c9                   	leave  
  802252:	c3                   	ret    

00802253 <tcp_timer_needed>:
{
  802253:	f3 0f 1e fb          	endbr32 
  if (!tcpip_tcp_timer_active && (tcp_active_pcbs || tcp_tw_pcbs)) {
  802257:	83 3d e0 52 81 00 00 	cmpl   $0x0,0x8152e0
  80225e:	75 38                	jne    802298 <tcp_timer_needed+0x45>
  802260:	83 3d 3c b2 b3 00 00 	cmpl   $0x0,0xb3b23c
  802267:	74 26                	je     80228f <tcp_timer_needed+0x3c>
{
  802269:	55                   	push   %ebp
  80226a:	89 e5                	mov    %esp,%ebp
  80226c:	83 ec 0c             	sub    $0xc,%esp
    tcpip_tcp_timer_active = 1;
  80226f:	c7 05 e0 52 81 00 01 	movl   $0x1,0x8152e0
  802276:	00 00 00 
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
  802279:	6a 00                	push   $0x0
  80227b:	68 0d 20 80 00       	push   $0x80200d
  802280:	68 fa 00 00 00       	push   $0xfa
  802285:	e8 38 30 00 00       	call   8052c2 <sys_timeout>
  80228a:	83 c4 10             	add    $0x10,%esp
}
  80228d:	c9                   	leave  
  80228e:	c3                   	ret    
  if (!tcpip_tcp_timer_active && (tcp_active_pcbs || tcp_tw_pcbs)) {
  80228f:	83 3d 50 b2 b3 00 00 	cmpl   $0x0,0xb3b250
  802296:	75 d1                	jne    802269 <tcp_timer_needed+0x16>
  802298:	c3                   	ret    

00802299 <tcpip_input>:
{
  802299:	f3 0f 1e fb          	endbr32 
  if (mbox != SYS_MBOX_NULL) {
  80229d:	83 3d 00 40 81 00 ff 	cmpl   $0xffffffff,0x814000
  8022a4:	74 59                	je     8022ff <tcpip_input+0x66>
{
  8022a6:	55                   	push   %ebp
  8022a7:	89 e5                	mov    %esp,%ebp
  8022a9:	53                   	push   %ebx
  8022aa:	83 ec 10             	sub    $0x10,%esp
    msg = memp_malloc(MEMP_TCPIP_MSG_INPKT);
  8022ad:	6a 09                	push   $0x9
  8022af:	e8 97 22 00 00       	call   80454b <memp_malloc>
  8022b4:	89 c3                	mov    %eax,%ebx
    if (msg == NULL) {
  8022b6:	83 c4 10             	add    $0x10,%esp
  8022b9:	85 c0                	test   %eax,%eax
  8022bb:	74 48                	je     802305 <tcpip_input+0x6c>
    msg->type = TCPIP_MSG_INPKT;
  8022bd:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    msg->msg.inp.p = p;
  8022c3:	8b 45 08             	mov    0x8(%ebp),%eax
  8022c6:	89 43 08             	mov    %eax,0x8(%ebx)
    msg->msg.inp.netif = inp;
  8022c9:	8b 45 0c             	mov    0xc(%ebp),%eax
  8022cc:	89 43 0c             	mov    %eax,0xc(%ebx)
    if (sys_mbox_trypost(mbox, msg) != ERR_OK) {
  8022cf:	83 ec 08             	sub    $0x8,%esp
  8022d2:	53                   	push   %ebx
  8022d3:	ff 35 00 40 81 00    	pushl  0x814000
  8022d9:	e8 24 81 00 00       	call   80a402 <sys_mbox_trypost>
  8022de:	83 c4 10             	add    $0x10,%esp
  8022e1:	84 c0                	test   %al,%al
  8022e3:	75 05                	jne    8022ea <tcpip_input+0x51>
}
  8022e5:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  8022e8:	c9                   	leave  
  8022e9:	c3                   	ret    
      memp_free(MEMP_TCPIP_MSG_INPKT, msg);
  8022ea:	83 ec 08             	sub    $0x8,%esp
  8022ed:	53                   	push   %ebx
  8022ee:	6a 09                	push   $0x9
  8022f0:	e8 b0 22 00 00       	call   8045a5 <memp_free>
      return ERR_MEM;
  8022f5:	83 c4 10             	add    $0x10,%esp
  8022f8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8022fd:	eb e6                	jmp    8022e5 <tcpip_input+0x4c>
  return ERR_VAL;
  8022ff:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
}
  802304:	c3                   	ret    
      return ERR_MEM;
  802305:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80230a:	eb d9                	jmp    8022e5 <tcpip_input+0x4c>

0080230c <tcpip_callback_with_block>:
{
  80230c:	f3 0f 1e fb          	endbr32 
  802310:	55                   	push   %ebp
  802311:	89 e5                	mov    %esp,%ebp
  802313:	56                   	push   %esi
  802314:	53                   	push   %ebx
  802315:	8b 75 10             	mov    0x10(%ebp),%esi
  if (mbox != SYS_MBOX_NULL) {
  802318:	83 3d 00 40 81 00 ff 	cmpl   $0xffffffff,0x814000
  80231f:	74 76                	je     802397 <tcpip_callback_with_block+0x8b>
    msg = memp_malloc(MEMP_TCPIP_MSG_API);
  802321:	83 ec 0c             	sub    $0xc,%esp
  802324:	6a 08                	push   $0x8
  802326:	e8 20 22 00 00       	call   80454b <memp_malloc>
  80232b:	89 c3                	mov    %eax,%ebx
    if (msg == NULL) {
  80232d:	83 c4 10             	add    $0x10,%esp
  802330:	85 c0                	test   %eax,%eax
  802332:	74 6a                	je     80239e <tcpip_callback_with_block+0x92>
    msg->type = TCPIP_MSG_CALLBACK;
  802334:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
    msg->msg.cb.f = f;
  80233a:	8b 45 08             	mov    0x8(%ebp),%eax
  80233d:	89 43 08             	mov    %eax,0x8(%ebx)
    msg->msg.cb.ctx = ctx;
  802340:	8b 45 0c             	mov    0xc(%ebp),%eax
  802343:	89 43 0c             	mov    %eax,0xc(%ebx)
    if (block) {
  802346:	89 f0                	mov    %esi,%eax
  802348:	84 c0                	test   %al,%al
  80234a:	75 1d                	jne    802369 <tcpip_callback_with_block+0x5d>
      if (sys_mbox_trypost(mbox, msg) != ERR_OK) {
  80234c:	83 ec 08             	sub    $0x8,%esp
  80234f:	53                   	push   %ebx
  802350:	ff 35 00 40 81 00    	pushl  0x814000
  802356:	e8 a7 80 00 00       	call   80a402 <sys_mbox_trypost>
  80235b:	83 c4 10             	add    $0x10,%esp
  80235e:	84 c0                	test   %al,%al
  802360:	75 20                	jne    802382 <tcpip_callback_with_block+0x76>
}
  802362:	8d 65 f8             	lea    -0x8(%ebp),%esp
  802365:	5b                   	pop    %ebx
  802366:	5e                   	pop    %esi
  802367:	5d                   	pop    %ebp
  802368:	c3                   	ret    
      sys_mbox_post(mbox, msg);
  802369:	83 ec 08             	sub    $0x8,%esp
  80236c:	53                   	push   %ebx
  80236d:	ff 35 00 40 81 00    	pushl  0x814000
  802373:	e8 53 81 00 00       	call   80a4cb <sys_mbox_post>
  802378:	83 c4 10             	add    $0x10,%esp
    return ERR_OK;
  80237b:	b8 00 00 00 00       	mov    $0x0,%eax
  802380:	eb e0                	jmp    802362 <tcpip_callback_with_block+0x56>
        memp_free(MEMP_TCPIP_MSG_API, msg);
  802382:	83 ec 08             	sub    $0x8,%esp
  802385:	53                   	push   %ebx
  802386:	6a 08                	push   $0x8
  802388:	e8 18 22 00 00       	call   8045a5 <memp_free>
        return ERR_MEM;
  80238d:	83 c4 10             	add    $0x10,%esp
  802390:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  802395:	eb cb                	jmp    802362 <tcpip_callback_with_block+0x56>
  return ERR_VAL;
  802397:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  80239c:	eb c4                	jmp    802362 <tcpip_callback_with_block+0x56>
      return ERR_MEM;
  80239e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8023a3:	eb bd                	jmp    802362 <tcpip_callback_with_block+0x56>

008023a5 <tcpip_timeout>:
{
  8023a5:	f3 0f 1e fb          	endbr32 
  if (mbox != SYS_MBOX_NULL) {
  8023a9:	83 3d 00 40 81 00 ff 	cmpl   $0xffffffff,0x814000
  8023b0:	74 45                	je     8023f7 <tcpip_timeout+0x52>
{
  8023b2:	55                   	push   %ebp
  8023b3:	89 e5                	mov    %esp,%ebp
  8023b5:	83 ec 14             	sub    $0x14,%esp
    msg = memp_malloc(MEMP_TCPIP_MSG_API);
  8023b8:	6a 08                	push   $0x8
  8023ba:	e8 8c 21 00 00       	call   80454b <memp_malloc>
    if (msg == NULL) {
  8023bf:	83 c4 10             	add    $0x10,%esp
  8023c2:	85 c0                	test   %eax,%eax
  8023c4:	74 37                	je     8023fd <tcpip_timeout+0x58>
    msg->type = TCPIP_MSG_TIMEOUT;
  8023c6:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
    msg->msg.tmo.msecs = msecs;
  8023cc:	8b 55 08             	mov    0x8(%ebp),%edx
  8023cf:	89 50 08             	mov    %edx,0x8(%eax)
    msg->msg.tmo.h = h;
  8023d2:	8b 55 0c             	mov    0xc(%ebp),%edx
  8023d5:	89 50 0c             	mov    %edx,0xc(%eax)
    msg->msg.tmo.arg = arg;
  8023d8:	8b 55 10             	mov    0x10(%ebp),%edx
  8023db:	89 50 10             	mov    %edx,0x10(%eax)
    sys_mbox_post(mbox, msg);
  8023de:	83 ec 08             	sub    $0x8,%esp
  8023e1:	50                   	push   %eax
  8023e2:	ff 35 00 40 81 00    	pushl  0x814000
  8023e8:	e8 de 80 00 00       	call   80a4cb <sys_mbox_post>
    return ERR_OK;
  8023ed:	83 c4 10             	add    $0x10,%esp
  8023f0:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8023f5:	c9                   	leave  
  8023f6:	c3                   	ret    
  return ERR_VAL;
  8023f7:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
}
  8023fc:	c3                   	ret    
      return ERR_MEM;
  8023fd:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  802402:	eb f1                	jmp    8023f5 <tcpip_timeout+0x50>

00802404 <tcpip_apimsg>:
{
  802404:	f3 0f 1e fb          	endbr32 
  802408:	55                   	push   %ebp
  802409:	89 e5                	mov    %esp,%ebp
  80240b:	53                   	push   %ebx
  80240c:	83 ec 24             	sub    $0x24,%esp
  80240f:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (mbox != SYS_MBOX_NULL) {
  802412:	a1 00 40 81 00       	mov    0x814000,%eax
  802417:	83 f8 ff             	cmp    $0xffffffff,%eax
  80241a:	74 34                	je     802450 <tcpip_apimsg+0x4c>
    msg.type = TCPIP_MSG_API;
  80241c:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    msg.msg.apimsg = apimsg;
  802423:	89 5d ec             	mov    %ebx,-0x14(%ebp)
    sys_mbox_post(mbox, &msg);
  802426:	83 ec 08             	sub    $0x8,%esp
  802429:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  80242c:	52                   	push   %edx
  80242d:	50                   	push   %eax
  80242e:	e8 98 80 00 00       	call   80a4cb <sys_mbox_post>
    sys_arch_sem_wait(apimsg->msg.conn->op_completed, 0);
  802433:	83 c4 08             	add    $0x8,%esp
  802436:	6a 00                	push   $0x0
  802438:	8b 43 04             	mov    0x4(%ebx),%eax
  80243b:	ff 70 10             	pushl  0x10(%eax)
  80243e:	e8 ab 7e 00 00       	call   80a2ee <sys_arch_sem_wait>
    return ERR_OK;
  802443:	83 c4 10             	add    $0x10,%esp
  802446:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80244b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80244e:	c9                   	leave  
  80244f:	c3                   	ret    
  return ERR_VAL;
  802450:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  802455:	eb f4                	jmp    80244b <tcpip_apimsg+0x47>

00802457 <tcpip_init>:
{
  802457:	f3 0f 1e fb          	endbr32 
  80245b:	55                   	push   %ebp
  80245c:	89 e5                	mov    %esp,%ebp
  80245e:	83 ec 08             	sub    $0x8,%esp
  lwip_init();
  802461:	e8 96 03 00 00       	call   8027fc <lwip_init>
  tcpip_init_done = initfunc;
  802466:	8b 45 08             	mov    0x8(%ebp),%eax
  802469:	a3 e8 52 81 00       	mov    %eax,0x8152e8
  tcpip_init_done_arg = arg;
  80246e:	8b 45 0c             	mov    0xc(%ebp),%eax
  802471:	a3 e4 52 81 00       	mov    %eax,0x8152e4
  mbox = sys_mbox_new(TCPIP_MBOX_SIZE);
  802476:	83 ec 0c             	sub    $0xc,%esp
  802479:	6a 00                	push   $0x0
  80247b:	e8 e2 7c 00 00       	call   80a162 <sys_mbox_new>
  802480:	a3 00 40 81 00       	mov    %eax,0x814000
  sys_thread_new(TCPIP_THREAD_NAME, tcpip_thread, NULL, TCPIP_THREAD_STACKSIZE, TCPIP_THREAD_PRIO);
  802485:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  80248c:	6a 00                	push   $0x0
  80248e:	6a 00                	push   $0x0
  802490:	68 53 20 80 00       	push   $0x802053
  802495:	68 9c 15 81 00       	push   $0x81159c
  80249a:	e8 6b 81 00 00       	call   80a60a <sys_thread_new>
}
  80249f:	83 c4 20             	add    $0x20,%esp
  8024a2:	c9                   	leave  
  8024a3:	c3                   	ret    

008024a4 <pbuf_free_callback>:
 * @param p The pbuf (chain) to be dereferenced.
 * @return ERR_OK if callback could be enqueued, an err_t if not
 */
err_t
pbuf_free_callback(struct pbuf *p)
{
  8024a4:	f3 0f 1e fb          	endbr32 
  8024a8:	55                   	push   %ebp
  8024a9:	89 e5                	mov    %esp,%ebp
  8024ab:	83 ec 0c             	sub    $0xc,%esp
  return tcpip_callback_with_block(pbuf_free_int, p, 0);
  8024ae:	6a 00                	push   $0x0
  8024b0:	ff 75 08             	pushl  0x8(%ebp)
  8024b3:	68 3c 22 80 00       	push   $0x80223c
  8024b8:	e8 4f fe ff ff       	call   80230c <tcpip_callback_with_block>
}
  8024bd:	c9                   	leave  
  8024be:	c3                   	ret    

008024bf <mem_free_callback>:
 * @param m the heap memory to free
 * @return ERR_OK if callback could be enqueued, an err_t if not
 */
err_t
mem_free_callback(void *m)
{
  8024bf:	f3 0f 1e fb          	endbr32 
  8024c3:	55                   	push   %ebp
  8024c4:	89 e5                	mov    %esp,%ebp
  8024c6:	83 ec 0c             	sub    $0xc,%esp
  return tcpip_callback_with_block(mem_free, m, 0);
  8024c9:	6a 00                	push   $0x0
  8024cb:	ff 75 08             	pushl  0x8(%ebp)
  8024ce:	68 f3 3f 80 00       	push   $0x803ff3
  8024d3:	e8 34 fe ff ff       	call   80230c <tcpip_callback_with_block>
}
  8024d8:	c9                   	leave  
  8024d9:	c3                   	ret    

008024da <netbuf_new>:
 * @return a pointer to a new netbuf
 *         NULL on lack of memory
 */
struct
netbuf *netbuf_new(void)
{
  8024da:	f3 0f 1e fb          	endbr32 
  8024de:	55                   	push   %ebp
  8024df:	89 e5                	mov    %esp,%ebp
  8024e1:	83 ec 14             	sub    $0x14,%esp
  struct netbuf *buf;

  buf = memp_malloc(MEMP_NETBUF);
  8024e4:	6a 06                	push   $0x6
  8024e6:	e8 60 20 00 00       	call   80454b <memp_malloc>
  if (buf != NULL) {
  8024eb:	83 c4 10             	add    $0x10,%esp
  8024ee:	85 c0                	test   %eax,%eax
  8024f0:	74 14                	je     802506 <netbuf_new+0x2c>
    buf->p = NULL;
  8024f2:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    buf->ptr = NULL;
  8024f8:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    buf->addr = NULL;
  8024ff:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    return buf;
  } else {
    return NULL;
  }
}
  802506:	c9                   	leave  
  802507:	c3                   	ret    

00802508 <netbuf_delete>:
 *
 * @param buf pointer to a netbuf allocated by netbuf_new()
 */
void
netbuf_delete(struct netbuf *buf)
{
  802508:	f3 0f 1e fb          	endbr32 
  80250c:	55                   	push   %ebp
  80250d:	89 e5                	mov    %esp,%ebp
  80250f:	53                   	push   %ebx
  802510:	83 ec 04             	sub    $0x4,%esp
  802513:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (buf != NULL) {
  802516:	85 db                	test   %ebx,%ebx
  802518:	74 2d                	je     802547 <netbuf_delete+0x3f>
    if (buf->p != NULL) {
  80251a:	8b 03                	mov    (%ebx),%eax
  80251c:	85 c0                	test   %eax,%eax
  80251e:	74 19                	je     802539 <netbuf_delete+0x31>
      pbuf_free(buf->p);
  802520:	83 ec 0c             	sub    $0xc,%esp
  802523:	50                   	push   %eax
  802524:	e8 ff 23 00 00       	call   804928 <pbuf_free>
      buf->p = buf->ptr = NULL;
  802529:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  802530:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
  802536:	83 c4 10             	add    $0x10,%esp
    }
    memp_free(MEMP_NETBUF, buf);
  802539:	83 ec 08             	sub    $0x8,%esp
  80253c:	53                   	push   %ebx
  80253d:	6a 06                	push   $0x6
  80253f:	e8 61 20 00 00       	call   8045a5 <memp_free>
  802544:	83 c4 10             	add    $0x10,%esp
  }
}
  802547:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80254a:	c9                   	leave  
  80254b:	c3                   	ret    

0080254c <netbuf_alloc>:
 * @return pointer to the allocated memory
 *         NULL if no memory could be allocated
 */
void *
netbuf_alloc(struct netbuf *buf, u16_t size)
{
  80254c:	f3 0f 1e fb          	endbr32 
  802550:	55                   	push   %ebp
  802551:	89 e5                	mov    %esp,%ebp
  802553:	56                   	push   %esi
  802554:	53                   	push   %ebx
  802555:	8b 5d 08             	mov    0x8(%ebp),%ebx
  802558:	8b 75 0c             	mov    0xc(%ebp),%esi
  LWIP_ERROR("netbuf_alloc: invalid buf", (buf != NULL), return NULL;);
  80255b:	85 db                	test   %ebx,%ebx
  80255d:	74 3e                	je     80259d <netbuf_alloc+0x51>

  /* Deallocate any previously allocated memory. */
  if (buf->p != NULL) {
  80255f:	8b 03                	mov    (%ebx),%eax
  802561:	85 c0                	test   %eax,%eax
  802563:	74 0c                	je     802571 <netbuf_alloc+0x25>
    pbuf_free(buf->p);
  802565:	83 ec 0c             	sub    $0xc,%esp
  802568:	50                   	push   %eax
  802569:	e8 ba 23 00 00       	call   804928 <pbuf_free>
  80256e:	83 c4 10             	add    $0x10,%esp
  }
  buf->p = pbuf_alloc(PBUF_TRANSPORT, size, PBUF_RAM);
  802571:	83 ec 04             	sub    $0x4,%esp
  802574:	6a 00                	push   $0x0
  802576:	0f b7 c6             	movzwl %si,%eax
  802579:	50                   	push   %eax
  80257a:	6a 00                	push   $0x0
  80257c:	e8 71 24 00 00       	call   8049f2 <pbuf_alloc>
  802581:	89 03                	mov    %eax,(%ebx)
  if (buf->p == NULL) {
  802583:	83 c4 10             	add    $0x10,%esp
  802586:	85 c0                	test   %eax,%eax
  802588:	74 0c                	je     802596 <netbuf_alloc+0x4a>
     return NULL;
  }
  LWIP_ASSERT("check that first pbuf can hold size",
  80258a:	66 39 70 0a          	cmp    %si,0xa(%eax)
  80258e:	72 21                	jb     8025b1 <netbuf_alloc+0x65>
             (buf->p->len >= size));
  buf->ptr = buf->p;
  802590:	89 43 04             	mov    %eax,0x4(%ebx)
  return buf->p->payload;
  802593:	8b 40 04             	mov    0x4(%eax),%eax
}
  802596:	8d 65 f8             	lea    -0x8(%ebp),%esp
  802599:	5b                   	pop    %ebx
  80259a:	5e                   	pop    %esi
  80259b:	5d                   	pop    %ebp
  80259c:	c3                   	ret    
  LWIP_ERROR("netbuf_alloc: invalid buf", (buf != NULL), return NULL;);
  80259d:	83 ec 04             	sub    $0x4,%esp
  8025a0:	68 a9 15 81 00       	push   $0x8115a9
  8025a5:	6a 63                	push   $0x63
  8025a7:	68 c3 15 81 00       	push   $0x8115c3
  8025ac:	e8 96 c2 00 00       	call   80e847 <_panic>
  LWIP_ASSERT("check that first pbuf can hold size",
  8025b1:	83 ec 04             	sub    $0x4,%esp
  8025b4:	68 90 16 81 00       	push   $0x811690
  8025b9:	6a 6d                	push   $0x6d
  8025bb:	68 c3 15 81 00       	push   $0x8115c3
  8025c0:	e8 82 c2 00 00       	call   80e847 <_panic>

008025c5 <netbuf_free>:
 *
 * @param buf pointer to the netbuf which contains the packet buffer to free
 */
void
netbuf_free(struct netbuf *buf)
{
  8025c5:	f3 0f 1e fb          	endbr32 
  8025c9:	55                   	push   %ebp
  8025ca:	89 e5                	mov    %esp,%ebp
  8025cc:	53                   	push   %ebx
  8025cd:	83 ec 04             	sub    $0x4,%esp
  8025d0:	8b 5d 08             	mov    0x8(%ebp),%ebx
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return;);
  8025d3:	85 db                	test   %ebx,%ebx
  8025d5:	74 24                	je     8025fb <netbuf_free+0x36>
  if (buf->p != NULL) {
  8025d7:	8b 03                	mov    (%ebx),%eax
  8025d9:	85 c0                	test   %eax,%eax
  8025db:	74 0c                	je     8025e9 <netbuf_free+0x24>
    pbuf_free(buf->p);
  8025dd:	83 ec 0c             	sub    $0xc,%esp
  8025e0:	50                   	push   %eax
  8025e1:	e8 42 23 00 00       	call   804928 <pbuf_free>
  8025e6:	83 c4 10             	add    $0x10,%esp
  }
  buf->p = buf->ptr = NULL;
  8025e9:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  8025f0:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
}
  8025f6:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  8025f9:	c9                   	leave  
  8025fa:	c3                   	ret    
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return;);
  8025fb:	83 ec 04             	sub    $0x4,%esp
  8025fe:	68 d9 15 81 00       	push   $0x8115d9
  802603:	6a 7b                	push   $0x7b
  802605:	68 c3 15 81 00       	push   $0x8115c3
  80260a:	e8 38 c2 00 00       	call   80e847 <_panic>

0080260f <netbuf_ref>:
 * @return ERR_OK if data is referenced
 *         ERR_MEM if data couldn't be referenced due to lack of memory
 */
err_t
netbuf_ref(struct netbuf *buf, const void *dataptr, u16_t size)
{
  80260f:	f3 0f 1e fb          	endbr32 
  802613:	55                   	push   %ebp
  802614:	89 e5                	mov    %esp,%ebp
  802616:	56                   	push   %esi
  802617:	53                   	push   %ebx
  802618:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80261b:	8b 75 10             	mov    0x10(%ebp),%esi
  LWIP_ERROR("netbuf_ref: invalid buf", (buf != NULL), return ERR_ARG;);
  80261e:	85 db                	test   %ebx,%ebx
  802620:	74 4c                	je     80266e <netbuf_ref+0x5f>
  if (buf->p != NULL) {
  802622:	8b 03                	mov    (%ebx),%eax
  802624:	85 c0                	test   %eax,%eax
  802626:	74 0c                	je     802634 <netbuf_ref+0x25>
    pbuf_free(buf->p);
  802628:	83 ec 0c             	sub    $0xc,%esp
  80262b:	50                   	push   %eax
  80262c:	e8 f7 22 00 00       	call   804928 <pbuf_free>
  802631:	83 c4 10             	add    $0x10,%esp
  }
  buf->p = pbuf_alloc(PBUF_TRANSPORT, 0, PBUF_REF);
  802634:	83 ec 04             	sub    $0x4,%esp
  802637:	6a 02                	push   $0x2
  802639:	6a 00                	push   $0x0
  80263b:	6a 00                	push   $0x0
  80263d:	e8 b0 23 00 00       	call   8049f2 <pbuf_alloc>
  802642:	89 03                	mov    %eax,(%ebx)
  if (buf->p == NULL) {
  802644:	83 c4 10             	add    $0x10,%esp
  802647:	85 c0                	test   %eax,%eax
  802649:	74 3a                	je     802685 <netbuf_ref+0x76>
    buf->ptr = NULL;
    return ERR_MEM;
  }
  buf->p->payload = (void*)dataptr;
  80264b:	8b 55 0c             	mov    0xc(%ebp),%edx
  80264e:	89 50 04             	mov    %edx,0x4(%eax)
  buf->p->len = buf->p->tot_len = size;
  802651:	8b 03                	mov    (%ebx),%eax
  802653:	66 89 70 08          	mov    %si,0x8(%eax)
  802657:	8b 03                	mov    (%ebx),%eax
  802659:	66 89 70 0a          	mov    %si,0xa(%eax)
  buf->ptr = buf->p;
  80265d:	8b 03                	mov    (%ebx),%eax
  80265f:	89 43 04             	mov    %eax,0x4(%ebx)
  return ERR_OK;
  802662:	b8 00 00 00 00       	mov    $0x0,%eax
}
  802667:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80266a:	5b                   	pop    %ebx
  80266b:	5e                   	pop    %esi
  80266c:	5d                   	pop    %ebp
  80266d:	c3                   	ret    
  LWIP_ERROR("netbuf_ref: invalid buf", (buf != NULL), return ERR_ARG;);
  80266e:	83 ec 04             	sub    $0x4,%esp
  802671:	68 f2 15 81 00       	push   $0x8115f2
  802676:	68 8e 00 00 00       	push   $0x8e
  80267b:	68 c3 15 81 00       	push   $0x8115c3
  802680:	e8 c2 c1 00 00       	call   80e847 <_panic>
    buf->ptr = NULL;
  802685:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    return ERR_MEM;
  80268c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  802691:	eb d4                	jmp    802667 <netbuf_ref+0x58>

00802693 <netbuf_chain>:
 * @param head the first netbuf
 * @param tail netbuf to chain after head
 */
void
netbuf_chain(struct netbuf *head, struct netbuf *tail)
{
  802693:	f3 0f 1e fb          	endbr32 
  802697:	55                   	push   %ebp
  802698:	89 e5                	mov    %esp,%ebp
  80269a:	56                   	push   %esi
  80269b:	53                   	push   %ebx
  80269c:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80269f:	8b 75 0c             	mov    0xc(%ebp),%esi
  LWIP_ERROR("netbuf_ref: invalid head", (head != NULL), return;);
  8026a2:	85 db                	test   %ebx,%ebx
  8026a4:	74 2a                	je     8026d0 <netbuf_chain+0x3d>
  LWIP_ERROR("netbuf_chain: invalid tail", (tail != NULL), return;);
  8026a6:	85 f6                	test   %esi,%esi
  8026a8:	74 3d                	je     8026e7 <netbuf_chain+0x54>
  pbuf_chain(head->p, tail->p);
  8026aa:	83 ec 08             	sub    $0x8,%esp
  8026ad:	ff 36                	pushl  (%esi)
  8026af:	ff 33                	pushl  (%ebx)
  8026b1:	e8 54 27 00 00       	call   804e0a <pbuf_chain>
  head->ptr = head->p;
  8026b6:	8b 03                	mov    (%ebx),%eax
  8026b8:	89 43 04             	mov    %eax,0x4(%ebx)
  memp_free(MEMP_NETBUF, tail);
  8026bb:	83 c4 08             	add    $0x8,%esp
  8026be:	56                   	push   %esi
  8026bf:	6a 06                	push   $0x6
  8026c1:	e8 df 1e 00 00       	call   8045a5 <memp_free>
  8026c6:	83 c4 10             	add    $0x10,%esp
}
  8026c9:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8026cc:	5b                   	pop    %ebx
  8026cd:	5e                   	pop    %esi
  8026ce:	5d                   	pop    %ebp
  8026cf:	c3                   	ret    
  LWIP_ERROR("netbuf_ref: invalid head", (head != NULL), return;);
  8026d0:	83 ec 04             	sub    $0x4,%esp
  8026d3:	68 0a 16 81 00       	push   $0x81160a
  8026d8:	68 a6 00 00 00       	push   $0xa6
  8026dd:	68 c3 15 81 00       	push   $0x8115c3
  8026e2:	e8 60 c1 00 00       	call   80e847 <_panic>
  LWIP_ERROR("netbuf_chain: invalid tail", (tail != NULL), return;);
  8026e7:	83 ec 04             	sub    $0x4,%esp
  8026ea:	68 23 16 81 00       	push   $0x811623
  8026ef:	68 a7 00 00 00       	push   $0xa7
  8026f4:	68 c3 15 81 00       	push   $0x8115c3
  8026f9:	e8 49 c1 00 00       	call   80e847 <_panic>

008026fe <netbuf_data>:
 * @return ERR_OK if the information was retreived,
 *         ERR_BUF on error.
 */
err_t
netbuf_data(struct netbuf *buf, void **dataptr, u16_t *len)
{
  8026fe:	f3 0f 1e fb          	endbr32 
  802702:	55                   	push   %ebp
  802703:	89 e5                	mov    %esp,%ebp
  802705:	53                   	push   %ebx
  802706:	83 ec 04             	sub    $0x4,%esp
  802709:	8b 45 08             	mov    0x8(%ebp),%eax
  80270c:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80270f:	8b 55 10             	mov    0x10(%ebp),%edx
  LWIP_ERROR("netbuf_data: invalid buf", (buf != NULL), return ERR_ARG;);
  802712:	85 c0                	test   %eax,%eax
  802714:	74 28                	je     80273e <netbuf_data+0x40>
  LWIP_ERROR("netbuf_data: invalid dataptr", (dataptr != NULL), return ERR_ARG;);
  802716:	85 c9                	test   %ecx,%ecx
  802718:	74 3b                	je     802755 <netbuf_data+0x57>
  LWIP_ERROR("netbuf_data: invalid len", (len != NULL), return ERR_ARG;);
  80271a:	85 d2                	test   %edx,%edx
  80271c:	74 4e                	je     80276c <netbuf_data+0x6e>

  if (buf->ptr == NULL) {
  80271e:	8b 58 04             	mov    0x4(%eax),%ebx
  802721:	85 db                	test   %ebx,%ebx
  802723:	74 5e                	je     802783 <netbuf_data+0x85>
    return ERR_BUF;
  }
  *dataptr = buf->ptr->payload;
  802725:	8b 5b 04             	mov    0x4(%ebx),%ebx
  802728:	89 19                	mov    %ebx,(%ecx)
  *len = buf->ptr->len;
  80272a:	8b 40 04             	mov    0x4(%eax),%eax
  80272d:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
  802731:	66 89 02             	mov    %ax,(%edx)
  return ERR_OK;
  802734:	b8 00 00 00 00       	mov    $0x0,%eax
}
  802739:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80273c:	c9                   	leave  
  80273d:	c3                   	ret    
  LWIP_ERROR("netbuf_data: invalid buf", (buf != NULL), return ERR_ARG;);
  80273e:	83 ec 04             	sub    $0x4,%esp
  802741:	68 3e 16 81 00       	push   $0x81163e
  802746:	68 b9 00 00 00       	push   $0xb9
  80274b:	68 c3 15 81 00       	push   $0x8115c3
  802750:	e8 f2 c0 00 00       	call   80e847 <_panic>
  LWIP_ERROR("netbuf_data: invalid dataptr", (dataptr != NULL), return ERR_ARG;);
  802755:	83 ec 04             	sub    $0x4,%esp
  802758:	68 57 16 81 00       	push   $0x811657
  80275d:	68 ba 00 00 00       	push   $0xba
  802762:	68 c3 15 81 00       	push   $0x8115c3
  802767:	e8 db c0 00 00       	call   80e847 <_panic>
  LWIP_ERROR("netbuf_data: invalid len", (len != NULL), return ERR_ARG;);
  80276c:	83 ec 04             	sub    $0x4,%esp
  80276f:	68 74 16 81 00       	push   $0x811674
  802774:	68 bb 00 00 00       	push   $0xbb
  802779:	68 c3 15 81 00       	push   $0x8115c3
  80277e:	e8 c4 c0 00 00       	call   80e847 <_panic>
    return ERR_BUF;
  802783:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  802788:	eb af                	jmp    802739 <netbuf_data+0x3b>

0080278a <netbuf_next>:
 *         1  if moved to the next part but now there is no next part
 *         0  if moved to the next part and there are still more parts
 */
s8_t
netbuf_next(struct netbuf *buf)
{
  80278a:	f3 0f 1e fb          	endbr32 
  80278e:	55                   	push   %ebp
  80278f:	89 e5                	mov    %esp,%ebp
  802791:	83 ec 08             	sub    $0x8,%esp
  802794:	8b 45 08             	mov    0x8(%ebp),%eax
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return -1;);
  802797:	85 c0                	test   %eax,%eax
  802799:	74 14                	je     8027af <netbuf_next+0x25>
  if (buf->ptr->next == NULL) {
  80279b:	8b 50 04             	mov    0x4(%eax),%edx
  80279e:	8b 12                	mov    (%edx),%edx
  8027a0:	85 d2                	test   %edx,%edx
  8027a2:	74 22                	je     8027c6 <netbuf_next+0x3c>
    return -1;
  }
  buf->ptr = buf->ptr->next;
  8027a4:	89 50 04             	mov    %edx,0x4(%eax)
  if (buf->ptr->next == NULL) {
  8027a7:	83 3a 00             	cmpl   $0x0,(%edx)
  8027aa:	0f 94 c0             	sete   %al
    return 1;
  }
  return 0;
}
  8027ad:	c9                   	leave  
  8027ae:	c3                   	ret    
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return -1;);
  8027af:	83 ec 04             	sub    $0x4,%esp
  8027b2:	68 d9 15 81 00       	push   $0x8115d9
  8027b7:	68 d2 00 00 00       	push   $0xd2
  8027bc:	68 c3 15 81 00       	push   $0x8115c3
  8027c1:	e8 81 c0 00 00       	call   80e847 <_panic>
    return -1;
  8027c6:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8027cb:	eb e0                	jmp    8027ad <netbuf_next+0x23>

008027cd <netbuf_first>:
 *
 * @param buf the netbuf to modify
 */
void
netbuf_first(struct netbuf *buf)
{
  8027cd:	f3 0f 1e fb          	endbr32 
  8027d1:	55                   	push   %ebp
  8027d2:	89 e5                	mov    %esp,%ebp
  8027d4:	83 ec 08             	sub    $0x8,%esp
  8027d7:	8b 45 08             	mov    0x8(%ebp),%eax
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return;);
  8027da:	85 c0                	test   %eax,%eax
  8027dc:	74 07                	je     8027e5 <netbuf_first+0x18>
  buf->ptr = buf->p;
  8027de:	8b 10                	mov    (%eax),%edx
  8027e0:	89 50 04             	mov    %edx,0x4(%eax)
}
  8027e3:	c9                   	leave  
  8027e4:	c3                   	ret    
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return;);
  8027e5:	83 ec 04             	sub    $0x4,%esp
  8027e8:	68 d9 15 81 00       	push   $0x8115d9
  8027ed:	68 e7 00 00 00       	push   $0xe7
  8027f2:	68 c3 15 81 00       	push   $0x8115c3
  8027f7:	e8 4b c0 00 00       	call   80e847 <_panic>

008027fc <lwip_init>:
/**
 * Perform Sanity check of user-configurable values, and initialize all modules.
 */
void
lwip_init(void)
{
  8027fc:	f3 0f 1e fb          	endbr32 
  802800:	55                   	push   %ebp
  802801:	89 e5                	mov    %esp,%ebp
  802803:	83 ec 08             	sub    $0x8,%esp
  /* Sanity check user-configurable values */
  lwip_sanity_check();

  /* Modules initialization */
  stats_init();
  sys_init();
  802806:	e8 01 77 00 00       	call   809f0c <sys_init>
  mem_init();
  80280b:	e8 79 17 00 00       	call   803f89 <mem_init>
  memp_init();
  802810:	e8 d6 1c 00 00       	call   8044eb <memp_init>
  pbuf_init();
  netif_init();
#if LWIP_SOCKET
  lwip_socket_init();
  802815:	e8 f3 e5 ff ff       	call   800e0d <lwip_socket_init>
  igmp_init();
#endif /* LWIP_IGMP */
#if LWIP_DNS
  dns_init();
#endif /* LWIP_DNS */
}
  80281a:	c9                   	leave  
  80281b:	c3                   	ret    

0080281c <dhcp_set_state>:
 * TODO: we might also want to reset the timeout here?
 */
static void
dhcp_set_state(struct dhcp *dhcp, u8_t new_state)
{
  if (new_state != dhcp->state) {
  80281c:	38 10                	cmp    %dl,(%eax)
  80281e:	74 06                	je     802826 <dhcp_set_state+0xa>
    dhcp->state = new_state;
  802820:	88 10                	mov    %dl,(%eax)
    dhcp->tries = 0;
  802822:	c6 40 01 00          	movb   $0x0,0x1(%eax)
  }
}
  802826:	c3                   	ret    

00802827 <dhcp_get_option_ptr>:
 *
 * @return a byte offset into the UDP message where the option was found, or
 * zero if the given option was not found.
 */
static u8_t *dhcp_get_option_ptr(struct dhcp *dhcp, u8_t option_type)
{
  802827:	55                   	push   %ebp
  802828:	89 e5                	mov    %esp,%ebp
  80282a:	57                   	push   %edi
  80282b:	56                   	push   %esi
  80282c:	53                   	push   %ebx
  80282d:	83 ec 0c             	sub    $0xc,%esp
  802830:	89 45 e8             	mov    %eax,-0x18(%ebp)
  u8_t overload = DHCP_OVERLOAD_NONE;

  /* options available? */
  if ((dhcp->options_in != NULL) && (dhcp->options_in_len > 0)) {
  802833:	8b 48 14             	mov    0x14(%eax),%ecx
  802836:	85 c9                	test   %ecx,%ecx
  802838:	74 19                	je     802853 <dhcp_get_option_ptr+0x2c>
  80283a:	89 d6                	mov    %edx,%esi
  80283c:	0f b7 78 18          	movzwl 0x18(%eax),%edi
    /* start with options field */
    u8_t *options = (u8_t *)dhcp->options_in;
    u16_t offset = 0;
  802840:	b8 00 00 00 00       	mov    $0x0,%eax
  u8_t overload = DHCP_OVERLOAD_NONE;
  802845:	c6 45 ef 00          	movb   $0x0,-0x11(%ebp)
  if ((dhcp->options_in != NULL) && (dhcp->options_in_len > 0)) {
  802849:	66 85 ff             	test   %di,%di
  80284c:	75 2f                	jne    80287d <dhcp_get_option_ptr+0x56>
          offset += 1 + options[offset];
        }
      }
    }
  }
  return NULL;
  80284e:	b9 00 00 00 00       	mov    $0x0,%ecx
}
  802853:	89 c8                	mov    %ecx,%eax
  802855:	83 c4 0c             	add    $0xc,%esp
  802858:	5b                   	pop    %ebx
  802859:	5e                   	pop    %esi
  80285a:	5f                   	pop    %edi
  80285b:	5d                   	pop    %ebp
  80285c:	c3                   	ret    
        offset += 2;
  80285d:	8d 50 02             	lea    0x2(%eax),%edx
        overload = options[offset++];
  802860:	83 c0 03             	add    $0x3,%eax
  802863:	0f b7 d2             	movzwl %dx,%edx
  802866:	0f b6 1c 11          	movzbl (%ecx,%edx,1),%ebx
  80286a:	88 5d ef             	mov    %bl,-0x11(%ebp)
  80286d:	eb 0e                	jmp    80287d <dhcp_get_option_ptr+0x56>
        offset++;
  80286f:	8d 50 01             	lea    0x1(%eax),%edx
        offset += 1 + options[offset];
  802872:	0f b7 d2             	movzwl %dx,%edx
  802875:	0f b6 14 11          	movzbl (%ecx,%edx,1),%edx
  802879:	8d 44 02 02          	lea    0x2(%edx,%eax,1),%eax
    while ((offset < dhcp->options_in_len) && (options[offset] != DHCP_OPTION_END)) {
  80287d:	66 39 c7             	cmp    %ax,%di
  802880:	76 22                	jbe    8028a4 <dhcp_get_option_ptr+0x7d>
  802882:	0f b7 d8             	movzwl %ax,%ebx
  802885:	01 cb                	add    %ecx,%ebx
  802887:	89 5d f0             	mov    %ebx,-0x10(%ebp)
  80288a:	0f b6 13             	movzbl (%ebx),%edx
  80288d:	80 fa ff             	cmp    $0xff,%dl
  802890:	74 12                	je     8028a4 <dhcp_get_option_ptr+0x7d>
      if (options[offset] == DHCP_OPTION_OVERLOAD) {
  802892:	80 fa 34             	cmp    $0x34,%dl
  802895:	74 c6                	je     80285d <dhcp_get_option_ptr+0x36>
      else if (options[offset] == option_type) {
  802897:	89 f3                	mov    %esi,%ebx
  802899:	38 da                	cmp    %bl,%dl
  80289b:	75 d2                	jne    80286f <dhcp_get_option_ptr+0x48>
  80289d:	8b 5d f0             	mov    -0x10(%ebp),%ebx
    while ((offset < dhcp->options_in_len) && (options[offset] != DHCP_OPTION_END)) {
  8028a0:	89 d9                	mov    %ebx,%ecx
  8028a2:	eb af                	jmp    802853 <dhcp_get_option_ptr+0x2c>
  return NULL;
  8028a4:	b9 00 00 00 00       	mov    $0x0,%ecx
    if (overload != DHCP_OVERLOAD_NONE) {
  8028a9:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
  8028ad:	84 c0                	test   %al,%al
  8028af:	74 a2                	je     802853 <dhcp_get_option_ptr+0x2c>
      if (overload == DHCP_OVERLOAD_FILE) {
  8028b1:	3c 01                	cmp    $0x1,%al
  8028b3:	74 54                	je     802909 <dhcp_get_option_ptr+0xe2>
      } else if (overload == DHCP_OVERLOAD_SNAME) {
  8028b5:	80 7d ef 02          	cmpb   $0x2,-0x11(%ebp)
  8028b9:	74 5e                	je     802919 <dhcp_get_option_ptr+0xf2>
        options = (u8_t *)&dhcp->msg_in->sname;
  8028bb:	8b 45 e8             	mov    -0x18(%ebp),%eax
  8028be:	8b 58 10             	mov    0x10(%eax),%ebx
  8028c1:	83 c3 2c             	add    $0x2c,%ebx
        field_len = DHCP_FILE_LEN + DHCP_SNAME_LEN;
  8028c4:	bf c0 00 00 00       	mov    $0xc0,%edi
      offset = 0;
  8028c9:	ba 00 00 00 00       	mov    $0x0,%edx
  8028ce:	89 f0                	mov    %esi,%eax
  8028d0:	88 45 f0             	mov    %al,-0x10(%ebp)
      while ((offset < field_len) && (options[offset] != DHCP_OPTION_END)) {
  8028d3:	0f b7 ca             	movzwl %dx,%ecx
  8028d6:	01 d9                	add    %ebx,%ecx
  8028d8:	0f b6 31             	movzbl (%ecx),%esi
  8028db:	89 f0                	mov    %esi,%eax
  8028dd:	3c ff                	cmp    $0xff,%al
  8028df:	74 48                	je     802929 <dhcp_get_option_ptr+0x102>
        if (options[offset] == option_type) {
  8028e1:	89 f0                	mov    %esi,%eax
  8028e3:	3a 45 f0             	cmp    -0x10(%ebp),%al
  8028e6:	0f 84 67 ff ff ff    	je     802853 <dhcp_get_option_ptr+0x2c>
          offset++;
  8028ec:	8d 4a 01             	lea    0x1(%edx),%ecx
          offset += 1 + options[offset];
  8028ef:	0f b7 c9             	movzwl %cx,%ecx
  8028f2:	0f b6 0c 0b          	movzbl (%ebx,%ecx,1),%ecx
  8028f6:	8d 54 0a 02          	lea    0x2(%edx,%ecx,1),%edx
      while ((offset < field_len) && (options[offset] != DHCP_OPTION_END)) {
  8028fa:	66 39 d7             	cmp    %dx,%di
  8028fd:	77 d4                	ja     8028d3 <dhcp_get_option_ptr+0xac>
  return NULL;
  8028ff:	b9 00 00 00 00       	mov    $0x0,%ecx
  802904:	e9 4a ff ff ff       	jmp    802853 <dhcp_get_option_ptr+0x2c>
        options = (u8_t *)&dhcp->msg_in->file;
  802909:	8b 45 e8             	mov    -0x18(%ebp),%eax
  80290c:	8b 58 10             	mov    0x10(%eax),%ebx
  80290f:	83 c3 6c             	add    $0x6c,%ebx
        field_len = DHCP_FILE_LEN;
  802912:	bf 80 00 00 00       	mov    $0x80,%edi
  802917:	eb b0                	jmp    8028c9 <dhcp_get_option_ptr+0xa2>
        options = (u8_t *)&dhcp->msg_in->sname;
  802919:	8b 45 e8             	mov    -0x18(%ebp),%eax
  80291c:	8b 58 10             	mov    0x10(%eax),%ebx
  80291f:	83 c3 2c             	add    $0x2c,%ebx
        field_len = DHCP_SNAME_LEN;
  802922:	bf 40 00 00 00       	mov    $0x40,%edi
  802927:	eb a0                	jmp    8028c9 <dhcp_get_option_ptr+0xa2>
  return NULL;
  802929:	b9 00 00 00 00       	mov    $0x0,%ecx
  80292e:	e9 20 ff ff ff       	jmp    802853 <dhcp_get_option_ptr+0x2c>

00802933 <dhcp_get_option_long>:
 * @param ptr pointer obtained by dhcp_get_option_ptr().
 *
 * @return byte value at the given address.
 */
static u32_t dhcp_get_option_long(u8_t *ptr)
{
  802933:	89 c2                	mov    %eax,%edx
  u32_t value;
  value = (u32_t)(*ptr++) << 24;
  802935:	0f b6 00             	movzbl (%eax),%eax
  802938:	c1 e0 18             	shl    $0x18,%eax
  80293b:	89 c1                	mov    %eax,%ecx
  value |= (u32_t)(*ptr++) << 16;
  80293d:	0f b6 42 01          	movzbl 0x1(%edx),%eax
  802941:	c1 e0 10             	shl    $0x10,%eax
  802944:	09 c8                	or     %ecx,%eax
  value |= (u32_t)(*ptr++) << 8;
  value |= (u32_t)(*ptr++);
  802946:	0f b6 4a 03          	movzbl 0x3(%edx),%ecx
  80294a:	09 c8                	or     %ecx,%eax
  value |= (u32_t)(*ptr++) << 8;
  80294c:	0f b6 52 02          	movzbl 0x2(%edx),%edx
  802950:	c1 e2 08             	shl    $0x8,%edx
  value |= (u32_t)(*ptr++);
  802953:	09 d0                	or     %edx,%eax
  LWIP_DEBUGF(DHCP_DEBUG, ("option long value=%"U32_F"\n", value));
  return value;
}
  802955:	c3                   	ret    

00802956 <dhcp_option_byte>:
{
  802956:	55                   	push   %ebp
  802957:	89 e5                	mov    %esp,%ebp
  802959:	56                   	push   %esi
  80295a:	53                   	push   %ebx
  LWIP_ASSERT("dhcp_option_byte: dhcp->options_out_len < DHCP_OPTIONS_LEN", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  80295b:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  80295f:	66 83 f9 43          	cmp    $0x43,%cx
  802963:	77 1b                	ja     802980 <dhcp_option_byte+0x2a>
  dhcp->msg_out->options[dhcp->options_out_len++] = value;
  802965:	8b 58 20             	mov    0x20(%eax),%ebx
  802968:	8d 71 01             	lea    0x1(%ecx),%esi
  80296b:	66 89 70 24          	mov    %si,0x24(%eax)
  80296f:	0f b7 c9             	movzwl %cx,%ecx
  802972:	88 94 0b f0 00 00 00 	mov    %dl,0xf0(%ebx,%ecx,1)
}
  802979:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80297c:	5b                   	pop    %ebx
  80297d:	5e                   	pop    %esi
  80297e:	5d                   	pop    %ebp
  80297f:	c3                   	ret    
  LWIP_ASSERT("dhcp_option_byte: dhcp->options_out_len < DHCP_OPTIONS_LEN", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  802980:	83 ec 04             	sub    $0x4,%esp
  802983:	68 b4 16 81 00       	push   $0x8116b4
  802988:	68 65 04 00 00       	push   $0x465
  80298d:	68 02 1a 81 00       	push   $0x811a02
  802992:	e8 b0 be 00 00       	call   80e847 <_panic>

00802997 <dhcp_option>:
{
  802997:	55                   	push   %ebp
  802998:	89 e5                	mov    %esp,%ebp
  80299a:	57                   	push   %edi
  80299b:	56                   	push   %esi
  80299c:	53                   	push   %ebx
  80299d:	83 ec 0c             	sub    $0xc,%esp
  LWIP_ASSERT("dhcp_option: dhcp->options_out_len + 2 + option_len <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U + option_len <= DHCP_OPTIONS_LEN);
  8029a0:	0f b7 58 24          	movzwl 0x24(%eax),%ebx
  8029a4:	0f b6 f9             	movzbl %cl,%edi
  8029a7:	0f b7 f3             	movzwl %bx,%esi
  8029aa:	8d 74 37 02          	lea    0x2(%edi,%esi,1),%esi
  8029ae:	83 fe 44             	cmp    $0x44,%esi
  8029b1:	77 34                	ja     8029e7 <dhcp_option+0x50>
  dhcp->msg_out->options[dhcp->options_out_len++] = option_type;
  8029b3:	8b 70 20             	mov    0x20(%eax),%esi
  8029b6:	8d 7b 01             	lea    0x1(%ebx),%edi
  8029b9:	66 89 78 24          	mov    %di,0x24(%eax)
  8029bd:	0f b7 db             	movzwl %bx,%ebx
  8029c0:	88 94 1e f0 00 00 00 	mov    %dl,0xf0(%esi,%ebx,1)
  dhcp->msg_out->options[dhcp->options_out_len++] = option_len;
  8029c7:	8b 58 20             	mov    0x20(%eax),%ebx
  8029ca:	0f b7 50 24          	movzwl 0x24(%eax),%edx
  8029ce:	8d 72 01             	lea    0x1(%edx),%esi
  8029d1:	66 89 70 24          	mov    %si,0x24(%eax)
  8029d5:	0f b7 d2             	movzwl %dx,%edx
  8029d8:	88 8c 13 f0 00 00 00 	mov    %cl,0xf0(%ebx,%edx,1)
}
  8029df:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8029e2:	5b                   	pop    %ebx
  8029e3:	5e                   	pop    %esi
  8029e4:	5f                   	pop    %edi
  8029e5:	5d                   	pop    %ebp
  8029e6:	c3                   	ret    
  LWIP_ASSERT("dhcp_option: dhcp->options_out_len + 2 + option_len <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U + option_len <= DHCP_OPTIONS_LEN);
  8029e7:	83 ec 04             	sub    $0x4,%esp
  8029ea:	68 f0 16 81 00       	push   $0x8116f0
  8029ef:	68 5a 04 00 00       	push   $0x45a
  8029f4:	68 02 1a 81 00       	push   $0x811a02
  8029f9:	e8 49 be 00 00       	call   80e847 <_panic>

008029fe <dhcp_option_short>:
{
  8029fe:	55                   	push   %ebp
  8029ff:	89 e5                	mov    %esp,%ebp
  802a01:	56                   	push   %esi
  802a02:	53                   	push   %ebx
  LWIP_ASSERT("dhcp_option_short: dhcp->options_out_len + 2 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U <= DHCP_OPTIONS_LEN);
  802a03:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  802a07:	0f b7 d9             	movzwl %cx,%ebx
  802a0a:	83 c3 02             	add    $0x2,%ebx
  802a0d:	83 fb 44             	cmp    $0x44,%ebx
  802a10:	77 33                	ja     802a45 <dhcp_option_short+0x47>
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff00U) >> 8);
  802a12:	8b 58 20             	mov    0x20(%eax),%ebx
  802a15:	8d 71 01             	lea    0x1(%ecx),%esi
  802a18:	66 89 70 24          	mov    %si,0x24(%eax)
  802a1c:	0f b7 c9             	movzwl %cx,%ecx
  802a1f:	88 b4 0b f0 00 00 00 	mov    %dh,0xf0(%ebx,%ecx,1)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t) (value & 0x00ffU);
  802a26:	8b 58 20             	mov    0x20(%eax),%ebx
  802a29:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  802a2d:	8d 71 01             	lea    0x1(%ecx),%esi
  802a30:	66 89 70 24          	mov    %si,0x24(%eax)
  802a34:	0f b7 c9             	movzwl %cx,%ecx
  802a37:	88 94 0b f0 00 00 00 	mov    %dl,0xf0(%ebx,%ecx,1)
}
  802a3e:	8d 65 f8             	lea    -0x8(%ebp),%esp
  802a41:	5b                   	pop    %ebx
  802a42:	5e                   	pop    %esi
  802a43:	5d                   	pop    %ebp
  802a44:	c3                   	ret    
  LWIP_ASSERT("dhcp_option_short: dhcp->options_out_len + 2 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U <= DHCP_OPTIONS_LEN);
  802a45:	83 ec 04             	sub    $0x4,%esp
  802a48:	68 38 17 81 00       	push   $0x811738
  802a4d:	68 6c 04 00 00       	push   $0x46c
  802a52:	68 02 1a 81 00       	push   $0x811a02
  802a57:	e8 eb bd 00 00       	call   80e847 <_panic>

00802a5c <dhcp_option_trailer>:
{
  802a5c:	55                   	push   %ebp
  802a5d:	89 e5                	mov    %esp,%ebp
  802a5f:	53                   	push   %ebx
  802a60:	83 ec 04             	sub    $0x4,%esp
  LWIP_ERROR("dhcp_option_trailer: dhcp != NULL", (dhcp != NULL), return;);
  802a63:	85 c0                	test   %eax,%eax
  802a65:	74 25                	je     802a8c <dhcp_option_trailer+0x30>
  LWIP_ASSERT("dhcp_option_trailer: dhcp->msg_out != NULL\n", dhcp->msg_out != NULL);
  802a67:	8b 48 20             	mov    0x20(%eax),%ecx
  802a6a:	85 c9                	test   %ecx,%ecx
  802a6c:	74 35                	je     802aa3 <dhcp_option_trailer+0x47>
  LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  802a6e:	0f b7 50 24          	movzwl 0x24(%eax),%edx
  802a72:	66 83 fa 43          	cmp    $0x43,%dx
  802a76:	77 42                	ja     802aba <dhcp_option_trailer+0x5e>
  dhcp->msg_out->options[dhcp->options_out_len++] = DHCP_OPTION_END;
  802a78:	8d 5a 01             	lea    0x1(%edx),%ebx
  802a7b:	66 89 58 24          	mov    %bx,0x24(%eax)
  802a7f:	0f b7 d2             	movzwl %dx,%edx
  802a82:	c6 84 11 f0 00 00 00 	movb   $0xff,0xf0(%ecx,%edx,1)
  802a89:	ff 
  while ((dhcp->options_out_len < DHCP_MIN_OPTIONS_LEN) || (dhcp->options_out_len & 3)) {
  802a8a:	eb 5a                	jmp    802ae6 <dhcp_option_trailer+0x8a>
  LWIP_ERROR("dhcp_option_trailer: dhcp != NULL", (dhcp != NULL), return;);
  802a8c:	83 ec 04             	sub    $0x4,%esp
  802a8f:	68 7c 17 81 00       	push   $0x81177c
  802a94:	68 80 05 00 00       	push   $0x580
  802a99:	68 02 1a 81 00       	push   $0x811a02
  802a9e:	e8 a4 bd 00 00       	call   80e847 <_panic>
  LWIP_ASSERT("dhcp_option_trailer: dhcp->msg_out != NULL\n", dhcp->msg_out != NULL);
  802aa3:	83 ec 04             	sub    $0x4,%esp
  802aa6:	68 a0 17 81 00       	push   $0x8117a0
  802aab:	68 81 05 00 00       	push   $0x581
  802ab0:	68 02 1a 81 00       	push   $0x811a02
  802ab5:	e8 8d bd 00 00       	call   80e847 <_panic>
  LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  802aba:	83 ec 04             	sub    $0x4,%esp
  802abd:	68 cc 17 81 00       	push   $0x8117cc
  802ac2:	68 82 05 00 00       	push   $0x582
  802ac7:	68 02 1a 81 00       	push   $0x811a02
  802acc:	e8 76 bd 00 00       	call   80e847 <_panic>
    dhcp->msg_out->options[dhcp->options_out_len++] = 0;
  802ad1:	8b 48 20             	mov    0x20(%eax),%ecx
  802ad4:	8d 5a 01             	lea    0x1(%edx),%ebx
  802ad7:	66 89 58 24          	mov    %bx,0x24(%eax)
  802adb:	0f b7 d2             	movzwl %dx,%edx
  802ade:	c6 84 11 f0 00 00 00 	movb   $0x0,0xf0(%ecx,%edx,1)
  802ae5:	00 
  while ((dhcp->options_out_len < DHCP_MIN_OPTIONS_LEN) || (dhcp->options_out_len & 3)) {
  802ae6:	0f b7 50 24          	movzwl 0x24(%eax),%edx
  802aea:	66 83 fa 43          	cmp    $0x43,%dx
  802aee:	76 e1                	jbe    802ad1 <dhcp_option_trailer+0x75>
  802af0:	f6 c2 03             	test   $0x3,%dl
  802af3:	74 17                	je     802b0c <dhcp_option_trailer+0xb0>
    LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  802af5:	83 ec 04             	sub    $0x4,%esp
  802af8:	68 cc 17 81 00       	push   $0x8117cc
  802afd:	68 87 05 00 00       	push   $0x587
  802b02:	68 02 1a 81 00       	push   $0x811a02
  802b07:	e8 3b bd 00 00       	call   80e847 <_panic>
}
  802b0c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  802b0f:	c9                   	leave  
  802b10:	c3                   	ret    

00802b11 <dhcp_option_long>:
{
  802b11:	55                   	push   %ebp
  802b12:	89 e5                	mov    %esp,%ebp
  802b14:	56                   	push   %esi
  802b15:	53                   	push   %ebx
  LWIP_ASSERT("dhcp_option_long: dhcp->options_out_len + 4 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 4U <= DHCP_OPTIONS_LEN);
  802b16:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  802b1a:	0f b7 d9             	movzwl %cx,%ebx
  802b1d:	83 c3 04             	add    $0x4,%ebx
  802b20:	83 fb 44             	cmp    $0x44,%ebx
  802b23:	77 6d                	ja     802b92 <dhcp_option_long+0x81>
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff000000UL) >> 24);
  802b25:	8d 71 01             	lea    0x1(%ecx),%esi
  802b28:	66 89 70 24          	mov    %si,0x24(%eax)
  802b2c:	0f b7 c9             	movzwl %cx,%ecx
  802b2f:	89 d3                	mov    %edx,%ebx
  802b31:	c1 eb 18             	shr    $0x18,%ebx
  802b34:	8b 70 20             	mov    0x20(%eax),%esi
  802b37:	88 9c 0e f0 00 00 00 	mov    %bl,0xf0(%esi,%ecx,1)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x00ff0000UL) >> 16);
  802b3e:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  802b42:	8d 71 01             	lea    0x1(%ecx),%esi
  802b45:	66 89 70 24          	mov    %si,0x24(%eax)
  802b49:	0f b7 c9             	movzwl %cx,%ecx
  802b4c:	89 d3                	mov    %edx,%ebx
  802b4e:	c1 eb 10             	shr    $0x10,%ebx
  802b51:	8b 70 20             	mov    0x20(%eax),%esi
  802b54:	88 9c 0e f0 00 00 00 	mov    %bl,0xf0(%esi,%ecx,1)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x0000ff00UL) >> 8);
  802b5b:	8b 58 20             	mov    0x20(%eax),%ebx
  802b5e:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  802b62:	8d 71 01             	lea    0x1(%ecx),%esi
  802b65:	66 89 70 24          	mov    %si,0x24(%eax)
  802b69:	0f b7 c9             	movzwl %cx,%ecx
  802b6c:	88 b4 0b f0 00 00 00 	mov    %dh,0xf0(%ebx,%ecx,1)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x000000ffUL));
  802b73:	8b 58 20             	mov    0x20(%eax),%ebx
  802b76:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  802b7a:	8d 71 01             	lea    0x1(%ecx),%esi
  802b7d:	66 89 70 24          	mov    %si,0x24(%eax)
  802b81:	0f b7 c9             	movzwl %cx,%ecx
  802b84:	88 94 0b f0 00 00 00 	mov    %dl,0xf0(%ebx,%ecx,1)
}
  802b8b:	8d 65 f8             	lea    -0x8(%ebp),%esp
  802b8e:	5b                   	pop    %ebx
  802b8f:	5e                   	pop    %esi
  802b90:	5d                   	pop    %ebp
  802b91:	c3                   	ret    
  LWIP_ASSERT("dhcp_option_long: dhcp->options_out_len + 4 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 4U <= DHCP_OPTIONS_LEN);
  802b92:	83 ec 04             	sub    $0x4,%esp
  802b95:	68 0c 18 81 00       	push   $0x81180c
  802b9a:	68 74 04 00 00       	push   $0x474
  802b9f:	68 02 1a 81 00       	push   $0x811a02
  802ba4:	e8 9e bc 00 00       	call   80e847 <_panic>

00802ba9 <dhcp_create_request>:
{
  802ba9:	55                   	push   %ebp
  802baa:	89 e5                	mov    %esp,%ebp
  802bac:	57                   	push   %edi
  802bad:	56                   	push   %esi
  802bae:	53                   	push   %ebx
  802baf:	83 ec 0c             	sub    $0xc,%esp
  LWIP_ERROR("dhcp_create_request: netif != NULL", (netif != NULL), return ERR_ARG;);
  802bb2:	85 c0                	test   %eax,%eax
  802bb4:	0f 84 d8 00 00 00    	je     802c92 <dhcp_create_request+0xe9>
  802bba:	89 c6                	mov    %eax,%esi
  dhcp = netif->dhcp;
  802bbc:	8b 58 20             	mov    0x20(%eax),%ebx
  LWIP_ERROR("dhcp_create_request: dhcp != NULL", (dhcp != NULL), return ERR_VAL;);
  802bbf:	85 db                	test   %ebx,%ebx
  802bc1:	0f 84 e2 00 00 00    	je     802ca9 <dhcp_create_request+0x100>
  LWIP_ASSERT("dhcp_create_request: dhcp->p_out == NULL", dhcp->p_out == NULL);
  802bc7:	83 7b 1c 00          	cmpl   $0x0,0x1c(%ebx)
  802bcb:	0f 85 ef 00 00 00    	jne    802cc0 <dhcp_create_request+0x117>
  LWIP_ASSERT("dhcp_create_request: dhcp->msg_out == NULL", dhcp->msg_out == NULL);
  802bd1:	83 7b 20 00          	cmpl   $0x0,0x20(%ebx)
  802bd5:	0f 85 fc 00 00 00    	jne    802cd7 <dhcp_create_request+0x12e>
  dhcp->p_out = pbuf_alloc(PBUF_TRANSPORT, sizeof(struct dhcp_msg), PBUF_RAM);
  802bdb:	83 ec 04             	sub    $0x4,%esp
  802bde:	6a 00                	push   $0x0
  802be0:	68 34 01 00 00       	push   $0x134
  802be5:	6a 00                	push   $0x0
  802be7:	e8 06 1e 00 00       	call   8049f2 <pbuf_alloc>
  802bec:	89 43 1c             	mov    %eax,0x1c(%ebx)
  if (dhcp->p_out == NULL) {
  802bef:	83 c4 10             	add    $0x10,%esp
  802bf2:	85 c0                	test   %eax,%eax
  802bf4:	0f 84 9b 01 00 00    	je     802d95 <dhcp_create_request+0x1ec>
  LWIP_ASSERT("dhcp_create_request: check that first pbuf can hold struct dhcp_msg",
  802bfa:	66 81 78 0a 33 01    	cmpw   $0x133,0xa(%eax)
  802c00:	0f 86 e8 00 00 00    	jbe    802cee <dhcp_create_request+0x145>
  dhcp->xid = xid++;
  802c06:	8b 15 04 40 81 00    	mov    0x814004,%edx
  802c0c:	8d 4a 01             	lea    0x1(%edx),%ecx
  802c0f:	89 0d 04 40 81 00    	mov    %ecx,0x814004
  802c15:	89 53 04             	mov    %edx,0x4(%ebx)
  dhcp->msg_out = (struct dhcp_msg *)dhcp->p_out->payload;
  802c18:	8b 40 04             	mov    0x4(%eax),%eax
  802c1b:	89 43 20             	mov    %eax,0x20(%ebx)
  dhcp->msg_out->op = DHCP_BOOTREQUEST;
  802c1e:	c6 00 01             	movb   $0x1,(%eax)
  dhcp->msg_out->htype = DHCP_HTYPE_ETH;
  802c21:	8b 43 20             	mov    0x20(%ebx),%eax
  802c24:	c6 40 01 01          	movb   $0x1,0x1(%eax)
  dhcp->msg_out->hlen = DHCP_HLEN_ETH;
  802c28:	8b 43 20             	mov    0x20(%ebx),%eax
  802c2b:	c6 40 02 06          	movb   $0x6,0x2(%eax)
  dhcp->msg_out->hops = 0;
  802c2f:	8b 43 20             	mov    0x20(%ebx),%eax
  802c32:	c6 40 03 00          	movb   $0x0,0x3(%eax)
  dhcp->msg_out->xid = htonl(dhcp->xid);
  802c36:	8b 7b 20             	mov    0x20(%ebx),%edi
  802c39:	83 ec 0c             	sub    $0xc,%esp
  802c3c:	ff 73 04             	pushl  0x4(%ebx)
  802c3f:	e8 3e 4c 00 00       	call   807882 <htonl>
  802c44:	89 47 04             	mov    %eax,0x4(%edi)
  dhcp->msg_out->secs = 0;
  802c47:	8b 43 20             	mov    0x20(%ebx),%eax
  802c4a:	66 c7 40 08 00 00    	movw   $0x0,0x8(%eax)
  dhcp->msg_out->flags = 0;
  802c50:	8b 43 20             	mov    0x20(%ebx),%eax
  802c53:	66 c7 40 0a 00 00    	movw   $0x0,0xa(%eax)
  dhcp->msg_out->ciaddr.addr = netif->ip_addr.addr;
  802c59:	8b 43 20             	mov    0x20(%ebx),%eax
  802c5c:	8b 56 04             	mov    0x4(%esi),%edx
  802c5f:	89 50 0c             	mov    %edx,0xc(%eax)
  dhcp->msg_out->yiaddr.addr = 0;
  802c62:	8b 43 20             	mov    0x20(%ebx),%eax
  802c65:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  dhcp->msg_out->siaddr.addr = 0;
  802c6c:	8b 43 20             	mov    0x20(%ebx),%eax
  802c6f:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
  dhcp->msg_out->giaddr.addr = 0;
  802c76:	8b 43 20             	mov    0x20(%ebx),%eax
  802c79:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
  802c80:	83 c4 10             	add    $0x10,%esp
  802c83:	b8 00 00 00 00       	mov    $0x0,%eax
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  802c88:	bf 00 00 00 00       	mov    $0x0,%edi
  802c8d:	e9 82 00 00 00       	jmp    802d14 <dhcp_create_request+0x16b>
  LWIP_ERROR("dhcp_create_request: netif != NULL", (netif != NULL), return ERR_ARG;);
  802c92:	83 ec 04             	sub    $0x4,%esp
  802c95:	68 4c 18 81 00       	push   $0x81184c
  802c9a:	68 2d 05 00 00       	push   $0x52d
  802c9f:	68 02 1a 81 00       	push   $0x811a02
  802ca4:	e8 9e bb 00 00       	call   80e847 <_panic>
  LWIP_ERROR("dhcp_create_request: dhcp != NULL", (dhcp != NULL), return ERR_VAL;);
  802ca9:	83 ec 04             	sub    $0x4,%esp
  802cac:	68 70 18 81 00       	push   $0x811870
  802cb1:	68 2f 05 00 00       	push   $0x52f
  802cb6:	68 02 1a 81 00       	push   $0x811a02
  802cbb:	e8 87 bb 00 00       	call   80e847 <_panic>
  LWIP_ASSERT("dhcp_create_request: dhcp->p_out == NULL", dhcp->p_out == NULL);
  802cc0:	83 ec 04             	sub    $0x4,%esp
  802cc3:	68 94 18 81 00       	push   $0x811894
  802cc8:	68 30 05 00 00       	push   $0x530
  802ccd:	68 02 1a 81 00       	push   $0x811a02
  802cd2:	e8 70 bb 00 00       	call   80e847 <_panic>
  LWIP_ASSERT("dhcp_create_request: dhcp->msg_out == NULL", dhcp->msg_out == NULL);
  802cd7:	83 ec 04             	sub    $0x4,%esp
  802cda:	68 c0 18 81 00       	push   $0x8118c0
  802cdf:	68 31 05 00 00       	push   $0x531
  802ce4:	68 02 1a 81 00       	push   $0x811a02
  802ce9:	e8 59 bb 00 00       	call   80e847 <_panic>
  LWIP_ASSERT("dhcp_create_request: check that first pbuf can hold struct dhcp_msg",
  802cee:	83 ec 04             	sub    $0x4,%esp
  802cf1:	68 ec 18 81 00       	push   $0x8118ec
  802cf6:	68 37 05 00 00       	push   $0x537
  802cfb:	68 02 1a 81 00       	push   $0x811a02
  802d00:	e8 42 bb 00 00       	call   80e847 <_panic>
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  802d05:	8b 4b 20             	mov    0x20(%ebx),%ecx
  802d08:	88 54 01 1c          	mov    %dl,0x1c(%ecx,%eax,1)
  802d0c:	83 c0 01             	add    $0x1,%eax
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
  802d0f:	83 f8 10             	cmp    $0x10,%eax
  802d12:	74 12                	je     802d26 <dhcp_create_request+0x17d>
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  802d14:	0f b6 4e 24          	movzbl 0x24(%esi),%ecx
  802d18:	89 fa                	mov    %edi,%edx
  802d1a:	66 39 c1             	cmp    %ax,%cx
  802d1d:	76 e6                	jbe    802d05 <dhcp_create_request+0x15c>
  802d1f:	0f b6 54 06 25       	movzbl 0x25(%esi,%eax,1),%edx
  802d24:	eb df                	jmp    802d05 <dhcp_create_request+0x15c>
  802d26:	b8 00 00 00 00       	mov    $0x0,%eax
    dhcp->msg_out->sname[i] = 0;
  802d2b:	8b 53 20             	mov    0x20(%ebx),%edx
  802d2e:	c6 44 02 2c 00       	movb   $0x0,0x2c(%edx,%eax,1)
  802d33:	83 c0 01             	add    $0x1,%eax
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
  802d36:	83 f8 40             	cmp    $0x40,%eax
  802d39:	75 f0                	jne    802d2b <dhcp_create_request+0x182>
  802d3b:	b8 00 00 00 00       	mov    $0x0,%eax
    dhcp->msg_out->file[i] = 0;
  802d40:	8b 53 20             	mov    0x20(%ebx),%edx
  802d43:	c6 44 02 6c 00       	movb   $0x0,0x6c(%edx,%eax,1)
  802d48:	83 c0 01             	add    $0x1,%eax
  for (i = 0; i < DHCP_FILE_LEN; i++) {
  802d4b:	3d 80 00 00 00       	cmp    $0x80,%eax
  802d50:	75 ee                	jne    802d40 <dhcp_create_request+0x197>
  dhcp->msg_out->cookie = htonl(0x63825363UL);
  802d52:	8b 73 20             	mov    0x20(%ebx),%esi
  802d55:	83 ec 0c             	sub    $0xc,%esp
  802d58:	68 63 53 82 63       	push   $0x63825363
  802d5d:	e8 20 4b 00 00       	call   807882 <htonl>
  802d62:	89 86 ec 00 00 00    	mov    %eax,0xec(%esi)
  dhcp->options_out_len = 0;
  802d68:	66 c7 43 24 00 00    	movw   $0x0,0x24(%ebx)
  802d6e:	83 c4 10             	add    $0x10,%esp
  802d71:	b8 00 00 00 00       	mov    $0x0,%eax
    dhcp->msg_out->options[i] = (u8_t)i; /* for debugging only, no matter if truncated */
  802d76:	8b 53 20             	mov    0x20(%ebx),%edx
  802d79:	88 84 02 f0 00 00 00 	mov    %al,0xf0(%edx,%eax,1)
  802d80:	83 c0 01             	add    $0x1,%eax
  for (i = 0; i < DHCP_OPTIONS_LEN; i++) {
  802d83:	83 f8 44             	cmp    $0x44,%eax
  802d86:	75 ee                	jne    802d76 <dhcp_create_request+0x1cd>
  return ERR_OK;
  802d88:	b8 00 00 00 00       	mov    $0x0,%eax
}
  802d8d:	8d 65 f4             	lea    -0xc(%ebp),%esp
  802d90:	5b                   	pop    %ebx
  802d91:	5e                   	pop    %esi
  802d92:	5f                   	pop    %edi
  802d93:	5d                   	pop    %ebp
  802d94:	c3                   	ret    
    return ERR_MEM;
  802d95:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  802d9a:	eb f1                	jmp    802d8d <dhcp_create_request+0x1e4>

00802d9c <dhcp_delete_request>:
{
  802d9c:	55                   	push   %ebp
  802d9d:	89 e5                	mov    %esp,%ebp
  802d9f:	53                   	push   %ebx
  802da0:	83 ec 04             	sub    $0x4,%esp
  LWIP_ERROR("dhcp_delete_request: netif != NULL", (netif != NULL), return;);
  802da3:	85 c0                	test   %eax,%eax
  802da5:	74 33                	je     802dda <dhcp_delete_request+0x3e>
  dhcp = netif->dhcp;
  802da7:	8b 58 20             	mov    0x20(%eax),%ebx
  LWIP_ERROR("dhcp_delete_request: dhcp != NULL", (dhcp != NULL), return;);
  802daa:	85 db                	test   %ebx,%ebx
  802dac:	74 43                	je     802df1 <dhcp_delete_request+0x55>
  LWIP_ASSERT("dhcp_delete_request: dhcp->p_out != NULL", dhcp->p_out != NULL);
  802dae:	8b 43 1c             	mov    0x1c(%ebx),%eax
  802db1:	85 c0                	test   %eax,%eax
  802db3:	74 53                	je     802e08 <dhcp_delete_request+0x6c>
  LWIP_ASSERT("dhcp_delete_request: dhcp->msg_out != NULL", dhcp->msg_out != NULL);
  802db5:	83 7b 20 00          	cmpl   $0x0,0x20(%ebx)
  802db9:	74 64                	je     802e1f <dhcp_delete_request+0x83>
    pbuf_free(dhcp->p_out);
  802dbb:	83 ec 0c             	sub    $0xc,%esp
  802dbe:	50                   	push   %eax
  802dbf:	e8 64 1b 00 00       	call   804928 <pbuf_free>
  dhcp->p_out = NULL;
  802dc4:	c7 43 1c 00 00 00 00 	movl   $0x0,0x1c(%ebx)
  dhcp->msg_out = NULL;
  802dcb:	c7 43 20 00 00 00 00 	movl   $0x0,0x20(%ebx)
  802dd2:	83 c4 10             	add    $0x10,%esp
}
  802dd5:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  802dd8:	c9                   	leave  
  802dd9:	c3                   	ret    
  LWIP_ERROR("dhcp_delete_request: netif != NULL", (netif != NULL), return;);
  802dda:	83 ec 04             	sub    $0x4,%esp
  802ddd:	68 30 19 81 00       	push   $0x811930
  802de2:	68 69 05 00 00       	push   $0x569
  802de7:	68 02 1a 81 00       	push   $0x811a02
  802dec:	e8 56 ba 00 00       	call   80e847 <_panic>
  LWIP_ERROR("dhcp_delete_request: dhcp != NULL", (dhcp != NULL), return;);
  802df1:	83 ec 04             	sub    $0x4,%esp
  802df4:	68 54 19 81 00       	push   $0x811954
  802df9:	68 6b 05 00 00       	push   $0x56b
  802dfe:	68 02 1a 81 00       	push   $0x811a02
  802e03:	e8 3f ba 00 00       	call   80e847 <_panic>
  LWIP_ASSERT("dhcp_delete_request: dhcp->p_out != NULL", dhcp->p_out != NULL);
  802e08:	83 ec 04             	sub    $0x4,%esp
  802e0b:	68 78 19 81 00       	push   $0x811978
  802e10:	68 6c 05 00 00       	push   $0x56c
  802e15:	68 02 1a 81 00       	push   $0x811a02
  802e1a:	e8 28 ba 00 00       	call   80e847 <_panic>
  LWIP_ASSERT("dhcp_delete_request: dhcp->msg_out != NULL", dhcp->msg_out != NULL);
  802e1f:	83 ec 04             	sub    $0x4,%esp
  802e22:	68 a4 19 81 00       	push   $0x8119a4
  802e27:	68 6d 05 00 00       	push   $0x56d
  802e2c:	68 02 1a 81 00       	push   $0x811a02
  802e31:	e8 11 ba 00 00       	call   80e847 <_panic>

00802e36 <dhcp_rebind>:
{
  802e36:	55                   	push   %ebp
  802e37:	89 e5                	mov    %esp,%ebp
  802e39:	57                   	push   %edi
  802e3a:	56                   	push   %esi
  802e3b:	53                   	push   %ebx
  802e3c:	83 ec 0c             	sub    $0xc,%esp
  802e3f:	89 c7                	mov    %eax,%edi
  struct dhcp *dhcp = netif->dhcp;
  802e41:	8b 58 20             	mov    0x20(%eax),%ebx
  dhcp_set_state(dhcp, DHCP_REBINDING);
  802e44:	ba 04 00 00 00       	mov    $0x4,%edx
  802e49:	89 d8                	mov    %ebx,%eax
  802e4b:	e8 cc f9 ff ff       	call   80281c <dhcp_set_state>
  result = dhcp_create_request(netif);
  802e50:	89 f8                	mov    %edi,%eax
  802e52:	e8 52 fd ff ff       	call   802ba9 <dhcp_create_request>
  802e57:	89 c6                	mov    %eax,%esi
  if (result == ERR_OK) {
  802e59:	84 c0                	test   %al,%al
  802e5b:	74 3e                	je     802e9b <dhcp_rebind+0x65>
  dhcp->tries++;
  802e5d:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
  802e61:	83 c0 01             	add    $0x1,%eax
  802e64:	88 43 01             	mov    %al,0x1(%ebx)
  msecs = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
  802e67:	ba 10 27 00 00       	mov    $0x2710,%edx
  802e6c:	3c 09                	cmp    $0x9,%al
  802e6e:	77 08                	ja     802e78 <dhcp_rebind+0x42>
  802e70:	0f b6 d0             	movzbl %al,%edx
  802e73:	66 69 d2 e8 03       	imul   $0x3e8,%dx,%dx
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  802e78:	0f b7 d2             	movzwl %dx,%edx
  802e7b:	81 c2 f3 01 00 00    	add    $0x1f3,%edx
  802e81:	b9 d3 4d 62 10       	mov    $0x10624dd3,%ecx
  802e86:	89 d0                	mov    %edx,%eax
  802e88:	f7 e9                	imul   %ecx
  802e8a:	c1 fa 05             	sar    $0x5,%edx
  802e8d:	66 89 53 26          	mov    %dx,0x26(%ebx)
}
  802e91:	89 f0                	mov    %esi,%eax
  802e93:	8d 65 f4             	lea    -0xc(%ebp),%esp
  802e96:	5b                   	pop    %ebx
  802e97:	5e                   	pop    %esi
  802e98:	5f                   	pop    %edi
  802e99:	5d                   	pop    %ebp
  802e9a:	c3                   	ret    
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  802e9b:	b9 01 00 00 00       	mov    $0x1,%ecx
  802ea0:	ba 35 00 00 00       	mov    $0x35,%edx
  802ea5:	89 d8                	mov    %ebx,%eax
  802ea7:	e8 eb fa ff ff       	call   802997 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_REQUEST);
  802eac:	ba 03 00 00 00       	mov    $0x3,%edx
  802eb1:	89 d8                	mov    %ebx,%eax
  802eb3:	e8 9e fa ff ff       	call   802956 <dhcp_option_byte>
    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  802eb8:	b9 02 00 00 00       	mov    $0x2,%ecx
  802ebd:	ba 39 00 00 00       	mov    $0x39,%edx
  802ec2:	89 d8                	mov    %ebx,%eax
  802ec4:	e8 ce fa ff ff       	call   802997 <dhcp_option>
    dhcp_option_short(dhcp, 576);
  802ec9:	ba 40 02 00 00       	mov    $0x240,%edx
  802ece:	89 d8                	mov    %ebx,%eax
  802ed0:	e8 29 fb ff ff       	call   8029fe <dhcp_option_short>
    dhcp_option_trailer(dhcp);
  802ed5:	89 d8                	mov    %ebx,%eax
  802ed7:	e8 80 fb ff ff       	call   802a5c <dhcp_option_trailer>
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  802edc:	83 ec 08             	sub    $0x8,%esp
  802edf:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  802ee3:	66 05 f0 00          	add    $0xf0,%ax
  802ee7:	0f b7 c0             	movzwl %ax,%eax
  802eea:	50                   	push   %eax
  802eeb:	ff 73 1c             	pushl  0x1c(%ebx)
  802eee:	e8 5e 1d 00 00       	call   804c51 <pbuf_realloc>
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  802ef3:	83 c4 0c             	add    $0xc,%esp
  802ef6:	6a 43                	push   $0x43
  802ef8:	68 a8 22 81 00       	push   $0x8122a8
  802efd:	ff 73 08             	pushl  0x8(%ebx)
  802f00:	e8 c0 61 00 00       	call   8090c5 <udp_connect>
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  802f05:	89 3c 24             	mov    %edi,(%esp)
  802f08:	6a 43                	push   $0x43
  802f0a:	68 a4 22 81 00       	push   $0x8122a4
  802f0f:	ff 73 1c             	pushl  0x1c(%ebx)
  802f12:	ff 73 08             	pushl  0x8(%ebx)
  802f15:	e8 aa 5f 00 00       	call   808ec4 <udp_sendto_if>
    dhcp_delete_request(netif);
  802f1a:	83 c4 20             	add    $0x20,%esp
  802f1d:	89 f8                	mov    %edi,%eax
  802f1f:	e8 78 fe ff ff       	call   802d9c <dhcp_delete_request>
  802f24:	e9 34 ff ff ff       	jmp    802e5d <dhcp_rebind+0x27>

00802f29 <dhcp_discover>:
{
  802f29:	55                   	push   %ebp
  802f2a:	89 e5                	mov    %esp,%ebp
  802f2c:	57                   	push   %edi
  802f2d:	56                   	push   %esi
  802f2e:	53                   	push   %ebx
  802f2f:	83 ec 0c             	sub    $0xc,%esp
  802f32:	89 c7                	mov    %eax,%edi
  struct dhcp *dhcp = netif->dhcp;
  802f34:	8b 58 20             	mov    0x20(%eax),%ebx
  ip_addr_set(&dhcp->offered_ip_addr, IP_ADDR_ANY);
  802f37:	a1 a8 22 81 00       	mov    0x8122a8,%eax
  802f3c:	89 43 30             	mov    %eax,0x30(%ebx)
  result = dhcp_create_request(netif);
  802f3f:	89 f8                	mov    %edi,%eax
  802f41:	e8 63 fc ff ff       	call   802ba9 <dhcp_create_request>
  802f46:	89 c6                	mov    %eax,%esi
  if (result == ERR_OK) {
  802f48:	84 c0                	test   %al,%al
  802f4a:	74 41                	je     802f8d <dhcp_discover+0x64>
  dhcp->tries++;
  802f4c:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
  802f50:	83 c0 01             	add    $0x1,%eax
  802f53:	88 43 01             	mov    %al,0x1(%ebx)
  msecs = dhcp->tries < 4 ? (dhcp->tries + 1) * 1000 : 10 * 1000;
  802f56:	ba 10 27 00 00       	mov    $0x2710,%edx
  802f5b:	3c 03                	cmp    $0x3,%al
  802f5d:	77 0b                	ja     802f6a <dhcp_discover+0x41>
  802f5f:	0f b6 d0             	movzbl %al,%edx
  802f62:	83 c2 01             	add    $0x1,%edx
  802f65:	66 69 d2 e8 03       	imul   $0x3e8,%dx,%dx
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  802f6a:	0f b7 d2             	movzwl %dx,%edx
  802f6d:	81 c2 f3 01 00 00    	add    $0x1f3,%edx
  802f73:	b9 d3 4d 62 10       	mov    $0x10624dd3,%ecx
  802f78:	89 d0                	mov    %edx,%eax
  802f7a:	f7 e9                	imul   %ecx
  802f7c:	c1 fa 05             	sar    $0x5,%edx
  802f7f:	66 89 53 26          	mov    %dx,0x26(%ebx)
}
  802f83:	89 f0                	mov    %esi,%eax
  802f85:	8d 65 f4             	lea    -0xc(%ebp),%esp
  802f88:	5b                   	pop    %ebx
  802f89:	5e                   	pop    %esi
  802f8a:	5f                   	pop    %edi
  802f8b:	5d                   	pop    %ebp
  802f8c:	c3                   	ret    
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  802f8d:	b9 01 00 00 00       	mov    $0x1,%ecx
  802f92:	ba 35 00 00 00       	mov    $0x35,%edx
  802f97:	89 d8                	mov    %ebx,%eax
  802f99:	e8 f9 f9 ff ff       	call   802997 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_DISCOVER);
  802f9e:	ba 01 00 00 00       	mov    $0x1,%edx
  802fa3:	89 d8                	mov    %ebx,%eax
  802fa5:	e8 ac f9 ff ff       	call   802956 <dhcp_option_byte>
    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  802faa:	b9 02 00 00 00       	mov    $0x2,%ecx
  802faf:	ba 39 00 00 00       	mov    $0x39,%edx
  802fb4:	89 d8                	mov    %ebx,%eax
  802fb6:	e8 dc f9 ff ff       	call   802997 <dhcp_option>
    dhcp_option_short(dhcp, 576);
  802fbb:	ba 40 02 00 00       	mov    $0x240,%edx
  802fc0:	89 d8                	mov    %ebx,%eax
  802fc2:	e8 37 fa ff ff       	call   8029fe <dhcp_option_short>
    dhcp_option(dhcp, DHCP_OPTION_PARAMETER_REQUEST_LIST, 4/*num options*/);
  802fc7:	b9 04 00 00 00       	mov    $0x4,%ecx
  802fcc:	ba 37 00 00 00       	mov    $0x37,%edx
  802fd1:	89 d8                	mov    %ebx,%eax
  802fd3:	e8 bf f9 ff ff       	call   802997 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_OPTION_SUBNET_MASK);
  802fd8:	ba 01 00 00 00       	mov    $0x1,%edx
  802fdd:	89 d8                	mov    %ebx,%eax
  802fdf:	e8 72 f9 ff ff       	call   802956 <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_ROUTER);
  802fe4:	ba 03 00 00 00       	mov    $0x3,%edx
  802fe9:	89 d8                	mov    %ebx,%eax
  802feb:	e8 66 f9 ff ff       	call   802956 <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_BROADCAST);
  802ff0:	ba 1c 00 00 00       	mov    $0x1c,%edx
  802ff5:	89 d8                	mov    %ebx,%eax
  802ff7:	e8 5a f9 ff ff       	call   802956 <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_DNS_SERVER);
  802ffc:	ba 06 00 00 00       	mov    $0x6,%edx
  803001:	89 d8                	mov    %ebx,%eax
  803003:	e8 4e f9 ff ff       	call   802956 <dhcp_option_byte>
    dhcp_option_trailer(dhcp);
  803008:	89 d8                	mov    %ebx,%eax
  80300a:	e8 4d fa ff ff       	call   802a5c <dhcp_option_trailer>
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  80300f:	83 ec 08             	sub    $0x8,%esp
  803012:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  803016:	66 05 f0 00          	add    $0xf0,%ax
  80301a:	0f b7 c0             	movzwl %ax,%eax
  80301d:	50                   	push   %eax
  80301e:	ff 73 1c             	pushl  0x1c(%ebx)
  803021:	e8 2b 1c 00 00       	call   804c51 <pbuf_realloc>
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  803026:	83 c4 0c             	add    $0xc,%esp
  803029:	6a 43                	push   $0x43
  80302b:	68 a8 22 81 00       	push   $0x8122a8
  803030:	ff 73 08             	pushl  0x8(%ebx)
  803033:	e8 8d 60 00 00       	call   8090c5 <udp_connect>
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  803038:	89 3c 24             	mov    %edi,(%esp)
  80303b:	6a 43                	push   $0x43
  80303d:	68 a4 22 81 00       	push   $0x8122a4
  803042:	ff 73 1c             	pushl  0x1c(%ebx)
  803045:	ff 73 08             	pushl  0x8(%ebx)
  803048:	e8 77 5e 00 00       	call   808ec4 <udp_sendto_if>
    dhcp_delete_request(netif);
  80304d:	83 c4 20             	add    $0x20,%esp
  803050:	89 f8                	mov    %edi,%eax
  803052:	e8 45 fd ff ff       	call   802d9c <dhcp_delete_request>
    dhcp_set_state(dhcp, DHCP_SELECTING);
  803057:	ba 06 00 00 00       	mov    $0x6,%edx
  80305c:	89 d8                	mov    %ebx,%eax
  80305e:	e8 b9 f7 ff ff       	call   80281c <dhcp_set_state>
  803063:	e9 e4 fe ff ff       	jmp    802f4c <dhcp_discover+0x23>

00803068 <dhcp_select>:
{
  803068:	55                   	push   %ebp
  803069:	89 e5                	mov    %esp,%ebp
  80306b:	57                   	push   %edi
  80306c:	56                   	push   %esi
  80306d:	53                   	push   %ebx
  80306e:	83 ec 0c             	sub    $0xc,%esp
  803071:	89 c7                	mov    %eax,%edi
  struct dhcp *dhcp = netif->dhcp;
  803073:	8b 58 20             	mov    0x20(%eax),%ebx
  result = dhcp_create_request(netif);
  803076:	e8 2e fb ff ff       	call   802ba9 <dhcp_create_request>
  80307b:	89 c6                	mov    %eax,%esi
  if (result == ERR_OK) {
  80307d:	84 c0                	test   %al,%al
  80307f:	74 3e                	je     8030bf <dhcp_select+0x57>
  dhcp->tries++;
  803081:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
  803085:	83 c0 01             	add    $0x1,%eax
  803088:	88 43 01             	mov    %al,0x1(%ebx)
  msecs = dhcp->tries < 4 ? dhcp->tries * 1000 : 4 * 1000;
  80308b:	ba a0 0f 00 00       	mov    $0xfa0,%edx
  803090:	3c 03                	cmp    $0x3,%al
  803092:	77 08                	ja     80309c <dhcp_select+0x34>
  803094:	0f b6 d0             	movzbl %al,%edx
  803097:	66 69 d2 e8 03       	imul   $0x3e8,%dx,%dx
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  80309c:	0f b7 d2             	movzwl %dx,%edx
  80309f:	81 c2 f3 01 00 00    	add    $0x1f3,%edx
  8030a5:	b9 d3 4d 62 10       	mov    $0x10624dd3,%ecx
  8030aa:	89 d0                	mov    %edx,%eax
  8030ac:	f7 e9                	imul   %ecx
  8030ae:	c1 fa 05             	sar    $0x5,%edx
  8030b1:	66 89 53 26          	mov    %dx,0x26(%ebx)
}
  8030b5:	89 f0                	mov    %esi,%eax
  8030b7:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8030ba:	5b                   	pop    %ebx
  8030bb:	5e                   	pop    %esi
  8030bc:	5f                   	pop    %edi
  8030bd:	5d                   	pop    %ebp
  8030be:	c3                   	ret    
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  8030bf:	b9 01 00 00 00       	mov    $0x1,%ecx
  8030c4:	ba 35 00 00 00       	mov    $0x35,%edx
  8030c9:	89 d8                	mov    %ebx,%eax
  8030cb:	e8 c7 f8 ff ff       	call   802997 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_REQUEST);
  8030d0:	ba 03 00 00 00       	mov    $0x3,%edx
  8030d5:	89 d8                	mov    %ebx,%eax
  8030d7:	e8 7a f8 ff ff       	call   802956 <dhcp_option_byte>
    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  8030dc:	b9 02 00 00 00       	mov    $0x2,%ecx
  8030e1:	ba 39 00 00 00       	mov    $0x39,%edx
  8030e6:	89 d8                	mov    %ebx,%eax
  8030e8:	e8 aa f8 ff ff       	call   802997 <dhcp_option>
    dhcp_option_short(dhcp, 576);
  8030ed:	ba 40 02 00 00       	mov    $0x240,%edx
  8030f2:	89 d8                	mov    %ebx,%eax
  8030f4:	e8 05 f9 ff ff       	call   8029fe <dhcp_option_short>
    dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
  8030f9:	b9 04 00 00 00       	mov    $0x4,%ecx
  8030fe:	ba 32 00 00 00       	mov    $0x32,%edx
  803103:	89 d8                	mov    %ebx,%eax
  803105:	e8 8d f8 ff ff       	call   802997 <dhcp_option>
    dhcp_option_long(dhcp, ntohl(dhcp->offered_ip_addr.addr));
  80310a:	83 ec 0c             	sub    $0xc,%esp
  80310d:	ff 73 30             	pushl  0x30(%ebx)
  803110:	e8 9a 49 00 00       	call   807aaf <ntohl>
  803115:	89 c2                	mov    %eax,%edx
  803117:	89 d8                	mov    %ebx,%eax
  803119:	e8 f3 f9 ff ff       	call   802b11 <dhcp_option_long>
    dhcp_option(dhcp, DHCP_OPTION_SERVER_ID, 4);
  80311e:	b9 04 00 00 00       	mov    $0x4,%ecx
  803123:	ba 36 00 00 00       	mov    $0x36,%edx
  803128:	89 d8                	mov    %ebx,%eax
  80312a:	e8 68 f8 ff ff       	call   802997 <dhcp_option>
    dhcp_option_long(dhcp, ntohl(dhcp->server_ip_addr.addr));
  80312f:	83 c4 04             	add    $0x4,%esp
  803132:	ff 73 2c             	pushl  0x2c(%ebx)
  803135:	e8 75 49 00 00       	call   807aaf <ntohl>
  80313a:	89 c2                	mov    %eax,%edx
  80313c:	89 d8                	mov    %ebx,%eax
  80313e:	e8 ce f9 ff ff       	call   802b11 <dhcp_option_long>
    dhcp_option(dhcp, DHCP_OPTION_PARAMETER_REQUEST_LIST, 4/*num options*/);
  803143:	b9 04 00 00 00       	mov    $0x4,%ecx
  803148:	ba 37 00 00 00       	mov    $0x37,%edx
  80314d:	89 d8                	mov    %ebx,%eax
  80314f:	e8 43 f8 ff ff       	call   802997 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_OPTION_SUBNET_MASK);
  803154:	ba 01 00 00 00       	mov    $0x1,%edx
  803159:	89 d8                	mov    %ebx,%eax
  80315b:	e8 f6 f7 ff ff       	call   802956 <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_ROUTER);
  803160:	ba 03 00 00 00       	mov    $0x3,%edx
  803165:	89 d8                	mov    %ebx,%eax
  803167:	e8 ea f7 ff ff       	call   802956 <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_BROADCAST);
  80316c:	ba 1c 00 00 00       	mov    $0x1c,%edx
  803171:	89 d8                	mov    %ebx,%eax
  803173:	e8 de f7 ff ff       	call   802956 <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_DNS_SERVER);
  803178:	ba 06 00 00 00       	mov    $0x6,%edx
  80317d:	89 d8                	mov    %ebx,%eax
  80317f:	e8 d2 f7 ff ff       	call   802956 <dhcp_option_byte>
    dhcp_option_trailer(dhcp);
  803184:	89 d8                	mov    %ebx,%eax
  803186:	e8 d1 f8 ff ff       	call   802a5c <dhcp_option_trailer>
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  80318b:	83 c4 08             	add    $0x8,%esp
  80318e:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  803192:	66 05 f0 00          	add    $0xf0,%ax
  803196:	0f b7 c0             	movzwl %ax,%eax
  803199:	50                   	push   %eax
  80319a:	ff 73 1c             	pushl  0x1c(%ebx)
  80319d:	e8 af 1a 00 00       	call   804c51 <pbuf_realloc>
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  8031a2:	89 3c 24             	mov    %edi,(%esp)
  8031a5:	6a 43                	push   $0x43
  8031a7:	68 a4 22 81 00       	push   $0x8122a4
  8031ac:	ff 73 1c             	pushl  0x1c(%ebx)
  8031af:	ff 73 08             	pushl  0x8(%ebx)
  8031b2:	e8 0d 5d 00 00       	call   808ec4 <udp_sendto_if>
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  8031b7:	83 c4 1c             	add    $0x1c,%esp
  8031ba:	6a 43                	push   $0x43
  8031bc:	68 a8 22 81 00       	push   $0x8122a8
  8031c1:	ff 73 08             	pushl  0x8(%ebx)
  8031c4:	e8 fc 5e 00 00       	call   8090c5 <udp_connect>
    dhcp_delete_request(netif);
  8031c9:	89 f8                	mov    %edi,%eax
  8031cb:	e8 cc fb ff ff       	call   802d9c <dhcp_delete_request>
    dhcp_set_state(dhcp, DHCP_REQUESTING);
  8031d0:	ba 01 00 00 00       	mov    $0x1,%edx
  8031d5:	89 d8                	mov    %ebx,%eax
  8031d7:	e8 40 f6 ff ff       	call   80281c <dhcp_set_state>
  8031dc:	83 c4 10             	add    $0x10,%esp
  8031df:	e9 9d fe ff ff       	jmp    803081 <dhcp_select+0x19>

008031e4 <dhcp_check>:
{
  8031e4:	55                   	push   %ebp
  8031e5:	89 e5                	mov    %esp,%ebp
  8031e7:	53                   	push   %ebx
  8031e8:	83 ec 08             	sub    $0x8,%esp
  struct dhcp *dhcp = netif->dhcp;
  8031eb:	8b 58 20             	mov    0x20(%eax),%ebx
  result = etharp_query(netif, &dhcp->offered_ip_addr, NULL);
  8031ee:	6a 00                	push   $0x0
  8031f0:	8d 53 30             	lea    0x30(%ebx),%edx
  8031f3:	52                   	push   %edx
  8031f4:	50                   	push   %eax
  8031f5:	e8 cc 68 00 00       	call   809ac6 <etharp_query>
  dhcp->tries++;
  8031fa:	80 43 01 01          	addb   $0x1,0x1(%ebx)
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  8031fe:	66 c7 43 26 01 00    	movw   $0x1,0x26(%ebx)
  dhcp_set_state(dhcp, DHCP_CHECKING);
  803204:	ba 08 00 00 00       	mov    $0x8,%edx
  803209:	89 d8                	mov    %ebx,%eax
  80320b:	e8 0c f6 ff ff       	call   80281c <dhcp_set_state>
}
  803210:	83 c4 10             	add    $0x10,%esp
  803213:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  803216:	c9                   	leave  
  803217:	c3                   	ret    

00803218 <dhcp_bind>:
{
  803218:	55                   	push   %ebp
  803219:	89 e5                	mov    %esp,%ebp
  80321b:	56                   	push   %esi
  80321c:	53                   	push   %ebx
  80321d:	83 ec 10             	sub    $0x10,%esp
  LWIP_ERROR("dhcp_bind: netif != NULL", (netif != NULL), return;);
  803220:	85 c0                	test   %eax,%eax
  803222:	0f 84 d9 00 00 00    	je     803301 <dhcp_bind+0xe9>
  803228:	89 c6                	mov    %eax,%esi
  dhcp = netif->dhcp;
  80322a:	8b 58 20             	mov    0x20(%eax),%ebx
  LWIP_ERROR("dhcp_bind: dhcp != NULL", (dhcp != NULL), return;);
  80322d:	85 db                	test   %ebx,%ebx
  80322f:	0f 84 e3 00 00 00    	je     803318 <dhcp_bind+0x100>
  if (dhcp->offered_t1_renew != 0xffffffffUL) {
  803235:	8b 53 50             	mov    0x50(%ebx),%edx
  803238:	83 fa ff             	cmp    $0xffffffff,%edx
  80323b:	74 2f                	je     80326c <dhcp_bind+0x54>
    timeout = (dhcp->offered_t1_renew + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
  80323d:	83 c2 1e             	add    $0x1e,%edx
    if(timeout > 0xffff) {
  803240:	81 fa ff ff 3b 00    	cmp    $0x3bffff,%edx
  803246:	0f 87 7e 01 00 00    	ja     8033ca <dhcp_bind+0x1b2>
    timeout = (dhcp->offered_t1_renew + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
  80324c:	b9 89 88 88 88       	mov    $0x88888889,%ecx
  803251:	89 d0                	mov    %edx,%eax
  803253:	f7 e1                	mul    %ecx
  803255:	89 d0                	mov    %edx,%eax
  803257:	c1 e8 05             	shr    $0x5,%eax
    if (dhcp->t1_timeout == 0) {
  80325a:	f7 c2 e0 ff 1f 00    	test   $0x1fffe0,%edx
  803260:	0f 85 c9 00 00 00    	jne    80332f <dhcp_bind+0x117>
      dhcp->t1_timeout = 1;
  803266:	66 c7 43 28 01 00    	movw   $0x1,0x28(%ebx)
  if (dhcp->offered_t2_rebind != 0xffffffffUL) {
  80326c:	8b 53 54             	mov    0x54(%ebx),%edx
  80326f:	83 fa ff             	cmp    $0xffffffff,%edx
  803272:	74 2f                	je     8032a3 <dhcp_bind+0x8b>
    timeout = (dhcp->offered_t2_rebind + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
  803274:	83 c2 1e             	add    $0x1e,%edx
    if(timeout > 0xffff) {
  803277:	81 fa ff ff 3b 00    	cmp    $0x3bffff,%edx
  80327d:	0f 87 3c 01 00 00    	ja     8033bf <dhcp_bind+0x1a7>
    timeout = (dhcp->offered_t2_rebind + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
  803283:	b9 89 88 88 88       	mov    $0x88888889,%ecx
  803288:	89 d0                	mov    %edx,%eax
  80328a:	f7 e1                	mul    %ecx
  80328c:	89 d0                	mov    %edx,%eax
  80328e:	c1 e8 05             	shr    $0x5,%eax
    if (dhcp->t2_timeout == 0) {
  803291:	f7 c2 e0 ff 1f 00    	test   $0x1fffe0,%edx
  803297:	0f 85 9b 00 00 00    	jne    803338 <dhcp_bind+0x120>
      dhcp->t2_timeout = 1;
  80329d:	66 c7 43 2a 01 00    	movw   $0x1,0x2a(%ebx)
  ip_addr_set(&sn_mask, &dhcp->offered_sn_mask);
  8032a3:	8b 43 34             	mov    0x34(%ebx),%eax
  8032a6:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (sn_mask.addr == 0) {
  8032a9:	85 c0                	test   %eax,%eax
  8032ab:	0f 84 90 00 00 00    	je     803341 <dhcp_bind+0x129>
  ip_addr_set(&gw_addr, &dhcp->offered_gw_addr);
  8032b1:	8b 43 38             	mov    0x38(%ebx),%eax
  8032b4:	89 45 f0             	mov    %eax,-0x10(%ebp)
  if (gw_addr.addr == 0) {
  8032b7:	85 c0                	test   %eax,%eax
  8032b9:	0f 84 e2 00 00 00    	je     8033a1 <dhcp_bind+0x189>
  netif_set_ipaddr(netif, &dhcp->offered_ip_addr);
  8032bf:	83 ec 08             	sub    $0x8,%esp
  8032c2:	8d 43 30             	lea    0x30(%ebx),%eax
  8032c5:	50                   	push   %eax
  8032c6:	56                   	push   %esi
  8032c7:	e8 a2 13 00 00       	call   80466e <netif_set_ipaddr>
  netif_set_netmask(netif, &sn_mask);
  8032cc:	83 c4 08             	add    $0x8,%esp
  8032cf:	8d 45 f4             	lea    -0xc(%ebp),%eax
  8032d2:	50                   	push   %eax
  8032d3:	56                   	push   %esi
  8032d4:	e8 ea 14 00 00       	call   8047c3 <netif_set_netmask>
  netif_set_gw(netif, &gw_addr);
  8032d9:	83 c4 08             	add    $0x8,%esp
  8032dc:	8d 45 f0             	lea    -0x10(%ebp),%eax
  8032df:	50                   	push   %eax
  8032e0:	56                   	push   %esi
  8032e1:	e8 c0 14 00 00       	call   8047a6 <netif_set_gw>
  netif_set_up(netif);
  8032e6:	89 34 24             	mov    %esi,(%esp)
  8032e9:	e8 03 15 00 00       	call   8047f1 <netif_set_up>
  dhcp_set_state(dhcp, DHCP_BOUND);
  8032ee:	ba 0a 00 00 00       	mov    $0xa,%edx
  8032f3:	89 d8                	mov    %ebx,%eax
  8032f5:	e8 22 f5 ff ff       	call   80281c <dhcp_set_state>
}
  8032fa:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8032fd:	5b                   	pop    %ebx
  8032fe:	5e                   	pop    %esi
  8032ff:	5d                   	pop    %ebp
  803300:	c3                   	ret    
  LWIP_ERROR("dhcp_bind: netif != NULL", (netif != NULL), return;);
  803301:	83 ec 04             	sub    $0x4,%esp
  803304:	68 17 1a 81 00       	push   $0x811a17
  803309:	68 3d 03 00 00       	push   $0x33d
  80330e:	68 02 1a 81 00       	push   $0x811a02
  803313:	e8 2f b5 00 00       	call   80e847 <_panic>
  LWIP_ERROR("dhcp_bind: dhcp != NULL", (dhcp != NULL), return;);
  803318:	83 ec 04             	sub    $0x4,%esp
  80331b:	68 30 1a 81 00       	push   $0x811a30
  803320:	68 3f 03 00 00       	push   $0x33f
  803325:	68 02 1a 81 00       	push   $0x811a02
  80332a:	e8 18 b5 00 00       	call   80e847 <_panic>
    dhcp->t1_timeout = (u16_t)timeout;
  80332f:	66 89 43 28          	mov    %ax,0x28(%ebx)
  803333:	e9 34 ff ff ff       	jmp    80326c <dhcp_bind+0x54>
    dhcp->t2_timeout = (u16_t)timeout;
  803338:	66 89 43 2a          	mov    %ax,0x2a(%ebx)
  80333c:	e9 62 ff ff ff       	jmp    8032a3 <dhcp_bind+0x8b>
    u8_t first_octet = ip4_addr1(&sn_mask);
  803341:	83 ec 0c             	sub    $0xc,%esp
  803344:	6a 00                	push   $0x0
  803346:	e8 64 47 00 00       	call   807aaf <ntohl>
  80334b:	c1 e8 18             	shr    $0x18,%eax
    if (first_octet <= 127) {
  80334e:	83 c4 10             	add    $0x10,%esp
  803351:	84 c0                	test   %al,%al
  803353:	79 1c                	jns    803371 <dhcp_bind+0x159>
    } else if (first_octet >= 192) {
  803355:	3c bf                	cmp    $0xbf,%al
  803357:	76 30                	jbe    803389 <dhcp_bind+0x171>
      sn_mask.addr = htonl(0xffffff00);
  803359:	83 ec 0c             	sub    $0xc,%esp
  80335c:	68 00 ff ff ff       	push   $0xffffff00
  803361:	e8 1c 45 00 00       	call   807882 <htonl>
  803366:	89 45 f4             	mov    %eax,-0xc(%ebp)
  803369:	83 c4 10             	add    $0x10,%esp
  80336c:	e9 40 ff ff ff       	jmp    8032b1 <dhcp_bind+0x99>
      sn_mask.addr = htonl(0xff000000);
  803371:	83 ec 0c             	sub    $0xc,%esp
  803374:	68 00 00 00 ff       	push   $0xff000000
  803379:	e8 04 45 00 00       	call   807882 <htonl>
  80337e:	89 45 f4             	mov    %eax,-0xc(%ebp)
  803381:	83 c4 10             	add    $0x10,%esp
  803384:	e9 28 ff ff ff       	jmp    8032b1 <dhcp_bind+0x99>
      sn_mask.addr = htonl(0xffff0000);
  803389:	83 ec 0c             	sub    $0xc,%esp
  80338c:	68 00 00 ff ff       	push   $0xffff0000
  803391:	e8 ec 44 00 00       	call   807882 <htonl>
  803396:	89 45 f4             	mov    %eax,-0xc(%ebp)
  803399:	83 c4 10             	add    $0x10,%esp
  80339c:	e9 10 ff ff ff       	jmp    8032b1 <dhcp_bind+0x99>
    gw_addr.addr = (dhcp->offered_ip_addr.addr & sn_mask.addr);
  8033a1:	8b 43 30             	mov    0x30(%ebx),%eax
  8033a4:	23 45 f4             	and    -0xc(%ebp),%eax
  8033a7:	89 45 f0             	mov    %eax,-0x10(%ebp)
    gw_addr.addr |= htonl(0x00000001);
  8033aa:	83 ec 0c             	sub    $0xc,%esp
  8033ad:	6a 01                	push   $0x1
  8033af:	e8 ce 44 00 00       	call   807882 <htonl>
  8033b4:	09 45 f0             	or     %eax,-0x10(%ebp)
  8033b7:	83 c4 10             	add    $0x10,%esp
  8033ba:	e9 00 ff ff ff       	jmp    8032bf <dhcp_bind+0xa7>
    dhcp->t2_timeout = (u16_t)timeout;
  8033bf:	66 c7 43 2a ff ff    	movw   $0xffff,0x2a(%ebx)
  8033c5:	e9 d9 fe ff ff       	jmp    8032a3 <dhcp_bind+0x8b>
    dhcp->t1_timeout = (u16_t)timeout;
  8033ca:	66 c7 43 28 ff ff    	movw   $0xffff,0x28(%ebx)
  8033d0:	e9 97 fe ff ff       	jmp    80326c <dhcp_bind+0x54>

008033d5 <dhcp_free_reply>:
{
  8033d5:	55                   	push   %ebp
  8033d6:	89 e5                	mov    %esp,%ebp
  8033d8:	53                   	push   %ebx
  8033d9:	83 ec 04             	sub    $0x4,%esp
  8033dc:	89 c3                	mov    %eax,%ebx
  if (dhcp->msg_in != NULL) {
  8033de:	8b 40 10             	mov    0x10(%eax),%eax
  8033e1:	85 c0                	test   %eax,%eax
  8033e3:	74 13                	je     8033f8 <dhcp_free_reply+0x23>
    mem_free((void *)dhcp->msg_in);
  8033e5:	83 ec 0c             	sub    $0xc,%esp
  8033e8:	50                   	push   %eax
  8033e9:	e8 05 0c 00 00       	call   803ff3 <mem_free>
    dhcp->msg_in = NULL;
  8033ee:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  8033f5:	83 c4 10             	add    $0x10,%esp
  if (dhcp->options_in) {
  8033f8:	8b 43 14             	mov    0x14(%ebx),%eax
  8033fb:	85 c0                	test   %eax,%eax
  8033fd:	74 19                	je     803418 <dhcp_free_reply+0x43>
    mem_free((void *)dhcp->options_in);
  8033ff:	83 ec 0c             	sub    $0xc,%esp
  803402:	50                   	push   %eax
  803403:	e8 eb 0b 00 00       	call   803ff3 <mem_free>
    dhcp->options_in = NULL;
  803408:	c7 43 14 00 00 00 00 	movl   $0x0,0x14(%ebx)
    dhcp->options_in_len = 0;
  80340f:	66 c7 43 18 00 00    	movw   $0x0,0x18(%ebx)
  803415:	83 c4 10             	add    $0x10,%esp
}
  803418:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80341b:	c9                   	leave  
  80341c:	c3                   	ret    

0080341d <dhcp_recv>:
{
  80341d:	f3 0f 1e fb          	endbr32 
  803421:	55                   	push   %ebp
  803422:	89 e5                	mov    %esp,%ebp
  803424:	57                   	push   %edi
  803425:	56                   	push   %esi
  803426:	53                   	push   %ebx
  803427:	83 ec 1c             	sub    $0x1c,%esp
  struct dhcp *dhcp = netif->dhcp;
  80342a:	8b 45 08             	mov    0x8(%ebp),%eax
  80342d:	8b 78 20             	mov    0x20(%eax),%edi
  struct dhcp_msg *reply_msg = (struct dhcp_msg *)p->payload;
  803430:	8b 45 10             	mov    0x10(%ebp),%eax
  803433:	8b 70 04             	mov    0x4(%eax),%esi
  803436:	89 75 e4             	mov    %esi,-0x1c(%ebp)
  dhcp->p = p;
  803439:	89 47 0c             	mov    %eax,0xc(%edi)
  if (reply_msg->op != DHCP_BOOTREPLY) {
  80343c:	80 3e 02             	cmpb   $0x2,(%esi)
  80343f:	75 26                	jne    803467 <dhcp_recv+0x4a>
  803441:	8b 45 08             	mov    0x8(%ebp),%eax
  803444:	83 c0 25             	add    $0x25,%eax
  803447:	8d 56 1c             	lea    0x1c(%esi),%edx
  80344a:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80344d:	0f b6 71 24          	movzbl 0x24(%ecx),%esi
  803451:	01 c6                	add    %eax,%esi
  for (i = 0; i < netif->hwaddr_len; i++) {
  803453:	39 f0                	cmp    %esi,%eax
  803455:	74 2a                	je     803481 <dhcp_recv+0x64>
    if (netif->hwaddr[i] != reply_msg->chaddr[i]) {
  803457:	0f b6 18             	movzbl (%eax),%ebx
  80345a:	0f b6 0a             	movzbl (%edx),%ecx
  80345d:	83 c0 01             	add    $0x1,%eax
  803460:	83 c2 01             	add    $0x1,%edx
  803463:	38 cb                	cmp    %cl,%bl
  803465:	74 ec                	je     803453 <dhcp_recv+0x36>
  pbuf_free(p);
  803467:	83 ec 0c             	sub    $0xc,%esp
  80346a:	ff 75 10             	pushl  0x10(%ebp)
  80346d:	e8 b6 14 00 00       	call   804928 <pbuf_free>
  dhcp->p = NULL;
  803472:	c7 47 0c 00 00 00 00 	movl   $0x0,0xc(%edi)
}
  803479:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80347c:	5b                   	pop    %ebx
  80347d:	5e                   	pop    %esi
  80347e:	5f                   	pop    %edi
  80347f:	5d                   	pop    %ebp
  803480:	c3                   	ret    
  if (ntohl(reply_msg->xid) != dhcp->xid) {
  803481:	83 ec 0c             	sub    $0xc,%esp
  803484:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  803487:	ff 70 04             	pushl  0x4(%eax)
  80348a:	e8 20 46 00 00       	call   807aaf <ntohl>
  80348f:	83 c4 10             	add    $0x10,%esp
  803492:	3b 47 04             	cmp    0x4(%edi),%eax
  803495:	75 d0                	jne    803467 <dhcp_recv+0x4a>
  LWIP_ERROR("dhcp->p != NULL", (dhcp->p != NULL), return ERR_VAL;);
  803497:	83 7f 0c 00          	cmpl   $0x0,0xc(%edi)
  80349b:	0f 84 17 01 00 00    	je     8035b8 <dhcp_recv+0x19b>
  dhcp_free_reply(dhcp);
  8034a1:	89 f8                	mov    %edi,%eax
  8034a3:	e8 2d ff ff ff       	call   8033d5 <dhcp_free_reply>
  if (dhcp->p->tot_len > (sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN)) {
  8034a8:	8b 47 0c             	mov    0xc(%edi),%eax
  8034ab:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  8034af:	66 3d f0 00          	cmp    $0xf0,%ax
  8034b3:	76 1e                	jbe    8034d3 <dhcp_recv+0xb6>
    dhcp->options_in_len = dhcp->p->tot_len - (sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  8034b5:	66 2d f0 00          	sub    $0xf0,%ax
  8034b9:	66 89 47 18          	mov    %ax,0x18(%edi)
    dhcp->options_in = mem_malloc(dhcp->options_in_len);
  8034bd:	83 ec 0c             	sub    $0xc,%esp
  8034c0:	0f b7 c0             	movzwl %ax,%eax
  8034c3:	50                   	push   %eax
  8034c4:	e8 21 0e 00 00       	call   8042ea <mem_malloc>
  8034c9:	89 47 14             	mov    %eax,0x14(%edi)
    if (dhcp->options_in == NULL) {
  8034cc:	83 c4 10             	add    $0x10,%esp
  8034cf:	85 c0                	test   %eax,%eax
  8034d1:	74 94                	je     803467 <dhcp_recv+0x4a>
  dhcp->msg_in = mem_malloc(sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  8034d3:	83 ec 0c             	sub    $0xc,%esp
  8034d6:	68 f0 00 00 00       	push   $0xf0
  8034db:	e8 0a 0e 00 00       	call   8042ea <mem_malloc>
  8034e0:	89 47 10             	mov    %eax,0x10(%edi)
  if (dhcp->msg_in == NULL) {
  8034e3:	83 c4 10             	add    $0x10,%esp
  8034e6:	85 c0                	test   %eax,%eax
  8034e8:	0f 84 e1 00 00 00    	je     8035cf <dhcp_recv+0x1b2>
  ret = pbuf_copy_partial(dhcp->p, dhcp->msg_in, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN, 0);
  8034ee:	6a 00                	push   $0x0
  8034f0:	68 f0 00 00 00       	push   $0xf0
  8034f5:	50                   	push   %eax
  8034f6:	ff 77 0c             	pushl  0xc(%edi)
  8034f9:	e8 b3 1b 00 00       	call   8050b1 <pbuf_copy_partial>
  LWIP_ASSERT("ret == sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN", ret == sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  8034fe:	83 c4 10             	add    $0x10,%esp
  803501:	66 3d f0 00          	cmp    $0xf0,%ax
  803505:	0f 85 de 00 00 00    	jne    8035e9 <dhcp_recv+0x1cc>
  if (dhcp->options_in != NULL) {
  80350b:	8b 47 14             	mov    0x14(%edi),%eax
  80350e:	85 c0                	test   %eax,%eax
  803510:	74 20                	je     803532 <dhcp_recv+0x115>
    ret = pbuf_copy_partial(dhcp->p, dhcp->options_in, dhcp->options_in_len, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  803512:	68 f0 00 00 00       	push   $0xf0
  803517:	0f b7 57 18          	movzwl 0x18(%edi),%edx
  80351b:	52                   	push   %edx
  80351c:	50                   	push   %eax
  80351d:	ff 77 0c             	pushl  0xc(%edi)
  803520:	e8 8c 1b 00 00       	call   8050b1 <pbuf_copy_partial>
    LWIP_ASSERT("ret == dhcp->options_in_len", ret == dhcp->options_in_len);
  803525:	83 c4 10             	add    $0x10,%esp
  803528:	66 3b 47 18          	cmp    0x18(%edi),%ax
  80352c:	0f 85 ce 00 00 00    	jne    803600 <dhcp_recv+0x1e3>
  options_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_MESSAGE_TYPE);
  803532:	ba 35 00 00 00       	mov    $0x35,%edx
  803537:	89 f8                	mov    %edi,%eax
  803539:	e8 e9 f2 ff ff       	call   802827 <dhcp_get_option_ptr>
  if (options_ptr == NULL) {
  80353e:	85 c0                	test   %eax,%eax
  803540:	0f 84 21 ff ff ff    	je     803467 <dhcp_recv+0x4a>
  return *ptr;
  803546:	0f b6 40 02          	movzbl 0x2(%eax),%eax
  if (msg_type == DHCP_ACK) {
  80354a:	3c 05                	cmp    $0x5,%al
  80354c:	0f 84 c5 00 00 00    	je     803617 <dhcp_recv+0x1fa>
  else if ((msg_type == DHCP_NAK) &&
  803552:	3c 06                	cmp    $0x6,%al
  803554:	0f 84 5a 02 00 00    	je     8037b4 <dhcp_recv+0x397>
  else if ((msg_type == DHCP_OFFER) && (dhcp->state == DHCP_SELECTING)) {
  80355a:	3c 02                	cmp    $0x2,%al
  80355c:	0f 85 05 ff ff ff    	jne    803467 <dhcp_recv+0x4a>
  803562:	80 3f 06             	cmpb   $0x6,(%edi)
  803565:	0f 85 fc fe ff ff    	jne    803467 <dhcp_recv+0x4a>
    dhcp->request_timeout = 0;
  80356b:	66 c7 47 26 00 00    	movw   $0x0,0x26(%edi)
  struct dhcp *dhcp = netif->dhcp;
  803571:	8b 45 08             	mov    0x8(%ebp),%eax
  803574:	8b 58 20             	mov    0x20(%eax),%ebx
  u8_t *option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_SERVER_ID);
  803577:	ba 36 00 00 00       	mov    $0x36,%edx
  80357c:	89 d8                	mov    %ebx,%eax
  80357e:	e8 a4 f2 ff ff       	call   802827 <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  803583:	85 c0                	test   %eax,%eax
  803585:	0f 84 dc fe ff ff    	je     803467 <dhcp_recv+0x4a>
    dhcp->server_ip_addr.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  80358b:	83 c0 02             	add    $0x2,%eax
  80358e:	e8 a0 f3 ff ff       	call   802933 <dhcp_get_option_long>
  803593:	83 ec 0c             	sub    $0xc,%esp
  803596:	50                   	push   %eax
  803597:	e8 e6 42 00 00       	call   807882 <htonl>
  80359c:	89 43 2c             	mov    %eax,0x2c(%ebx)
    ip_addr_set(&dhcp->offered_ip_addr, (struct ip_addr *)&dhcp->msg_in->yiaddr);
  80359f:	8b 43 10             	mov    0x10(%ebx),%eax
  8035a2:	8b 40 10             	mov    0x10(%eax),%eax
  8035a5:	89 43 30             	mov    %eax,0x30(%ebx)
    dhcp_select(netif);
  8035a8:	8b 45 08             	mov    0x8(%ebp),%eax
  8035ab:	e8 b8 fa ff ff       	call   803068 <dhcp_select>
  8035b0:	83 c4 10             	add    $0x10,%esp
  8035b3:	e9 af fe ff ff       	jmp    803467 <dhcp_recv+0x4a>
  LWIP_ERROR("dhcp->p != NULL", (dhcp->p != NULL), return ERR_VAL;);
  8035b8:	83 ec 04             	sub    $0x4,%esp
  8035bb:	68 48 1a 81 00       	push   $0x811a48
  8035c0:	68 8a 04 00 00       	push   $0x48a
  8035c5:	68 02 1a 81 00       	push   $0x811a02
  8035ca:	e8 78 b2 00 00       	call   80e847 <_panic>
    mem_free((void *)dhcp->options_in);
  8035cf:	83 ec 0c             	sub    $0xc,%esp
  8035d2:	ff 77 14             	pushl  0x14(%edi)
  8035d5:	e8 19 0a 00 00       	call   803ff3 <mem_free>
    dhcp->options_in = NULL;
  8035da:	c7 47 14 00 00 00 00 	movl   $0x0,0x14(%edi)
    return ERR_MEM;
  8035e1:	83 c4 10             	add    $0x10,%esp
  8035e4:	e9 7e fe ff ff       	jmp    803467 <dhcp_recv+0x4a>
  LWIP_ASSERT("ret == sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN", ret == sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  8035e9:	83 ec 04             	sub    $0x4,%esp
  8035ec:	68 d0 19 81 00       	push   $0x8119d0
  8035f1:	68 a0 04 00 00       	push   $0x4a0
  8035f6:	68 02 1a 81 00       	push   $0x811a02
  8035fb:	e8 47 b2 00 00       	call   80e847 <_panic>
    LWIP_ASSERT("ret == dhcp->options_in_len", ret == dhcp->options_in_len);
  803600:	83 ec 04             	sub    $0x4,%esp
  803603:	68 58 1a 81 00       	push   $0x811a58
  803608:	68 a7 04 00 00       	push   $0x4a7
  80360d:	68 02 1a 81 00       	push   $0x811a02
  803612:	e8 30 b2 00 00       	call   80e847 <_panic>
    if (dhcp->state == DHCP_REQUESTING) {
  803617:	0f b6 07             	movzbl (%edi),%eax
  80361a:	3c 01                	cmp    $0x1,%al
  80361c:	74 1e                	je     80363c <dhcp_recv+0x21f>
    else if ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REBINDING) || (dhcp->state == DHCP_RENEWING)) {
  80361e:	83 e8 03             	sub    $0x3,%eax
  803621:	3c 02                	cmp    $0x2,%al
  803623:	0f 87 3e fe ff ff    	ja     803467 <dhcp_recv+0x4a>
      dhcp->request_timeout = 0;
  803629:	66 c7 47 26 00 00    	movw   $0x0,0x26(%edi)
      dhcp_bind(netif);
  80362f:	8b 45 08             	mov    0x8(%ebp),%eax
  803632:	e8 e1 fb ff ff       	call   803218 <dhcp_bind>
  803637:	e9 2b fe ff ff       	jmp    803467 <dhcp_recv+0x4a>
  struct dhcp *dhcp = netif->dhcp;
  80363c:	8b 45 08             	mov    0x8(%ebp),%eax
  80363f:	8b 70 20             	mov    0x20(%eax),%esi
  dhcp->offered_sn_mask.addr = 0;
  803642:	c7 46 34 00 00 00 00 	movl   $0x0,0x34(%esi)
  dhcp->offered_gw_addr.addr = 0;
  803649:	c7 46 38 00 00 00 00 	movl   $0x0,0x38(%esi)
  dhcp->offered_bc_addr.addr = 0;
  803650:	c7 46 3c 00 00 00 00 	movl   $0x0,0x3c(%esi)
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_LEASE_TIME);
  803657:	ba 33 00 00 00       	mov    $0x33,%edx
  80365c:	89 f0                	mov    %esi,%eax
  80365e:	e8 c4 f1 ff ff       	call   802827 <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  803663:	85 c0                	test   %eax,%eax
  803665:	74 0b                	je     803672 <dhcp_recv+0x255>
    dhcp->offered_t0_lease = dhcp_get_option_long(option_ptr + 2);
  803667:	83 c0 02             	add    $0x2,%eax
  80366a:	e8 c4 f2 ff ff       	call   802933 <dhcp_get_option_long>
  80366f:	89 46 4c             	mov    %eax,0x4c(%esi)
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_T1);
  803672:	ba 3a 00 00 00       	mov    $0x3a,%edx
  803677:	89 f0                	mov    %esi,%eax
  803679:	e8 a9 f1 ff ff       	call   802827 <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  80367e:	85 c0                	test   %eax,%eax
  803680:	0f 84 dc 00 00 00    	je     803762 <dhcp_recv+0x345>
    dhcp->offered_t1_renew = dhcp_get_option_long(option_ptr + 2);
  803686:	83 c0 02             	add    $0x2,%eax
  803689:	e8 a5 f2 ff ff       	call   802933 <dhcp_get_option_long>
  80368e:	89 46 50             	mov    %eax,0x50(%esi)
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_T2);
  803691:	ba 3b 00 00 00       	mov    $0x3b,%edx
  803696:	89 f0                	mov    %esi,%eax
  803698:	e8 8a f1 ff ff       	call   802827 <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  80369d:	85 c0                	test   %eax,%eax
  80369f:	0f 84 c7 00 00 00    	je     80376c <dhcp_recv+0x34f>
    dhcp->offered_t2_rebind = dhcp_get_option_long(option_ptr + 2);
  8036a5:	83 c0 02             	add    $0x2,%eax
  8036a8:	e8 86 f2 ff ff       	call   802933 <dhcp_get_option_long>
  8036ad:	89 46 54             	mov    %eax,0x54(%esi)
  ip_addr_set(&dhcp->offered_ip_addr, &dhcp->msg_in->yiaddr);
  8036b0:	8b 46 10             	mov    0x10(%esi),%eax
  8036b3:	8b 40 10             	mov    0x10(%eax),%eax
  8036b6:	89 46 30             	mov    %eax,0x30(%esi)
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_SUBNET_MASK);
  8036b9:	ba 01 00 00 00       	mov    $0x1,%edx
  8036be:	89 f0                	mov    %esi,%eax
  8036c0:	e8 62 f1 ff ff       	call   802827 <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  8036c5:	85 c0                	test   %eax,%eax
  8036c7:	74 17                	je     8036e0 <dhcp_recv+0x2c3>
    dhcp->offered_sn_mask.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  8036c9:	83 c0 02             	add    $0x2,%eax
  8036cc:	e8 62 f2 ff ff       	call   802933 <dhcp_get_option_long>
  8036d1:	83 ec 0c             	sub    $0xc,%esp
  8036d4:	50                   	push   %eax
  8036d5:	e8 a8 41 00 00       	call   807882 <htonl>
  8036da:	89 46 34             	mov    %eax,0x34(%esi)
  8036dd:	83 c4 10             	add    $0x10,%esp
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_ROUTER);
  8036e0:	ba 03 00 00 00       	mov    $0x3,%edx
  8036e5:	89 f0                	mov    %esi,%eax
  8036e7:	e8 3b f1 ff ff       	call   802827 <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  8036ec:	85 c0                	test   %eax,%eax
  8036ee:	74 17                	je     803707 <dhcp_recv+0x2ea>
    dhcp->offered_gw_addr.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  8036f0:	83 c0 02             	add    $0x2,%eax
  8036f3:	e8 3b f2 ff ff       	call   802933 <dhcp_get_option_long>
  8036f8:	83 ec 0c             	sub    $0xc,%esp
  8036fb:	50                   	push   %eax
  8036fc:	e8 81 41 00 00       	call   807882 <htonl>
  803701:	89 46 38             	mov    %eax,0x38(%esi)
  803704:	83 c4 10             	add    $0x10,%esp
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_BROADCAST);
  803707:	ba 1c 00 00 00       	mov    $0x1c,%edx
  80370c:	89 f0                	mov    %esi,%eax
  80370e:	e8 14 f1 ff ff       	call   802827 <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  803713:	85 c0                	test   %eax,%eax
  803715:	74 17                	je     80372e <dhcp_recv+0x311>
    dhcp->offered_bc_addr.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  803717:	83 c0 02             	add    $0x2,%eax
  80371a:	e8 14 f2 ff ff       	call   802933 <dhcp_get_option_long>
  80371f:	83 ec 0c             	sub    $0xc,%esp
  803722:	50                   	push   %eax
  803723:	e8 5a 41 00 00       	call   807882 <htonl>
  803728:	89 46 3c             	mov    %eax,0x3c(%esi)
  80372b:	83 c4 10             	add    $0x10,%esp
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_DNS_SERVER);
  80372e:	ba 06 00 00 00       	mov    $0x6,%edx
  803733:	89 f0                	mov    %esi,%eax
  803735:	e8 ed f0 ff ff       	call   802827 <dhcp_get_option_ptr>
  80373a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  if (option_ptr != NULL) {
  80373d:	85 c0                	test   %eax,%eax
  80373f:	74 60                	je     8037a1 <dhcp_recv+0x384>
    dhcp->dns_count = dhcp_get_option_byte(&option_ptr[1]) / (u32_t)sizeof(struct ip_addr);
  803741:	0f b6 40 01          	movzbl 0x1(%eax),%eax
  803745:	c0 e8 02             	shr    $0x2,%al
  803748:	0f b6 d0             	movzbl %al,%edx
  80374b:	3c 02                	cmp    $0x2,%al
  80374d:	b8 02 00 00 00       	mov    $0x2,%eax
  803752:	0f 46 c2             	cmovbe %edx,%eax
  803755:	89 46 40             	mov    %eax,0x40(%esi)
{
  803758:	bb 00 00 00 00       	mov    $0x0,%ebx
  80375d:	89 7d e0             	mov    %edi,-0x20(%ebp)
  803760:	eb 34                	jmp    803796 <dhcp_recv+0x379>
    dhcp->offered_t1_renew = dhcp->offered_t0_lease / 2;
  803762:	8b 46 4c             	mov    0x4c(%esi),%eax
  803765:	d1 e8                	shr    %eax
  803767:	e9 22 ff ff ff       	jmp    80368e <dhcp_recv+0x271>
    dhcp->offered_t2_rebind = dhcp->offered_t0_lease;
  80376c:	8b 46 4c             	mov    0x4c(%esi),%eax
  80376f:	e9 39 ff ff ff       	jmp    8036ad <dhcp_recv+0x290>
      dhcp->offered_dns_addr[n].addr = htonl(dhcp_get_option_long(&option_ptr[2 + n * 4]));
  803774:	0f b6 fb             	movzbl %bl,%edi
  803777:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80377a:	8d 44 b8 02          	lea    0x2(%eax,%edi,4),%eax
  80377e:	e8 b0 f1 ff ff       	call   802933 <dhcp_get_option_long>
  803783:	83 ec 0c             	sub    $0xc,%esp
  803786:	50                   	push   %eax
  803787:	e8 f6 40 00 00       	call   807882 <htonl>
  80378c:	89 44 be 44          	mov    %eax,0x44(%esi,%edi,4)
    for (n = 0; n < dhcp->dns_count; n++) {
  803790:	83 c3 01             	add    $0x1,%ebx
  803793:	83 c4 10             	add    $0x10,%esp
  803796:	0f b6 c3             	movzbl %bl,%eax
  803799:	3b 46 40             	cmp    0x40(%esi),%eax
  80379c:	72 d6                	jb     803774 <dhcp_recv+0x357>
  80379e:	8b 7d e0             	mov    -0x20(%ebp),%edi
      dhcp->request_timeout = 0;
  8037a1:	66 c7 47 26 00 00    	movw   $0x0,0x26(%edi)
      dhcp_check(netif);
  8037a7:	8b 45 08             	mov    0x8(%ebp),%eax
  8037aa:	e8 35 fa ff ff       	call   8031e4 <dhcp_check>
  8037af:	e9 b3 fc ff ff       	jmp    803467 <dhcp_recv+0x4a>
    ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REQUESTING) ||
  8037b4:	0f b6 07             	movzbl (%edi),%eax
  8037b7:	8d 50 fd             	lea    -0x3(%eax),%edx
     (dhcp->state == DHCP_REBINDING) || (dhcp->state == DHCP_RENEWING  ))) {
  8037ba:	80 fa 02             	cmp    $0x2,%dl
  8037bd:	76 08                	jbe    8037c7 <dhcp_recv+0x3aa>
  8037bf:	3c 01                	cmp    $0x1,%al
  8037c1:	0f 85 a0 fc ff ff    	jne    803467 <dhcp_recv+0x4a>
    dhcp->request_timeout = 0;
  8037c7:	66 c7 47 26 00 00    	movw   $0x0,0x26(%edi)
  struct dhcp *dhcp = netif->dhcp;
  8037cd:	8b 45 08             	mov    0x8(%ebp),%eax
  8037d0:	8b 58 20             	mov    0x20(%eax),%ebx
  netif_set_down(netif);
  8037d3:	83 ec 0c             	sub    $0xc,%esp
  8037d6:	50                   	push   %eax
  8037d7:	e8 4c 10 00 00       	call   804828 <netif_set_down>
  netif_set_ipaddr(netif, IP_ADDR_ANY);
  8037dc:	83 c4 08             	add    $0x8,%esp
  8037df:	68 a8 22 81 00       	push   $0x8122a8
  8037e4:	ff 75 08             	pushl  0x8(%ebp)
  8037e7:	e8 82 0e 00 00       	call   80466e <netif_set_ipaddr>
  netif_set_gw(netif, IP_ADDR_ANY);
  8037ec:	83 c4 08             	add    $0x8,%esp
  8037ef:	68 a8 22 81 00       	push   $0x8122a8
  8037f4:	ff 75 08             	pushl  0x8(%ebp)
  8037f7:	e8 aa 0f 00 00       	call   8047a6 <netif_set_gw>
  netif_set_netmask(netif, IP_ADDR_ANY); 
  8037fc:	83 c4 08             	add    $0x8,%esp
  8037ff:	68 a8 22 81 00       	push   $0x8122a8
  803804:	ff 75 08             	pushl  0x8(%ebp)
  803807:	e8 b7 0f 00 00       	call   8047c3 <netif_set_netmask>
  dhcp_set_state(dhcp, DHCP_BACKING_OFF);
  80380c:	ba 0c 00 00 00       	mov    $0xc,%edx
  803811:	89 d8                	mov    %ebx,%eax
  803813:	e8 04 f0 ff ff       	call   80281c <dhcp_set_state>
  dhcp_discover(netif);
  803818:	8b 45 08             	mov    0x8(%ebp),%eax
  80381b:	e8 09 f7 ff ff       	call   802f29 <dhcp_discover>
}
  803820:	83 c4 10             	add    $0x10,%esp
  803823:	e9 3f fc ff ff       	jmp    803467 <dhcp_recv+0x4a>

00803828 <dhcp_inform>:
{
  803828:	f3 0f 1e fb          	endbr32 
  80382c:	55                   	push   %ebp
  80382d:	89 e5                	mov    %esp,%ebp
  80382f:	57                   	push   %edi
  803830:	56                   	push   %esi
  803831:	53                   	push   %ebx
  803832:	83 ec 18             	sub    $0x18,%esp
  803835:	8b 75 08             	mov    0x8(%ebp),%esi
  struct dhcp *dhcp, *old_dhcp = netif->dhcp;
  803838:	8b 7e 20             	mov    0x20(%esi),%edi
  dhcp = mem_malloc(sizeof(struct dhcp));
  80383b:	6a 58                	push   $0x58
  80383d:	e8 a8 0a 00 00       	call   8042ea <mem_malloc>
  if (dhcp == NULL) {
  803842:	83 c4 10             	add    $0x10,%esp
  803845:	85 c0                	test   %eax,%eax
  803847:	74 55                	je     80389e <dhcp_inform+0x76>
  803849:	89 c3                	mov    %eax,%ebx
  netif->dhcp = dhcp;
  80384b:	89 46 20             	mov    %eax,0x20(%esi)
  memset(dhcp, 0, sizeof(struct dhcp));
  80384e:	83 ec 04             	sub    $0x4,%esp
  803851:	6a 58                	push   $0x58
  803853:	6a 00                	push   $0x0
  803855:	50                   	push   %eax
  803856:	e8 47 b8 00 00       	call   80f0a2 <memset>
  dhcp->pcb = udp_new();
  80385b:	e8 59 59 00 00       	call   8091b9 <udp_new>
  803860:	89 43 08             	mov    %eax,0x8(%ebx)
  if (dhcp->pcb == NULL) {
  803863:	83 c4 10             	add    $0x10,%esp
  803866:	85 c0                	test   %eax,%eax
  803868:	74 3c                	je     8038a6 <dhcp_inform+0x7e>
  result = dhcp_create_request(netif);
  80386a:	89 f0                	mov    %esi,%eax
  80386c:	e8 38 f3 ff ff       	call   802ba9 <dhcp_create_request>
  if (result == ERR_OK) {
  803871:	84 c0                	test   %al,%al
  803873:	74 3f                	je     8038b4 <dhcp_inform+0x8c>
    if (dhcp->pcb != NULL) {
  803875:	8b 43 08             	mov    0x8(%ebx),%eax
  803878:	85 c0                	test   %eax,%eax
  80387a:	74 0c                	je     803888 <dhcp_inform+0x60>
      udp_remove(dhcp->pcb);
  80387c:	83 ec 0c             	sub    $0xc,%esp
  80387f:	50                   	push   %eax
  803880:	e8 ec 58 00 00       	call   809171 <udp_remove>
  803885:	83 c4 10             	add    $0x10,%esp
    dhcp->pcb = NULL;
  803888:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    mem_free((void *)dhcp);
  80388f:	83 ec 0c             	sub    $0xc,%esp
  803892:	53                   	push   %ebx
  803893:	e8 5b 07 00 00       	call   803ff3 <mem_free>
    netif->dhcp = old_dhcp;
  803898:	89 7e 20             	mov    %edi,0x20(%esi)
  80389b:	83 c4 10             	add    $0x10,%esp
}
  80389e:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8038a1:	5b                   	pop    %ebx
  8038a2:	5e                   	pop    %esi
  8038a3:	5f                   	pop    %edi
  8038a4:	5d                   	pop    %ebp
  8038a5:	c3                   	ret    
    mem_free((void *)dhcp);
  8038a6:	83 ec 0c             	sub    $0xc,%esp
  8038a9:	53                   	push   %ebx
  8038aa:	e8 44 07 00 00       	call   803ff3 <mem_free>
    return;
  8038af:	83 c4 10             	add    $0x10,%esp
  8038b2:	eb ea                	jmp    80389e <dhcp_inform+0x76>
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  8038b4:	b9 01 00 00 00       	mov    $0x1,%ecx
  8038b9:	ba 35 00 00 00       	mov    $0x35,%edx
  8038be:	89 d8                	mov    %ebx,%eax
  8038c0:	e8 d2 f0 ff ff       	call   802997 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_INFORM);
  8038c5:	ba 08 00 00 00       	mov    $0x8,%edx
  8038ca:	89 d8                	mov    %ebx,%eax
  8038cc:	e8 85 f0 ff ff       	call   802956 <dhcp_option_byte>
    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  8038d1:	b9 02 00 00 00       	mov    $0x2,%ecx
  8038d6:	ba 39 00 00 00       	mov    $0x39,%edx
  8038db:	89 d8                	mov    %ebx,%eax
  8038dd:	e8 b5 f0 ff ff       	call   802997 <dhcp_option>
    dhcp_option_short(dhcp, 576);
  8038e2:	ba 40 02 00 00       	mov    $0x240,%edx
  8038e7:	89 d8                	mov    %ebx,%eax
  8038e9:	e8 10 f1 ff ff       	call   8029fe <dhcp_option_short>
    dhcp_option_trailer(dhcp);
  8038ee:	89 d8                	mov    %ebx,%eax
  8038f0:	e8 67 f1 ff ff       	call   802a5c <dhcp_option_trailer>
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  8038f5:	83 ec 08             	sub    $0x8,%esp
  8038f8:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  8038fc:	66 05 f0 00          	add    $0xf0,%ax
  803900:	0f b7 c0             	movzwl %ax,%eax
  803903:	50                   	push   %eax
  803904:	ff 73 1c             	pushl  0x1c(%ebx)
  803907:	e8 45 13 00 00       	call   804c51 <pbuf_realloc>
    udp_bind(dhcp->pcb, IP_ADDR_ANY, DHCP_CLIENT_PORT);
  80390c:	83 c4 0c             	add    $0xc,%esp
  80390f:	6a 44                	push   $0x44
  803911:	68 a8 22 81 00       	push   $0x8122a8
  803916:	ff 73 08             	pushl  0x8(%ebx)
  803919:	e8 e7 54 00 00       	call   808e05 <udp_bind>
    udp_connect(dhcp->pcb, IP_ADDR_BROADCAST, DHCP_SERVER_PORT);
  80391e:	83 c4 0c             	add    $0xc,%esp
  803921:	6a 43                	push   $0x43
  803923:	68 a4 22 81 00       	push   $0x8122a4
  803928:	ff 73 08             	pushl  0x8(%ebx)
  80392b:	e8 95 57 00 00       	call   8090c5 <udp_connect>
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  803930:	89 34 24             	mov    %esi,(%esp)
  803933:	6a 43                	push   $0x43
  803935:	68 a4 22 81 00       	push   $0x8122a4
  80393a:	ff 73 1c             	pushl  0x1c(%ebx)
  80393d:	ff 73 08             	pushl  0x8(%ebx)
  803940:	e8 7f 55 00 00       	call   808ec4 <udp_sendto_if>
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  803945:	83 c4 1c             	add    $0x1c,%esp
  803948:	6a 43                	push   $0x43
  80394a:	68 a8 22 81 00       	push   $0x8122a8
  80394f:	ff 73 08             	pushl  0x8(%ebx)
  803952:	e8 6e 57 00 00       	call   8090c5 <udp_connect>
    dhcp_delete_request(netif);
  803957:	89 f0                	mov    %esi,%eax
  803959:	e8 3e f4 ff ff       	call   802d9c <dhcp_delete_request>
  80395e:	83 c4 10             	add    $0x10,%esp
  803961:	e9 0f ff ff ff       	jmp    803875 <dhcp_inform+0x4d>

00803966 <dhcp_arp_reply>:
{
  803966:	f3 0f 1e fb          	endbr32 
  80396a:	55                   	push   %ebp
  80396b:	89 e5                	mov    %esp,%ebp
  80396d:	56                   	push   %esi
  80396e:	53                   	push   %ebx
  80396f:	8b 75 08             	mov    0x8(%ebp),%esi
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  803972:	85 f6                	test   %esi,%esi
  803974:	74 13                	je     803989 <dhcp_arp_reply+0x23>
  if ((netif->dhcp != NULL) && (netif->dhcp->state == DHCP_CHECKING)) {
  803976:	8b 5e 20             	mov    0x20(%esi),%ebx
  803979:	85 db                	test   %ebx,%ebx
  80397b:	74 05                	je     803982 <dhcp_arp_reply+0x1c>
  80397d:	80 3b 08             	cmpb   $0x8,(%ebx)
  803980:	74 1e                	je     8039a0 <dhcp_arp_reply+0x3a>
}
  803982:	8d 65 f8             	lea    -0x8(%ebp),%esp
  803985:	5b                   	pop    %ebx
  803986:	5e                   	pop    %esi
  803987:	5d                   	pop    %ebp
  803988:	c3                   	ret    
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  803989:	83 ec 04             	sub    $0x4,%esp
  80398c:	68 22 1a 81 00       	push   $0x811a22
  803991:	68 b5 02 00 00       	push   $0x2b5
  803996:	68 02 1a 81 00       	push   $0x811a02
  80399b:	e8 a7 ae 00 00       	call   80e847 <_panic>
    if (ip_addr_cmp(addr, &netif->dhcp->offered_ip_addr)) {
  8039a0:	8b 45 0c             	mov    0xc(%ebp),%eax
  8039a3:	8b 4b 30             	mov    0x30(%ebx),%ecx
  8039a6:	39 08                	cmp    %ecx,(%eax)
  8039a8:	75 d8                	jne    803982 <dhcp_arp_reply+0x1c>
  dhcp_set_state(dhcp, DHCP_BACKING_OFF);
  8039aa:	ba 0c 00 00 00       	mov    $0xc,%edx
  8039af:	89 d8                	mov    %ebx,%eax
  8039b1:	e8 66 ee ff ff       	call   80281c <dhcp_set_state>
  result = dhcp_create_request(netif);
  8039b6:	89 f0                	mov    %esi,%eax
  8039b8:	e8 ec f1 ff ff       	call   802ba9 <dhcp_create_request>
  if (result == ERR_OK) {
  8039bd:	84 c0                	test   %al,%al
  8039bf:	74 0c                	je     8039cd <dhcp_arp_reply+0x67>
  dhcp->tries++;
  8039c1:	80 43 01 01          	addb   $0x1,0x1(%ebx)
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  8039c5:	66 c7 43 26 14 00    	movw   $0x14,0x26(%ebx)
  return result;
  8039cb:	eb b5                	jmp    803982 <dhcp_arp_reply+0x1c>
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  8039cd:	b9 01 00 00 00       	mov    $0x1,%ecx
  8039d2:	ba 35 00 00 00       	mov    $0x35,%edx
  8039d7:	89 d8                	mov    %ebx,%eax
  8039d9:	e8 b9 ef ff ff       	call   802997 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_DECLINE);
  8039de:	ba 04 00 00 00       	mov    $0x4,%edx
  8039e3:	89 d8                	mov    %ebx,%eax
  8039e5:	e8 6c ef ff ff       	call   802956 <dhcp_option_byte>
    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  8039ea:	b9 02 00 00 00       	mov    $0x2,%ecx
  8039ef:	ba 39 00 00 00       	mov    $0x39,%edx
  8039f4:	89 d8                	mov    %ebx,%eax
  8039f6:	e8 9c ef ff ff       	call   802997 <dhcp_option>
    dhcp_option_short(dhcp, 576);
  8039fb:	ba 40 02 00 00       	mov    $0x240,%edx
  803a00:	89 d8                	mov    %ebx,%eax
  803a02:	e8 f7 ef ff ff       	call   8029fe <dhcp_option_short>
    dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
  803a07:	b9 04 00 00 00       	mov    $0x4,%ecx
  803a0c:	ba 32 00 00 00       	mov    $0x32,%edx
  803a11:	89 d8                	mov    %ebx,%eax
  803a13:	e8 7f ef ff ff       	call   802997 <dhcp_option>
    dhcp_option_long(dhcp, ntohl(dhcp->offered_ip_addr.addr));
  803a18:	83 ec 0c             	sub    $0xc,%esp
  803a1b:	ff 73 30             	pushl  0x30(%ebx)
  803a1e:	e8 8c 40 00 00       	call   807aaf <ntohl>
  803a23:	89 c2                	mov    %eax,%edx
  803a25:	89 d8                	mov    %ebx,%eax
  803a27:	e8 e5 f0 ff ff       	call   802b11 <dhcp_option_long>
    dhcp_option_trailer(dhcp);
  803a2c:	89 d8                	mov    %ebx,%eax
  803a2e:	e8 29 f0 ff ff       	call   802a5c <dhcp_option_trailer>
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  803a33:	83 c4 08             	add    $0x8,%esp
  803a36:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  803a3a:	66 05 f0 00          	add    $0xf0,%ax
  803a3e:	0f b7 c0             	movzwl %ax,%eax
  803a41:	50                   	push   %eax
  803a42:	ff 73 1c             	pushl  0x1c(%ebx)
  803a45:	e8 07 12 00 00       	call   804c51 <pbuf_realloc>
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  803a4a:	83 c4 0c             	add    $0xc,%esp
  803a4d:	6a 43                	push   $0x43
  803a4f:	68 a8 22 81 00       	push   $0x8122a8
  803a54:	ff 73 08             	pushl  0x8(%ebx)
  803a57:	e8 69 56 00 00       	call   8090c5 <udp_connect>
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  803a5c:	89 34 24             	mov    %esi,(%esp)
  803a5f:	6a 43                	push   $0x43
  803a61:	68 a4 22 81 00       	push   $0x8122a4
  803a66:	ff 73 1c             	pushl  0x1c(%ebx)
  803a69:	ff 73 08             	pushl  0x8(%ebx)
  803a6c:	e8 53 54 00 00       	call   808ec4 <udp_sendto_if>
    dhcp_delete_request(netif);
  803a71:	83 c4 20             	add    $0x20,%esp
  803a74:	89 f0                	mov    %esi,%eax
  803a76:	e8 21 f3 ff ff       	call   802d9c <dhcp_delete_request>
  803a7b:	e9 41 ff ff ff       	jmp    8039c1 <dhcp_arp_reply+0x5b>

00803a80 <dhcp_renew>:
{
  803a80:	f3 0f 1e fb          	endbr32 
  803a84:	55                   	push   %ebp
  803a85:	89 e5                	mov    %esp,%ebp
  803a87:	57                   	push   %edi
  803a88:	56                   	push   %esi
  803a89:	53                   	push   %ebx
  803a8a:	83 ec 1c             	sub    $0x1c,%esp
  803a8d:	8b 7d 08             	mov    0x8(%ebp),%edi
  struct dhcp *dhcp = netif->dhcp;
  803a90:	8b 5f 20             	mov    0x20(%edi),%ebx
  dhcp_set_state(dhcp, DHCP_RENEWING);
  803a93:	ba 05 00 00 00       	mov    $0x5,%edx
  803a98:	89 d8                	mov    %ebx,%eax
  803a9a:	e8 7d ed ff ff       	call   80281c <dhcp_set_state>
  result = dhcp_create_request(netif);
  803a9f:	89 f8                	mov    %edi,%eax
  803aa1:	e8 03 f1 ff ff       	call   802ba9 <dhcp_create_request>
  803aa6:	89 c6                	mov    %eax,%esi
  if (result == ERR_OK) {
  803aa8:	84 c0                	test   %al,%al
  803aaa:	74 3e                	je     803aea <dhcp_renew+0x6a>
  dhcp->tries++;
  803aac:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
  803ab0:	83 c0 01             	add    $0x1,%eax
  803ab3:	88 43 01             	mov    %al,0x1(%ebx)
  msecs = dhcp->tries < 10 ? dhcp->tries * 2000 : 20 * 1000;
  803ab6:	ba 20 4e 00 00       	mov    $0x4e20,%edx
  803abb:	3c 09                	cmp    $0x9,%al
  803abd:	77 08                	ja     803ac7 <dhcp_renew+0x47>
  803abf:	0f b6 d0             	movzbl %al,%edx
  803ac2:	66 69 d2 d0 07       	imul   $0x7d0,%dx,%dx
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  803ac7:	0f b7 d2             	movzwl %dx,%edx
  803aca:	81 c2 f3 01 00 00    	add    $0x1f3,%edx
  803ad0:	b9 d3 4d 62 10       	mov    $0x10624dd3,%ecx
  803ad5:	89 d0                	mov    %edx,%eax
  803ad7:	f7 e9                	imul   %ecx
  803ad9:	c1 fa 05             	sar    $0x5,%edx
  803adc:	66 89 53 26          	mov    %dx,0x26(%ebx)
}
  803ae0:	89 f0                	mov    %esi,%eax
  803ae2:	8d 65 f4             	lea    -0xc(%ebp),%esp
  803ae5:	5b                   	pop    %ebx
  803ae6:	5e                   	pop    %esi
  803ae7:	5f                   	pop    %edi
  803ae8:	5d                   	pop    %ebp
  803ae9:	c3                   	ret    
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  803aea:	b9 01 00 00 00       	mov    $0x1,%ecx
  803aef:	ba 35 00 00 00       	mov    $0x35,%edx
  803af4:	89 d8                	mov    %ebx,%eax
  803af6:	e8 9c ee ff ff       	call   802997 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_REQUEST);
  803afb:	ba 03 00 00 00       	mov    $0x3,%edx
  803b00:	89 d8                	mov    %ebx,%eax
  803b02:	e8 4f ee ff ff       	call   802956 <dhcp_option_byte>
    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  803b07:	b9 02 00 00 00       	mov    $0x2,%ecx
  803b0c:	ba 39 00 00 00       	mov    $0x39,%edx
  803b11:	89 d8                	mov    %ebx,%eax
  803b13:	e8 7f ee ff ff       	call   802997 <dhcp_option>
    dhcp_option_short(dhcp, 576);
  803b18:	ba 40 02 00 00       	mov    $0x240,%edx
  803b1d:	89 d8                	mov    %ebx,%eax
  803b1f:	e8 da ee ff ff       	call   8029fe <dhcp_option_short>
    dhcp_option_trailer(dhcp);
  803b24:	89 d8                	mov    %ebx,%eax
  803b26:	e8 31 ef ff ff       	call   802a5c <dhcp_option_trailer>
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  803b2b:	83 ec 08             	sub    $0x8,%esp
  803b2e:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  803b32:	66 05 f0 00          	add    $0xf0,%ax
  803b36:	0f b7 c0             	movzwl %ax,%eax
  803b39:	50                   	push   %eax
  803b3a:	ff 73 1c             	pushl  0x1c(%ebx)
  803b3d:	e8 0f 11 00 00       	call   804c51 <pbuf_realloc>
    udp_connect(dhcp->pcb, &dhcp->server_ip_addr, DHCP_SERVER_PORT);
  803b42:	8d 43 2c             	lea    0x2c(%ebx),%eax
  803b45:	83 c4 0c             	add    $0xc,%esp
  803b48:	6a 43                	push   $0x43
  803b4a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  803b4d:	50                   	push   %eax
  803b4e:	ff 73 08             	pushl  0x8(%ebx)
  803b51:	e8 6f 55 00 00       	call   8090c5 <udp_connect>
    udp_sendto_if(dhcp->pcb, dhcp->p_out, &dhcp->server_ip_addr, DHCP_SERVER_PORT, netif);
  803b56:	89 3c 24             	mov    %edi,(%esp)
  803b59:	6a 43                	push   $0x43
  803b5b:	ff 75 e4             	pushl  -0x1c(%ebp)
  803b5e:	ff 73 1c             	pushl  0x1c(%ebx)
  803b61:	ff 73 08             	pushl  0x8(%ebx)
  803b64:	e8 5b 53 00 00       	call   808ec4 <udp_sendto_if>
    dhcp_delete_request(netif);
  803b69:	83 c4 20             	add    $0x20,%esp
  803b6c:	89 f8                	mov    %edi,%eax
  803b6e:	e8 29 f2 ff ff       	call   802d9c <dhcp_delete_request>
  803b73:	e9 34 ff ff ff       	jmp    803aac <dhcp_renew+0x2c>

00803b78 <dhcp_coarse_tmr>:
{
  803b78:	f3 0f 1e fb          	endbr32 
  803b7c:	55                   	push   %ebp
  803b7d:	89 e5                	mov    %esp,%ebp
  803b7f:	53                   	push   %ebx
  803b80:	83 ec 04             	sub    $0x4,%esp
  struct netif *netif = netif_list;
  803b83:	8b 1d 34 b2 b3 00    	mov    0xb3b234,%ebx
  while (netif != NULL) {
  803b89:	eb 1d                	jmp    803ba8 <dhcp_coarse_tmr+0x30>
  if ((dhcp->state == DHCP_REQUESTING) || (dhcp->state == DHCP_BOUND) || (dhcp->state == DHCP_RENEWING)) {
  803b8b:	8b 43 20             	mov    0x20(%ebx),%eax
  803b8e:	0f b6 00             	movzbl (%eax),%eax
  803b91:	89 c2                	mov    %eax,%edx
  803b93:	83 e2 fb             	and    $0xfffffffb,%edx
  803b96:	80 fa 01             	cmp    $0x1,%dl
  803b99:	74 04                	je     803b9f <dhcp_coarse_tmr+0x27>
  803b9b:	3c 0a                	cmp    $0xa,%al
  803b9d:	75 07                	jne    803ba6 <dhcp_coarse_tmr+0x2e>
    dhcp_rebind(netif);
  803b9f:	89 d8                	mov    %ebx,%eax
  803ba1:	e8 90 f2 ff ff       	call   802e36 <dhcp_rebind>
    netif = netif->next;
  803ba6:	8b 1b                	mov    (%ebx),%ebx
  while (netif != NULL) {
  803ba8:	85 db                	test   %ebx,%ebx
  803baa:	74 4e                	je     803bfa <dhcp_coarse_tmr+0x82>
    if (netif->dhcp != NULL) {
  803bac:	8b 43 20             	mov    0x20(%ebx),%eax
  803baf:	85 c0                	test   %eax,%eax
  803bb1:	74 f3                	je     803ba6 <dhcp_coarse_tmr+0x2e>
      if (netif->dhcp->t2_timeout-- == 1) {
  803bb3:	0f b7 50 2a          	movzwl 0x2a(%eax),%edx
  803bb7:	8d 4a ff             	lea    -0x1(%edx),%ecx
  803bba:	66 89 48 2a          	mov    %cx,0x2a(%eax)
  803bbe:	66 83 fa 01          	cmp    $0x1,%dx
  803bc2:	74 c7                	je     803b8b <dhcp_coarse_tmr+0x13>
      } else if (netif->dhcp->t1_timeout-- == 1) {
  803bc4:	8b 53 20             	mov    0x20(%ebx),%edx
  803bc7:	0f b7 42 28          	movzwl 0x28(%edx),%eax
  803bcb:	8d 48 ff             	lea    -0x1(%eax),%ecx
  803bce:	66 89 4a 28          	mov    %cx,0x28(%edx)
  803bd2:	66 83 f8 01          	cmp    $0x1,%ax
  803bd6:	75 ce                	jne    803ba6 <dhcp_coarse_tmr+0x2e>
  if ((dhcp->state == DHCP_REQUESTING) || (dhcp->state == DHCP_BOUND) || (dhcp->state == DHCP_RENEWING)) {
  803bd8:	8b 43 20             	mov    0x20(%ebx),%eax
  803bdb:	0f b6 00             	movzbl (%eax),%eax
  803bde:	89 c2                	mov    %eax,%edx
  803be0:	83 e2 fb             	and    $0xfffffffb,%edx
  803be3:	80 fa 01             	cmp    $0x1,%dl
  803be6:	74 04                	je     803bec <dhcp_coarse_tmr+0x74>
  803be8:	3c 0a                	cmp    $0xa,%al
  803bea:	75 ba                	jne    803ba6 <dhcp_coarse_tmr+0x2e>
    dhcp_renew(netif);
  803bec:	83 ec 0c             	sub    $0xc,%esp
  803bef:	53                   	push   %ebx
  803bf0:	e8 8b fe ff ff       	call   803a80 <dhcp_renew>
  803bf5:	83 c4 10             	add    $0x10,%esp
  803bf8:	eb ac                	jmp    803ba6 <dhcp_coarse_tmr+0x2e>
}
  803bfa:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  803bfd:	c9                   	leave  
  803bfe:	c3                   	ret    

00803bff <dhcp_release>:
{
  803bff:	f3 0f 1e fb          	endbr32 
  803c03:	55                   	push   %ebp
  803c04:	89 e5                	mov    %esp,%ebp
  803c06:	57                   	push   %edi
  803c07:	56                   	push   %esi
  803c08:	53                   	push   %ebx
  803c09:	83 ec 1c             	sub    $0x1c,%esp
  803c0c:	8b 75 08             	mov    0x8(%ebp),%esi
  struct dhcp *dhcp = netif->dhcp;
  803c0f:	8b 5e 20             	mov    0x20(%esi),%ebx
  dhcp_set_state(dhcp, DHCP_OFF);
  803c12:	ba 0d 00 00 00       	mov    $0xd,%edx
  803c17:	89 d8                	mov    %ebx,%eax
  803c19:	e8 fe eb ff ff       	call   80281c <dhcp_set_state>
  dhcp->server_ip_addr.addr = 0;
  803c1e:	c7 43 2c 00 00 00 00 	movl   $0x0,0x2c(%ebx)
  dhcp->offered_ip_addr.addr = dhcp->offered_sn_mask.addr = 0;
  803c25:	c7 43 34 00 00 00 00 	movl   $0x0,0x34(%ebx)
  803c2c:	c7 43 30 00 00 00 00 	movl   $0x0,0x30(%ebx)
  dhcp->offered_gw_addr.addr = dhcp->offered_bc_addr.addr = 0;
  803c33:	c7 43 3c 00 00 00 00 	movl   $0x0,0x3c(%ebx)
  803c3a:	c7 43 38 00 00 00 00 	movl   $0x0,0x38(%ebx)
  dhcp->offered_t0_lease = dhcp->offered_t1_renew = dhcp->offered_t2_rebind = 0;
  803c41:	c7 43 54 00 00 00 00 	movl   $0x0,0x54(%ebx)
  803c48:	c7 43 50 00 00 00 00 	movl   $0x0,0x50(%ebx)
  803c4f:	c7 43 4c 00 00 00 00 	movl   $0x0,0x4c(%ebx)
  dhcp->dns_count = 0;
  803c56:	c7 43 40 00 00 00 00 	movl   $0x0,0x40(%ebx)
  result = dhcp_create_request(netif);
  803c5d:	89 f0                	mov    %esi,%eax
  803c5f:	e8 45 ef ff ff       	call   802ba9 <dhcp_create_request>
  803c64:	89 c7                	mov    %eax,%edi
  if (result == ERR_OK) {
  803c66:	84 c0                	test   %al,%al
  803c68:	74 71                	je     803cdb <dhcp_release+0xdc>
  dhcp->tries++;
  803c6a:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
  803c6e:	83 c0 01             	add    $0x1,%eax
  803c71:	88 43 01             	mov    %al,0x1(%ebx)
  msecs = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
  803c74:	ba 10 27 00 00       	mov    $0x2710,%edx
  803c79:	3c 09                	cmp    $0x9,%al
  803c7b:	77 08                	ja     803c85 <dhcp_release+0x86>
  803c7d:	0f b6 d0             	movzbl %al,%edx
  803c80:	66 69 d2 e8 03       	imul   $0x3e8,%dx,%dx
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  803c85:	0f b7 d2             	movzwl %dx,%edx
  803c88:	81 c2 f3 01 00 00    	add    $0x1f3,%edx
  803c8e:	b9 d3 4d 62 10       	mov    $0x10624dd3,%ecx
  803c93:	89 d0                	mov    %edx,%eax
  803c95:	f7 e9                	imul   %ecx
  803c97:	c1 fa 05             	sar    $0x5,%edx
  803c9a:	66 89 53 26          	mov    %dx,0x26(%ebx)
  netif_set_down(netif);
  803c9e:	83 ec 0c             	sub    $0xc,%esp
  803ca1:	56                   	push   %esi
  803ca2:	e8 81 0b 00 00       	call   804828 <netif_set_down>
  netif_set_ipaddr(netif, IP_ADDR_ANY);
  803ca7:	83 c4 08             	add    $0x8,%esp
  803caa:	68 a8 22 81 00       	push   $0x8122a8
  803caf:	56                   	push   %esi
  803cb0:	e8 b9 09 00 00       	call   80466e <netif_set_ipaddr>
  netif_set_gw(netif, IP_ADDR_ANY);
  803cb5:	83 c4 08             	add    $0x8,%esp
  803cb8:	68 a8 22 81 00       	push   $0x8122a8
  803cbd:	56                   	push   %esi
  803cbe:	e8 e3 0a 00 00       	call   8047a6 <netif_set_gw>
  netif_set_netmask(netif, IP_ADDR_ANY);
  803cc3:	83 c4 08             	add    $0x8,%esp
  803cc6:	68 a8 22 81 00       	push   $0x8122a8
  803ccb:	56                   	push   %esi
  803ccc:	e8 f2 0a 00 00       	call   8047c3 <netif_set_netmask>
}
  803cd1:	89 f8                	mov    %edi,%eax
  803cd3:	8d 65 f4             	lea    -0xc(%ebp),%esp
  803cd6:	5b                   	pop    %ebx
  803cd7:	5e                   	pop    %esi
  803cd8:	5f                   	pop    %edi
  803cd9:	5d                   	pop    %ebp
  803cda:	c3                   	ret    
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  803cdb:	b9 01 00 00 00       	mov    $0x1,%ecx
  803ce0:	ba 35 00 00 00       	mov    $0x35,%edx
  803ce5:	89 d8                	mov    %ebx,%eax
  803ce7:	e8 ab ec ff ff       	call   802997 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_RELEASE);
  803cec:	ba 07 00 00 00       	mov    $0x7,%edx
  803cf1:	89 d8                	mov    %ebx,%eax
  803cf3:	e8 5e ec ff ff       	call   802956 <dhcp_option_byte>
    dhcp_option_trailer(dhcp);
  803cf8:	89 d8                	mov    %ebx,%eax
  803cfa:	e8 5d ed ff ff       	call   802a5c <dhcp_option_trailer>
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  803cff:	83 ec 08             	sub    $0x8,%esp
  803d02:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  803d06:	66 05 f0 00          	add    $0xf0,%ax
  803d0a:	0f b7 c0             	movzwl %ax,%eax
  803d0d:	50                   	push   %eax
  803d0e:	ff 73 1c             	pushl  0x1c(%ebx)
  803d11:	e8 3b 0f 00 00       	call   804c51 <pbuf_realloc>
    udp_connect(dhcp->pcb, &dhcp->server_ip_addr, DHCP_SERVER_PORT);
  803d16:	8d 43 2c             	lea    0x2c(%ebx),%eax
  803d19:	83 c4 0c             	add    $0xc,%esp
  803d1c:	6a 43                	push   $0x43
  803d1e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  803d21:	50                   	push   %eax
  803d22:	ff 73 08             	pushl  0x8(%ebx)
  803d25:	e8 9b 53 00 00       	call   8090c5 <udp_connect>
    udp_sendto_if(dhcp->pcb, dhcp->p_out, &dhcp->server_ip_addr, DHCP_SERVER_PORT, netif);
  803d2a:	89 34 24             	mov    %esi,(%esp)
  803d2d:	6a 43                	push   $0x43
  803d2f:	ff 75 e4             	pushl  -0x1c(%ebp)
  803d32:	ff 73 1c             	pushl  0x1c(%ebx)
  803d35:	ff 73 08             	pushl  0x8(%ebx)
  803d38:	e8 87 51 00 00       	call   808ec4 <udp_sendto_if>
    dhcp_delete_request(netif);
  803d3d:	83 c4 20             	add    $0x20,%esp
  803d40:	89 f0                	mov    %esi,%eax
  803d42:	e8 55 f0 ff ff       	call   802d9c <dhcp_delete_request>
  803d47:	e9 1e ff ff ff       	jmp    803c6a <dhcp_release+0x6b>

00803d4c <dhcp_fine_tmr>:
{
  803d4c:	f3 0f 1e fb          	endbr32 
  803d50:	55                   	push   %ebp
  803d51:	89 e5                	mov    %esp,%ebp
  803d53:	53                   	push   %ebx
  803d54:	83 ec 04             	sub    $0x4,%esp
  struct netif *netif = netif_list;
  803d57:	8b 1d 34 b2 b3 00    	mov    0xb3b234,%ebx
  while (netif != NULL) {
  803d5d:	eb 04                	jmp    803d63 <dhcp_fine_tmr+0x17>
      else if (netif->dhcp->request_timeout == 1) {
  803d5f:	74 24                	je     803d85 <dhcp_fine_tmr+0x39>
    netif = netif->next;
  803d61:	8b 1b                	mov    (%ebx),%ebx
  while (netif != NULL) {
  803d63:	85 db                	test   %ebx,%ebx
  803d65:	0f 84 c4 00 00 00    	je     803e2f <dhcp_fine_tmr+0xe3>
    if (netif->dhcp != NULL) {
  803d6b:	8b 43 20             	mov    0x20(%ebx),%eax
  803d6e:	85 c0                	test   %eax,%eax
  803d70:	74 ef                	je     803d61 <dhcp_fine_tmr+0x15>
      if (netif->dhcp->request_timeout > 1) {
  803d72:	0f b7 50 26          	movzwl 0x26(%eax),%edx
  803d76:	66 83 fa 01          	cmp    $0x1,%dx
  803d7a:	76 e3                	jbe    803d5f <dhcp_fine_tmr+0x13>
        netif->dhcp->request_timeout--;
  803d7c:	83 ea 01             	sub    $0x1,%edx
  803d7f:	66 89 50 26          	mov    %dx,0x26(%eax)
  803d83:	eb dc                	jmp    803d61 <dhcp_fine_tmr+0x15>
        netif->dhcp->request_timeout--;
  803d85:	66 c7 40 26 00 00    	movw   $0x0,0x26(%eax)
  struct dhcp *dhcp = netif->dhcp;
  803d8b:	8b 53 20             	mov    0x20(%ebx),%edx
  if ((dhcp->state == DHCP_BACKING_OFF) || (dhcp->state == DHCP_SELECTING)) {
  803d8e:	0f b6 02             	movzbl (%edx),%eax
  803d91:	3c 0c                	cmp    $0xc,%al
  803d93:	74 23                	je     803db8 <dhcp_fine_tmr+0x6c>
  803d95:	3c 06                	cmp    $0x6,%al
  803d97:	74 1f                	je     803db8 <dhcp_fine_tmr+0x6c>
  } else if (dhcp->state == DHCP_REQUESTING) {
  803d99:	3c 01                	cmp    $0x1,%al
  803d9b:	74 24                	je     803dc1 <dhcp_fine_tmr+0x75>
  } else if (dhcp->state == DHCP_CHECKING) {
  803d9d:	3c 08                	cmp    $0x8,%al
  803d9f:	74 47                	je     803de8 <dhcp_fine_tmr+0x9c>
  else if (dhcp->state == DHCP_RENEWING) {
  803da1:	3c 05                	cmp    $0x5,%al
  803da3:	74 61                	je     803e06 <dhcp_fine_tmr+0xba>
  } else if (dhcp->state == DHCP_REBINDING) {
  803da5:	3c 04                	cmp    $0x4,%al
  803da7:	75 b8                	jne    803d61 <dhcp_fine_tmr+0x15>
    if (dhcp->tries <= 8) {
  803da9:	80 7a 01 08          	cmpb   $0x8,0x1(%edx)
  803dad:	77 68                	ja     803e17 <dhcp_fine_tmr+0xcb>
      dhcp_rebind(netif);
  803daf:	89 d8                	mov    %ebx,%eax
  803db1:	e8 80 f0 ff ff       	call   802e36 <dhcp_rebind>
  803db6:	eb a9                	jmp    803d61 <dhcp_fine_tmr+0x15>
    dhcp_discover(netif);
  803db8:	89 d8                	mov    %ebx,%eax
  803dba:	e8 6a f1 ff ff       	call   802f29 <dhcp_discover>
  803dbf:	eb a0                	jmp    803d61 <dhcp_fine_tmr+0x15>
    if (dhcp->tries <= 5) {
  803dc1:	80 7a 01 05          	cmpb   $0x5,0x1(%edx)
  803dc5:	77 09                	ja     803dd0 <dhcp_fine_tmr+0x84>
      dhcp_select(netif);
  803dc7:	89 d8                	mov    %ebx,%eax
  803dc9:	e8 9a f2 ff ff       	call   803068 <dhcp_select>
  803dce:	eb 91                	jmp    803d61 <dhcp_fine_tmr+0x15>
      dhcp_release(netif);
  803dd0:	83 ec 0c             	sub    $0xc,%esp
  803dd3:	53                   	push   %ebx
  803dd4:	e8 26 fe ff ff       	call   803bff <dhcp_release>
      dhcp_discover(netif);
  803dd9:	89 d8                	mov    %ebx,%eax
  803ddb:	e8 49 f1 ff ff       	call   802f29 <dhcp_discover>
  803de0:	83 c4 10             	add    $0x10,%esp
  803de3:	e9 79 ff ff ff       	jmp    803d61 <dhcp_fine_tmr+0x15>
    if (dhcp->tries <= 1) {
  803de8:	80 7a 01 01          	cmpb   $0x1,0x1(%edx)
  803dec:	76 0c                	jbe    803dfa <dhcp_fine_tmr+0xae>
      dhcp_bind(netif);
  803dee:	89 d8                	mov    %ebx,%eax
  803df0:	e8 23 f4 ff ff       	call   803218 <dhcp_bind>
  803df5:	e9 67 ff ff ff       	jmp    803d61 <dhcp_fine_tmr+0x15>
      dhcp_check(netif);
  803dfa:	89 d8                	mov    %ebx,%eax
  803dfc:	e8 e3 f3 ff ff       	call   8031e4 <dhcp_check>
  803e01:	e9 5b ff ff ff       	jmp    803d61 <dhcp_fine_tmr+0x15>
    dhcp_renew(netif);
  803e06:	83 ec 0c             	sub    $0xc,%esp
  803e09:	53                   	push   %ebx
  803e0a:	e8 71 fc ff ff       	call   803a80 <dhcp_renew>
  803e0f:	83 c4 10             	add    $0x10,%esp
  803e12:	e9 4a ff ff ff       	jmp    803d61 <dhcp_fine_tmr+0x15>
      dhcp_release(netif);
  803e17:	83 ec 0c             	sub    $0xc,%esp
  803e1a:	53                   	push   %ebx
  803e1b:	e8 df fd ff ff       	call   803bff <dhcp_release>
      dhcp_discover(netif);
  803e20:	89 d8                	mov    %ebx,%eax
  803e22:	e8 02 f1 ff ff       	call   802f29 <dhcp_discover>
  803e27:	83 c4 10             	add    $0x10,%esp
  803e2a:	e9 32 ff ff ff       	jmp    803d61 <dhcp_fine_tmr+0x15>
}
  803e2f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  803e32:	c9                   	leave  
  803e33:	c3                   	ret    

00803e34 <dhcp_stop>:
{
  803e34:	f3 0f 1e fb          	endbr32 
  803e38:	55                   	push   %ebp
  803e39:	89 e5                	mov    %esp,%ebp
  803e3b:	56                   	push   %esi
  803e3c:	53                   	push   %ebx
  803e3d:	8b 75 08             	mov    0x8(%ebp),%esi
  struct dhcp *dhcp = netif->dhcp;
  803e40:	8b 5e 20             	mov    0x20(%esi),%ebx
  netif->flags &= ~NETIF_FLAG_DHCP;
  803e43:	80 66 2e f7          	andb   $0xf7,0x2e(%esi)
  if (dhcp != NULL) {
  803e47:	85 db                	test   %ebx,%ebx
  803e49:	74 4e                	je     803e99 <dhcp_stop+0x65>
    if (dhcp->pcb != NULL) {
  803e4b:	8b 43 08             	mov    0x8(%ebx),%eax
  803e4e:	85 c0                	test   %eax,%eax
  803e50:	74 13                	je     803e65 <dhcp_stop+0x31>
      udp_remove(dhcp->pcb);
  803e52:	83 ec 0c             	sub    $0xc,%esp
  803e55:	50                   	push   %eax
  803e56:	e8 16 53 00 00       	call   809171 <udp_remove>
      dhcp->pcb = NULL;
  803e5b:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
  803e62:	83 c4 10             	add    $0x10,%esp
    if (dhcp->p != NULL) {
  803e65:	8b 43 0c             	mov    0xc(%ebx),%eax
  803e68:	85 c0                	test   %eax,%eax
  803e6a:	74 13                	je     803e7f <dhcp_stop+0x4b>
      pbuf_free(dhcp->p);
  803e6c:	83 ec 0c             	sub    $0xc,%esp
  803e6f:	50                   	push   %eax
  803e70:	e8 b3 0a 00 00       	call   804928 <pbuf_free>
      dhcp->p = NULL;
  803e75:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
  803e7c:	83 c4 10             	add    $0x10,%esp
    dhcp_free_reply(dhcp);
  803e7f:	89 d8                	mov    %ebx,%eax
  803e81:	e8 4f f5 ff ff       	call   8033d5 <dhcp_free_reply>
    mem_free((void *)dhcp);
  803e86:	83 ec 0c             	sub    $0xc,%esp
  803e89:	53                   	push   %ebx
  803e8a:	e8 64 01 00 00       	call   803ff3 <mem_free>
    netif->dhcp = NULL;
  803e8f:	c7 46 20 00 00 00 00 	movl   $0x0,0x20(%esi)
  803e96:	83 c4 10             	add    $0x10,%esp
}
  803e99:	8d 65 f8             	lea    -0x8(%ebp),%esp
  803e9c:	5b                   	pop    %ebx
  803e9d:	5e                   	pop    %esi
  803e9e:	5d                   	pop    %ebp
  803e9f:	c3                   	ret    

00803ea0 <dhcp_start>:
{
  803ea0:	f3 0f 1e fb          	endbr32 
  803ea4:	55                   	push   %ebp
  803ea5:	89 e5                	mov    %esp,%ebp
  803ea7:	56                   	push   %esi
  803ea8:	53                   	push   %ebx
  803ea9:	8b 5d 08             	mov    0x8(%ebp),%ebx
  LWIP_ERROR("netif != NULL", (netif != NULL), return ERR_ARG;);
  803eac:	85 db                	test   %ebx,%ebx
  803eae:	74 73                	je     803f23 <dhcp_start+0x83>
  dhcp = netif->dhcp;
  803eb0:	8b 73 20             	mov    0x20(%ebx),%esi
  netif->flags &= ~NETIF_FLAG_DHCP;
  803eb3:	80 63 2e f7          	andb   $0xf7,0x2e(%ebx)
  if (dhcp == NULL) {
  803eb7:	85 f6                	test   %esi,%esi
  803eb9:	74 7f                	je     803f3a <dhcp_start+0x9a>
  memset(dhcp, 0, sizeof(struct dhcp));
  803ebb:	83 ec 04             	sub    $0x4,%esp
  803ebe:	6a 58                	push   $0x58
  803ec0:	6a 00                	push   $0x0
  803ec2:	56                   	push   %esi
  803ec3:	e8 da b1 00 00       	call   80f0a2 <memset>
  dhcp->pcb = udp_new();
  803ec8:	e8 ec 52 00 00       	call   8091b9 <udp_new>
  803ecd:	89 46 08             	mov    %eax,0x8(%esi)
  if (dhcp->pcb == NULL) {
  803ed0:	83 c4 10             	add    $0x10,%esp
  803ed3:	85 c0                	test   %eax,%eax
  803ed5:	74 7e                	je     803f55 <dhcp_start+0xb5>
  udp_bind(dhcp->pcb, IP_ADDR_ANY, DHCP_CLIENT_PORT);
  803ed7:	83 ec 04             	sub    $0x4,%esp
  803eda:	6a 44                	push   $0x44
  803edc:	68 a8 22 81 00       	push   $0x8122a8
  803ee1:	50                   	push   %eax
  803ee2:	e8 1e 4f 00 00       	call   808e05 <udp_bind>
  udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  803ee7:	83 c4 0c             	add    $0xc,%esp
  803eea:	6a 43                	push   $0x43
  803eec:	68 a8 22 81 00       	push   $0x8122a8
  803ef1:	ff 76 08             	pushl  0x8(%esi)
  803ef4:	e8 cc 51 00 00       	call   8090c5 <udp_connect>
  udp_recv(dhcp->pcb, dhcp_recv, netif);
  803ef9:	83 c4 0c             	add    $0xc,%esp
  803efc:	53                   	push   %ebx
  803efd:	68 1d 34 80 00       	push   $0x80341d
  803f02:	ff 76 08             	pushl  0x8(%esi)
  803f05:	e8 4f 52 00 00       	call   809159 <udp_recv>
  result = dhcp_discover(netif);
  803f0a:	89 d8                	mov    %ebx,%eax
  803f0c:	e8 18 f0 ff ff       	call   802f29 <dhcp_discover>
  if (result != ERR_OK) {
  803f11:	83 c4 10             	add    $0x10,%esp
  803f14:	84 c0                	test   %al,%al
  803f16:	75 57                	jne    803f6f <dhcp_start+0xcf>
  netif->flags |= NETIF_FLAG_DHCP;
  803f18:	80 4b 2e 08          	orb    $0x8,0x2e(%ebx)
}
  803f1c:	8d 65 f8             	lea    -0x8(%ebp),%esp
  803f1f:	5b                   	pop    %ebx
  803f20:	5e                   	pop    %esi
  803f21:	5d                   	pop    %ebp
  803f22:	c3                   	ret    
  LWIP_ERROR("netif != NULL", (netif != NULL), return ERR_ARG;);
  803f23:	83 ec 04             	sub    $0x4,%esp
  803f26:	68 22 1a 81 00       	push   $0x811a22
  803f2b:	68 38 02 00 00       	push   $0x238
  803f30:	68 02 1a 81 00       	push   $0x811a02
  803f35:	e8 0d a9 00 00       	call   80e847 <_panic>
    dhcp = mem_malloc(sizeof(struct dhcp));
  803f3a:	83 ec 0c             	sub    $0xc,%esp
  803f3d:	6a 58                	push   $0x58
  803f3f:	e8 a6 03 00 00       	call   8042ea <mem_malloc>
  803f44:	89 c6                	mov    %eax,%esi
    if (dhcp == NULL) {
  803f46:	83 c4 10             	add    $0x10,%esp
  803f49:	85 c0                	test   %eax,%eax
  803f4b:	74 35                	je     803f82 <dhcp_start+0xe2>
    netif->dhcp = dhcp;
  803f4d:	89 43 20             	mov    %eax,0x20(%ebx)
  803f50:	e9 66 ff ff ff       	jmp    803ebb <dhcp_start+0x1b>
    mem_free((void *)dhcp);
  803f55:	83 ec 0c             	sub    $0xc,%esp
  803f58:	56                   	push   %esi
  803f59:	e8 95 00 00 00       	call   803ff3 <mem_free>
    netif->dhcp = dhcp = NULL;
  803f5e:	c7 43 20 00 00 00 00 	movl   $0x0,0x20(%ebx)
    return ERR_MEM;
  803f65:	83 c4 10             	add    $0x10,%esp
  803f68:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  803f6d:	eb ad                	jmp    803f1c <dhcp_start+0x7c>
    dhcp_stop(netif);
  803f6f:	83 ec 0c             	sub    $0xc,%esp
  803f72:	53                   	push   %ebx
  803f73:	e8 bc fe ff ff       	call   803e34 <dhcp_stop>
    return ERR_MEM;
  803f78:	83 c4 10             	add    $0x10,%esp
  803f7b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  803f80:	eb 9a                	jmp    803f1c <dhcp_start+0x7c>
      return ERR_MEM;
  803f82:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  803f87:	eb 93                	jmp    803f1c <dhcp_start+0x7c>

00803f89 <mem_init>:
/**
 * Zero the heap and initialize start, end and lowest-free
 */
void
mem_init(void)
{
  803f89:	f3 0f 1e fb          	endbr32 
  803f8d:	55                   	push   %ebp
  803f8e:	89 e5                	mov    %esp,%ebp
  803f90:	83 ec 14             	sub    $0x14,%esp

  LWIP_ASSERT("Sanity check alignment",
    (SIZEOF_STRUCT_MEM & (MEM_ALIGNMENT-1)) == 0);

  /* align the heap */
  ram = LWIP_MEM_ALIGN(ram_heap);
  803f93:	b8 23 53 81 00       	mov    $0x815323,%eax
  803f98:	83 e0 fc             	and    $0xfffffffc,%eax
  803f9b:	a3 0c 53 81 00       	mov    %eax,0x81530c
  /* initialize the start of the heap */
  mem = (struct mem *)ram;
  mem->next = MEM_SIZE_ALIGNED;
  803fa0:	c7 00 00 00 22 00    	movl   $0x220000,(%eax)
  mem->prev = 0;
  803fa6:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  mem->used = 0;
  803fad:	c6 40 08 00          	movb   $0x0,0x8(%eax)
  /* initialize the end of the heap */
  ram_end = (struct mem *)&ram[MEM_SIZE_ALIGNED];
  803fb1:	8d 90 00 00 22 00    	lea    0x220000(%eax),%edx
  803fb7:	89 15 08 53 81 00    	mov    %edx,0x815308
  ram_end->used = 1;
  803fbd:	c6 80 08 00 22 00 01 	movb   $0x1,0x220008(%eax)
  ram_end->next = MEM_SIZE_ALIGNED;
  803fc4:	c7 80 00 00 22 00 00 	movl   $0x220000,0x220000(%eax)
  803fcb:	00 22 00 
  ram_end->prev = MEM_SIZE_ALIGNED;
  803fce:	c7 80 04 00 22 00 00 	movl   $0x220000,0x220004(%eax)
  803fd5:	00 22 00 

  mem_sem = sys_sem_new(1);
  803fd8:	6a 01                	push   $0x1
  803fda:	e8 ce 5f 00 00       	call   809fad <sys_sem_new>
  803fdf:	a3 00 53 81 00       	mov    %eax,0x815300

  /* initialize the lowest-free pointer to the start of the heap */
  lfree = (struct mem *)ram;
  803fe4:	a1 0c 53 81 00       	mov    0x81530c,%eax
  803fe9:	a3 04 53 81 00       	mov    %eax,0x815304

  MEM_STATS_AVAIL(avail, MEM_SIZE_ALIGNED);
}
  803fee:	83 c4 10             	add    $0x10,%esp
  803ff1:	c9                   	leave  
  803ff2:	c3                   	ret    

00803ff3 <mem_free>:
 * @param rmem is the data portion of a struct mem as returned by a previous
 *             call to mem_malloc()
 */
void
mem_free(void *rmem)
{
  803ff3:	f3 0f 1e fb          	endbr32 
  803ff7:	55                   	push   %ebp
  803ff8:	89 e5                	mov    %esp,%ebp
  803ffa:	56                   	push   %esi
  803ffb:	53                   	push   %ebx
  803ffc:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct mem *mem;
  LWIP_MEM_FREE_DECL_PROTECT();

  if (rmem == NULL) {
  803fff:	85 db                	test   %ebx,%ebx
  804001:	0f 84 e1 00 00 00    	je     8040e8 <mem_free+0xf5>
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_TRACE | 2, ("mem_free(p == NULL) was called.\n"));
    return;
  }
  LWIP_ASSERT("mem_free: sanity check alignment", (((mem_ptr_t)rmem) & (MEM_ALIGNMENT-1)) == 0);
  804007:	f6 c3 03             	test   $0x3,%bl
  80400a:	0f 85 df 00 00 00    	jne    8040ef <mem_free+0xfc>

  LWIP_ASSERT("mem_free: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
  804010:	39 1d 0c 53 81 00    	cmp    %ebx,0x81530c
  804016:	0f 87 ea 00 00 00    	ja     804106 <mem_free+0x113>
  80401c:	39 1d 08 53 81 00    	cmp    %ebx,0x815308
  804022:	0f 86 de 00 00 00    	jbe    804106 <mem_free+0x113>
    MEM_STATS_INC(illegal);
    SYS_ARCH_UNPROTECT(lev);
    return;
  }
  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();
  804028:	83 ec 08             	sub    $0x8,%esp
  80402b:	6a 00                	push   $0x0
  80402d:	ff 35 00 53 81 00    	pushl  0x815300
  804033:	e8 b6 62 00 00       	call   80a2ee <sys_arch_sem_wait>
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
  804038:	8d 43 f4             	lea    -0xc(%ebx),%eax
  /* ... which has to be in a used state ... */
  LWIP_ASSERT("mem_free: mem->used", mem->used);
  80403b:	83 c4 10             	add    $0x10,%esp
  80403e:	80 7b fc 00          	cmpb   $0x0,-0x4(%ebx)
  804042:	0f 84 d5 00 00 00    	je     80411d <mem_free+0x12a>
  /* ... and is now unused. */
  mem->used = 0;
  804048:	c6 43 fc 00          	movb   $0x0,-0x4(%ebx)

  if (mem < lfree) {
  80404c:	39 05 04 53 81 00    	cmp    %eax,0x815304
  804052:	76 05                	jbe    804059 <mem_free+0x66>
    /* the newly freed struct is now the lowest */
    lfree = mem;
  804054:	a3 04 53 81 00       	mov    %eax,0x815304
  LWIP_ASSERT("plug_holes: mem >= ram", (u8_t *)mem >= ram);
  804059:	8b 0d 0c 53 81 00    	mov    0x81530c,%ecx
  80405f:	39 c8                	cmp    %ecx,%eax
  804061:	0f 82 cd 00 00 00    	jb     804134 <mem_free+0x141>
  LWIP_ASSERT("plug_holes: mem < ram_end", (u8_t *)mem < (u8_t *)ram_end);
  804067:	8b 35 08 53 81 00    	mov    0x815308,%esi
  80406d:	39 f0                	cmp    %esi,%eax
  80406f:	0f 83 d6 00 00 00    	jae    80414b <mem_free+0x158>
  LWIP_ASSERT("plug_holes: mem->next <= MEM_SIZE_ALIGNED", mem->next <= MEM_SIZE_ALIGNED);
  804075:	8b 53 f4             	mov    -0xc(%ebx),%edx
  804078:	81 fa 00 00 22 00    	cmp    $0x220000,%edx
  80407e:	0f 87 de 00 00 00    	ja     804162 <mem_free+0x16f>
  nmem = (struct mem *)&ram[mem->next];
  804084:	01 ca                	add    %ecx,%edx
  if (mem != nmem && nmem->used == 0 && (u8_t *)nmem != (u8_t *)ram_end) {
  804086:	39 d0                	cmp    %edx,%eax
  804088:	74 25                	je     8040af <mem_free+0xbc>
  80408a:	80 7a 08 00          	cmpb   $0x0,0x8(%edx)
  80408e:	75 1f                	jne    8040af <mem_free+0xbc>
  804090:	39 d6                	cmp    %edx,%esi
  804092:	74 1b                	je     8040af <mem_free+0xbc>
    if (lfree == nmem) {
  804094:	3b 15 04 53 81 00    	cmp    0x815304,%edx
  80409a:	0f 84 d9 00 00 00    	je     804179 <mem_free+0x186>
    mem->next = nmem->next;
  8040a0:	8b 32                	mov    (%edx),%esi
  8040a2:	89 73 f4             	mov    %esi,-0xc(%ebx)
    ((struct mem *)&ram[nmem->next])->prev = (u8_t *)mem - ram;
  8040a5:	8b 12                	mov    (%edx),%edx
  8040a7:	89 c6                	mov    %eax,%esi
  8040a9:	29 ce                	sub    %ecx,%esi
  8040ab:	89 74 11 04          	mov    %esi,0x4(%ecx,%edx,1)
  pmem = (struct mem *)&ram[mem->prev];
  8040af:	8b 73 f8             	mov    -0x8(%ebx),%esi
  8040b2:	8d 14 31             	lea    (%ecx,%esi,1),%edx
  if (pmem != mem && pmem->used == 0) {
  8040b5:	39 d0                	cmp    %edx,%eax
  8040b7:	74 1e                	je     8040d7 <mem_free+0xe4>
  8040b9:	80 7a 08 00          	cmpb   $0x0,0x8(%edx)
  8040bd:	75 18                	jne    8040d7 <mem_free+0xe4>
    if (lfree == mem) {
  8040bf:	3b 05 04 53 81 00    	cmp    0x815304,%eax
  8040c5:	0f 84 b8 00 00 00    	je     804183 <mem_free+0x190>
    pmem->next = mem->next;
  8040cb:	8b 43 f4             	mov    -0xc(%ebx),%eax
  8040ce:	89 02                	mov    %eax,(%edx)
    ((struct mem *)&ram[mem->next])->prev = (u8_t *)pmem - ram;
  8040d0:	8b 43 f4             	mov    -0xc(%ebx),%eax
  8040d3:	89 74 01 04          	mov    %esi,0x4(%ecx,%eax,1)
  /* finally, see if prev or next are free also */
  plug_holes(mem);
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
  8040d7:	83 ec 0c             	sub    $0xc,%esp
  8040da:	ff 35 00 53 81 00    	pushl  0x815300
  8040e0:	e8 95 61 00 00       	call   80a27a <sys_sem_signal>
  8040e5:	83 c4 10             	add    $0x10,%esp
}
  8040e8:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8040eb:	5b                   	pop    %ebx
  8040ec:	5e                   	pop    %esi
  8040ed:	5d                   	pop    %ebp
  8040ee:	c3                   	ret    
  LWIP_ASSERT("mem_free: sanity check alignment", (((mem_ptr_t)rmem) & (MEM_ALIGNMENT-1)) == 0);
  8040ef:	83 ec 04             	sub    $0x4,%esp
  8040f2:	68 74 1a 81 00       	push   $0x811a74
  8040f7:	68 30 01 00 00       	push   $0x130
  8040fc:	68 6b 1b 81 00       	push   $0x811b6b
  804101:	e8 41 a7 00 00       	call   80e847 <_panic>
  LWIP_ASSERT("mem_free: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
  804106:	83 ec 04             	sub    $0x4,%esp
  804109:	68 7f 1b 81 00       	push   $0x811b7f
  80410e:	68 32 01 00 00       	push   $0x132
  804113:	68 6b 1b 81 00       	push   $0x811b6b
  804118:	e8 2a a7 00 00       	call   80e847 <_panic>
  LWIP_ASSERT("mem_free: mem->used", mem->used);
  80411d:	83 ec 04             	sub    $0x4,%esp
  804120:	68 96 1b 81 00       	push   $0x811b96
  804125:	68 43 01 00 00       	push   $0x143
  80412a:	68 6b 1b 81 00       	push   $0x811b6b
  80412f:	e8 13 a7 00 00       	call   80e847 <_panic>
  LWIP_ASSERT("plug_holes: mem >= ram", (u8_t *)mem >= ram);
  804134:	83 ec 04             	sub    $0x4,%esp
  804137:	68 aa 1b 81 00       	push   $0x811baa
  80413c:	68 e3 00 00 00       	push   $0xe3
  804141:	68 6b 1b 81 00       	push   $0x811b6b
  804146:	e8 fc a6 00 00       	call   80e847 <_panic>
  LWIP_ASSERT("plug_holes: mem < ram_end", (u8_t *)mem < (u8_t *)ram_end);
  80414b:	83 ec 04             	sub    $0x4,%esp
  80414e:	68 c1 1b 81 00       	push   $0x811bc1
  804153:	68 e4 00 00 00       	push   $0xe4
  804158:	68 6b 1b 81 00       	push   $0x811b6b
  80415d:	e8 e5 a6 00 00       	call   80e847 <_panic>
  LWIP_ASSERT("plug_holes: mem->next <= MEM_SIZE_ALIGNED", mem->next <= MEM_SIZE_ALIGNED);
  804162:	83 ec 04             	sub    $0x4,%esp
  804165:	68 98 1a 81 00       	push   $0x811a98
  80416a:	68 e8 00 00 00       	push   $0xe8
  80416f:	68 6b 1b 81 00       	push   $0x811b6b
  804174:	e8 ce a6 00 00       	call   80e847 <_panic>
      lfree = mem;
  804179:	a3 04 53 81 00       	mov    %eax,0x815304
  80417e:	e9 1d ff ff ff       	jmp    8040a0 <mem_free+0xad>
      lfree = pmem;
  804183:	89 15 04 53 81 00    	mov    %edx,0x815304
  804189:	e9 3d ff ff ff       	jmp    8040cb <mem_free+0xd8>

0080418e <mem_realloc>:
 *         or NULL if newsize is > old size, in which case rmem is NOT touched
 *         or freed!
 */
void *
mem_realloc(void *rmem, mem_size_t newsize)
{
  80418e:	f3 0f 1e fb          	endbr32 
  804192:	55                   	push   %ebp
  804193:	89 e5                	mov    %esp,%ebp
  804195:	57                   	push   %edi
  804196:	56                   	push   %esi
  804197:	53                   	push   %ebx
  804198:	83 ec 1c             	sub    $0x1c,%esp
  80419b:	8b 75 08             	mov    0x8(%ebp),%esi
  /* use the FREE_PROTECT here: it protects with sem OR SYS_ARCH_PROTECT */
  LWIP_MEM_FREE_DECL_PROTECT();

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  newsize = LWIP_MEM_ALIGN_SIZE(newsize);
  80419e:	8b 45 0c             	mov    0xc(%ebp),%eax
  8041a1:	8d 58 03             	lea    0x3(%eax),%ebx
  8041a4:	83 e3 fc             	and    $0xfffffffc,%ebx

  if(newsize < MIN_SIZE_ALIGNED) {
  8041a7:	83 fb 0b             	cmp    $0xb,%ebx
  8041aa:	76 12                	jbe    8041be <mem_realloc+0x30>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    newsize = MIN_SIZE_ALIGNED;
  }

  if (newsize > MEM_SIZE_ALIGNED) {
  8041ac:	81 fb 00 00 22 00    	cmp    $0x220000,%ebx
  8041b2:	76 0f                	jbe    8041c3 <mem_realloc+0x35>
    return NULL;
  8041b4:	be 00 00 00 00       	mov    $0x0,%esi
  8041b9:	e9 a1 00 00 00       	jmp    80425f <mem_realloc+0xd1>
    newsize = MIN_SIZE_ALIGNED;
  8041be:	bb 0c 00 00 00       	mov    $0xc,%ebx
  }

  LWIP_ASSERT("mem_realloc: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
  8041c3:	a1 0c 53 81 00       	mov    0x81530c,%eax
  8041c8:	39 f0                	cmp    %esi,%eax
  8041ca:	0f 87 99 00 00 00    	ja     804269 <mem_realloc+0xdb>
  8041d0:	39 35 08 53 81 00    	cmp    %esi,0x815308
  8041d6:	0f 86 8d 00 00 00    	jbe    804269 <mem_realloc+0xdb>
    MEM_STATS_INC(illegal);
    SYS_ARCH_UNPROTECT(lev);
    return rmem;
  }
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
  8041dc:	8d 56 f4             	lea    -0xc(%esi),%edx
  /* ... and its offset pointer */
  ptr = (u8_t *)mem - ram;
  8041df:	29 c2                	sub    %eax,%edx
  8041e1:	89 55 e4             	mov    %edx,-0x1c(%ebp)

  size = mem->next - ptr - SIZEOF_STRUCT_MEM;
  8041e4:	8b 4e f4             	mov    -0xc(%esi),%ecx
  8041e7:	8d 79 f4             	lea    -0xc(%ecx),%edi
  8041ea:	29 d7                	sub    %edx,%edi
  LWIP_ASSERT("mem_realloc can only shrink memory", newsize <= size);
  8041ec:	39 df                	cmp    %ebx,%edi
  8041ee:	0f 82 8c 00 00 00    	jb     804280 <mem_realloc+0xf2>
  if (newsize > size) {
    /* not supported */
    return NULL;
  }
  if (newsize == size) {
  8041f4:	74 69                	je     80425f <mem_realloc+0xd1>
    /* No change in size, simply return */
    return rmem;
  }

  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();
  8041f6:	83 ec 08             	sub    $0x8,%esp
  8041f9:	6a 00                	push   $0x0
  8041fb:	ff 35 00 53 81 00    	pushl  0x815300
  804201:	e8 e8 60 00 00       	call   80a2ee <sys_arch_sem_wait>

  MEM_STATS_DEC_USED(used, (size - newsize));

  mem2 = (struct mem *)&ram[mem->next];
  804206:	a1 0c 53 81 00       	mov    0x81530c,%eax
  80420b:	89 c2                	mov    %eax,%edx
  80420d:	03 56 f4             	add    -0xc(%esi),%edx
  if(mem2->used == 0) {
  804210:	83 c4 10             	add    $0x10,%esp
  804213:	80 7a 08 00          	cmpb   $0x0,0x8(%edx)
  804217:	0f 85 85 00 00 00    	jne    8042a2 <mem_realloc+0x114>
    /* The next struct is unused, we can simply move it at little */
    mem_size_t next;
    /* remember the old next pointer */
    next = mem2->next;
  80421d:	8b 0a                	mov    (%edx),%ecx
    /* create new struct mem which is moved directly after the shrinked mem */
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
  80421f:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  804222:	8d 5c 3b 0c          	lea    0xc(%ebx,%edi,1),%ebx
    if (lfree == mem2) {
  804226:	39 15 04 53 81 00    	cmp    %edx,0x815304
  80422c:	74 69                	je     804297 <mem_realloc+0x109>
      lfree = (struct mem *)&ram[ptr2];
    }
    mem2 = (struct mem *)&ram[ptr2];
  80422e:	8d 14 18             	lea    (%eax,%ebx,1),%edx
    mem2->used = 0;
  804231:	c6 42 08 00          	movb   $0x0,0x8(%edx)
    /* restore the next pointer */
    mem2->next = next;
  804235:	89 0a                	mov    %ecx,(%edx)
    /* link it back to mem */
    mem2->prev = ptr;
  804237:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  80423a:	89 4a 04             	mov    %ecx,0x4(%edx)
    /* link mem to it */
    mem->next = ptr2;
  80423d:	89 5e f4             	mov    %ebx,-0xc(%esi)
    /* last thing to restore linked list: as we have moved mem2,
     * let 'mem2->next->prev' point to mem2 again. but only if mem2->next is not
     * the end of the heap */
    if (mem2->next != MEM_SIZE_ALIGNED) {
  804240:	8b 12                	mov    (%edx),%edx
  804242:	81 fa 00 00 22 00    	cmp    $0x220000,%edx
  804248:	74 04                	je     80424e <mem_realloc+0xc0>
      ((struct mem *)&ram[mem2->next])->prev = ptr2;
  80424a:	89 5c 10 04          	mov    %ebx,0x4(%eax,%edx,1)
    -> the remaining space stays unused since it is too small
  } */
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
  80424e:	83 ec 0c             	sub    $0xc,%esp
  804251:	ff 35 00 53 81 00    	pushl  0x815300
  804257:	e8 1e 60 00 00       	call   80a27a <sys_sem_signal>
  return rmem;
  80425c:	83 c4 10             	add    $0x10,%esp
}
  80425f:	89 f0                	mov    %esi,%eax
  804261:	8d 65 f4             	lea    -0xc(%ebp),%esp
  804264:	5b                   	pop    %ebx
  804265:	5e                   	pop    %esi
  804266:	5f                   	pop    %edi
  804267:	5d                   	pop    %ebp
  804268:	c3                   	ret    
  LWIP_ASSERT("mem_realloc: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
  804269:	83 ec 04             	sub    $0x4,%esp
  80426c:	68 db 1b 81 00       	push   $0x811bdb
  804271:	68 78 01 00 00       	push   $0x178
  804276:	68 6b 1b 81 00       	push   $0x811b6b
  80427b:	e8 c7 a5 00 00       	call   80e847 <_panic>
  LWIP_ASSERT("mem_realloc can only shrink memory", newsize <= size);
  804280:	83 ec 04             	sub    $0x4,%esp
  804283:	68 c4 1a 81 00       	push   $0x811ac4
  804288:	68 8a 01 00 00       	push   $0x18a
  80428d:	68 6b 1b 81 00       	push   $0x811b6b
  804292:	e8 b0 a5 00 00       	call   80e847 <_panic>
      lfree = (struct mem *)&ram[ptr2];
  804297:	8d 14 18             	lea    (%eax,%ebx,1),%edx
  80429a:	89 15 04 53 81 00    	mov    %edx,0x815304
  8042a0:	eb 8c                	jmp    80422e <mem_realloc+0xa0>
  } else if (newsize + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED <= size) {
  8042a2:	8d 53 18             	lea    0x18(%ebx),%edx
  8042a5:	39 fa                	cmp    %edi,%edx
  8042a7:	77 a5                	ja     80424e <mem_realloc+0xc0>
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
  8042a9:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  8042ac:	8d 4c 0b 0c          	lea    0xc(%ebx,%ecx,1),%ecx
    mem2 = (struct mem *)&ram[ptr2];
  8042b0:	8d 14 08             	lea    (%eax,%ecx,1),%edx
    if (mem2 < lfree) {
  8042b3:	39 15 04 53 81 00    	cmp    %edx,0x815304
  8042b9:	76 06                	jbe    8042c1 <mem_realloc+0x133>
      lfree = mem2;
  8042bb:	89 15 04 53 81 00    	mov    %edx,0x815304
    mem2->used = 0;
  8042c1:	c6 42 08 00          	movb   $0x0,0x8(%edx)
    mem2->next = mem->next;
  8042c5:	8b 5e f4             	mov    -0xc(%esi),%ebx
  8042c8:	89 1a                	mov    %ebx,(%edx)
    mem2->prev = ptr;
  8042ca:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  8042cd:	89 7a 04             	mov    %edi,0x4(%edx)
    mem->next = ptr2;
  8042d0:	89 4e f4             	mov    %ecx,-0xc(%esi)
    if (mem2->next != MEM_SIZE_ALIGNED) {
  8042d3:	8b 12                	mov    (%edx),%edx
  8042d5:	81 fa 00 00 22 00    	cmp    $0x220000,%edx
  8042db:	0f 84 6d ff ff ff    	je     80424e <mem_realloc+0xc0>
      ((struct mem *)&ram[mem2->next])->prev = ptr2;
  8042e1:	89 4c 10 04          	mov    %ecx,0x4(%eax,%edx,1)
  8042e5:	e9 64 ff ff ff       	jmp    80424e <mem_realloc+0xc0>

008042ea <mem_malloc>:
 *
 * Note that the returned value will always be aligned (as defined by MEM_ALIGNMENT).
 */
void *
mem_malloc(mem_size_t size)
{
  8042ea:	f3 0f 1e fb          	endbr32 
  8042ee:	55                   	push   %ebp
  8042ef:	89 e5                	mov    %esp,%ebp
  8042f1:	57                   	push   %edi
  8042f2:	56                   	push   %esi
  8042f3:	53                   	push   %ebx
  8042f4:	83 ec 1c             	sub    $0x1c,%esp
  8042f7:	8b 45 08             	mov    0x8(%ebp),%eax
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  u8_t local_mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_ALLOC_DECL_PROTECT();

  if (size == 0) {
  8042fa:	85 c0                	test   %eax,%eax
  8042fc:	0f 84 a1 01 00 00    	je     8044a3 <mem_malloc+0x1b9>
    return NULL;
  }

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  size = LWIP_MEM_ALIGN_SIZE(size);
  804302:	83 c0 03             	add    $0x3,%eax
  804305:	83 e0 fc             	and    $0xfffffffc,%eax
  804308:	89 c7                	mov    %eax,%edi

  if(size < MIN_SIZE_ALIGNED) {
  80430a:	83 f8 0b             	cmp    $0xb,%eax
  80430d:	76 3a                	jbe    804349 <mem_malloc+0x5f>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    size = MIN_SIZE_ALIGNED;
  }

  if (size > MEM_SIZE_ALIGNED) {
  80430f:	3d 00 00 22 00       	cmp    $0x220000,%eax
  804314:	0f 87 90 01 00 00    	ja     8044aa <mem_malloc+0x1c0>
    return NULL;
  }

  /* protect the heap from concurrent access */
  sys_arch_sem_wait(mem_sem, 0);
  80431a:	83 ec 08             	sub    $0x8,%esp
  80431d:	6a 00                	push   $0x0
  80431f:	ff 35 00 53 81 00    	pushl  0x815300
  804325:	e8 c4 5f 00 00       	call   80a2ee <sys_arch_sem_wait>
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (u8_t *)lfree - ram; ptr < MEM_SIZE_ALIGNED - size;
  80432a:	a1 04 53 81 00       	mov    0x815304,%eax
  80432f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  804332:	8b 35 0c 53 81 00    	mov    0x81530c,%esi
  804338:	29 f0                	sub    %esi,%eax
  80433a:	83 c4 10             	add    $0x10,%esp
  80433d:	b9 00 00 22 00       	mov    $0x220000,%ecx
  804342:	29 f9                	sub    %edi,%ecx
  804344:	e9 e3 00 00 00       	jmp    80442c <mem_malloc+0x142>
    size = MIN_SIZE_ALIGNED;
  804349:	bf 0c 00 00 00       	mov    $0xc,%edi
  80434e:	eb ca                	jmp    80431a <mem_malloc+0x30>
           * take care of this).
           * -> near fit or excact fit: do not split, no mem2 creation
           * also can't move mem->next directly behind mem, since mem->next
           * will always be used at this point!
           */
          mem->used = 1;
  804350:	c6 43 08 01          	movb   $0x1,0x8(%ebx)
          MEM_STATS_INC_USED(used, mem->next - ((u8_t *)mem - ram));
        }

        if (mem == lfree) {
  804354:	39 5d e4             	cmp    %ebx,-0x1c(%ebp)
  804357:	74 4d                	je     8043a6 <mem_malloc+0xbc>
            lfree = (struct mem *)&ram[lfree->next];
          }
          LWIP_ASSERT("mem_malloc: !lfree->used", ((lfree == ram_end) || (!lfree->used)));
        }
        LWIP_MEM_ALLOC_UNPROTECT();
        sys_sem_signal(mem_sem);
  804359:	83 ec 0c             	sub    $0xc,%esp
  80435c:	ff 35 00 53 81 00    	pushl  0x815300
  804362:	e8 13 5f 00 00       	call   80a27a <sys_sem_signal>
        LWIP_ASSERT("mem_malloc: allocated memory not above ram_end.",
  804367:	8d 44 3b 0c          	lea    0xc(%ebx,%edi,1),%eax
  80436b:	83 c4 10             	add    $0x10,%esp
  80436e:	39 05 08 53 81 00    	cmp    %eax,0x815308
  804374:	0f 82 82 00 00 00    	jb     8043fc <mem_malloc+0x112>
         (mem_ptr_t)mem + SIZEOF_STRUCT_MEM + size <= (mem_ptr_t)ram_end);
        LWIP_ASSERT("mem_malloc: allocated memory properly aligned.",
  80437a:	8d 43 0c             	lea    0xc(%ebx),%eax
  80437d:	f6 c3 03             	test   $0x3,%bl
  804380:	0f 85 8d 00 00 00    	jne    804413 <mem_malloc+0x129>
         (unsigned long)((u8_t *)mem + SIZEOF_STRUCT_MEM) % MEM_ALIGNMENT == 0);
        LWIP_ASSERT("mem_malloc: sanity check alignment",
  804386:	f6 c3 03             	test   $0x3,%bl
  804389:	0f 84 0c 01 00 00    	je     80449b <mem_malloc+0x1b1>
  80438f:	83 ec 04             	sub    $0x4,%esp
  804392:	68 48 1b 81 00       	push   $0x811b48
  804397:	68 4e 02 00 00       	push   $0x24e
  80439c:	68 6b 1b 81 00       	push   $0x811b6b
  8043a1:	e8 a1 a4 00 00       	call   80e847 <_panic>
          while (lfree->used && lfree != ram_end) {
  8043a6:	8b 15 08 53 81 00    	mov    0x815308,%edx
  8043ac:	b8 00 00 00 00       	mov    $0x0,%eax
            lfree = (struct mem *)&ram[lfree->next];
  8043b1:	b9 01 00 00 00       	mov    $0x1,%ecx
  8043b6:	89 7d e0             	mov    %edi,-0x20(%ebp)
  8043b9:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  8043bc:	eb 08                	jmp    8043c6 <mem_malloc+0xdc>
  8043be:	89 f0                	mov    %esi,%eax
  8043c0:	03 07                	add    (%edi),%eax
  8043c2:	89 c7                	mov    %eax,%edi
  8043c4:	89 c8                	mov    %ecx,%eax
          while (lfree->used && lfree != ram_end) {
  8043c6:	80 7f 08 00          	cmpb   $0x0,0x8(%edi)
  8043ca:	74 18                	je     8043e4 <mem_malloc+0xfa>
  8043cc:	39 fa                	cmp    %edi,%edx
  8043ce:	75 ee                	jne    8043be <mem_malloc+0xd4>
  8043d0:	89 fe                	mov    %edi,%esi
  8043d2:	8b 7d e0             	mov    -0x20(%ebp),%edi
  8043d5:	84 c0                	test   %al,%al
  8043d7:	74 80                	je     804359 <mem_malloc+0x6f>
  8043d9:	89 35 04 53 81 00    	mov    %esi,0x815304
  8043df:	e9 75 ff ff ff       	jmp    804359 <mem_malloc+0x6f>
  8043e4:	89 fe                	mov    %edi,%esi
  8043e6:	8b 7d e0             	mov    -0x20(%ebp),%edi
  8043e9:	84 c0                	test   %al,%al
  8043eb:	0f 84 68 ff ff ff    	je     804359 <mem_malloc+0x6f>
  8043f1:	89 35 04 53 81 00    	mov    %esi,0x815304
  8043f7:	e9 5d ff ff ff       	jmp    804359 <mem_malloc+0x6f>
        LWIP_ASSERT("mem_malloc: allocated memory not above ram_end.",
  8043fc:	83 ec 04             	sub    $0x4,%esp
  8043ff:	68 e8 1a 81 00       	push   $0x811ae8
  804404:	68 4a 02 00 00       	push   $0x24a
  804409:	68 6b 1b 81 00       	push   $0x811b6b
  80440e:	e8 34 a4 00 00       	call   80e847 <_panic>
        LWIP_ASSERT("mem_malloc: allocated memory properly aligned.",
  804413:	83 ec 04             	sub    $0x4,%esp
  804416:	68 18 1b 81 00       	push   $0x811b18
  80441b:	68 4c 02 00 00       	push   $0x24c
  804420:	68 6b 1b 81 00       	push   $0x811b6b
  804425:	e8 1d a4 00 00       	call   80e847 <_panic>
         ptr = ((struct mem *)&ram[ptr])->next) {
  80442a:	8b 03                	mov    (%ebx),%eax
    for (ptr = (u8_t *)lfree - ram; ptr < MEM_SIZE_ALIGNED - size;
  80442c:	39 c1                	cmp    %eax,%ecx
  80442e:	76 55                	jbe    804485 <mem_malloc+0x19b>
      mem = (struct mem *)&ram[ptr];
  804430:	8d 1c 06             	lea    (%esi,%eax,1),%ebx
      if ((!mem->used) &&
  804433:	80 7b 08 00          	cmpb   $0x0,0x8(%ebx)
  804437:	75 f1                	jne    80442a <mem_malloc+0x140>
          (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
  804439:	ba f4 ff ff ff       	mov    $0xfffffff4,%edx
  80443e:	29 c2                	sub    %eax,%edx
  804440:	03 13                	add    (%ebx),%edx
      if ((!mem->used) &&
  804442:	39 fa                	cmp    %edi,%edx
  804444:	72 e4                	jb     80442a <mem_malloc+0x140>
        if (mem->next - (ptr + SIZEOF_STRUCT_MEM) >= (size + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED)) {
  804446:	8d 4f 18             	lea    0x18(%edi),%ecx
  804449:	39 ca                	cmp    %ecx,%edx
  80444b:	0f 82 ff fe ff ff    	jb     804350 <mem_malloc+0x66>
          ptr2 = ptr + SIZEOF_STRUCT_MEM + size;
  804451:	8d 4c 38 0c          	lea    0xc(%eax,%edi,1),%ecx
          mem2 = (struct mem *)&ram[ptr2];
  804455:	89 4d e0             	mov    %ecx,-0x20(%ebp)
  804458:	8d 14 0e             	lea    (%esi,%ecx,1),%edx
          mem2->used = 0;
  80445b:	c6 42 08 00          	movb   $0x0,0x8(%edx)
          mem2->next = mem->next;
  80445f:	8b 0b                	mov    (%ebx),%ecx
  804461:	89 0a                	mov    %ecx,(%edx)
          mem2->prev = ptr;
  804463:	89 42 04             	mov    %eax,0x4(%edx)
          mem->next = ptr2;
  804466:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  804469:	89 0b                	mov    %ecx,(%ebx)
          mem->used = 1;
  80446b:	c6 43 08 01          	movb   $0x1,0x8(%ebx)
          if (mem2->next != MEM_SIZE_ALIGNED) {
  80446f:	8b 02                	mov    (%edx),%eax
  804471:	3d 00 00 22 00       	cmp    $0x220000,%eax
  804476:	0f 84 d8 fe ff ff    	je     804354 <mem_malloc+0x6a>
            ((struct mem *)&ram[mem2->next])->prev = ptr2;
  80447c:	89 4c 06 04          	mov    %ecx,0x4(%esi,%eax,1)
  804480:	e9 cf fe ff ff       	jmp    804354 <mem_malloc+0x6a>
  } while(local_mem_free_count != 0);
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_DEBUGF(MEM_DEBUG | 2, ("mem_malloc: could not allocate %"S16_F" bytes\n", (s16_t)size));
  MEM_STATS_INC(err);
  LWIP_MEM_ALLOC_UNPROTECT();
  sys_sem_signal(mem_sem);
  804485:	83 ec 0c             	sub    $0xc,%esp
  804488:	ff 35 00 53 81 00    	pushl  0x815300
  80448e:	e8 e7 5d 00 00       	call   80a27a <sys_sem_signal>
  return NULL;
  804493:	83 c4 10             	add    $0x10,%esp
  804496:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80449b:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80449e:	5b                   	pop    %ebx
  80449f:	5e                   	pop    %esi
  8044a0:	5f                   	pop    %edi
  8044a1:	5d                   	pop    %ebp
  8044a2:	c3                   	ret    
    return NULL;
  8044a3:	b8 00 00 00 00       	mov    $0x0,%eax
  8044a8:	eb f1                	jmp    80449b <mem_malloc+0x1b1>
    return NULL;
  8044aa:	b8 00 00 00 00       	mov    $0x0,%eax
  8044af:	eb ea                	jmp    80449b <mem_malloc+0x1b1>

008044b1 <mem_calloc>:
 * @param count number of objects to allocate
 * @param size size of the objects to allocate
 * @return pointer to allocated memory / NULL pointer if there is an error
 */
void *mem_calloc(mem_size_t count, mem_size_t size)
{
  8044b1:	f3 0f 1e fb          	endbr32 
  8044b5:	55                   	push   %ebp
  8044b6:	89 e5                	mov    %esp,%ebp
  8044b8:	56                   	push   %esi
  8044b9:	53                   	push   %ebx
  void *p;

  /* allocate 'count' objects of size 'size' */
  p = mem_malloc(count * size);
  8044ba:	8b 75 0c             	mov    0xc(%ebp),%esi
  8044bd:	0f af 75 08          	imul   0x8(%ebp),%esi
  8044c1:	83 ec 0c             	sub    $0xc,%esp
  8044c4:	56                   	push   %esi
  8044c5:	e8 20 fe ff ff       	call   8042ea <mem_malloc>
  8044ca:	89 c3                	mov    %eax,%ebx
  if (p) {
  8044cc:	83 c4 10             	add    $0x10,%esp
  8044cf:	85 c0                	test   %eax,%eax
  8044d1:	74 0f                	je     8044e2 <mem_calloc+0x31>
    /* zero the memory */
    memset(p, 0, count * size);
  8044d3:	83 ec 04             	sub    $0x4,%esp
  8044d6:	56                   	push   %esi
  8044d7:	6a 00                	push   $0x0
  8044d9:	50                   	push   %eax
  8044da:	e8 c3 ab 00 00       	call   80f0a2 <memset>
  8044df:	83 c4 10             	add    $0x10,%esp
  }
  return p;
}
  8044e2:	89 d8                	mov    %ebx,%eax
  8044e4:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8044e7:	5b                   	pop    %ebx
  8044e8:	5e                   	pop    %esi
  8044e9:	5d                   	pop    %ebp
  8044ea:	c3                   	ret    

008044eb <memp_init>:
 * 
 * Carves out memp_memory into linked lists for each pool-type.
 */
void
memp_init(void)
{
  8044eb:	f3 0f 1e fb          	endbr32 
  8044ef:	55                   	push   %ebp
  8044f0:	89 e5                	mov    %esp,%ebp
  8044f2:	56                   	push   %esi
  8044f3:	53                   	push   %ebx
    MEMP_STATS_AVAIL(max, i, 0);
    MEMP_STATS_AVAIL(err, i, 0);
    MEMP_STATS_AVAIL(avail, i, memp_num[i]);
  }

  memp = LWIP_MEM_ALIGN(memp_memory);
  8044f4:	b8 43 53 a3 00       	mov    $0xa35343,%eax
  8044f9:	83 e0 fc             	and    $0xfffffffc,%eax
  8044fc:	ba 00 00 00 00       	mov    $0x0,%edx
  804501:	eb 2a                	jmp    80452d <memp_init+0x42>
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
    memp_tab[i] = NULL;
    /* create a linked list of memp elements */
    for (j = 0; j < memp_num[i]; ++j) {
      memp->next = memp_tab[i];
  804503:	8b 1c 95 c0 43 b3 00 	mov    0xb343c0(,%edx,4),%ebx
  80450a:	89 18                	mov    %ebx,(%eax)
      memp_tab[i] = memp;
  80450c:	89 04 95 c0 43 b3 00 	mov    %eax,0xb343c0(,%edx,4)
      memp = (struct memp *)((u8_t *)memp + MEMP_SIZE + memp_sizes[i]);
  804513:	0f b7 9c 12 88 1c 81 	movzwl 0x811c88(%edx,%edx,1),%ebx
  80451a:	00 
  80451b:	01 d8                	add    %ebx,%eax
    for (j = 0; j < memp_num[i]; ++j) {
  80451d:	83 c1 01             	add    $0x1,%ecx
  804520:	66 39 ce             	cmp    %cx,%si
  804523:	75 de                	jne    804503 <memp_init+0x18>
  804525:	83 c2 01             	add    $0x1,%edx
  for (i = 0; i < MEMP_MAX; ++i) {
  804528:	83 fa 0e             	cmp    $0xe,%edx
  80452b:	74 1a                	je     804547 <memp_init+0x5c>
    memp_tab[i] = NULL;
  80452d:	c7 04 95 c0 43 b3 00 	movl   $0x0,0xb343c0(,%edx,4)
  804534:	00 00 00 00 
    for (j = 0; j < memp_num[i]; ++j) {
  804538:	0f b7 b4 12 6c 1c 81 	movzwl 0x811c6c(%edx,%edx,1),%esi
  80453f:	00 
  804540:	b9 00 00 00 00       	mov    $0x0,%ecx
  804545:	eb d9                	jmp    804520 <memp_init+0x35>
#if MEMP_OVERFLOW_CHECK
  memp_overflow_init();
  /* check everything a first time to see if it worked */
  memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK */
}
  804547:	5b                   	pop    %ebx
  804548:	5e                   	pop    %esi
  804549:	5d                   	pop    %ebp
  80454a:	c3                   	ret    

0080454b <memp_malloc>:
#if !MEMP_OVERFLOW_CHECK
memp_malloc(memp_t type)
#else
memp_malloc_fn(memp_t type, const char* file, const int line)
#endif
{
  80454b:	f3 0f 1e fb          	endbr32 
  80454f:	55                   	push   %ebp
  804550:	89 e5                	mov    %esp,%ebp
  804552:	83 ec 08             	sub    $0x8,%esp
  804555:	8b 55 08             	mov    0x8(%ebp),%edx
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);
 
  LWIP_ERROR("memp_malloc: type < MEMP_MAX", (type < MEMP_MAX), return NULL;);
  804558:	83 fa 0d             	cmp    $0xd,%edx
  80455b:	77 1a                	ja     804577 <memp_malloc+0x2c>
  SYS_ARCH_PROTECT(old_level);
#if MEMP_OVERFLOW_CHECK >= 2
  memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK >= 2 */

  memp = memp_tab[type];
  80455d:	8b 04 95 c0 43 b3 00 	mov    0xb343c0(,%edx,4),%eax
  
  if (memp != NULL) {    
  804564:	85 c0                	test   %eax,%eax
  804566:	74 0d                	je     804575 <memp_malloc+0x2a>
    memp_tab[type] = memp->next;    
  804568:	8b 08                	mov    (%eax),%ecx
  80456a:	89 0c 95 c0 43 b3 00 	mov    %ecx,0xb343c0(,%edx,4)
    memp->next = NULL;
    memp->file = file;
    memp->line = line;
#endif /* MEMP_OVERFLOW_CHECK */
    MEMP_STATS_INC_USED(used, type);
    LWIP_ASSERT("memp_malloc: memp properly aligned",
  804571:	a8 03                	test   $0x3,%al
  804573:	75 19                	jne    80458e <memp_malloc+0x43>
  }

  SYS_ARCH_UNPROTECT(old_level);

  return memp;
}
  804575:	c9                   	leave  
  804576:	c3                   	ret    
  LWIP_ERROR("memp_malloc: type < MEMP_MAX", (type < MEMP_MAX), return NULL;);
  804577:	83 ec 04             	sub    $0x4,%esp
  80457a:	68 f5 1b 81 00       	push   $0x811bf5
  80457f:	68 2d 01 00 00       	push   $0x12d
  804584:	68 12 1c 81 00       	push   $0x811c12
  804589:	e8 b9 a2 00 00       	call   80e847 <_panic>
    LWIP_ASSERT("memp_malloc: memp properly aligned",
  80458e:	83 ec 04             	sub    $0x4,%esp
  804591:	68 28 1c 81 00       	push   $0x811c28
  804596:	68 3e 01 00 00       	push   $0x13e
  80459b:	68 12 1c 81 00       	push   $0x811c12
  8045a0:	e8 a2 a2 00 00       	call   80e847 <_panic>

008045a5 <memp_free>:
 * @param type the pool where to put mem
 * @param mem the memp element to free
 */
void
memp_free(memp_t type, void *mem)
{
  8045a5:	f3 0f 1e fb          	endbr32 
  8045a9:	55                   	push   %ebp
  8045aa:	89 e5                	mov    %esp,%ebp
  8045ac:	83 ec 08             	sub    $0x8,%esp
  8045af:	8b 55 08             	mov    0x8(%ebp),%edx
  8045b2:	8b 45 0c             	mov    0xc(%ebp),%eax
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);

  if (mem == NULL) {
  8045b5:	85 c0                	test   %eax,%eax
  8045b7:	74 14                	je     8045cd <memp_free+0x28>
    return;
  }
  LWIP_ASSERT("memp_free: mem properly aligned",
  8045b9:	a8 03                	test   $0x3,%al
  8045bb:	75 12                	jne    8045cf <memp_free+0x2a>
#endif /* MEMP_OVERFLOW_CHECK >= 2 */
#endif /* MEMP_OVERFLOW_CHECK */

  MEMP_STATS_DEC(used, type); 
  
  memp->next = memp_tab[type]; 
  8045bd:	8b 0c 95 c0 43 b3 00 	mov    0xb343c0(,%edx,4),%ecx
  8045c4:	89 08                	mov    %ecx,(%eax)
  memp_tab[type] = memp;
  8045c6:	89 04 95 c0 43 b3 00 	mov    %eax,0xb343c0(,%edx,4)
#if MEMP_SANITY_CHECK
  LWIP_ASSERT("memp sanity", memp_sanity());
#endif /* MEMP_SANITY_CHECK */

  SYS_ARCH_UNPROTECT(old_level);
}
  8045cd:	c9                   	leave  
  8045ce:	c3                   	ret    
  LWIP_ASSERT("memp_free: mem properly aligned",
  8045cf:	83 ec 04             	sub    $0x4,%esp
  8045d2:	68 4c 1c 81 00       	push   $0x811c4c
  8045d7:	68 5a 01 00 00       	push   $0x15a
  8045dc:	68 12 1c 81 00       	push   $0x811c12
  8045e1:	e8 61 a2 00 00       	call   80e847 <_panic>

008045e6 <netif_remove>:
 * Remove a network interface from the list of lwIP netifs.
 *
 * @param netif the network interface to remove
 */
void netif_remove(struct netif * netif)
{
  8045e6:	f3 0f 1e fb          	endbr32 
  8045ea:	55                   	push   %ebp
  8045eb:	89 e5                	mov    %esp,%ebp
  8045ed:	8b 4d 08             	mov    0x8(%ebp),%ecx
  if ( netif == NULL ) return;
  8045f0:	85 c9                	test   %ecx,%ecx
  8045f2:	74 2c                	je     804620 <netif_remove+0x3a>
#endif /* LWIP_IGMP */

  snmp_delete_ipaddridx_tree(netif);

  /*  is it the first netif? */
  if (netif_list == netif) {
  8045f4:	a1 34 b2 b3 00       	mov    0xb3b234,%eax
  8045f9:	39 c8                	cmp    %ecx,%eax
  8045fb:	74 0e                	je     80460b <netif_remove+0x25>
    snmp_dec_iflist();
  }
  else {
    /*  look for netif further down the list */
    struct netif * tmpNetif;
    for (tmpNetif = netif_list; tmpNetif != NULL; tmpNetif = tmpNetif->next) {
  8045fd:	85 c0                	test   %eax,%eax
  8045ff:	74 1f                	je     804620 <netif_remove+0x3a>
      if (tmpNetif->next == netif) {
  804601:	8b 10                	mov    (%eax),%edx
  804603:	39 ca                	cmp    %ecx,%edx
  804605:	74 0d                	je     804614 <netif_remove+0x2e>
    for (tmpNetif = netif_list; tmpNetif != NULL; tmpNetif = tmpNetif->next) {
  804607:	89 d0                	mov    %edx,%eax
  804609:	eb f2                	jmp    8045fd <netif_remove+0x17>
    netif_list = netif->next;
  80460b:	8b 01                	mov    (%ecx),%eax
  80460d:	a3 34 b2 b3 00       	mov    %eax,0xb3b234
  804612:	eb 04                	jmp    804618 <netif_remove+0x32>
        tmpNetif->next = netif->next;
  804614:	8b 11                	mov    (%ecx),%edx
  804616:	89 10                	mov    %edx,(%eax)
    }
    if (tmpNetif == NULL)
      return; /*  we didn't find any netif today */
  }
  /* this netif is default? */
  if (netif_default == netif)
  804618:	39 0d 38 b2 b3 00    	cmp    %ecx,0xb3b238
  80461e:	74 02                	je     804622 <netif_remove+0x3c>
    /* reset default netif */
    netif_set_default(NULL);
  LWIP_DEBUGF( NETIF_DEBUG, ("netif_remove: removed netif\n") );
}
  804620:	5d                   	pop    %ebp
  804621:	c3                   	ret    
  else
  {
    /* install default route */
    snmp_insert_iprteidx_tree(1, netif);
  }
  netif_default = netif;
  804622:	c7 05 38 b2 b3 00 00 	movl   $0x0,0xb3b238
  804629:	00 00 00 
  LWIP_DEBUGF(NETIF_DEBUG, ("netif: setting default interface %c%c\n",
           netif ? netif->name[0] : '\'', netif ? netif->name[1] : '\''));
}
  80462c:	eb f2                	jmp    804620 <netif_remove+0x3a>

0080462e <netif_find>:
{
  80462e:	f3 0f 1e fb          	endbr32 
  804632:	55                   	push   %ebp
  804633:	89 e5                	mov    %esp,%ebp
  804635:	53                   	push   %ebx
  804636:	8b 4d 08             	mov    0x8(%ebp),%ecx
  if (name == NULL) {
  804639:	85 c9                	test   %ecx,%ecx
  80463b:	74 2d                	je     80466a <netif_find+0x3c>
  num = name[2] - '0';
  80463d:	0f b6 41 02          	movzbl 0x2(%ecx),%eax
  804641:	8d 50 d0             	lea    -0x30(%eax),%edx
  for(netif = netif_list; netif != NULL; netif = netif->next) {
  804644:	a1 34 b2 b3 00       	mov    0xb3b234,%eax
  804649:	eb 02                	jmp    80464d <netif_find+0x1f>
  80464b:	8b 00                	mov    (%eax),%eax
  80464d:	85 c0                	test   %eax,%eax
  80464f:	74 16                	je     804667 <netif_find+0x39>
    if (num == netif->num &&
  804651:	38 50 31             	cmp    %dl,0x31(%eax)
  804654:	75 f5                	jne    80464b <netif_find+0x1d>
  804656:	0f b6 58 2f          	movzbl 0x2f(%eax),%ebx
  80465a:	38 19                	cmp    %bl,(%ecx)
  80465c:	75 ed                	jne    80464b <netif_find+0x1d>
       name[0] == netif->name[0] &&
  80465e:	0f b6 58 30          	movzbl 0x30(%eax),%ebx
  804662:	38 59 01             	cmp    %bl,0x1(%ecx)
  804665:	75 e4                	jne    80464b <netif_find+0x1d>
}
  804667:	5b                   	pop    %ebx
  804668:	5d                   	pop    %ebp
  804669:	c3                   	ret    
    return NULL;
  80466a:	89 c8                	mov    %ecx,%eax
  80466c:	eb f9                	jmp    804667 <netif_find+0x39>

0080466e <netif_set_ipaddr>:
{
  80466e:	f3 0f 1e fb          	endbr32 
  804672:	55                   	push   %ebp
  804673:	89 e5                	mov    %esp,%ebp
  804675:	57                   	push   %edi
  804676:	56                   	push   %esi
  804677:	53                   	push   %ebx
  804678:	83 ec 0c             	sub    $0xc,%esp
  80467b:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80467e:	8b 75 0c             	mov    0xc(%ebp),%esi
  if ((ip_addr_cmp(ipaddr, &(netif->ip_addr))) == 0)
  804681:	8b 43 04             	mov    0x4(%ebx),%eax
  804684:	39 06                	cmp    %eax,(%esi)
  804686:	74 47                	je     8046cf <netif_set_ipaddr+0x61>
    pcb = tcp_active_pcbs;
  804688:	a1 3c b2 b3 00       	mov    0xb3b23c,%eax
    while (pcb != NULL) {
  80468d:	eb 11                	jmp    8046a0 <netif_set_ipaddr+0x32>
        struct tcp_pcb *next = pcb->next;
  80468f:	8b 78 0c             	mov    0xc(%eax),%edi
        tcp_abort(pcb);
  804692:	83 ec 0c             	sub    $0xc,%esp
  804695:	50                   	push   %eax
  804696:	e8 45 16 00 00       	call   805ce0 <tcp_abort>
  80469b:	83 c4 10             	add    $0x10,%esp
        pcb = next;
  80469e:	89 f8                	mov    %edi,%eax
    while (pcb != NULL) {
  8046a0:	85 c0                	test   %eax,%eax
  8046a2:	74 0c                	je     8046b0 <netif_set_ipaddr+0x42>
      if (ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))) {
  8046a4:	8b 4b 04             	mov    0x4(%ebx),%ecx
  8046a7:	39 08                	cmp    %ecx,(%eax)
  8046a9:	74 e4                	je     80468f <netif_set_ipaddr+0x21>
        pcb = pcb->next;
  8046ab:	8b 40 0c             	mov    0xc(%eax),%eax
  8046ae:	eb f0                	jmp    8046a0 <netif_set_ipaddr+0x32>
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  8046b0:	a1 44 b2 b3 00       	mov    0xb3b244,%eax
  8046b5:	eb 03                	jmp    8046ba <netif_set_ipaddr+0x4c>
  8046b7:	8b 40 0c             	mov    0xc(%eax),%eax
  8046ba:	85 c0                	test   %eax,%eax
  8046bc:	74 11                	je     8046cf <netif_set_ipaddr+0x61>
      if ((!(ip_addr_isany(&(lpcb->local_ip)))) &&
  8046be:	8b 10                	mov    (%eax),%edx
  8046c0:	85 d2                	test   %edx,%edx
  8046c2:	74 f3                	je     8046b7 <netif_set_ipaddr+0x49>
  8046c4:	3b 53 04             	cmp    0x4(%ebx),%edx
  8046c7:	75 ee                	jne    8046b7 <netif_set_ipaddr+0x49>
        ip_addr_set(&(lpcb->local_ip), ipaddr);
  8046c9:	8b 16                	mov    (%esi),%edx
  8046cb:	89 10                	mov    %edx,(%eax)
  8046cd:	eb e8                	jmp    8046b7 <netif_set_ipaddr+0x49>
  ip_addr_set(&(netif->ip_addr), ipaddr);
  8046cf:	8b 06                	mov    (%esi),%eax
  8046d1:	89 43 04             	mov    %eax,0x4(%ebx)
}
  8046d4:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8046d7:	5b                   	pop    %ebx
  8046d8:	5e                   	pop    %esi
  8046d9:	5f                   	pop    %edi
  8046da:	5d                   	pop    %ebp
  8046db:	c3                   	ret    

008046dc <netif_set_addr>:
{
  8046dc:	f3 0f 1e fb          	endbr32 
  8046e0:	55                   	push   %ebp
  8046e1:	89 e5                	mov    %esp,%ebp
  8046e3:	57                   	push   %edi
  8046e4:	56                   	push   %esi
  8046e5:	53                   	push   %ebx
  8046e6:	83 ec 14             	sub    $0x14,%esp
  8046e9:	8b 5d 08             	mov    0x8(%ebp),%ebx
  8046ec:	8b 7d 10             	mov    0x10(%ebp),%edi
  8046ef:	8b 75 14             	mov    0x14(%ebp),%esi
  netif_set_ipaddr(netif, ipaddr);
  8046f2:	ff 75 0c             	pushl  0xc(%ebp)
  8046f5:	53                   	push   %ebx
  8046f6:	e8 73 ff ff ff       	call   80466e <netif_set_ipaddr>
  ip_addr_set(&(netif->netmask), netmask);
  8046fb:	83 c4 10             	add    $0x10,%esp
  8046fe:	b8 00 00 00 00       	mov    $0x0,%eax
  804703:	85 ff                	test   %edi,%edi
  804705:	74 02                	je     804709 <netif_set_addr+0x2d>
  804707:	8b 07                	mov    (%edi),%eax
  804709:	89 43 08             	mov    %eax,0x8(%ebx)
  ip_addr_set(&(netif->gw), gw);
  80470c:	b8 00 00 00 00       	mov    $0x0,%eax
  804711:	85 f6                	test   %esi,%esi
  804713:	74 02                	je     804717 <netif_set_addr+0x3b>
  804715:	8b 06                	mov    (%esi),%eax
  804717:	89 43 0c             	mov    %eax,0xc(%ebx)
}
  80471a:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80471d:	5b                   	pop    %ebx
  80471e:	5e                   	pop    %esi
  80471f:	5f                   	pop    %edi
  804720:	5d                   	pop    %ebp
  804721:	c3                   	ret    

00804722 <netif_add>:
{
  804722:	f3 0f 1e fb          	endbr32 
  804726:	55                   	push   %ebp
  804727:	89 e5                	mov    %esp,%ebp
  804729:	53                   	push   %ebx
  80472a:	83 ec 04             	sub    $0x4,%esp
  80472d:	8b 5d 08             	mov    0x8(%ebp),%ebx
  netif->ip_addr.addr = 0;
  804730:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  netif->netmask.addr = 0;
  804737:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
  netif->gw.addr = 0;
  80473e:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
  netif->flags = 0;
  804745:	c6 43 2e 00          	movb   $0x0,0x2e(%ebx)
  netif->dhcp = NULL;
  804749:	c7 43 20 00 00 00 00 	movl   $0x0,0x20(%ebx)
  netif->state = state;
  804750:	8b 45 18             	mov    0x18(%ebp),%eax
  804753:	89 43 1c             	mov    %eax,0x1c(%ebx)
  netif->num = netifnum++;
  804756:	0f b6 05 f8 43 b3 00 	movzbl 0xb343f8,%eax
  80475d:	8d 50 01             	lea    0x1(%eax),%edx
  804760:	88 15 f8 43 b3 00    	mov    %dl,0xb343f8
  804766:	88 43 31             	mov    %al,0x31(%ebx)
  netif->input = input;
  804769:	8b 45 20             	mov    0x20(%ebp),%eax
  80476c:	89 43 10             	mov    %eax,0x10(%ebx)
  netif_set_addr(netif, ipaddr, netmask, gw);
  80476f:	ff 75 14             	pushl  0x14(%ebp)
  804772:	ff 75 10             	pushl  0x10(%ebp)
  804775:	ff 75 0c             	pushl  0xc(%ebp)
  804778:	53                   	push   %ebx
  804779:	e8 5e ff ff ff       	call   8046dc <netif_set_addr>
  if (init(netif) != ERR_OK) {
  80477e:	89 1c 24             	mov    %ebx,(%esp)
  804781:	ff 55 1c             	call   *0x1c(%ebp)
  804784:	83 c4 10             	add    $0x10,%esp
  804787:	84 c0                	test   %al,%al
  804789:	75 14                	jne    80479f <netif_add+0x7d>
  netif->next = netif_list;
  80478b:	a1 34 b2 b3 00       	mov    0xb3b234,%eax
  804790:	89 03                	mov    %eax,(%ebx)
  netif_list = netif;
  804792:	89 1d 34 b2 b3 00    	mov    %ebx,0xb3b234
  return netif;
  804798:	89 d8                	mov    %ebx,%eax
}
  80479a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80479d:	c9                   	leave  
  80479e:	c3                   	ret    
    return NULL;
  80479f:	b8 00 00 00 00       	mov    $0x0,%eax
  8047a4:	eb f4                	jmp    80479a <netif_add+0x78>

008047a6 <netif_set_gw>:
{
  8047a6:	f3 0f 1e fb          	endbr32 
  8047aa:	55                   	push   %ebp
  8047ab:	89 e5                	mov    %esp,%ebp
  8047ad:	8b 55 0c             	mov    0xc(%ebp),%edx
  ip_addr_set(&(netif->gw), gw);
  8047b0:	b8 00 00 00 00       	mov    $0x0,%eax
  8047b5:	85 d2                	test   %edx,%edx
  8047b7:	74 02                	je     8047bb <netif_set_gw+0x15>
  8047b9:	8b 02                	mov    (%edx),%eax
  8047bb:	8b 55 08             	mov    0x8(%ebp),%edx
  8047be:	89 42 0c             	mov    %eax,0xc(%edx)
}
  8047c1:	5d                   	pop    %ebp
  8047c2:	c3                   	ret    

008047c3 <netif_set_netmask>:
{
  8047c3:	f3 0f 1e fb          	endbr32 
  8047c7:	55                   	push   %ebp
  8047c8:	89 e5                	mov    %esp,%ebp
  8047ca:	8b 55 0c             	mov    0xc(%ebp),%edx
  ip_addr_set(&(netif->netmask), netmask);
  8047cd:	b8 00 00 00 00       	mov    $0x0,%eax
  8047d2:	85 d2                	test   %edx,%edx
  8047d4:	74 02                	je     8047d8 <netif_set_netmask+0x15>
  8047d6:	8b 02                	mov    (%edx),%eax
  8047d8:	8b 55 08             	mov    0x8(%ebp),%edx
  8047db:	89 42 08             	mov    %eax,0x8(%edx)
}
  8047de:	5d                   	pop    %ebp
  8047df:	c3                   	ret    

008047e0 <netif_set_default>:
{
  8047e0:	f3 0f 1e fb          	endbr32 
  8047e4:	55                   	push   %ebp
  8047e5:	89 e5                	mov    %esp,%ebp
  netif_default = netif;
  8047e7:	8b 45 08             	mov    0x8(%ebp),%eax
  8047ea:	a3 38 b2 b3 00       	mov    %eax,0xb3b238
}
  8047ef:	5d                   	pop    %ebp
  8047f0:	c3                   	ret    

008047f1 <netif_set_up>:
 * up once configured.
 * 
 * @see dhcp_start()
 */ 
void netif_set_up(struct netif *netif)
{
  8047f1:	f3 0f 1e fb          	endbr32 
  8047f5:	55                   	push   %ebp
  8047f6:	89 e5                	mov    %esp,%ebp
  8047f8:	83 ec 08             	sub    $0x8,%esp
  8047fb:	8b 55 08             	mov    0x8(%ebp),%edx
  if ( !(netif->flags & NETIF_FLAG_UP )) {
  8047fe:	0f b6 42 2e          	movzbl 0x2e(%edx),%eax
  804802:	a8 01                	test   $0x1,%al
  804804:	75 0c                	jne    804812 <netif_set_up+0x21>
    netif->flags |= NETIF_FLAG_UP;
  804806:	89 c1                	mov    %eax,%ecx
  804808:	83 c9 01             	or     $0x1,%ecx
  80480b:	88 4a 2e             	mov    %cl,0x2e(%edx)
    /** For Ethernet network interfaces, we would like to send a
     *  "gratuitous ARP"; this is an ARP packet sent by a node in order
     *  to spontaneously cause other nodes to update an entry in their
     *  ARP cache. From RFC 3220 "IP Mobility Support for IPv4" section 4.6.
     */ 
    if (netif->flags & NETIF_FLAG_ETHARP) {
  80480e:	a8 20                	test   $0x20,%al
  804810:	75 02                	jne    804814 <netif_set_up+0x23>
      etharp_query(netif, &(netif->ip_addr), NULL);
    }
#endif /* LWIP_ARP */
    
  }
}
  804812:	c9                   	leave  
  804813:	c3                   	ret    
      etharp_query(netif, &(netif->ip_addr), NULL);
  804814:	83 ec 04             	sub    $0x4,%esp
  804817:	6a 00                	push   $0x0
  804819:	8d 42 04             	lea    0x4(%edx),%eax
  80481c:	50                   	push   %eax
  80481d:	52                   	push   %edx
  80481e:	e8 a3 52 00 00       	call   809ac6 <etharp_query>
  804823:	83 c4 10             	add    $0x10,%esp
}
  804826:	eb ea                	jmp    804812 <netif_set_up+0x21>

00804828 <netif_set_down>:
 * up once configured.
 * 
 * @see dhcp_start()
 */ 
void netif_set_down(struct netif *netif)
{
  804828:	f3 0f 1e fb          	endbr32 
  80482c:	55                   	push   %ebp
  80482d:	89 e5                	mov    %esp,%ebp
  80482f:	8b 55 08             	mov    0x8(%ebp),%edx
  if ( netif->flags & NETIF_FLAG_UP )
  804832:	0f b6 42 2e          	movzbl 0x2e(%edx),%eax
  804836:	a8 01                	test   $0x1,%al
  804838:	74 06                	je     804840 <netif_set_down+0x18>
    {
      netif->flags &= ~NETIF_FLAG_UP;
  80483a:	83 e0 fe             	and    $0xfffffffe,%eax
  80483d:	88 42 2e             	mov    %al,0x2e(%edx)
#endif
      
      NETIF_LINK_CALLBACK(netif);
      NETIF_STATUS_CALLBACK(netif);
    }
}
  804840:	5d                   	pop    %ebp
  804841:	c3                   	ret    

00804842 <netif_is_up>:

/**
 * Ask if an interface is up
 */ 
u8_t netif_is_up(struct netif *netif)
{
  804842:	f3 0f 1e fb          	endbr32 
  804846:	55                   	push   %ebp
  804847:	89 e5                	mov    %esp,%ebp
  return (netif->flags & NETIF_FLAG_UP)?1:0;
  804849:	8b 45 08             	mov    0x8(%ebp),%eax
  80484c:	0f b6 40 2e          	movzbl 0x2e(%eax),%eax
  804850:	83 e0 01             	and    $0x1,%eax
}
  804853:	5d                   	pop    %ebp
  804854:	c3                   	ret    

00804855 <pbuf_header>:
 * @return non-zero on failure, zero on success.
 *
 */
u8_t
pbuf_header(struct pbuf *p, s16_t header_size_increment)
{
  804855:	f3 0f 1e fb          	endbr32 
  804859:	55                   	push   %ebp
  80485a:	89 e5                	mov    %esp,%ebp
  80485c:	56                   	push   %esi
  80485d:	53                   	push   %ebx
  80485e:	8b 45 08             	mov    0x8(%ebp),%eax
  804861:	8b 55 0c             	mov    0xc(%ebp),%edx
  u16_t type;
  void *payload;
  u16_t increment_magnitude;

  LWIP_ASSERT("p != NULL", p != NULL);
  804864:	85 c0                	test   %eax,%eax
  804866:	74 42                	je     8048aa <pbuf_header+0x55>
  if ((header_size_increment == 0) || (p == NULL))
  804868:	66 85 d2             	test   %dx,%dx
  80486b:	0f 84 b0 00 00 00    	je     804921 <pbuf_header+0xcc>
  if (header_size_increment < 0){
    increment_magnitude = -header_size_increment;
    /* Check that we aren't going to move off the end of the pbuf */
    LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
  } else {
    increment_magnitude = header_size_increment;
  804871:	89 d6                	mov    %edx,%esi
  if (header_size_increment < 0){
  804873:	78 4c                	js     8048c1 <pbuf_header+0x6c>
    LWIP_ASSERT("p->payload - increment_magnitude >= p + SIZEOF_STRUCT_PBUF",
                (u8_t *)p->payload - increment_magnitude >= (u8_t *)p + SIZEOF_STRUCT_PBUF);
#endif
  }

  type = p->type;
  804875:	0f b6 48 0c          	movzbl 0xc(%eax),%ecx
  /* remember current payload pointer */
  payload = p->payload;
  804879:	8b 58 04             	mov    0x4(%eax),%ebx

  /* pbuf types containing payloads? */
  if (type == PBUF_RAM || type == PBUF_POOL) {
  80487c:	66 85 c9             	test   %cx,%cx
  80487f:	74 5f                	je     8048e0 <pbuf_header+0x8b>
  804881:	66 83 f9 03          	cmp    $0x3,%cx
  804885:	74 59                	je     8048e0 <pbuf_header+0x8b>
      p->payload = payload;
      /* bail out unsuccesfully */
      return 1;
    }
  /* pbuf types refering to external payloads? */
  } else if (type == PBUF_REF || type == PBUF_ROM) {
  804887:	83 e9 01             	sub    $0x1,%ecx
  80488a:	66 83 f9 01          	cmp    $0x1,%cx
  80488e:	77 7a                	ja     80490a <pbuf_header+0xb5>
      /* increase payload pointer */
      p->payload = (u8_t *)p->payload - header_size_increment;
    } else {
      /* cannot expand payload to front (yet!)
       * bail out unsuccesfully */
      return 1;
  804890:	b9 01 00 00 00       	mov    $0x1,%ecx
    if ((header_size_increment < 0) && (increment_magnitude <= p->len)) {
  804895:	66 85 d2             	test   %dx,%dx
  804898:	79 67                	jns    804901 <pbuf_header+0xac>
  80489a:	66 39 70 0a          	cmp    %si,0xa(%eax)
  80489e:	72 61                	jb     804901 <pbuf_header+0xac>
      p->payload = (u8_t *)p->payload - header_size_increment;
  8048a0:	0f bf ca             	movswl %dx,%ecx
  8048a3:	29 cb                	sub    %ecx,%ebx
  8048a5:	89 58 04             	mov    %ebx,0x4(%eax)
  8048a8:	eb 4a                	jmp    8048f4 <pbuf_header+0x9f>
  LWIP_ASSERT("p != NULL", p != NULL);
  8048aa:	83 ec 04             	sub    $0x4,%esp
  8048ad:	68 68 1d 81 00       	push   $0x811d68
  8048b2:	68 64 01 00 00       	push   $0x164
  8048b7:	68 a4 1c 81 00       	push   $0x811ca4
  8048bc:	e8 86 9f 00 00       	call   80e847 <_panic>
    increment_magnitude = -header_size_increment;
  8048c1:	f7 de                	neg    %esi
    LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
  8048c3:	66 39 70 0a          	cmp    %si,0xa(%eax)
  8048c7:	73 ac                	jae    804875 <pbuf_header+0x20>
  8048c9:	83 ec 04             	sub    $0x4,%esp
  8048cc:	68 b9 1c 81 00       	push   $0x811cb9
  8048d1:	68 6b 01 00 00       	push   $0x16b
  8048d6:	68 a4 1c 81 00       	push   $0x811ca4
  8048db:	e8 67 9f 00 00       	call   80e847 <_panic>
    p->payload = (u8_t *)p->payload - header_size_increment;
  8048e0:	0f bf ca             	movswl %dx,%ecx
  8048e3:	29 cb                	sub    %ecx,%ebx
    if ((u8_t *)p->payload < (u8_t *)p + SIZEOF_STRUCT_PBUF) {
  8048e5:	8d 70 10             	lea    0x10(%eax),%esi
      return 1;
  8048e8:	b9 01 00 00 00       	mov    $0x1,%ecx
    if ((u8_t *)p->payload < (u8_t *)p + SIZEOF_STRUCT_PBUF) {
  8048ed:	39 f3                	cmp    %esi,%ebx
  8048ef:	72 10                	jb     804901 <pbuf_header+0xac>
    p->payload = (u8_t *)p->payload - header_size_increment;
  8048f1:	89 58 04             	mov    %ebx,0x4(%eax)
    /* Unknown type */
    LWIP_ASSERT("bad pbuf type", 0);
    return 1;
  }
  /* modify pbuf length fields */
  p->len += header_size_increment;
  8048f4:	66 01 50 0a          	add    %dx,0xa(%eax)
  p->tot_len += header_size_increment;
  8048f8:	66 01 50 08          	add    %dx,0x8(%eax)

  LWIP_DEBUGF(PBUF_DEBUG, ("pbuf_header: old %p new %p (%"S16_F")\n",
    (void *)payload, (void *)p->payload, header_size_increment));

  return 0;
  8048fc:	b9 00 00 00 00       	mov    $0x0,%ecx
}
  804901:	89 c8                	mov    %ecx,%eax
  804903:	8d 65 f8             	lea    -0x8(%ebp),%esp
  804906:	5b                   	pop    %ebx
  804907:	5e                   	pop    %esi
  804908:	5d                   	pop    %ebp
  804909:	c3                   	ret    
    LWIP_ASSERT("bad pbuf type", 0);
  80490a:	83 ec 04             	sub    $0x4,%esp
  80490d:	68 d7 1c 81 00       	push   $0x811cd7
  804912:	68 9a 01 00 00       	push   $0x19a
  804917:	68 a4 1c 81 00       	push   $0x811ca4
  80491c:	e8 26 9f 00 00       	call   80e847 <_panic>
    return 0;
  804921:	b9 00 00 00 00       	mov    $0x0,%ecx
  804926:	eb d9                	jmp    804901 <pbuf_header+0xac>

00804928 <pbuf_free>:
 * 1->1->1 becomes .......
 *
 */
u8_t
pbuf_free(struct pbuf *p)
{
  804928:	f3 0f 1e fb          	endbr32 
  80492c:	55                   	push   %ebp
  80492d:	89 e5                	mov    %esp,%ebp
  80492f:	56                   	push   %esi
  804930:	53                   	push   %ebx
  804931:	8b 45 08             	mov    0x8(%ebp),%eax
  u16_t type;
  struct pbuf *q;
  u8_t count;

  if (p == NULL) {
  804934:	85 c0                	test   %eax,%eax
  804936:	74 0d                	je     804945 <pbuf_free+0x1d>
  }
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_free(%p)\n", (void *)p));

  PERF_START;

  LWIP_ASSERT("pbuf_free: sane type",
  804938:	80 78 0c 03          	cmpb   $0x3,0xc(%eax)
  80493c:	77 1e                	ja     80495c <pbuf_free+0x34>
    p->type == PBUF_RAM || p->type == PBUF_ROM ||
    p->type == PBUF_REF || p->type == PBUF_POOL);

  count = 0;
  80493e:	bb 00 00 00 00       	mov    $0x0,%ebx
  804943:	eb 6c                	jmp    8049b1 <pbuf_free+0x89>
    LWIP_ASSERT("p != NULL", p != NULL);
  804945:	83 ec 04             	sub    $0x4,%esp
  804948:	68 68 1d 81 00       	push   $0x811d68
  80494d:	68 d0 01 00 00       	push   $0x1d0
  804952:	68 a4 1c 81 00       	push   $0x811ca4
  804957:	e8 eb 9e 00 00       	call   80e847 <_panic>
  LWIP_ASSERT("pbuf_free: sane type",
  80495c:	83 ec 04             	sub    $0x4,%esp
  80495f:	68 e5 1c 81 00       	push   $0x811ce5
  804964:	68 d9 01 00 00       	push   $0x1d9
  804969:	68 a4 1c 81 00       	push   $0x811ca4
  80496e:	e8 d4 9e 00 00       	call   80e847 <_panic>
    /* Since decrementing ref cannot be guaranteed to be a single machine operation
     * we must protect it. We put the new ref into a local variable to prevent
     * further protection. */
    SYS_ARCH_PROTECT(old_level);
    /* all pbufs in a chain are referenced at least once */
    LWIP_ASSERT("pbuf_free: p->ref > 0", p->ref > 0);
  804973:	83 ec 04             	sub    $0x4,%esp
  804976:	68 fa 1c 81 00       	push   $0x811cfa
  80497b:	68 e8 01 00 00       	push   $0x1e8
  804980:	68 a4 1c 81 00       	push   $0x811ca4
  804985:	e8 bd 9e 00 00       	call   80e847 <_panic>
      q = p->next;
      LWIP_DEBUGF( PBUF_DEBUG | 2, ("pbuf_free: deallocating %p\n", (void *)p));
      type = p->type;
      /* is this a pbuf from the pool? */
      if (type == PBUF_POOL) {
        memp_free(MEMP_PBUF_POOL, p);
  80498a:	83 ec 08             	sub    $0x8,%esp
  80498d:	50                   	push   %eax
  80498e:	6a 0d                	push   $0xd
  804990:	e8 10 fc ff ff       	call   8045a5 <memp_free>
  804995:	83 c4 10             	add    $0x10,%esp
  804998:	eb 0e                	jmp    8049a8 <pbuf_free+0x80>
      /* is this a ROM or RAM referencing pbuf? */
      } else if (type == PBUF_ROM || type == PBUF_REF) {
        memp_free(MEMP_PBUF, p);
  80499a:	83 ec 08             	sub    $0x8,%esp
  80499d:	50                   	push   %eax
  80499e:	6a 0c                	push   $0xc
  8049a0:	e8 00 fc ff ff       	call   8045a5 <memp_free>
  8049a5:	83 c4 10             	add    $0x10,%esp
      /* type == PBUF_RAM */
      } else {
        mem_free(p);
      }
      count++;
  8049a8:	83 c3 01             	add    $0x1,%ebx
  while (p != NULL) {
  8049ab:	85 f6                	test   %esi,%esi
  8049ad:	74 3a                	je     8049e9 <pbuf_free+0xc1>
      /* proceed to next pbuf */
      p = q;
  8049af:	89 f0                	mov    %esi,%eax
    LWIP_ASSERT("pbuf_free: p->ref > 0", p->ref > 0);
  8049b1:	0f b7 50 0e          	movzwl 0xe(%eax),%edx
  8049b5:	66 85 d2             	test   %dx,%dx
  8049b8:	74 b9                	je     804973 <pbuf_free+0x4b>
    ref = --(p->ref);
  8049ba:	83 ea 01             	sub    $0x1,%edx
  8049bd:	66 89 50 0e          	mov    %dx,0xe(%eax)
    if (ref == 0) {
  8049c1:	66 85 d2             	test   %dx,%dx
  8049c4:	75 23                	jne    8049e9 <pbuf_free+0xc1>
      q = p->next;
  8049c6:	8b 30                	mov    (%eax),%esi
      type = p->type;
  8049c8:	0f b6 50 0c          	movzbl 0xc(%eax),%edx
      if (type == PBUF_POOL) {
  8049cc:	66 83 fa 03          	cmp    $0x3,%dx
  8049d0:	74 b8                	je     80498a <pbuf_free+0x62>
      } else if (type == PBUF_ROM || type == PBUF_REF) {
  8049d2:	83 ea 01             	sub    $0x1,%edx
  8049d5:	66 83 fa 01          	cmp    $0x1,%dx
  8049d9:	76 bf                	jbe    80499a <pbuf_free+0x72>
        mem_free(p);
  8049db:	83 ec 0c             	sub    $0xc,%esp
  8049de:	50                   	push   %eax
  8049df:	e8 0f f6 ff ff       	call   803ff3 <mem_free>
  8049e4:	83 c4 10             	add    $0x10,%esp
  8049e7:	eb bf                	jmp    8049a8 <pbuf_free+0x80>
    }
  }
  PERF_STOP("pbuf_free");
  /* return number of de-allocated pbufs */
  return count;
}
  8049e9:	89 d8                	mov    %ebx,%eax
  8049eb:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8049ee:	5b                   	pop    %ebx
  8049ef:	5e                   	pop    %esi
  8049f0:	5d                   	pop    %ebp
  8049f1:	c3                   	ret    

008049f2 <pbuf_alloc>:
{
  8049f2:	f3 0f 1e fb          	endbr32 
  8049f6:	55                   	push   %ebp
  8049f7:	89 e5                	mov    %esp,%ebp
  8049f9:	57                   	push   %edi
  8049fa:	56                   	push   %esi
  8049fb:	53                   	push   %ebx
  8049fc:	83 ec 1c             	sub    $0x1c,%esp
  8049ff:	8b 45 08             	mov    0x8(%ebp),%eax
  804a02:	8b 75 0c             	mov    0xc(%ebp),%esi
  804a05:	8b 5d 10             	mov    0x10(%ebp),%ebx
  switch (layer) {
  804a08:	83 f8 02             	cmp    $0x2,%eax
  804a0b:	0f 84 8b 00 00 00    	je     804a9c <pbuf_alloc+0xaa>
  804a11:	77 14                	ja     804a27 <pbuf_alloc+0x35>
  offset = 0;
  804a13:	83 f8 01             	cmp    $0x1,%eax
  804a16:	19 ff                	sbb    %edi,%edi
  804a18:	83 e7 14             	and    $0x14,%edi
    offset += PBUF_IP_HLEN;
  804a1b:	83 c7 14             	add    $0x14,%edi
    offset += PBUF_LINK_HLEN;
  804a1e:	8d 47 0e             	lea    0xe(%edi),%eax
  804a21:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
    break;
  804a25:	eb 0b                	jmp    804a32 <pbuf_alloc+0x40>
  switch (layer) {
  804a27:	83 f8 03             	cmp    $0x3,%eax
  804a2a:	75 7a                	jne    804aa6 <pbuf_alloc+0xb4>
  804a2c:	66 c7 45 e4 00 00    	movw   $0x0,-0x1c(%ebp)
  switch (type) {
  804a32:	83 fb 02             	cmp    $0x2,%ebx
  804a35:	0f 87 82 00 00 00    	ja     804abd <pbuf_alloc+0xcb>
  804a3b:	85 db                	test   %ebx,%ebx
  804a3d:	0f 85 c3 01 00 00    	jne    804c06 <pbuf_alloc+0x214>
    p = (struct pbuf*)mem_malloc(LWIP_MEM_ALIGN_SIZE(SIZEOF_STRUCT_PBUF + offset) + LWIP_MEM_ALIGN_SIZE(length));
  804a43:	0f b7 5d e4          	movzwl -0x1c(%ebp),%ebx
  804a47:	83 ec 0c             	sub    $0xc,%esp
  804a4a:	8d 43 13             	lea    0x13(%ebx),%eax
  804a4d:	83 e0 fc             	and    $0xfffffffc,%eax
  804a50:	89 c2                	mov    %eax,%edx
  804a52:	0f b7 c6             	movzwl %si,%eax
  804a55:	83 c0 03             	add    $0x3,%eax
  804a58:	83 e0 fc             	and    $0xfffffffc,%eax
  804a5b:	01 d0                	add    %edx,%eax
  804a5d:	50                   	push   %eax
  804a5e:	e8 87 f8 ff ff       	call   8042ea <mem_malloc>
  804a63:	89 c7                	mov    %eax,%edi
    if (p == NULL) {
  804a65:	83 c4 10             	add    $0x10,%esp
  804a68:	85 c0                	test   %eax,%eax
  804a6a:	74 26                	je     804a92 <pbuf_alloc+0xa0>
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + SIZEOF_STRUCT_PBUF + offset));
  804a6c:	8d 44 18 13          	lea    0x13(%eax,%ebx,1),%eax
  804a70:	83 e0 fc             	and    $0xfffffffc,%eax
  804a73:	89 47 04             	mov    %eax,0x4(%edi)
    p->len = p->tot_len = length;
  804a76:	66 89 77 08          	mov    %si,0x8(%edi)
  804a7a:	66 89 77 0a          	mov    %si,0xa(%edi)
    p->next = NULL;
  804a7e:	c7 07 00 00 00 00    	movl   $0x0,(%edi)
    p->type = type;
  804a84:	c6 47 0c 00          	movb   $0x0,0xc(%edi)
  p->ref = 1;
  804a88:	66 c7 47 0e 01 00    	movw   $0x1,0xe(%edi)
  p->flags = 0;
  804a8e:	c6 47 0d 00          	movb   $0x0,0xd(%edi)
}
  804a92:	89 f8                	mov    %edi,%eax
  804a94:	8d 65 f4             	lea    -0xc(%ebp),%esp
  804a97:	5b                   	pop    %ebx
  804a98:	5e                   	pop    %esi
  804a99:	5f                   	pop    %edi
  804a9a:	5d                   	pop    %ebp
  804a9b:	c3                   	ret    
  switch (layer) {
  804a9c:	bf 00 00 00 00       	mov    $0x0,%edi
  804aa1:	e9 78 ff ff ff       	jmp    804a1e <pbuf_alloc+0x2c>
    LWIP_ASSERT("pbuf_alloc: bad pbuf layer", 0);
  804aa6:	83 ec 04             	sub    $0x4,%esp
  804aa9:	68 10 1d 81 00       	push   $0x811d10
  804aae:	68 8a 00 00 00       	push   $0x8a
  804ab3:	68 a4 1c 81 00       	push   $0x811ca4
  804ab8:	e8 8a 9d 00 00       	call   80e847 <_panic>
  switch (type) {
  804abd:	83 fb 03             	cmp    $0x3,%ebx
  804ac0:	0f 85 74 01 00 00    	jne    804c3a <pbuf_alloc+0x248>
      p = memp_malloc(MEMP_PBUF_POOL);
  804ac6:	83 ec 0c             	sub    $0xc,%esp
  804ac9:	6a 0d                	push   $0xd
  804acb:	e8 7b fa ff ff       	call   80454b <memp_malloc>
  804ad0:	89 c7                	mov    %eax,%edi
    if (p == NULL) {
  804ad2:	83 c4 10             	add    $0x10,%esp
  804ad5:	85 c0                	test   %eax,%eax
  804ad7:	74 b9                	je     804a92 <pbuf_alloc+0xa0>
    p->type = type;
  804ad9:	c6 40 0c 03          	movb   $0x3,0xc(%eax)
    p->next = NULL;
  804add:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + (SIZEOF_STRUCT_PBUF + offset)));
  804ae3:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  804ae7:	8d 54 07 13          	lea    0x13(%edi,%eax,1),%edx
  804aeb:	83 e2 fc             	and    $0xfffffffc,%edx
  804aee:	89 57 04             	mov    %edx,0x4(%edi)
    p->tot_len = length;
  804af1:	66 89 77 08          	mov    %si,0x8(%edi)
    p->len = LWIP_MIN(length, PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset));
  804af5:	0f b7 f6             	movzwl %si,%esi
  804af8:	83 c0 03             	add    $0x3,%eax
  804afb:	83 e0 fc             	and    $0xfffffffc,%eax
  804afe:	89 c1                	mov    %eax,%ecx
  804b00:	b8 d0 07 00 00       	mov    $0x7d0,%eax
  804b05:	29 c8                	sub    %ecx,%eax
  804b07:	39 f0                	cmp    %esi,%eax
  804b09:	0f 4f c6             	cmovg  %esi,%eax
  804b0c:	66 89 47 0a          	mov    %ax,0xa(%edi)
    LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
  804b10:	8d 9f e0 07 00 00    	lea    0x7e0(%edi),%ebx
  804b16:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
  804b19:	01 c2                	add    %eax,%edx
  804b1b:	39 d3                	cmp    %edx,%ebx
  804b1d:	72 76                	jb     804b95 <pbuf_alloc+0x1a3>
    p->ref = 1;
  804b1f:	66 c7 47 0e 01 00    	movw   $0x1,0xe(%edi)
    rem_len = length - p->len;
  804b25:	29 c6                	sub    %eax,%esi
    r = p;
  804b27:	89 fb                	mov    %edi,%ebx
    while (rem_len > 0) {
  804b29:	85 f6                	test   %esi,%esi
  804b2b:	0f 8e 57 ff ff ff    	jle    804a88 <pbuf_alloc+0x96>
      q = memp_malloc(MEMP_PBUF_POOL);
  804b31:	83 ec 0c             	sub    $0xc,%esp
  804b34:	6a 0d                	push   $0xd
  804b36:	e8 10 fa ff ff       	call   80454b <memp_malloc>
      if (q == NULL) {
  804b3b:	83 c4 10             	add    $0x10,%esp
  804b3e:	85 c0                	test   %eax,%eax
  804b40:	74 6a                	je     804bac <pbuf_alloc+0x1ba>
      q->type = type;
  804b42:	c6 40 0c 03          	movb   $0x3,0xc(%eax)
      q->flags = 0;
  804b46:	c6 40 0d 00          	movb   $0x0,0xd(%eax)
      q->next = NULL;
  804b4a:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
      r->next = q;
  804b50:	89 03                	mov    %eax,(%ebx)
      LWIP_ASSERT("rem_len < max_u16_t", rem_len < 0xffff);
  804b52:	81 fe fe ff 00 00    	cmp    $0xfffe,%esi
  804b58:	7f 67                	jg     804bc1 <pbuf_alloc+0x1cf>
      q->tot_len = (u16_t)rem_len;
  804b5a:	66 89 70 08          	mov    %si,0x8(%eax)
      q->len = LWIP_MIN((u16_t)rem_len, PBUF_POOL_BUFSIZE_ALIGNED);
  804b5e:	66 81 fe d0 07       	cmp    $0x7d0,%si
  804b63:	ba d0 07 00 00       	mov    $0x7d0,%edx
  804b68:	0f 46 d6             	cmovbe %esi,%edx
  804b6b:	66 89 50 0a          	mov    %dx,0xa(%eax)
      q->payload = (void *)((u8_t *)q + SIZEOF_STRUCT_PBUF);
  804b6f:	8d 48 10             	lea    0x10(%eax),%ecx
  804b72:	89 48 04             	mov    %ecx,0x4(%eax)
      LWIP_ASSERT("pbuf_alloc: pbuf q->payload properly aligned",
  804b75:	f6 c1 03             	test   $0x3,%cl
  804b78:	75 5e                	jne    804bd8 <pbuf_alloc+0x1e6>
      LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
  804b7a:	0f b7 4f 0a          	movzwl 0xa(%edi),%ecx
  804b7e:	03 4f 04             	add    0x4(%edi),%ecx
  804b81:	39 4d e4             	cmp    %ecx,-0x1c(%ebp)
  804b84:	72 69                	jb     804bef <pbuf_alloc+0x1fd>
      q->ref = 1;
  804b86:	66 c7 40 0e 01 00    	movw   $0x1,0xe(%eax)
      rem_len -= q->len;
  804b8c:	0f b7 d2             	movzwl %dx,%edx
  804b8f:	29 d6                	sub    %edx,%esi
      r = q;
  804b91:	89 c3                	mov    %eax,%ebx
  804b93:	eb 94                	jmp    804b29 <pbuf_alloc+0x137>
    LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
  804b95:	83 ec 04             	sub    $0x4,%esp
  804b98:	68 28 1e 81 00       	push   $0x811e28
  804b9d:	68 a1 00 00 00       	push   $0xa1
  804ba2:	68 a4 1c 81 00       	push   $0x811ca4
  804ba7:	e8 9b 9c 00 00       	call   80e847 <_panic>
  804bac:	89 c3                	mov    %eax,%ebx
        pbuf_free(p);
  804bae:	83 ec 0c             	sub    $0xc,%esp
  804bb1:	57                   	push   %edi
  804bb2:	e8 71 fd ff ff       	call   804928 <pbuf_free>
        return NULL;
  804bb7:	83 c4 10             	add    $0x10,%esp
  804bba:	89 df                	mov    %ebx,%edi
  804bbc:	e9 d1 fe ff ff       	jmp    804a92 <pbuf_alloc+0xa0>
      LWIP_ASSERT("rem_len < max_u16_t", rem_len < 0xffff);
  804bc1:	83 ec 04             	sub    $0x4,%esp
  804bc4:	68 2b 1d 81 00       	push   $0x811d2b
  804bc9:	68 bc 00 00 00       	push   $0xbc
  804bce:	68 a4 1c 81 00       	push   $0x811ca4
  804bd3:	e8 6f 9c 00 00       	call   80e847 <_panic>
      LWIP_ASSERT("pbuf_alloc: pbuf q->payload properly aligned",
  804bd8:	83 ec 04             	sub    $0x4,%esp
  804bdb:	68 5c 1e 81 00       	push   $0x811e5c
  804be0:	68 c1 00 00 00       	push   $0xc1
  804be5:	68 a4 1c 81 00       	push   $0x811ca4
  804bea:	e8 58 9c 00 00       	call   80e847 <_panic>
      LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
  804bef:	83 ec 04             	sub    $0x4,%esp
  804bf2:	68 28 1e 81 00       	push   $0x811e28
  804bf7:	68 c3 00 00 00       	push   $0xc3
  804bfc:	68 a4 1c 81 00       	push   $0x811ca4
  804c01:	e8 41 9c 00 00       	call   80e847 <_panic>
    p = memp_malloc(MEMP_PBUF);
  804c06:	83 ec 0c             	sub    $0xc,%esp
  804c09:	6a 0c                	push   $0xc
  804c0b:	e8 3b f9 ff ff       	call   80454b <memp_malloc>
  804c10:	89 c7                	mov    %eax,%edi
    if (p == NULL) {
  804c12:	83 c4 10             	add    $0x10,%esp
  804c15:	85 c0                	test   %eax,%eax
  804c17:	0f 84 75 fe ff ff    	je     804a92 <pbuf_alloc+0xa0>
    p->payload = NULL;
  804c1d:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    p->len = p->tot_len = length;
  804c24:	66 89 70 08          	mov    %si,0x8(%eax)
  804c28:	66 89 70 0a          	mov    %si,0xa(%eax)
    p->next = NULL;
  804c2c:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    p->type = type;
  804c32:	88 58 0c             	mov    %bl,0xc(%eax)
    break;
  804c35:	e9 4e fe ff ff       	jmp    804a88 <pbuf_alloc+0x96>
    LWIP_ASSERT("pbuf_alloc: erroneous type", 0);
  804c3a:	83 ec 04             	sub    $0x4,%esp
  804c3d:	68 3f 1d 81 00       	push   $0x811d3f
  804c42:	68 f1 00 00 00       	push   $0xf1
  804c47:	68 a4 1c 81 00       	push   $0x811ca4
  804c4c:	e8 f6 9b 00 00       	call   80e847 <_panic>

00804c51 <pbuf_realloc>:
{
  804c51:	f3 0f 1e fb          	endbr32 
  804c55:	55                   	push   %ebp
  804c56:	89 e5                	mov    %esp,%ebp
  804c58:	57                   	push   %edi
  804c59:	56                   	push   %esi
  804c5a:	53                   	push   %ebx
  804c5b:	83 ec 0c             	sub    $0xc,%esp
  804c5e:	8b 5d 08             	mov    0x8(%ebp),%ebx
  804c61:	8b 75 0c             	mov    0xc(%ebp),%esi
  LWIP_ASSERT("pbuf_realloc: p != NULL", p != NULL);
  804c64:	85 db                	test   %ebx,%ebx
  804c66:	74 53                	je     804cbb <pbuf_realloc+0x6a>
  804c68:	89 f2                	mov    %esi,%edx
  LWIP_ASSERT("pbuf_realloc: sane p->type", p->type == PBUF_POOL ||
  804c6a:	80 7b 0c 03          	cmpb   $0x3,0xc(%ebx)
  804c6e:	77 62                	ja     804cd2 <pbuf_realloc+0x81>
  if (new_len >= p->tot_len) {
  804c70:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  804c74:	66 39 f0             	cmp    %si,%ax
  804c77:	0f 86 ae 00 00 00    	jbe    804d2b <pbuf_realloc+0xda>
  grow = new_len - p->tot_len;
  804c7d:	0f b7 ce             	movzwl %si,%ecx
  804c80:	0f b7 f8             	movzwl %ax,%edi
  804c83:	29 f9                	sub    %edi,%ecx
    q->tot_len += (u16_t)grow;
  804c85:	29 c2                	sub    %eax,%edx
  while (rem_len > q->len) {
  804c87:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  804c8b:	66 39 f0             	cmp    %si,%ax
  804c8e:	73 70                	jae    804d00 <pbuf_realloc+0xaf>
    rem_len -= q->len;
  804c90:	29 c6                	sub    %eax,%esi
    LWIP_ASSERT("grow < max_u16_t", grow < 0xffff);
  804c92:	81 f9 fe ff 00 00    	cmp    $0xfffe,%ecx
  804c98:	7f 4f                	jg     804ce9 <pbuf_realloc+0x98>
    q->tot_len += (u16_t)grow;
  804c9a:	66 01 53 08          	add    %dx,0x8(%ebx)
    q = q->next;
  804c9e:	8b 1b                	mov    (%ebx),%ebx
    LWIP_ASSERT("pbuf_realloc: q != NULL", q != NULL);
  804ca0:	85 db                	test   %ebx,%ebx
  804ca2:	75 e3                	jne    804c87 <pbuf_realloc+0x36>
  804ca4:	83 ec 04             	sub    $0x4,%esp
  804ca7:	68 9e 1d 81 00       	push   $0x811d9e
  804cac:	68 2f 01 00 00       	push   $0x12f
  804cb1:	68 a4 1c 81 00       	push   $0x811ca4
  804cb6:	e8 8c 9b 00 00       	call   80e847 <_panic>
  LWIP_ASSERT("pbuf_realloc: p != NULL", p != NULL);
  804cbb:	83 ec 04             	sub    $0x4,%esp
  804cbe:	68 5a 1d 81 00       	push   $0x811d5a
  804cc3:	68 13 01 00 00       	push   $0x113
  804cc8:	68 a4 1c 81 00       	push   $0x811ca4
  804ccd:	e8 75 9b 00 00       	call   80e847 <_panic>
  LWIP_ASSERT("pbuf_realloc: sane p->type", p->type == PBUF_POOL ||
  804cd2:	83 ec 04             	sub    $0x4,%esp
  804cd5:	68 72 1d 81 00       	push   $0x811d72
  804cda:	68 14 01 00 00       	push   $0x114
  804cdf:	68 a4 1c 81 00       	push   $0x811ca4
  804ce4:	e8 5e 9b 00 00       	call   80e847 <_panic>
    LWIP_ASSERT("grow < max_u16_t", grow < 0xffff);
  804ce9:	83 ec 04             	sub    $0x4,%esp
  804cec:	68 8d 1d 81 00       	push   $0x811d8d
  804cf1:	68 2b 01 00 00       	push   $0x12b
  804cf6:	68 a4 1c 81 00       	push   $0x811ca4
  804cfb:	e8 47 9b 00 00       	call   80e847 <_panic>
  if ((q->type == PBUF_RAM) && (rem_len != q->len)) {
  804d00:	80 7b 0c 00          	cmpb   $0x0,0xc(%ebx)
  804d04:	75 05                	jne    804d0b <pbuf_realloc+0xba>
  804d06:	66 39 f0             	cmp    %si,%ax
  804d09:	75 28                	jne    804d33 <pbuf_realloc+0xe2>
  q->len = rem_len;
  804d0b:	66 89 73 0a          	mov    %si,0xa(%ebx)
  q->tot_len = q->len;
  804d0f:	66 89 73 08          	mov    %si,0x8(%ebx)
  if (q->next != NULL) {
  804d13:	8b 03                	mov    (%ebx),%eax
  804d15:	85 c0                	test   %eax,%eax
  804d17:	74 0c                	je     804d25 <pbuf_realloc+0xd4>
    pbuf_free(q->next);
  804d19:	83 ec 0c             	sub    $0xc,%esp
  804d1c:	50                   	push   %eax
  804d1d:	e8 06 fc ff ff       	call   804928 <pbuf_free>
  804d22:	83 c4 10             	add    $0x10,%esp
  q->next = NULL;
  804d25:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
}
  804d2b:	8d 65 f4             	lea    -0xc(%ebp),%esp
  804d2e:	5b                   	pop    %ebx
  804d2f:	5e                   	pop    %esi
  804d30:	5f                   	pop    %edi
  804d31:	5d                   	pop    %ebp
  804d32:	c3                   	ret    
    q = mem_realloc(q, (u8_t *)q->payload - (u8_t *)q + rem_len);
  804d33:	8b 43 04             	mov    0x4(%ebx),%eax
  804d36:	29 d8                	sub    %ebx,%eax
  804d38:	0f b7 d6             	movzwl %si,%edx
  804d3b:	01 d0                	add    %edx,%eax
  804d3d:	83 ec 08             	sub    $0x8,%esp
  804d40:	50                   	push   %eax
  804d41:	53                   	push   %ebx
  804d42:	e8 47 f4 ff ff       	call   80418e <mem_realloc>
  804d47:	89 c3                	mov    %eax,%ebx
    LWIP_ASSERT("mem_realloc give q == NULL", q != NULL);
  804d49:	83 c4 10             	add    $0x10,%esp
  804d4c:	85 c0                	test   %eax,%eax
  804d4e:	75 bb                	jne    804d0b <pbuf_realloc+0xba>
  804d50:	83 ec 04             	sub    $0x4,%esp
  804d53:	68 b6 1d 81 00       	push   $0x811db6
  804d58:	68 39 01 00 00       	push   $0x139
  804d5d:	68 a4 1c 81 00       	push   $0x811ca4
  804d62:	e8 e0 9a 00 00       	call   80e847 <_panic>

00804d67 <pbuf_clen>:
 * @return the number of pbufs in a chain
 */

u8_t
pbuf_clen(struct pbuf *p)
{
  804d67:	f3 0f 1e fb          	endbr32 
  804d6b:	55                   	push   %ebp
  804d6c:	89 e5                	mov    %esp,%ebp
  804d6e:	8b 45 08             	mov    0x8(%ebp),%eax
  u8_t len;

  len = 0;
  804d71:	ba 00 00 00 00       	mov    $0x0,%edx
  while (p != NULL) {
  804d76:	85 c0                	test   %eax,%eax
  804d78:	74 07                	je     804d81 <pbuf_clen+0x1a>
    ++len;
  804d7a:	83 c2 01             	add    $0x1,%edx
    p = p->next;
  804d7d:	8b 00                	mov    (%eax),%eax
  804d7f:	eb f5                	jmp    804d76 <pbuf_clen+0xf>
  }
  return len;
}
  804d81:	89 d0                	mov    %edx,%eax
  804d83:	5d                   	pop    %ebp
  804d84:	c3                   	ret    

00804d85 <pbuf_ref>:
 * @param p pbuf to increase reference counter of
 *
 */
void
pbuf_ref(struct pbuf *p)
{
  804d85:	f3 0f 1e fb          	endbr32 
  804d89:	55                   	push   %ebp
  804d8a:	89 e5                	mov    %esp,%ebp
  804d8c:	8b 45 08             	mov    0x8(%ebp),%eax
  SYS_ARCH_DECL_PROTECT(old_level);
  /* pbuf given? */
  if (p != NULL) {
  804d8f:	85 c0                	test   %eax,%eax
  804d91:	74 05                	je     804d98 <pbuf_ref+0x13>
    SYS_ARCH_PROTECT(old_level);
    ++(p->ref);
  804d93:	66 83 40 0e 01       	addw   $0x1,0xe(%eax)
    SYS_ARCH_UNPROTECT(old_level);
  }
}
  804d98:	5d                   	pop    %ebp
  804d99:	c3                   	ret    

00804d9a <pbuf_cat>:
 * @see pbuf_chain()
 */

void
pbuf_cat(struct pbuf *h, struct pbuf *t)
{
  804d9a:	f3 0f 1e fb          	endbr32 
  804d9e:	55                   	push   %ebp
  804d9f:	89 e5                	mov    %esp,%ebp
  804da1:	53                   	push   %ebx
  804da2:	83 ec 04             	sub    $0x4,%esp
  804da5:	8b 45 08             	mov    0x8(%ebp),%eax
  804da8:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  struct pbuf *p;

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
  804dab:	85 c0                	test   %eax,%eax
  804dad:	74 04                	je     804db3 <pbuf_cat+0x19>
  804daf:	85 db                	test   %ebx,%ebx
  804db1:	75 21                	jne    804dd4 <pbuf_cat+0x3a>
  804db3:	83 ec 04             	sub    $0x4,%esp
  804db6:	68 8c 1e 81 00       	push   $0x811e8c
  804dbb:	68 41 02 00 00       	push   $0x241
  804dc0:	68 a4 1c 81 00       	push   $0x811ca4
  804dc5:	e8 7d 9a 00 00       	call   80e847 <_panic>
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
    /* add total length of second chain to all totals of first chain */
    p->tot_len += t->tot_len;
  804dca:	0f b7 4b 08          	movzwl 0x8(%ebx),%ecx
  804dce:	66 01 48 08          	add    %cx,0x8(%eax)
  for (p = h; p->next != NULL; p = p->next) {
  804dd2:	89 d0                	mov    %edx,%eax
  804dd4:	8b 10                	mov    (%eax),%edx
  804dd6:	85 d2                	test   %edx,%edx
  804dd8:	75 f0                	jne    804dca <pbuf_cat+0x30>
  }
  /* { p is last pbuf of first h chain, p->next == NULL } */
  LWIP_ASSERT("p->tot_len == p->len (of last pbuf in chain)", p->tot_len == p->len);
  804dda:	0f b7 50 08          	movzwl 0x8(%eax),%edx
  804dde:	66 3b 50 0a          	cmp    0xa(%eax),%dx
  804de2:	75 0f                	jne    804df3 <pbuf_cat+0x59>
  LWIP_ASSERT("p->next == NULL", p->next == NULL);
  /* add total length of second chain to last pbuf total of first chain */
  p->tot_len += t->tot_len;
  804de4:	66 03 53 08          	add    0x8(%ebx),%dx
  804de8:	66 89 50 08          	mov    %dx,0x8(%eax)
  /* chain last pbuf of head (p) with first of tail (t) */
  p->next = t;
  804dec:	89 18                	mov    %ebx,(%eax)
  /* p->next now references t, but the caller will drop its reference to t,
   * so netto there is no change to the reference count of t.
   */
}
  804dee:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  804df1:	c9                   	leave  
  804df2:	c3                   	ret    
  LWIP_ASSERT("p->tot_len == p->len (of last pbuf in chain)", p->tot_len == p->len);
  804df3:	83 ec 04             	sub    $0x4,%esp
  804df6:	68 c4 1e 81 00       	push   $0x811ec4
  804dfb:	68 4a 02 00 00       	push   $0x24a
  804e00:	68 a4 1c 81 00       	push   $0x811ca4
  804e05:	e8 3d 9a 00 00       	call   80e847 <_panic>

00804e0a <pbuf_chain>:
 * The ->ref field of the first pbuf of the tail chain is adjusted.
 *
 */
void
pbuf_chain(struct pbuf *h, struct pbuf *t)
{
  804e0a:	f3 0f 1e fb          	endbr32 
  804e0e:	55                   	push   %ebp
  804e0f:	89 e5                	mov    %esp,%ebp
  804e11:	53                   	push   %ebx
  804e12:	83 ec 0c             	sub    $0xc,%esp
  804e15:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  pbuf_cat(h, t);
  804e18:	53                   	push   %ebx
  804e19:	ff 75 08             	pushl  0x8(%ebp)
  804e1c:	e8 79 ff ff ff       	call   804d9a <pbuf_cat>
  /* t is now referenced by h */
  pbuf_ref(t);
  804e21:	89 1c 24             	mov    %ebx,(%esp)
  804e24:	e8 5c ff ff ff       	call   804d85 <pbuf_ref>
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_FRESH | 2, ("pbuf_chain: %p references %p\n", (void *)h, (void *)t));
}
  804e29:	83 c4 10             	add    $0x10,%esp
  804e2c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  804e2f:	c9                   	leave  
  804e30:	c3                   	ret    

00804e31 <pbuf_dechain>:
 * @return remainder of the pbuf chain, or NULL if it was de-allocated.
 * @note May not be called on a packet queue.
 */
struct pbuf *
pbuf_dechain(struct pbuf *p)
{
  804e31:	f3 0f 1e fb          	endbr32 
  804e35:	55                   	push   %ebp
  804e36:	89 e5                	mov    %esp,%ebp
  804e38:	57                   	push   %edi
  804e39:	56                   	push   %esi
  804e3a:	53                   	push   %ebx
  804e3b:	83 ec 1c             	sub    $0x1c,%esp
  804e3e:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct pbuf *q;
  u8_t tail_gone = 1;
  /* tail */
  q = p->next;
  804e41:	8b 33                	mov    (%ebx),%esi
  /* pbuf has successor in chain? */
  if (q != NULL) {
  804e43:	85 f6                	test   %esi,%esi
  804e45:	74 71                	je     804eb8 <pbuf_dechain+0x87>
    /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
    LWIP_ASSERT("p->tot_len == p->len + q->tot_len", q->tot_len == p->tot_len - p->len);
  804e47:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  804e4b:	0f b7 4b 0a          	movzwl 0xa(%ebx),%ecx
  804e4f:	0f b7 7e 08          	movzwl 0x8(%esi),%edi
  804e53:	89 7d e4             	mov    %edi,-0x1c(%ebp)
  804e56:	0f b7 d0             	movzwl %ax,%edx
  804e59:	0f b7 f9             	movzwl %cx,%edi
  804e5c:	29 fa                	sub    %edi,%edx
  804e5e:	39 55 e4             	cmp    %edx,-0x1c(%ebp)
  804e61:	75 3e                	jne    804ea1 <pbuf_dechain+0x70>
    /* enforce invariant if assertion is disabled */
    q->tot_len = p->tot_len - p->len;
  804e63:	29 c8                	sub    %ecx,%eax
  804e65:	66 89 46 08          	mov    %ax,0x8(%esi)
    /* decouple pbuf from remainder */
    p->next = NULL;
  804e69:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
    /* total length of pbuf p is its own length only */
    p->tot_len = p->len;
  804e6f:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  804e73:	66 89 43 08          	mov    %ax,0x8(%ebx)
    /* q is no longer referenced by p, free it */
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_STATE, ("pbuf_dechain: unreferencing %p\n", (void *)q));
    tail_gone = pbuf_free(q);
  804e77:	83 ec 0c             	sub    $0xc,%esp
  804e7a:	56                   	push   %esi
  804e7b:	e8 a8 fa ff ff       	call   804928 <pbuf_free>
                  ("pbuf_dechain: deallocated %p (as it is no longer referenced)\n", (void *)q));
    }
    /* return remaining tail or NULL if deallocated */
  }
  /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
  LWIP_ASSERT("p->tot_len == p->len", p->tot_len == p->len);
  804e80:	83 c4 10             	add    $0x10,%esp
  804e83:	0f b7 4b 0a          	movzwl 0xa(%ebx),%ecx
  804e87:	66 39 4b 08          	cmp    %cx,0x8(%ebx)
  804e8b:	75 35                	jne    804ec2 <pbuf_dechain+0x91>
  return ((tail_gone > 0) ? NULL : q);
  804e8d:	84 c0                	test   %al,%al
  804e8f:	b8 00 00 00 00       	mov    $0x0,%eax
  804e94:	0f 45 f0             	cmovne %eax,%esi
}
  804e97:	89 f0                	mov    %esi,%eax
  804e99:	8d 65 f4             	lea    -0xc(%ebp),%esp
  804e9c:	5b                   	pop    %ebx
  804e9d:	5e                   	pop    %esi
  804e9e:	5f                   	pop    %edi
  804e9f:	5d                   	pop    %ebp
  804ea0:	c3                   	ret    
    LWIP_ASSERT("p->tot_len == p->len + q->tot_len", q->tot_len == p->tot_len - p->len);
  804ea1:	83 ec 04             	sub    $0x4,%esp
  804ea4:	68 f4 1e 81 00       	push   $0x811ef4
  804ea9:	68 80 02 00 00       	push   $0x280
  804eae:	68 a4 1c 81 00       	push   $0x811ca4
  804eb3:	e8 8f 99 00 00       	call   80e847 <_panic>
  LWIP_ASSERT("p->tot_len == p->len", p->tot_len == p->len);
  804eb8:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  804ebc:	66 39 43 08          	cmp    %ax,0x8(%ebx)
  804ec0:	74 d5                	je     804e97 <pbuf_dechain+0x66>
  804ec2:	83 ec 04             	sub    $0x4,%esp
  804ec5:	68 d1 1d 81 00       	push   $0x811dd1
  804eca:	68 91 02 00 00       	push   $0x291
  804ecf:	68 a4 1c 81 00       	push   $0x811ca4
  804ed4:	e8 6e 99 00 00       	call   80e847 <_panic>

00804ed9 <pbuf_copy>:
 *         ERR_ARG if one of the pbufs is NULL or p_to is not big
 *                 enough to hold p_from
 */
err_t
pbuf_copy(struct pbuf *p_to, struct pbuf *p_from)
{
  804ed9:	f3 0f 1e fb          	endbr32 
  804edd:	55                   	push   %ebp
  804ede:	89 e5                	mov    %esp,%ebp
  804ee0:	57                   	push   %edi
  804ee1:	56                   	push   %esi
  804ee2:	53                   	push   %ebx
  804ee3:	83 ec 1c             	sub    $0x1c,%esp
  804ee6:	8b 7d 08             	mov    0x8(%ebp),%edi
  804ee9:	8b 5d 0c             	mov    0xc(%ebp),%ebx

  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_copy(%p, %p)\n",
    (void*)p_to, (void*)p_from));

  /* is the target big enough to hold the source? */
  LWIP_ERROR("pbuf_copy: target not big enough to hold source", ((p_to != NULL) &&
  804eec:	85 ff                	test   %edi,%edi
  804eee:	74 22                	je     804f12 <pbuf_copy+0x39>
  804ef0:	85 db                	test   %ebx,%ebx
  804ef2:	74 1e                	je     804f12 <pbuf_copy+0x39>
  804ef4:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  804ef8:	66 39 47 08          	cmp    %ax,0x8(%edi)
  804efc:	72 14                	jb     804f12 <pbuf_copy+0x39>
  u16_t offset_to=0, offset_from=0, len;
  804efe:	66 c7 45 e6 00 00    	movw   $0x0,-0x1a(%ebp)
  804f04:	66 c7 45 e4 00 00    	movw   $0x0,-0x1c(%ebp)
  804f0a:	89 7d 08             	mov    %edi,0x8(%ebp)
  804f0d:	e9 92 00 00 00       	jmp    804fa4 <pbuf_copy+0xcb>
  LWIP_ERROR("pbuf_copy: target not big enough to hold source", ((p_to != NULL) &&
  804f12:	83 ec 04             	sub    $0x4,%esp
  804f15:	68 18 1f 81 00       	push   $0x811f18
  804f1a:	68 b0 02 00 00       	push   $0x2b0
  804f1f:	68 a4 1c 81 00       	push   $0x811ca4
  804f24:	e8 1e 99 00 00       	call   80e847 <_panic>
      len = p_to->len - offset_to;
    }
    MEMCPY((u8_t*)p_to->payload + offset_to, (u8_t*)p_from->payload + offset_from, len);
    offset_to += len;
    offset_from += len;
    LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
  804f29:	83 ec 04             	sub    $0x4,%esp
  804f2c:	68 e6 1d 81 00       	push   $0x811de6
  804f31:	68 c2 02 00 00       	push   $0x2c2
  804f36:	68 a4 1c 81 00       	push   $0x811ca4
  804f3b:	e8 07 99 00 00       	call   80e847 <_panic>
    if (offset_to == p_to->len) {
      /* on to next p_to (if any) */
      offset_to = 0;
      p_to = p_to->next;
  804f40:	8b 45 08             	mov    0x8(%ebp),%eax
  804f43:	8b 00                	mov    (%eax),%eax
  804f45:	89 45 08             	mov    %eax,0x8(%ebp)
      offset_to = 0;
  804f48:	66 c7 45 e4 00 00    	movw   $0x0,-0x1c(%ebp)
  804f4e:	e9 c7 00 00 00       	jmp    80501a <pbuf_copy+0x141>
    }
    LWIP_ASSERT("offset_from <= p_from->len", offset_from <= p_from->len);
  804f53:	83 ec 04             	sub    $0x4,%esp
  804f56:	68 fd 1d 81 00       	push   $0x811dfd
  804f5b:	68 c8 02 00 00       	push   $0x2c8
  804f60:	68 a4 1c 81 00       	push   $0x811ca4
  804f65:	e8 dd 98 00 00       	call   80e847 <_panic>
    if (offset_from >= p_from->len) {
      /* on to next p_from (if any) */
      offset_from = 0;
  804f6a:	66 c7 45 e6 00 00    	movw   $0x0,-0x1a(%ebp)
      p_from = p_from->next;
    }

    if((p_from != NULL) && (p_from->len == p_from->tot_len)) {
  804f70:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  804f74:	66 39 43 0a          	cmp    %ax,0xa(%ebx)
  804f78:	0f 84 cf 00 00 00    	je     80504d <pbuf_copy+0x174>
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
                 (p_from->next == NULL), return ERR_VAL;);
    }
    if((p_to != NULL) && (p_to->len == p_to->tot_len)) {
  804f7e:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  804f82:	0f 84 05 01 00 00    	je     80508d <pbuf_copy+0x1b4>
  804f88:	8b 45 08             	mov    0x8(%ebp),%eax
  804f8b:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  804f8f:	8b 4d 08             	mov    0x8(%ebp),%ecx
  804f92:	66 39 41 0a          	cmp    %ax,0xa(%ecx)
  804f96:	0f 84 d1 00 00 00    	je     80506d <pbuf_copy+0x194>
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
                  (p_to->next == NULL), return ERR_VAL;);
    }
  } while (p_from);
  804f9c:	85 db                	test   %ebx,%ebx
  804f9e:	0f 84 00 01 00 00    	je     8050a4 <pbuf_copy+0x1cb>
    if ((p_to->len - offset_to) >= (p_from->len - offset_from)) {
  804fa4:	8b 45 08             	mov    0x8(%ebp),%eax
  804fa7:	0f b7 70 0a          	movzwl 0xa(%eax),%esi
  804fab:	0f b7 ce             	movzwl %si,%ecx
  804fae:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  804fb2:	29 c1                	sub    %eax,%ecx
  804fb4:	0f b7 53 0a          	movzwl 0xa(%ebx),%edx
  804fb8:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  804fbc:	29 c2                	sub    %eax,%edx
      len = p_from->len - offset_from;
  804fbe:	0f b7 7b 0a          	movzwl 0xa(%ebx),%edi
  804fc2:	66 2b 7d e6          	sub    -0x1a(%ebp),%di
  804fc6:	89 f8                	mov    %edi,%eax
  804fc8:	0f b7 7d e4          	movzwl -0x1c(%ebp),%edi
  804fcc:	29 fe                	sub    %edi,%esi
  804fce:	39 d1                	cmp    %edx,%ecx
  804fd0:	0f 4d f0             	cmovge %eax,%esi
    MEMCPY((u8_t*)p_to->payload + offset_to, (u8_t*)p_from->payload + offset_from, len);
  804fd3:	83 ec 04             	sub    $0x4,%esp
  804fd6:	0f b7 c6             	movzwl %si,%eax
  804fd9:	50                   	push   %eax
  804fda:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  804fde:	03 43 04             	add    0x4(%ebx),%eax
  804fe1:	50                   	push   %eax
  804fe2:	0f b7 c7             	movzwl %di,%eax
  804fe5:	8b 4d 08             	mov    0x8(%ebp),%ecx
  804fe8:	03 41 04             	add    0x4(%ecx),%eax
  804feb:	50                   	push   %eax
  804fec:	e8 63 a1 00 00       	call   80f154 <memcpy>
    offset_to += len;
  804ff1:	89 fa                	mov    %edi,%edx
  804ff3:	01 f2                	add    %esi,%edx
  804ff5:	66 89 55 e4          	mov    %dx,-0x1c(%ebp)
    offset_from += len;
  804ff9:	66 01 75 e6          	add    %si,-0x1a(%ebp)
    LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
  804ffd:	8b 45 08             	mov    0x8(%ebp),%eax
  805000:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
  805004:	83 c4 10             	add    $0x10,%esp
  805007:	66 39 d0             	cmp    %dx,%ax
  80500a:	0f 82 19 ff ff ff    	jb     804f29 <pbuf_copy+0x50>
    if (offset_to == p_to->len) {
  805010:	66 3b 45 e4          	cmp    -0x1c(%ebp),%ax
  805014:	0f 84 26 ff ff ff    	je     804f40 <pbuf_copy+0x67>
    LWIP_ASSERT("offset_from <= p_from->len", offset_from <= p_from->len);
  80501a:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  80501e:	66 3b 45 e6          	cmp    -0x1a(%ebp),%ax
  805022:	0f 82 2b ff ff ff    	jb     804f53 <pbuf_copy+0x7a>
    if (offset_from >= p_from->len) {
  805028:	66 3b 45 e6          	cmp    -0x1a(%ebp),%ax
  80502c:	0f 85 3e ff ff ff    	jne    804f70 <pbuf_copy+0x97>
      p_from = p_from->next;
  805032:	8b 1b                	mov    (%ebx),%ebx
    if((p_from != NULL) && (p_from->len == p_from->tot_len)) {
  805034:	85 db                	test   %ebx,%ebx
  805036:	0f 85 2e ff ff ff    	jne    804f6a <pbuf_copy+0x91>
    if((p_to != NULL) && (p_to->len == p_to->tot_len)) {
  80503c:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  805040:	74 62                	je     8050a4 <pbuf_copy+0x1cb>
      offset_from = 0;
  805042:	66 c7 45 e6 00 00    	movw   $0x0,-0x1a(%ebp)
  805048:	e9 3b ff ff ff       	jmp    804f88 <pbuf_copy+0xaf>
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
  80504d:	83 3b 00             	cmpl   $0x0,(%ebx)
  805050:	0f 84 28 ff ff ff    	je     804f7e <pbuf_copy+0xa5>
  805056:	83 ec 04             	sub    $0x4,%esp
  805059:	68 48 1f 81 00       	push   $0x811f48
  80505e:	68 d1 02 00 00       	push   $0x2d1
  805063:	68 a4 1c 81 00       	push   $0x811ca4
  805068:	e8 da 97 00 00       	call   80e847 <_panic>
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
  80506d:	83 39 00             	cmpl   $0x0,(%ecx)
  805070:	0f 84 26 ff ff ff    	je     804f9c <pbuf_copy+0xc3>
  805076:	83 ec 04             	sub    $0x4,%esp
  805079:	68 48 1f 81 00       	push   $0x811f48
  80507e:	68 d6 02 00 00       	push   $0x2d6
  805083:	68 a4 1c 81 00       	push   $0x811ca4
  805088:	e8 ba 97 00 00       	call   80e847 <_panic>
    LWIP_ASSERT("p_to != NULL", p_to != NULL);
  80508d:	83 ec 04             	sub    $0x4,%esp
  805090:	68 18 1e 81 00       	push   $0x811e18
  805095:	68 b6 02 00 00       	push   $0x2b6
  80509a:	68 a4 1c 81 00       	push   $0x811ca4
  80509f:	e8 a3 97 00 00       	call   80e847 <_panic>
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 1, ("pbuf_copy: end of chain reached.\n"));
  return ERR_OK;
}
  8050a4:	b8 00 00 00 00       	mov    $0x0,%eax
  8050a9:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8050ac:	5b                   	pop    %ebx
  8050ad:	5e                   	pop    %esi
  8050ae:	5f                   	pop    %edi
  8050af:	5d                   	pop    %ebp
  8050b0:	c3                   	ret    

008050b1 <pbuf_copy_partial>:
 * @param len length of data to copy (dataptr must be big enough)
 * @param offset offset into the packet buffer from where to begin copying len bytes
 */
u16_t
pbuf_copy_partial(struct pbuf *buf, void *dataptr, u16_t len, u16_t offset)
{
  8050b1:	f3 0f 1e fb          	endbr32 
  8050b5:	55                   	push   %ebp
  8050b6:	89 e5                	mov    %esp,%ebp
  8050b8:	57                   	push   %edi
  8050b9:	56                   	push   %esi
  8050ba:	53                   	push   %ebx
  8050bb:	83 ec 1c             	sub    $0x1c,%esp
  8050be:	8b 75 08             	mov    0x8(%ebp),%esi
  8050c1:	0f b7 7d 10          	movzwl 0x10(%ebp),%edi
  8050c5:	0f b7 45 14          	movzwl 0x14(%ebp),%eax
  struct pbuf *p;
  u16_t left;
  u16_t buf_copy_len;
  u16_t copied_total = 0;

  LWIP_ERROR("netbuf_copy_partial: invalid buf", (buf != NULL), return 0;);
  8050c9:	85 f6                	test   %esi,%esi
  8050cb:	74 14                	je     8050e1 <pbuf_copy_partial+0x30>
  LWIP_ERROR("netbuf_copy_partial: invalid dataptr", (dataptr != NULL), return 0;);
  8050cd:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  8050d1:	74 25                	je     8050f8 <pbuf_copy_partial+0x47>
  u16_t copied_total = 0;
  8050d3:	66 c7 45 e4 00 00    	movw   $0x0,-0x1c(%ebp)

  left = 0;
  8050d9:	66 c7 45 e6 00 00    	movw   $0x0,-0x1a(%ebp)
  8050df:	eb 69                	jmp    80514a <pbuf_copy_partial+0x99>
  LWIP_ERROR("netbuf_copy_partial: invalid buf", (buf != NULL), return 0;);
  8050e1:	83 ec 04             	sub    $0x4,%esp
  8050e4:	68 74 1f 81 00       	push   $0x811f74
  8050e9:	68 ef 02 00 00       	push   $0x2ef
  8050ee:	68 a4 1c 81 00       	push   $0x811ca4
  8050f3:	e8 4f 97 00 00       	call   80e847 <_panic>
  LWIP_ERROR("netbuf_copy_partial: invalid dataptr", (dataptr != NULL), return 0;);
  8050f8:	83 ec 04             	sub    $0x4,%esp
  8050fb:	68 98 1f 81 00       	push   $0x811f98
  805100:	68 f0 02 00 00       	push   $0x2f0
  805105:	68 a4 1c 81 00       	push   $0x811ca4
  80510a:	e8 38 97 00 00       	call   80e847 <_panic>
    if ((offset != 0) && (offset >= p->len)) {
      /* don't copy from this buffer -> on to the next */
      offset -= p->len;
    } else {
      /* copy from this buffer. maybe only partially. */
      buf_copy_len = p->len - offset;
  80510f:	0f b7 5e 0a          	movzwl 0xa(%esi),%ebx
  805113:	29 c3                	sub    %eax,%ebx
  805115:	66 39 df             	cmp    %bx,%di
  805118:	0f 46 df             	cmovbe %edi,%ebx
      if (buf_copy_len > len)
          buf_copy_len = len;
      /* copy the necessary parts of the buffer */
      MEMCPY(&((char*)dataptr)[left], &((char*)p->payload)[offset], buf_copy_len);
  80511b:	83 ec 04             	sub    $0x4,%esp
  80511e:	0f b7 d3             	movzwl %bx,%edx
  805121:	52                   	push   %edx
  805122:	0f b7 c0             	movzwl %ax,%eax
  805125:	03 46 04             	add    0x4(%esi),%eax
  805128:	50                   	push   %eax
  805129:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  80512d:	03 45 0c             	add    0xc(%ebp),%eax
  805130:	50                   	push   %eax
  805131:	e8 1e a0 00 00       	call   80f154 <memcpy>
      copied_total += buf_copy_len;
  805136:	66 01 5d e4          	add    %bx,-0x1c(%ebp)
      left += buf_copy_len;
  80513a:	66 01 5d e6          	add    %bx,-0x1a(%ebp)
      len -= buf_copy_len;
  80513e:	29 df                	sub    %ebx,%edi
  805140:	83 c4 10             	add    $0x10,%esp
      offset = 0;
  805143:	b8 00 00 00 00       	mov    $0x0,%eax
  for(p = buf; len != 0 && p != NULL; p = p->next) {
  805148:	8b 36                	mov    (%esi),%esi
  80514a:	66 85 ff             	test   %di,%di
  80514d:	74 16                	je     805165 <pbuf_copy_partial+0xb4>
  80514f:	85 f6                	test   %esi,%esi
  805151:	74 12                	je     805165 <pbuf_copy_partial+0xb4>
    if ((offset != 0) && (offset >= p->len)) {
  805153:	66 85 c0             	test   %ax,%ax
  805156:	74 b7                	je     80510f <pbuf_copy_partial+0x5e>
  805158:	0f b7 56 0a          	movzwl 0xa(%esi),%edx
  80515c:	66 39 c2             	cmp    %ax,%dx
  80515f:	77 ae                	ja     80510f <pbuf_copy_partial+0x5e>
      offset -= p->len;
  805161:	29 d0                	sub    %edx,%eax
  805163:	eb e3                	jmp    805148 <pbuf_copy_partial+0x97>
    }
  }
  return copied_total;
}
  805165:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  805169:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80516c:	5b                   	pop    %ebx
  80516d:	5e                   	pop    %esi
  80516e:	5f                   	pop    %edi
  80516f:	5d                   	pop    %ebp
  805170:	c3                   	ret    

00805171 <sswt_handler>:
 *
 * @param arg struct sswt_cb* used to signal a semaphore and end waiting.
 */
static void
sswt_handler(void *arg)
{
  805171:	f3 0f 1e fb          	endbr32 
  805175:	55                   	push   %ebp
  805176:	89 e5                	mov    %esp,%ebp
  805178:	83 ec 14             	sub    $0x14,%esp
  80517b:	8b 45 08             	mov    0x8(%ebp),%eax
  struct sswt_cb *sswt_cb = (struct sswt_cb *) arg;

  /* Timeout. Set flag to TRUE and signal semaphore */
  sswt_cb->timeflag = 1;
  80517e:	66 c7 00 01 00       	movw   $0x1,(%eax)
  sys_sem_signal(*(sswt_cb->psem));
  805183:	8b 40 04             	mov    0x4(%eax),%eax
  805186:	ff 30                	pushl  (%eax)
  805188:	e8 ed 50 00 00       	call   80a27a <sys_sem_signal>
}
  80518d:	83 c4 10             	add    $0x10,%esp
  805190:	c9                   	leave  
  805191:	c3                   	ret    

00805192 <sys_mbox_fetch>:
{
  805192:	f3 0f 1e fb          	endbr32 
  805196:	55                   	push   %ebp
  805197:	89 e5                	mov    %esp,%ebp
  805199:	57                   	push   %edi
  80519a:	56                   	push   %esi
  80519b:	53                   	push   %ebx
  80519c:	83 ec 0c             	sub    $0xc,%esp
  80519f:	8b 7d 0c             	mov    0xc(%ebp),%edi
  8051a2:	eb 44                	jmp    8051e8 <sys_mbox_fetch+0x56>
    time_needed = sys_arch_mbox_fetch(mbox, msg, 0);
  8051a4:	83 ec 04             	sub    $0x4,%esp
  8051a7:	6a 00                	push   $0x0
  8051a9:	57                   	push   %edi
  8051aa:	ff 75 08             	pushl  0x8(%ebp)
  8051ad:	e8 4d 53 00 00       	call   80a4ff <sys_arch_mbox_fetch>
  8051b2:	83 c4 10             	add    $0x10,%esp
}
  8051b5:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8051b8:	5b                   	pop    %ebx
  8051b9:	5e                   	pop    %esi
  8051ba:	5f                   	pop    %edi
  8051bb:	5d                   	pop    %ebp
  8051bc:	c3                   	ret    
      tmptimeout = timeouts->next;
  8051bd:	8b 03                	mov    (%ebx),%eax
      timeouts->next = tmptimeout->next;
  8051bf:	8b 10                	mov    (%eax),%edx
  8051c1:	89 13                	mov    %edx,(%ebx)
      h   = tmptimeout->h;
  8051c3:	8b 58 08             	mov    0x8(%eax),%ebx
      arg = tmptimeout->arg;
  8051c6:	8b 70 0c             	mov    0xc(%eax),%esi
      memp_free(MEMP_SYS_TIMEOUT, tmptimeout);
  8051c9:	83 ec 08             	sub    $0x8,%esp
  8051cc:	50                   	push   %eax
  8051cd:	6a 0b                	push   $0xb
  8051cf:	e8 d1 f3 ff ff       	call   8045a5 <memp_free>
      if (h != NULL) {
  8051d4:	83 c4 10             	add    $0x10,%esp
  8051d7:	85 db                	test   %ebx,%ebx
  8051d9:	74 0d                	je     8051e8 <sys_mbox_fetch+0x56>
        h(arg);
  8051db:	83 ec 0c             	sub    $0xc,%esp
  8051de:	56                   	push   %esi
  8051df:	ff d3                	call   *%ebx
  8051e1:	83 c4 10             	add    $0x10,%esp
  8051e4:	f3 0f 1e fb          	endbr32 
  timeouts = sys_arch_timeouts();
  8051e8:	e8 b3 54 00 00       	call   80a6a0 <sys_arch_timeouts>
  8051ed:	89 c3                	mov    %eax,%ebx
  if (!timeouts || !timeouts->next) {
  8051ef:	85 c0                	test   %eax,%eax
  8051f1:	74 b1                	je     8051a4 <sys_mbox_fetch+0x12>
  8051f3:	8b 00                	mov    (%eax),%eax
  8051f5:	85 c0                	test   %eax,%eax
  8051f7:	74 ab                	je     8051a4 <sys_mbox_fetch+0x12>
    if (timeouts->next->time > 0) {
  8051f9:	8b 40 04             	mov    0x4(%eax),%eax
  8051fc:	85 c0                	test   %eax,%eax
  8051fe:	74 bd                	je     8051bd <sys_mbox_fetch+0x2b>
      time_needed = sys_arch_mbox_fetch(mbox, msg, timeouts->next->time);
  805200:	83 ec 04             	sub    $0x4,%esp
  805203:	50                   	push   %eax
  805204:	57                   	push   %edi
  805205:	ff 75 08             	pushl  0x8(%ebp)
  805208:	e8 f2 52 00 00       	call   80a4ff <sys_arch_mbox_fetch>
    if (time_needed == SYS_ARCH_TIMEOUT) {
  80520d:	83 c4 10             	add    $0x10,%esp
  805210:	83 f8 ff             	cmp    $0xffffffff,%eax
  805213:	74 a8                	je     8051bd <sys_mbox_fetch+0x2b>
      if (time_needed < timeouts->next->time) {
  805215:	8b 0b                	mov    (%ebx),%ecx
  805217:	8b 59 04             	mov    0x4(%ecx),%ebx
        timeouts->next->time -= time_needed;
  80521a:	89 da                	mov    %ebx,%edx
  80521c:	29 c2                	sub    %eax,%edx
  80521e:	39 c3                	cmp    %eax,%ebx
  805220:	b8 00 00 00 00       	mov    $0x0,%eax
  805225:	0f 47 c2             	cmova  %edx,%eax
  805228:	89 41 04             	mov    %eax,0x4(%ecx)
  80522b:	eb 88                	jmp    8051b5 <sys_mbox_fetch+0x23>

0080522d <sys_sem_wait>:
{
  80522d:	f3 0f 1e fb          	endbr32 
  805231:	55                   	push   %ebp
  805232:	89 e5                	mov    %esp,%ebp
  805234:	57                   	push   %edi
  805235:	56                   	push   %esi
  805236:	53                   	push   %ebx
  805237:	83 ec 0c             	sub    $0xc,%esp
  80523a:	8b 75 08             	mov    0x8(%ebp),%esi
  80523d:	eb 41                	jmp    805280 <sys_sem_wait+0x53>
    sys_arch_sem_wait(sem, 0);
  80523f:	83 ec 08             	sub    $0x8,%esp
  805242:	6a 00                	push   $0x0
  805244:	56                   	push   %esi
  805245:	e8 a4 50 00 00       	call   80a2ee <sys_arch_sem_wait>
  80524a:	83 c4 10             	add    $0x10,%esp
}
  80524d:	8d 65 f4             	lea    -0xc(%ebp),%esp
  805250:	5b                   	pop    %ebx
  805251:	5e                   	pop    %esi
  805252:	5f                   	pop    %edi
  805253:	5d                   	pop    %ebp
  805254:	c3                   	ret    
      tmptimeout = timeouts->next;
  805255:	8b 03                	mov    (%ebx),%eax
      timeouts->next = tmptimeout->next;
  805257:	8b 10                	mov    (%eax),%edx
  805259:	89 13                	mov    %edx,(%ebx)
      h = tmptimeout->h;
  80525b:	8b 58 08             	mov    0x8(%eax),%ebx
      arg = tmptimeout->arg;
  80525e:	8b 78 0c             	mov    0xc(%eax),%edi
      memp_free(MEMP_SYS_TIMEOUT, tmptimeout);
  805261:	83 ec 08             	sub    $0x8,%esp
  805264:	50                   	push   %eax
  805265:	6a 0b                	push   $0xb
  805267:	e8 39 f3 ff ff       	call   8045a5 <memp_free>
      if (h != NULL) {
  80526c:	83 c4 10             	add    $0x10,%esp
  80526f:	85 db                	test   %ebx,%ebx
  805271:	74 0d                	je     805280 <sys_sem_wait+0x53>
        h(arg);
  805273:	83 ec 0c             	sub    $0xc,%esp
  805276:	57                   	push   %edi
  805277:	ff d3                	call   *%ebx
  805279:	83 c4 10             	add    $0x10,%esp
  80527c:	f3 0f 1e fb          	endbr32 
  timeouts = sys_arch_timeouts();
  805280:	e8 1b 54 00 00       	call   80a6a0 <sys_arch_timeouts>
  805285:	89 c3                	mov    %eax,%ebx
  if (!timeouts || !timeouts->next) {
  805287:	85 c0                	test   %eax,%eax
  805289:	74 b4                	je     80523f <sys_sem_wait+0x12>
  80528b:	8b 00                	mov    (%eax),%eax
  80528d:	85 c0                	test   %eax,%eax
  80528f:	74 ae                	je     80523f <sys_sem_wait+0x12>
    if (timeouts->next->time > 0) {
  805291:	8b 40 04             	mov    0x4(%eax),%eax
  805294:	85 c0                	test   %eax,%eax
  805296:	74 bd                	je     805255 <sys_sem_wait+0x28>
      time_needed = sys_arch_sem_wait(sem, timeouts->next->time);
  805298:	83 ec 08             	sub    $0x8,%esp
  80529b:	50                   	push   %eax
  80529c:	56                   	push   %esi
  80529d:	e8 4c 50 00 00       	call   80a2ee <sys_arch_sem_wait>
    if (time_needed == SYS_ARCH_TIMEOUT) {
  8052a2:	83 c4 10             	add    $0x10,%esp
  8052a5:	83 f8 ff             	cmp    $0xffffffff,%eax
  8052a8:	74 ab                	je     805255 <sys_sem_wait+0x28>
      if (time_needed < timeouts->next->time) {
  8052aa:	8b 0b                	mov    (%ebx),%ecx
  8052ac:	8b 59 04             	mov    0x4(%ecx),%ebx
        timeouts->next->time -= time_needed;
  8052af:	89 da                	mov    %ebx,%edx
  8052b1:	29 c2                	sub    %eax,%edx
  8052b3:	39 c3                	cmp    %eax,%ebx
  8052b5:	b8 00 00 00 00       	mov    $0x0,%eax
  8052ba:	0f 47 c2             	cmova  %edx,%eax
  8052bd:	89 41 04             	mov    %eax,0x4(%ecx)
  8052c0:	eb 8b                	jmp    80524d <sys_sem_wait+0x20>

008052c2 <sys_timeout>:
{
  8052c2:	f3 0f 1e fb          	endbr32 
  8052c6:	55                   	push   %ebp
  8052c7:	89 e5                	mov    %esp,%ebp
  8052c9:	57                   	push   %edi
  8052ca:	56                   	push   %esi
  8052cb:	53                   	push   %ebx
  8052cc:	83 ec 28             	sub    $0x28,%esp
  8052cf:	8b 75 08             	mov    0x8(%ebp),%esi
  timeout = memp_malloc(MEMP_SYS_TIMEOUT);
  8052d2:	6a 0b                	push   $0xb
  8052d4:	e8 72 f2 ff ff       	call   80454b <memp_malloc>
  if (timeout == NULL) {
  8052d9:	83 c4 10             	add    $0x10,%esp
  8052dc:	85 c0                	test   %eax,%eax
  8052de:	74 40                	je     805320 <sys_timeout+0x5e>
  8052e0:	89 c3                	mov    %eax,%ebx
  timeout->next = NULL;
  8052e2:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  timeout->h = h;
  8052e8:	8b 45 0c             	mov    0xc(%ebp),%eax
  8052eb:	89 43 08             	mov    %eax,0x8(%ebx)
  timeout->arg = arg;
  8052ee:	8b 45 10             	mov    0x10(%ebp),%eax
  8052f1:	89 43 0c             	mov    %eax,0xc(%ebx)
  timeout->time = msecs;
  8052f4:	89 73 04             	mov    %esi,0x4(%ebx)
  timeouts = sys_arch_timeouts();
  8052f7:	e8 a4 53 00 00       	call   80a6a0 <sys_arch_timeouts>
  if (timeouts == NULL) {
  8052fc:	85 c0                	test   %eax,%eax
  8052fe:	74 37                	je     805337 <sys_timeout+0x75>
  if (timeouts->next == NULL) {
  805300:	8b 10                	mov    (%eax),%edx
  805302:	85 d2                	test   %edx,%edx
  805304:	74 48                	je     80534e <sys_timeout+0x8c>
  if (timeouts->next->time > msecs) {
  805306:	8b 4a 04             	mov    0x4(%edx),%ecx
  805309:	39 f1                	cmp    %esi,%ecx
  80530b:	76 45                	jbe    805352 <sys_timeout+0x90>
    timeouts->next->time -= msecs;
  80530d:	29 f1                	sub    %esi,%ecx
  80530f:	89 4a 04             	mov    %ecx,0x4(%edx)
    timeout->next = timeouts->next;
  805312:	8b 10                	mov    (%eax),%edx
  805314:	89 13                	mov    %edx,(%ebx)
    timeouts->next = timeout;
  805316:	89 18                	mov    %ebx,(%eax)
}
  805318:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80531b:	5b                   	pop    %ebx
  80531c:	5e                   	pop    %esi
  80531d:	5f                   	pop    %edi
  80531e:	5d                   	pop    %ebp
  80531f:	c3                   	ret    
    LWIP_ASSERT("sys_timeout: timeout != NULL", timeout != NULL);
  805320:	83 ec 04             	sub    $0x4,%esp
  805323:	68 bd 1f 81 00       	push   $0x811fbd
  805328:	68 c3 00 00 00       	push   $0xc3
  80532d:	68 da 1f 81 00       	push   $0x811fda
  805332:	e8 10 95 00 00       	call   80e847 <_panic>
    LWIP_ASSERT("sys_timeout: timeouts != NULL", timeouts != NULL);
  805337:	83 ec 04             	sub    $0x4,%esp
  80533a:	68 ee 1f 81 00       	push   $0x811fee
  80533f:	68 d1 00 00 00       	push   $0xd1
  805344:	68 da 1f 81 00       	push   $0x811fda
  805349:	e8 f9 94 00 00       	call   80e847 <_panic>
    timeouts->next = timeout;
  80534e:	89 18                	mov    %ebx,(%eax)
    return;
  805350:	eb c6                	jmp    805318 <sys_timeout+0x56>
      timeout->time -= t->time;
  805352:	8b 7b 04             	mov    0x4(%ebx),%edi
  805355:	8b 72 04             	mov    0x4(%edx),%esi
  805358:	89 f8                	mov    %edi,%eax
  80535a:	29 f0                	sub    %esi,%eax
  80535c:	89 43 04             	mov    %eax,0x4(%ebx)
  80535f:	89 55 e4             	mov    %edx,-0x1c(%ebp)
      if (t->next == NULL || t->next->time > timeout->time) {
  805362:	8b 12                	mov    (%edx),%edx
  805364:	85 d2                	test   %edx,%edx
  805366:	74 0e                	je     805376 <sys_timeout+0xb4>
  805368:	8b 4a 04             	mov    0x4(%edx),%ecx
  80536b:	39 c8                	cmp    %ecx,%eax
  80536d:	73 e3                	jae    805352 <sys_timeout+0x90>
          t->next->time -= timeout->time;
  80536f:	29 f9                	sub    %edi,%ecx
  805371:	01 ce                	add    %ecx,%esi
  805373:	89 72 04             	mov    %esi,0x4(%edx)
        timeout->next = t->next;
  805376:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  805379:	8b 07                	mov    (%edi),%eax
  80537b:	89 03                	mov    %eax,(%ebx)
        t->next = timeout;
  80537d:	89 1f                	mov    %ebx,(%edi)
        break;
  80537f:	eb 97                	jmp    805318 <sys_timeout+0x56>

00805381 <sys_untimeout>:
{
  805381:	f3 0f 1e fb          	endbr32 
  805385:	55                   	push   %ebp
  805386:	89 e5                	mov    %esp,%ebp
  805388:	57                   	push   %edi
  805389:	56                   	push   %esi
  80538a:	53                   	push   %ebx
  80538b:	83 ec 0c             	sub    $0xc,%esp
  80538e:	8b 5d 08             	mov    0x8(%ebp),%ebx
  805391:	8b 75 0c             	mov    0xc(%ebp),%esi
  timeouts = sys_arch_timeouts();
  805394:	e8 07 53 00 00       	call   80a6a0 <sys_arch_timeouts>
  if (timeouts == NULL) {
  805399:	85 c0                	test   %eax,%eax
  80539b:	74 0f                	je     8053ac <sys_untimeout+0x2b>
  80539d:	89 c7                	mov    %eax,%edi
  if (timeouts->next == NULL) {
  80539f:	8b 10                	mov    (%eax),%edx
  8053a1:	85 d2                	test   %edx,%edx
  8053a3:	74 5a                	je     8053ff <sys_untimeout+0x7e>
  for (t = timeouts->next, prev_t = NULL; t != NULL; prev_t = t, t = t->next) {
  8053a5:	b8 00 00 00 00       	mov    $0x0,%eax
  8053aa:	eb 27                	jmp    8053d3 <sys_untimeout+0x52>
    LWIP_ASSERT("sys_untimeout: timeouts != NULL", timeouts != NULL);
  8053ac:	83 ec 04             	sub    $0x4,%esp
  8053af:	68 0c 20 81 00       	push   $0x81200c
  8053b4:	68 00 01 00 00       	push   $0x100
  8053b9:	68 da 1f 81 00       	push   $0x811fda
  8053be:	e8 84 94 00 00       	call   80e847 <_panic>
        timeouts->next = t->next;
  8053c3:	8b 02                	mov    (%edx),%eax
  8053c5:	89 07                	mov    %eax,(%edi)
  8053c7:	eb 1c                	jmp    8053e5 <sys_untimeout+0x64>
  for (t = timeouts->next, prev_t = NULL; t != NULL; prev_t = t, t = t->next) {
  8053c9:	8b 0a                	mov    (%edx),%ecx
  8053cb:	89 d0                	mov    %edx,%eax
  8053cd:	85 c9                	test   %ecx,%ecx
  8053cf:	74 2e                	je     8053ff <sys_untimeout+0x7e>
  8053d1:	89 ca                	mov    %ecx,%edx
    if ((t->h == h) && (t->arg == arg)) {
  8053d3:	39 5a 08             	cmp    %ebx,0x8(%edx)
  8053d6:	75 f1                	jne    8053c9 <sys_untimeout+0x48>
  8053d8:	39 72 0c             	cmp    %esi,0xc(%edx)
  8053db:	75 ec                	jne    8053c9 <sys_untimeout+0x48>
      if (prev_t == NULL)
  8053dd:	85 c0                	test   %eax,%eax
  8053df:	74 e2                	je     8053c3 <sys_untimeout+0x42>
        prev_t->next = t->next;
  8053e1:	8b 0a                	mov    (%edx),%ecx
  8053e3:	89 08                	mov    %ecx,(%eax)
      if (t->next != NULL)
  8053e5:	8b 02                	mov    (%edx),%eax
  8053e7:	85 c0                	test   %eax,%eax
  8053e9:	74 06                	je     8053f1 <sys_untimeout+0x70>
        t->next->time += t->time;
  8053eb:	8b 4a 04             	mov    0x4(%edx),%ecx
  8053ee:	01 48 04             	add    %ecx,0x4(%eax)
      memp_free(MEMP_SYS_TIMEOUT, t);
  8053f1:	83 ec 08             	sub    $0x8,%esp
  8053f4:	52                   	push   %edx
  8053f5:	6a 0b                	push   $0xb
  8053f7:	e8 a9 f1 ff ff       	call   8045a5 <memp_free>
      return;
  8053fc:	83 c4 10             	add    $0x10,%esp
}
  8053ff:	8d 65 f4             	lea    -0xc(%ebp),%esp
  805402:	5b                   	pop    %ebx
  805403:	5e                   	pop    %esi
  805404:	5f                   	pop    %edi
  805405:	5d                   	pop    %ebp
  805406:	c3                   	ret    

00805407 <sys_sem_wait_timeout>:
 * @param timeout timeout in ms (0: wait forever)
 * @return 0 on timeout, 1 otherwise
 */
int
sys_sem_wait_timeout(sys_sem_t sem, u32_t timeout)
{
  805407:	f3 0f 1e fb          	endbr32 
  80540b:	55                   	push   %ebp
  80540c:	89 e5                	mov    %esp,%ebp
  80540e:	83 ec 18             	sub    $0x18,%esp
  805411:	8b 45 0c             	mov    0xc(%ebp),%eax
  struct sswt_cb sswt_cb;

  sswt_cb.psem = &sem;
  805414:	8d 4d 08             	lea    0x8(%ebp),%ecx
  805417:	89 4d f4             	mov    %ecx,-0xc(%ebp)
  sswt_cb.timeflag = 0;
  80541a:	66 c7 45 f0 00 00    	movw   $0x0,-0x10(%ebp)

  /* If timeout is zero, then just wait forever */
  if (timeout > 0) {
  805420:	85 c0                	test   %eax,%eax
  805422:	75 1c                	jne    805440 <sys_sem_wait_timeout+0x39>
    /* Create a timer and pass it the address of our flag */
    sys_timeout(timeout, sswt_handler, &sswt_cb);
  }
  sys_sem_wait(sem);
  805424:	83 ec 0c             	sub    $0xc,%esp
  805427:	ff 75 08             	pushl  0x8(%ebp)
  80542a:	e8 fe fd ff ff       	call   80522d <sys_sem_wait>
  /* Was it a timeout? */
  if (sswt_cb.timeflag) {
  80542f:	83 c4 10             	add    $0x10,%esp
    /* timeout */
    return 0;
  805432:	b8 00 00 00 00       	mov    $0x0,%eax
  if (sswt_cb.timeflag) {
  805437:	66 83 7d f0 00       	cmpw   $0x0,-0x10(%ebp)
  80543c:	74 19                	je     805457 <sys_sem_wait_timeout+0x50>
  } else {
    /* Not a timeout. Remove timeout entry */
    sys_untimeout(sswt_handler, &sswt_cb);
    return 1;
  }
}
  80543e:	c9                   	leave  
  80543f:	c3                   	ret    
    sys_timeout(timeout, sswt_handler, &sswt_cb);
  805440:	83 ec 04             	sub    $0x4,%esp
  805443:	8d 55 f0             	lea    -0x10(%ebp),%edx
  805446:	52                   	push   %edx
  805447:	68 71 51 80 00       	push   $0x805171
  80544c:	50                   	push   %eax
  80544d:	e8 70 fe ff ff       	call   8052c2 <sys_timeout>
  805452:	83 c4 10             	add    $0x10,%esp
  805455:	eb cd                	jmp    805424 <sys_sem_wait_timeout+0x1d>
    sys_untimeout(sswt_handler, &sswt_cb);
  805457:	83 ec 08             	sub    $0x8,%esp
  80545a:	8d 45 f0             	lea    -0x10(%ebp),%eax
  80545d:	50                   	push   %eax
  80545e:	68 71 51 80 00       	push   $0x805171
  805463:	e8 19 ff ff ff       	call   805381 <sys_untimeout>
    return 1;
  805468:	83 c4 10             	add    $0x10,%esp
  80546b:	b8 01 00 00 00       	mov    $0x1,%eax
  805470:	eb cc                	jmp    80543e <sys_sem_wait_timeout+0x37>

00805472 <sys_msleep>:
 *
 * @param ms number of milliseconds to sleep
 */
void
sys_msleep(u32_t ms)
{
  805472:	f3 0f 1e fb          	endbr32 
  805476:	55                   	push   %ebp
  805477:	89 e5                	mov    %esp,%ebp
  805479:	53                   	push   %ebx
  80547a:	83 ec 10             	sub    $0x10,%esp
  sys_sem_t delaysem = sys_sem_new(0);
  80547d:	6a 00                	push   $0x0
  80547f:	e8 29 4b 00 00       	call   809fad <sys_sem_new>
  805484:	89 c3                	mov    %eax,%ebx

  sys_sem_wait_timeout(delaysem, ms);
  805486:	83 c4 08             	add    $0x8,%esp
  805489:	ff 75 08             	pushl  0x8(%ebp)
  80548c:	50                   	push   %eax
  80548d:	e8 75 ff ff ff       	call   805407 <sys_sem_wait_timeout>

  sys_sem_free(delaysem);
  805492:	89 1c 24             	mov    %ebx,(%esp)
  805495:	e8 98 4b 00 00       	call   80a032 <sys_sem_free>
}
  80549a:	83 c4 10             	add    $0x10,%esp
  80549d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  8054a0:	c9                   	leave  
  8054a1:	c3                   	ret    

008054a2 <tcp_accept_null>:
/**
 * Default accept callback if no accept callback is specified by the user.
 */
static err_t
tcp_accept_null(void *arg, struct tcp_pcb *pcb, err_t err)
{
  8054a2:	f3 0f 1e fb          	endbr32 
  LWIP_UNUSED_ARG(arg);
  LWIP_UNUSED_ARG(pcb);
  LWIP_UNUSED_ARG(err);

  return ERR_ABRT;
}
  8054a6:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
  8054ab:	c3                   	ret    

008054ac <tcp_new_port>:
 *
 * @return a new (free) local TCP port number
 */
static u16_t
tcp_new_port(void)
{
  8054ac:	55                   	push   %ebp
  8054ad:	89 e5                	mov    %esp,%ebp
  8054af:	57                   	push   %edi
  8054b0:	56                   	push   %esi
  8054b1:	53                   	push   %ebx
 again:
  if (++port > TCP_LOCAL_PORT_RANGE_END) {
    port = TCP_LOCAL_PORT_RANGE_START;
  }
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  8054b2:	8b 1d 3c b2 b3 00    	mov    0xb3b23c,%ebx
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  8054b8:	8b 35 50 b2 b3 00    	mov    0xb3b250,%esi
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
  8054be:	8b 3d 44 b2 b3 00    	mov    0xb3b244,%edi
  8054c4:	0f b7 15 0c 40 81 00 	movzwl 0x81400c,%edx
    port = TCP_LOCAL_PORT_RANGE_START;
  8054cb:	b9 00 10 00 00       	mov    $0x1000,%ecx
  if (++port > TCP_LOCAL_PORT_RANGE_END) {
  8054d0:	66 83 c2 01          	add    $0x1,%dx
    port = TCP_LOCAL_PORT_RANGE_START;
  8054d4:	0f 48 d1             	cmovs  %ecx,%edx
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  8054d7:	89 d8                	mov    %ebx,%eax
  8054d9:	85 c0                	test   %eax,%eax
  8054db:	74 0b                	je     8054e8 <tcp_new_port+0x3c>
    if (pcb->local_port == port) {
  8054dd:	66 39 50 1c          	cmp    %dx,0x1c(%eax)
  8054e1:	74 ed                	je     8054d0 <tcp_new_port+0x24>
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  8054e3:	8b 40 0c             	mov    0xc(%eax),%eax
  8054e6:	eb f1                	jmp    8054d9 <tcp_new_port+0x2d>
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  8054e8:	89 f0                	mov    %esi,%eax
  8054ea:	85 c0                	test   %eax,%eax
  8054ec:	74 0b                	je     8054f9 <tcp_new_port+0x4d>
    if (pcb->local_port == port) {
  8054ee:	66 39 50 1c          	cmp    %dx,0x1c(%eax)
  8054f2:	74 dc                	je     8054d0 <tcp_new_port+0x24>
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  8054f4:	8b 40 0c             	mov    0xc(%eax),%eax
  8054f7:	eb f1                	jmp    8054ea <tcp_new_port+0x3e>
  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
  8054f9:	89 f8                	mov    %edi,%eax
  8054fb:	85 c0                	test   %eax,%eax
  8054fd:	74 0b                	je     80550a <tcp_new_port+0x5e>
    if (pcb->local_port == port) {
  8054ff:	66 39 50 1c          	cmp    %dx,0x1c(%eax)
  805503:	74 cb                	je     8054d0 <tcp_new_port+0x24>
  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
  805505:	8b 40 0c             	mov    0xc(%eax),%eax
  805508:	eb f1                	jmp    8054fb <tcp_new_port+0x4f>
  80550a:	66 89 15 0c 40 81 00 	mov    %dx,0x81400c
      goto again;
    }
  }
  return port;
}
  805511:	89 d0                	mov    %edx,%eax
  805513:	5b                   	pop    %ebx
  805514:	5e                   	pop    %esi
  805515:	5f                   	pop    %edi
  805516:	5d                   	pop    %ebp
  805517:	c3                   	ret    

00805518 <tcp_bind>:
{
  805518:	f3 0f 1e fb          	endbr32 
  80551c:	55                   	push   %ebp
  80551d:	89 e5                	mov    %esp,%ebp
  80551f:	57                   	push   %edi
  805520:	56                   	push   %esi
  805521:	53                   	push   %ebx
  805522:	83 ec 0c             	sub    $0xc,%esp
  805525:	8b 75 08             	mov    0x8(%ebp),%esi
  805528:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  80552b:	8b 55 10             	mov    0x10(%ebp),%edx
  LWIP_ERROR("tcp_connect: can only bind in state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
  80552e:	83 7e 10 00          	cmpl   $0x0,0x10(%esi)
  805532:	75 0f                	jne    805543 <tcp_bind+0x2b>
  805534:	89 d0                	mov    %edx,%eax
  if (port == 0) {
  805536:	66 85 d2             	test   %dx,%dx
  805539:	74 1f                	je     80555a <tcp_bind+0x42>
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
  80553b:	8b 15 44 b2 b3 00    	mov    0xb3b244,%edx
  805541:	eb 21                	jmp    805564 <tcp_bind+0x4c>
  LWIP_ERROR("tcp_connect: can only bind in state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
  805543:	83 ec 04             	sub    $0x4,%esp
  805546:	68 2c 20 81 00       	push   $0x81202c
  80554b:	68 05 01 00 00       	push   $0x105
  805550:	68 0e 22 81 00       	push   $0x81220e
  805555:	e8 ed 92 00 00       	call   80e847 <_panic>
    port = tcp_new_port();
  80555a:	e8 4d ff ff ff       	call   8054ac <tcp_new_port>
  80555f:	eb da                	jmp    80553b <tcp_bind+0x23>
      cpcb != NULL; cpcb = cpcb->next) {
  805561:	8b 52 0c             	mov    0xc(%edx),%edx
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
  805564:	85 d2                	test   %edx,%edx
  805566:	74 2c                	je     805594 <tcp_bind+0x7c>
    if (cpcb->local_port == port) {
  805568:	66 39 42 1c          	cmp    %ax,0x1c(%edx)
  80556c:	75 f3                	jne    805561 <tcp_bind+0x49>
      if (ip_addr_isany(&(cpcb->local_ip)) ||
  80556e:	8b 0a                	mov    (%edx),%ecx
  805570:	85 db                	test   %ebx,%ebx
  805572:	0f 84 d4 00 00 00    	je     80564c <tcp_bind+0x134>
  805578:	85 c9                	test   %ecx,%ecx
  80557a:	0f 84 cc 00 00 00    	je     80564c <tcp_bind+0x134>
          ip_addr_isany(ipaddr) ||
  805580:	8b 3b                	mov    (%ebx),%edi
  805582:	39 f9                	cmp    %edi,%ecx
  805584:	74 04                	je     80558a <tcp_bind+0x72>
  805586:	85 ff                	test   %edi,%edi
  805588:	75 d7                	jne    805561 <tcp_bind+0x49>
        return ERR_USE;
  80558a:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  80558f:	e9 bd 00 00 00       	jmp    805651 <tcp_bind+0x139>
  for(cpcb = tcp_active_pcbs;
  805594:	8b 15 3c b2 b3 00    	mov    0xb3b23c,%edx
  80559a:	eb 03                	jmp    80559f <tcp_bind+0x87>
      cpcb != NULL; cpcb = cpcb->next) {
  80559c:	8b 52 0c             	mov    0xc(%edx),%edx
  for(cpcb = tcp_active_pcbs;
  80559f:	85 d2                	test   %edx,%edx
  8055a1:	74 2c                	je     8055cf <tcp_bind+0xb7>
    if (cpcb->local_port == port) {
  8055a3:	66 39 42 1c          	cmp    %ax,0x1c(%edx)
  8055a7:	75 f3                	jne    80559c <tcp_bind+0x84>
      if (ip_addr_isany(&(cpcb->local_ip)) ||
  8055a9:	8b 0a                	mov    (%edx),%ecx
  8055ab:	85 db                	test   %ebx,%ebx
  8055ad:	0f 84 a6 00 00 00    	je     805659 <tcp_bind+0x141>
  8055b3:	85 c9                	test   %ecx,%ecx
  8055b5:	0f 84 9e 00 00 00    	je     805659 <tcp_bind+0x141>
          ip_addr_isany(ipaddr) ||
  8055bb:	8b 3b                	mov    (%ebx),%edi
  8055bd:	39 f9                	cmp    %edi,%ecx
  8055bf:	74 04                	je     8055c5 <tcp_bind+0xad>
  8055c1:	85 ff                	test   %edi,%edi
  8055c3:	75 d7                	jne    80559c <tcp_bind+0x84>
        return ERR_USE;
  8055c5:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  8055ca:	e9 82 00 00 00       	jmp    805651 <tcp_bind+0x139>
  for(cpcb = tcp_bound_pcbs; cpcb != NULL; cpcb = cpcb->next) {
  8055cf:	8b 15 4c b2 b3 00    	mov    0xb3b24c,%edx
  8055d5:	eb 03                	jmp    8055da <tcp_bind+0xc2>
  8055d7:	8b 52 0c             	mov    0xc(%edx),%edx
  8055da:	85 d2                	test   %edx,%edx
  8055dc:	74 21                	je     8055ff <tcp_bind+0xe7>
    if (cpcb->local_port == port) {
  8055de:	66 39 42 1c          	cmp    %ax,0x1c(%edx)
  8055e2:	75 f3                	jne    8055d7 <tcp_bind+0xbf>
      if (ip_addr_isany(&(cpcb->local_ip)) ||
  8055e4:	8b 0a                	mov    (%edx),%ecx
  8055e6:	85 db                	test   %ebx,%ebx
  8055e8:	74 76                	je     805660 <tcp_bind+0x148>
  8055ea:	85 c9                	test   %ecx,%ecx
  8055ec:	74 72                	je     805660 <tcp_bind+0x148>
          ip_addr_isany(ipaddr) ||
  8055ee:	8b 3b                	mov    (%ebx),%edi
  8055f0:	39 f9                	cmp    %edi,%ecx
  8055f2:	74 04                	je     8055f8 <tcp_bind+0xe0>
  8055f4:	85 ff                	test   %edi,%edi
  8055f6:	75 df                	jne    8055d7 <tcp_bind+0xbf>
        return ERR_USE;
  8055f8:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  8055fd:	eb 52                	jmp    805651 <tcp_bind+0x139>
  for(cpcb = tcp_tw_pcbs; cpcb != NULL; cpcb = cpcb->next) {
  8055ff:	8b 15 50 b2 b3 00    	mov    0xb3b250,%edx
  805605:	eb 03                	jmp    80560a <tcp_bind+0xf2>
  805607:	8b 52 0c             	mov    0xc(%edx),%edx
  80560a:	85 d2                	test   %edx,%edx
  80560c:	74 13                	je     805621 <tcp_bind+0x109>
    if (cpcb->local_port == port) {
  80560e:	66 39 42 1c          	cmp    %ax,0x1c(%edx)
  805612:	75 f3                	jne    805607 <tcp_bind+0xef>
      if (ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
  805614:	8b 3b                	mov    (%ebx),%edi
  805616:	39 3a                	cmp    %edi,(%edx)
  805618:	75 ed                	jne    805607 <tcp_bind+0xef>
        return ERR_USE;
  80561a:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  80561f:	eb 30                	jmp    805651 <tcp_bind+0x139>
  if (!ip_addr_isany(ipaddr)) {
  805621:	85 db                	test   %ebx,%ebx
  805623:	74 09                	je     80562e <tcp_bind+0x116>
  805625:	83 3b 00             	cmpl   $0x0,(%ebx)
  805628:	74 04                	je     80562e <tcp_bind+0x116>
    pcb->local_ip = *ipaddr;
  80562a:	8b 13                	mov    (%ebx),%edx
  80562c:	89 16                	mov    %edx,(%esi)
  pcb->local_port = port;
  80562e:	66 89 46 1c          	mov    %ax,0x1c(%esi)
  TCP_REG(&tcp_bound_pcbs, pcb);
  805632:	a1 4c b2 b3 00       	mov    0xb3b24c,%eax
  805637:	89 46 0c             	mov    %eax,0xc(%esi)
  80563a:	89 35 4c b2 b3 00    	mov    %esi,0xb3b24c
  805640:	e8 0e cc ff ff       	call   802253 <tcp_timer_needed>
  return ERR_OK;
  805645:	b8 00 00 00 00       	mov    $0x0,%eax
  80564a:	eb 05                	jmp    805651 <tcp_bind+0x139>
        return ERR_USE;
  80564c:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
}
  805651:	8d 65 f4             	lea    -0xc(%ebp),%esp
  805654:	5b                   	pop    %ebx
  805655:	5e                   	pop    %esi
  805656:	5f                   	pop    %edi
  805657:	5d                   	pop    %ebp
  805658:	c3                   	ret    
        return ERR_USE;
  805659:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  80565e:	eb f1                	jmp    805651 <tcp_bind+0x139>
        return ERR_USE;
  805660:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  805665:	eb ea                	jmp    805651 <tcp_bind+0x139>

00805667 <tcp_listen_with_backlog>:
{
  805667:	f3 0f 1e fb          	endbr32 
  80566b:	55                   	push   %ebp
  80566c:	89 e5                	mov    %esp,%ebp
  80566e:	57                   	push   %edi
  80566f:	56                   	push   %esi
  805670:	53                   	push   %ebx
  805671:	83 ec 0c             	sub    $0xc,%esp
  805674:	8b 5d 08             	mov    0x8(%ebp),%ebx
  LWIP_ERROR("tcp_listen: pcb already connected", pcb->state == CLOSED, return NULL);
  805677:	83 7b 10 00          	cmpl   $0x0,0x10(%ebx)
  80567b:	75 65                	jne    8056e2 <tcp_listen_with_backlog+0x7b>
  lpcb = memp_malloc(MEMP_TCP_PCB_LISTEN);
  80567d:	83 ec 0c             	sub    $0xc,%esp
  805680:	6a 03                	push   $0x3
  805682:	e8 c4 ee ff ff       	call   80454b <memp_malloc>
  805687:	89 c6                	mov    %eax,%esi
  if (lpcb == NULL) {
  805689:	83 c4 10             	add    $0x10,%esp
  80568c:	85 c0                	test   %eax,%eax
  80568e:	0f 84 9c 00 00 00    	je     805730 <tcp_listen_with_backlog+0xc9>
  lpcb->callback_arg = pcb->callback_arg;
  805694:	8b 43 18             	mov    0x18(%ebx),%eax
  805697:	89 46 18             	mov    %eax,0x18(%esi)
  lpcb->local_port = pcb->local_port;
  80569a:	0f b7 43 1c          	movzwl 0x1c(%ebx),%eax
  80569e:	66 89 46 1c          	mov    %ax,0x1c(%esi)
  lpcb->state = LISTEN;
  8056a2:	c7 46 10 01 00 00 00 	movl   $0x1,0x10(%esi)
  lpcb->so_options |= SOF_ACCEPTCONN;
  8056a9:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  8056ad:	83 c8 02             	or     $0x2,%eax
  8056b0:	66 89 46 08          	mov    %ax,0x8(%esi)
  lpcb->ttl = pcb->ttl;
  8056b4:	0f b6 43 0b          	movzbl 0xb(%ebx),%eax
  8056b8:	88 46 0b             	mov    %al,0xb(%esi)
  lpcb->tos = pcb->tos;
  8056bb:	0f b6 43 0a          	movzbl 0xa(%ebx),%eax
  8056bf:	88 46 0a             	mov    %al,0xa(%esi)
  ip_addr_set(&lpcb->local_ip, &pcb->local_ip);
  8056c2:	8b 03                	mov    (%ebx),%eax
  8056c4:	89 06                	mov    %eax,(%esi)
  TCP_RMV(&tcp_bound_pcbs, pcb);
  8056c6:	8b 15 4c b2 b3 00    	mov    0xb3b24c,%edx
  8056cc:	39 da                	cmp    %ebx,%edx
  8056ce:	74 29                	je     8056f9 <tcp_listen_with_backlog+0x92>
  8056d0:	89 15 48 b2 b3 00    	mov    %edx,0xb3b248
  8056d6:	b9 00 00 00 00       	mov    $0x0,%ecx
  8056db:	bf 01 00 00 00       	mov    $0x1,%edi
  8056e0:	eb 5c                	jmp    80573e <tcp_listen_with_backlog+0xd7>
  LWIP_ERROR("tcp_listen: pcb already connected", pcb->state == CLOSED, return NULL);
  8056e2:	83 ec 04             	sub    $0x4,%esp
  8056e5:	68 58 20 81 00       	push   $0x812058
  8056ea:	68 60 01 00 00       	push   $0x160
  8056ef:	68 0e 22 81 00       	push   $0x81220e
  8056f4:	e8 4e 91 00 00       	call   80e847 <_panic>
  TCP_RMV(&tcp_bound_pcbs, pcb);
  8056f9:	8b 43 0c             	mov    0xc(%ebx),%eax
  8056fc:	a3 4c b2 b3 00       	mov    %eax,0xb3b24c
  805701:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
  memp_free(MEMP_TCP_PCB, pcb);
  805708:	83 ec 08             	sub    $0x8,%esp
  80570b:	53                   	push   %ebx
  80570c:	6a 02                	push   $0x2
  80570e:	e8 92 ee ff ff       	call   8045a5 <memp_free>
  lpcb->accept = tcp_accept_null;
  805713:	c7 46 20 a2 54 80 00 	movl   $0x8054a2,0x20(%esi)
  TCP_REG(&tcp_listen_pcbs.listen_pcbs, lpcb);
  80571a:	a1 44 b2 b3 00       	mov    0xb3b244,%eax
  80571f:	89 46 0c             	mov    %eax,0xc(%esi)
  805722:	89 35 44 b2 b3 00    	mov    %esi,0xb3b244
  805728:	e8 26 cb ff ff       	call   802253 <tcp_timer_needed>
  return (struct tcp_pcb *)lpcb;
  80572d:	83 c4 10             	add    $0x10,%esp
}
  805730:	89 f0                	mov    %esi,%eax
  805732:	8d 65 f4             	lea    -0xc(%ebp),%esp
  805735:	5b                   	pop    %ebx
  805736:	5e                   	pop    %esi
  805737:	5f                   	pop    %edi
  805738:	5d                   	pop    %ebp
  805739:	c3                   	ret    
  80573a:	89 f9                	mov    %edi,%ecx
  TCP_RMV(&tcp_bound_pcbs, pcb);
  80573c:	89 c2                	mov    %eax,%edx
  80573e:	85 d2                	test   %edx,%edx
  805740:	74 1d                	je     80575f <tcp_listen_with_backlog+0xf8>
  805742:	8b 42 0c             	mov    0xc(%edx),%eax
  805745:	39 d8                	cmp    %ebx,%eax
  805747:	75 f1                	jne    80573a <tcp_listen_with_backlog+0xd3>
  805749:	85 c0                	test   %eax,%eax
  80574b:	74 ed                	je     80573a <tcp_listen_with_backlog+0xd3>
  80574d:	84 c9                	test   %cl,%cl
  80574f:	74 06                	je     805757 <tcp_listen_with_backlog+0xf0>
  805751:	89 15 48 b2 b3 00    	mov    %edx,0xb3b248
  805757:	8b 43 0c             	mov    0xc(%ebx),%eax
  80575a:	89 42 0c             	mov    %eax,0xc(%edx)
  80575d:	eb a2                	jmp    805701 <tcp_listen_with_backlog+0x9a>
  80575f:	84 c9                	test   %cl,%cl
  805761:	74 9e                	je     805701 <tcp_listen_with_backlog+0x9a>
  805763:	c7 05 48 b2 b3 00 00 	movl   $0x0,0xb3b248
  80576a:	00 00 00 
  80576d:	eb 92                	jmp    805701 <tcp_listen_with_backlog+0x9a>

0080576f <tcp_recved>:
{
  80576f:	f3 0f 1e fb          	endbr32 
  805773:	55                   	push   %ebp
  805774:	89 e5                	mov    %esp,%ebp
  805776:	56                   	push   %esi
  805777:	53                   	push   %ebx
  805778:	8b 45 08             	mov    0x8(%ebp),%eax
  80577b:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  if ((u32_t)pcb->rcv_wnd + len > TCP_WND) {
  80577e:	0f b7 50 28          	movzwl 0x28(%eax),%edx
  805782:	0f b7 ca             	movzwl %dx,%ecx
  805785:	0f b7 f3             	movzwl %bx,%esi
  805788:	01 f1                	add    %esi,%ecx
  80578a:	81 f9 c0 5d 00 00    	cmp    $0x5dc0,%ecx
  805790:	76 27                	jbe    8057b9 <tcp_recved+0x4a>
    pcb->rcv_wnd = TCP_WND;
  805792:	66 c7 40 28 c0 5d    	movw   $0x5dc0,0x28(%eax)
    pcb->rcv_ann_wnd = TCP_WND;
  805798:	66 c7 40 2a c0 5d    	movw   $0x5dc0,0x2a(%eax)
  if (!(pcb->flags & TF_ACK_DELAY) &&
  80579e:	0f b6 50 20          	movzbl 0x20(%eax),%edx
  8057a2:	f6 c2 03             	test   $0x3,%dl
  8057a5:	75 3b                	jne    8057e2 <tcp_recved+0x73>
    tcp_ack(pcb);
  8057a7:	f6 c2 01             	test   $0x1,%dl
  8057aa:	75 1f                	jne    8057cb <tcp_recved+0x5c>
  8057ac:	83 ca 01             	or     $0x1,%edx
  8057af:	88 50 20             	mov    %dl,0x20(%eax)
}
  8057b2:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8057b5:	5b                   	pop    %ebx
  8057b6:	5e                   	pop    %esi
  8057b7:	5d                   	pop    %ebp
  8057b8:	c3                   	ret    
    pcb->rcv_wnd += len;
  8057b9:	01 da                	add    %ebx,%edx
  8057bb:	66 89 50 28          	mov    %dx,0x28(%eax)
    if (pcb->rcv_wnd >= pcb->mss) {
  8057bf:	66 3b 50 34          	cmp    0x34(%eax),%dx
  8057c3:	72 d9                	jb     80579e <tcp_recved+0x2f>
      pcb->rcv_ann_wnd = pcb->rcv_wnd;
  8057c5:	66 89 50 2a          	mov    %dx,0x2a(%eax)
  8057c9:	eb d3                	jmp    80579e <tcp_recved+0x2f>
    tcp_ack(pcb);
  8057cb:	83 e2 fe             	and    $0xfffffffe,%edx
  8057ce:	83 ca 02             	or     $0x2,%edx
  8057d1:	88 50 20             	mov    %dl,0x20(%eax)
  8057d4:	83 ec 0c             	sub    $0xc,%esp
  8057d7:	50                   	push   %eax
  8057d8:	e8 09 2a 00 00       	call   8081e6 <tcp_output>
  8057dd:	83 c4 10             	add    $0x10,%esp
  8057e0:	eb d0                	jmp    8057b2 <tcp_recved+0x43>
  else if (pcb->flags & TF_ACK_DELAY && pcb->rcv_wnd >= TCP_WND/2) {
  8057e2:	f6 c2 01             	test   $0x1,%dl
  8057e5:	74 cb                	je     8057b2 <tcp_recved+0x43>
  8057e7:	66 81 78 28 df 2e    	cmpw   $0x2edf,0x28(%eax)
  8057ed:	76 c3                	jbe    8057b2 <tcp_recved+0x43>
    tcp_ack_now(pcb);
  8057ef:	83 ca 02             	or     $0x2,%edx
  8057f2:	88 50 20             	mov    %dl,0x20(%eax)
  8057f5:	83 ec 0c             	sub    $0xc,%esp
  8057f8:	50                   	push   %eax
  8057f9:	e8 e8 29 00 00       	call   8081e6 <tcp_output>
  8057fe:	83 c4 10             	add    $0x10,%esp
}
  805801:	eb af                	jmp    8057b2 <tcp_recved+0x43>

00805803 <tcp_fasttmr>:
 *
 * Automatically called from tcp_tmr().
 */
void
tcp_fasttmr(void)
{
  805803:	f3 0f 1e fb          	endbr32 
  805807:	55                   	push   %ebp
  805808:	89 e5                	mov    %esp,%ebp
  80580a:	53                   	push   %ebx
  80580b:	83 ec 04             	sub    $0x4,%esp
  struct tcp_pcb *pcb;

  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80580e:	8b 1d 3c b2 b3 00    	mov    0xb3b23c,%ebx
  805814:	eb 21                	jmp    805837 <tcp_fasttmr+0x34>
    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
      /* Notify again application with data previously received. */
      err_t err;
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_fasttmr: notify kept packet\n"));
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
  805816:	83 ec 0c             	sub    $0xc,%esp
  805819:	50                   	push   %eax
  80581a:	e8 09 f1 ff ff       	call   804928 <pbuf_free>
  80581f:	83 c4 10             	add    $0x10,%esp
      if (err == ERR_OK) {
        pcb->refused_data = NULL;
  805822:	c7 83 80 00 00 00 00 	movl   $0x0,0x80(%ebx)
  805829:	00 00 00 
      }
    }

    /* send delayed ACKs */  
    if (pcb->flags & TF_ACK_DELAY) {
  80582c:	0f b6 43 20          	movzbl 0x20(%ebx),%eax
  805830:	a8 01                	test   $0x1,%al
  805832:	75 2d                	jne    805861 <tcp_fasttmr+0x5e>
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  805834:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  805837:	85 db                	test   %ebx,%ebx
  805839:	74 3e                	je     805879 <tcp_fasttmr+0x76>
    if (pcb->refused_data != NULL) {
  80583b:	8b 83 80 00 00 00    	mov    0x80(%ebx),%eax
  805841:	85 c0                	test   %eax,%eax
  805843:	74 e7                	je     80582c <tcp_fasttmr+0x29>
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
  805845:	8b 93 88 00 00 00    	mov    0x88(%ebx),%edx
  80584b:	85 d2                	test   %edx,%edx
  80584d:	74 c7                	je     805816 <tcp_fasttmr+0x13>
  80584f:	6a 00                	push   $0x0
  805851:	50                   	push   %eax
  805852:	53                   	push   %ebx
  805853:	ff 73 18             	pushl  0x18(%ebx)
  805856:	ff d2                	call   *%edx
      if (err == ERR_OK) {
  805858:	83 c4 10             	add    $0x10,%esp
  80585b:	84 c0                	test   %al,%al
  80585d:	74 c3                	je     805822 <tcp_fasttmr+0x1f>
  80585f:	eb cb                	jmp    80582c <tcp_fasttmr+0x29>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_fasttmr: delayed ACK\n"));
      tcp_ack_now(pcb);
  805861:	83 c8 02             	or     $0x2,%eax
  805864:	88 43 20             	mov    %al,0x20(%ebx)
  805867:	83 ec 0c             	sub    $0xc,%esp
  80586a:	53                   	push   %ebx
  80586b:	e8 76 29 00 00       	call   8081e6 <tcp_output>
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
  805870:	80 63 20 fc          	andb   $0xfc,0x20(%ebx)
  805874:	83 c4 10             	add    $0x10,%esp
  805877:	eb bb                	jmp    805834 <tcp_fasttmr+0x31>
    }
  }
}
  805879:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80587c:	c9                   	leave  
  80587d:	c3                   	ret    

0080587e <tcp_seg_free>:
 * @param seg single tcp_seg to free
 * @return the number of pbufs that were deallocated
 */
u8_t
tcp_seg_free(struct tcp_seg *seg)
{
  80587e:	f3 0f 1e fb          	endbr32 
  805882:	55                   	push   %ebp
  805883:	89 e5                	mov    %esp,%ebp
  805885:	56                   	push   %esi
  805886:	53                   	push   %ebx
  805887:	8b 75 08             	mov    0x8(%ebp),%esi
  u8_t count = 0;
  80588a:	bb 00 00 00 00       	mov    $0x0,%ebx
  
  if (seg != NULL) {
  80588f:	85 f6                	test   %esi,%esi
  805891:	74 23                	je     8058b6 <tcp_seg_free+0x38>
    if (seg->p != NULL) {
  805893:	8b 46 04             	mov    0x4(%esi),%eax
  805896:	85 c0                	test   %eax,%eax
  805898:	74 0e                	je     8058a8 <tcp_seg_free+0x2a>
      count = pbuf_free(seg->p);
  80589a:	83 ec 0c             	sub    $0xc,%esp
  80589d:	50                   	push   %eax
  80589e:	e8 85 f0 ff ff       	call   804928 <pbuf_free>
  8058a3:	89 c3                	mov    %eax,%ebx
  8058a5:	83 c4 10             	add    $0x10,%esp
#if TCP_DEBUG
      seg->p = NULL;
#endif /* TCP_DEBUG */
    }
    memp_free(MEMP_TCP_SEG, seg);
  8058a8:	83 ec 08             	sub    $0x8,%esp
  8058ab:	56                   	push   %esi
  8058ac:	6a 04                	push   $0x4
  8058ae:	e8 f2 ec ff ff       	call   8045a5 <memp_free>
  8058b3:	83 c4 10             	add    $0x10,%esp
  }
  return count;
}
  8058b6:	89 d8                	mov    %ebx,%eax
  8058b8:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8058bb:	5b                   	pop    %ebx
  8058bc:	5e                   	pop    %esi
  8058bd:	5d                   	pop    %ebp
  8058be:	c3                   	ret    

008058bf <tcp_segs_free>:
{
  8058bf:	f3 0f 1e fb          	endbr32 
  8058c3:	55                   	push   %ebp
  8058c4:	89 e5                	mov    %esp,%ebp
  8058c6:	56                   	push   %esi
  8058c7:	53                   	push   %ebx
  8058c8:	8b 45 08             	mov    0x8(%ebp),%eax
  u8_t count = 0;
  8058cb:	bb 00 00 00 00       	mov    $0x0,%ebx
  while (seg != NULL) {
  8058d0:	85 c0                	test   %eax,%eax
  8058d2:	74 14                	je     8058e8 <tcp_segs_free+0x29>
    next = seg->next;
  8058d4:	8b 30                	mov    (%eax),%esi
    count += tcp_seg_free(seg);
  8058d6:	83 ec 0c             	sub    $0xc,%esp
  8058d9:	50                   	push   %eax
  8058da:	e8 9f ff ff ff       	call   80587e <tcp_seg_free>
  8058df:	01 c3                	add    %eax,%ebx
  8058e1:	83 c4 10             	add    $0x10,%esp
    seg = next;
  8058e4:	89 f0                	mov    %esi,%eax
  8058e6:	eb e8                	jmp    8058d0 <tcp_segs_free+0x11>
}
  8058e8:	89 d8                	mov    %ebx,%eax
  8058ea:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8058ed:	5b                   	pop    %ebx
  8058ee:	5e                   	pop    %esi
  8058ef:	5d                   	pop    %ebp
  8058f0:	c3                   	ret    

008058f1 <tcp_setprio>:
 * @param pcb the tcp_pcb to manipulate
 * @param prio new priority
 */
void
tcp_setprio(struct tcp_pcb *pcb, u8_t prio)
{
  8058f1:	f3 0f 1e fb          	endbr32 
  8058f5:	55                   	push   %ebp
  8058f6:	89 e5                	mov    %esp,%ebp
  pcb->prio = prio;
  8058f8:	8b 45 08             	mov    0x8(%ebp),%eax
  8058fb:	8b 55 0c             	mov    0xc(%ebp),%edx
  8058fe:	88 50 14             	mov    %dl,0x14(%eax)
}
  805901:	5d                   	pop    %ebp
  805902:	c3                   	ret    

00805903 <tcp_seg_copy>:
 * @param seg the old tcp_seg
 * @return a copy of seg
 */ 
struct tcp_seg *
tcp_seg_copy(struct tcp_seg *seg)
{
  805903:	f3 0f 1e fb          	endbr32 
  805907:	55                   	push   %ebp
  805908:	89 e5                	mov    %esp,%ebp
  80590a:	53                   	push   %ebx
  80590b:	83 ec 10             	sub    $0x10,%esp
  struct tcp_seg *cseg;

  cseg = memp_malloc(MEMP_TCP_SEG);
  80590e:	6a 04                	push   $0x4
  805910:	e8 36 ec ff ff       	call   80454b <memp_malloc>
  805915:	89 c3                	mov    %eax,%ebx
  if (cseg == NULL) {
  805917:	83 c4 10             	add    $0x10,%esp
  80591a:	85 c0                	test   %eax,%eax
  80591c:	74 1c                	je     80593a <tcp_seg_copy+0x37>
    return NULL;
  }
  SMEMCPY((u8_t *)cseg, (const u8_t *)seg, sizeof(struct tcp_seg)); 
  80591e:	83 ec 04             	sub    $0x4,%esp
  805921:	6a 14                	push   $0x14
  805923:	ff 75 08             	pushl  0x8(%ebp)
  805926:	50                   	push   %eax
  805927:	e8 28 98 00 00       	call   80f154 <memcpy>
  pbuf_ref(cseg->p);
  80592c:	83 c4 04             	add    $0x4,%esp
  80592f:	ff 73 04             	pushl  0x4(%ebx)
  805932:	e8 4e f4 ff ff       	call   804d85 <pbuf_ref>
  return cseg;
  805937:	83 c4 10             	add    $0x10,%esp
}
  80593a:	89 d8                	mov    %ebx,%eax
  80593c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80593f:	c9                   	leave  
  805940:	c3                   	ret    

00805941 <tcp_arg>:
 * @param pcb tcp_pcb to set the callback argument
 * @param arg void pointer argument to pass to callback functions
 */ 
void
tcp_arg(struct tcp_pcb *pcb, void *arg)
{  
  805941:	f3 0f 1e fb          	endbr32 
  805945:	55                   	push   %ebp
  805946:	89 e5                	mov    %esp,%ebp
  pcb->callback_arg = arg;
  805948:	8b 45 08             	mov    0x8(%ebp),%eax
  80594b:	8b 55 0c             	mov    0xc(%ebp),%edx
  80594e:	89 50 18             	mov    %edx,0x18(%eax)
}
  805951:	5d                   	pop    %ebp
  805952:	c3                   	ret    

00805953 <tcp_recv>:
 * @param recv callback function to call for this pcb when data is received
 */ 
void
tcp_recv(struct tcp_pcb *pcb,
   err_t (* recv)(void *arg, struct tcp_pcb *tpcb, struct pbuf *p, err_t err))
{
  805953:	f3 0f 1e fb          	endbr32 
  805957:	55                   	push   %ebp
  805958:	89 e5                	mov    %esp,%ebp
  pcb->recv = recv;
  80595a:	8b 45 08             	mov    0x8(%ebp),%eax
  80595d:	8b 55 0c             	mov    0xc(%ebp),%edx
  805960:	89 90 88 00 00 00    	mov    %edx,0x88(%eax)
}
  805966:	5d                   	pop    %ebp
  805967:	c3                   	ret    

00805968 <tcp_sent>:
 * @param sent callback function to call for this pcb when data is successfully sent
 */ 
void
tcp_sent(struct tcp_pcb *pcb,
   err_t (* sent)(void *arg, struct tcp_pcb *tpcb, u16_t len))
{
  805968:	f3 0f 1e fb          	endbr32 
  80596c:	55                   	push   %ebp
  80596d:	89 e5                	mov    %esp,%ebp
  pcb->sent = sent;
  80596f:	8b 45 08             	mov    0x8(%ebp),%eax
  805972:	8b 55 0c             	mov    0xc(%ebp),%edx
  805975:	89 90 84 00 00 00    	mov    %edx,0x84(%eax)
}
  80597b:	5d                   	pop    %ebp
  80597c:	c3                   	ret    

0080597d <tcp_err>:
 *        has occured on the connection
 */ 
void
tcp_err(struct tcp_pcb *pcb,
   void (* errf)(void *arg, err_t err))
{
  80597d:	f3 0f 1e fb          	endbr32 
  805981:	55                   	push   %ebp
  805982:	89 e5                	mov    %esp,%ebp
  pcb->errf = errf;
  805984:	8b 45 08             	mov    0x8(%ebp),%eax
  805987:	8b 55 0c             	mov    0xc(%ebp),%edx
  80598a:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
}
  805990:	5d                   	pop    %ebp
  805991:	c3                   	ret    

00805992 <tcp_accept>:
 *        connection has been connected to another host
 */ 
void
tcp_accept(struct tcp_pcb *pcb,
     err_t (* accept)(void *arg, struct tcp_pcb *newpcb, err_t err))
{
  805992:	f3 0f 1e fb          	endbr32 
  805996:	55                   	push   %ebp
  805997:	89 e5                	mov    %esp,%ebp
  ((struct tcp_pcb_listen *)pcb)->accept = accept;
  805999:	8b 45 08             	mov    0x8(%ebp),%eax
  80599c:	8b 55 0c             	mov    0xc(%ebp),%edx
  80599f:	89 50 20             	mov    %edx,0x20(%eax)
}
  8059a2:	5d                   	pop    %ebp
  8059a3:	c3                   	ret    

008059a4 <tcp_poll>:
 *
 */ 
void
tcp_poll(struct tcp_pcb *pcb,
   err_t (* poll)(void *arg, struct tcp_pcb *tpcb), u8_t interval)
{
  8059a4:	f3 0f 1e fb          	endbr32 
  8059a8:	55                   	push   %ebp
  8059a9:	89 e5                	mov    %esp,%ebp
  8059ab:	8b 45 08             	mov    0x8(%ebp),%eax
#if LWIP_CALLBACK_API
  pcb->poll = poll;
  8059ae:	8b 55 0c             	mov    0xc(%ebp),%edx
  8059b1:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
#endif /* LWIP_CALLBACK_API */  
  pcb->pollinterval = interval;
  8059b7:	8b 55 10             	mov    0x10(%ebp),%edx
  8059ba:	88 50 31             	mov    %dl,0x31(%eax)
}
  8059bd:	5d                   	pop    %ebp
  8059be:	c3                   	ret    

008059bf <tcp_pcb_purge>:
 *
 * @param pcb tcp_pcb to purge. The pcb itself is not deallocated!
 */
void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
  8059bf:	f3 0f 1e fb          	endbr32 
  8059c3:	55                   	push   %ebp
  8059c4:	89 e5                	mov    %esp,%ebp
  8059c6:	53                   	push   %ebx
  8059c7:	83 ec 04             	sub    $0x4,%esp
  8059ca:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (pcb->state != CLOSED &&
  8059cd:	8b 43 10             	mov    0x10(%ebx),%eax
     pcb->state != TIME_WAIT &&
  8059d0:	83 f8 0a             	cmp    $0xa,%eax
  8059d3:	74 05                	je     8059da <tcp_pcb_purge+0x1b>
  8059d5:	83 f8 01             	cmp    $0x1,%eax
  8059d8:	77 05                	ja     8059df <tcp_pcb_purge+0x20>
#endif /* TCP_QUEUE_OOSEQ */
    tcp_segs_free(pcb->unsent);
    tcp_segs_free(pcb->unacked);
    pcb->unacked = pcb->unsent = NULL;
  }
}
  8059da:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  8059dd:	c9                   	leave  
  8059de:	c3                   	ret    
    if (pcb->refused_data != NULL) {
  8059df:	8b 83 80 00 00 00    	mov    0x80(%ebx),%eax
  8059e5:	85 c0                	test   %eax,%eax
  8059e7:	74 16                	je     8059ff <tcp_pcb_purge+0x40>
      pbuf_free(pcb->refused_data);
  8059e9:	83 ec 0c             	sub    $0xc,%esp
  8059ec:	50                   	push   %eax
  8059ed:	e8 36 ef ff ff       	call   804928 <pbuf_free>
      pcb->refused_data = NULL;
  8059f2:	c7 83 80 00 00 00 00 	movl   $0x0,0x80(%ebx)
  8059f9:	00 00 00 
  8059fc:	83 c4 10             	add    $0x10,%esp
    pcb->rtime = -1;
  8059ff:	66 c7 43 32 ff ff    	movw   $0xffff,0x32(%ebx)
    tcp_segs_free(pcb->ooseq);
  805a05:	83 ec 0c             	sub    $0xc,%esp
  805a08:	ff 73 7c             	pushl  0x7c(%ebx)
  805a0b:	e8 af fe ff ff       	call   8058bf <tcp_segs_free>
    pcb->ooseq = NULL;
  805a10:	c7 43 7c 00 00 00 00 	movl   $0x0,0x7c(%ebx)
    tcp_segs_free(pcb->unsent);
  805a17:	83 c4 04             	add    $0x4,%esp
  805a1a:	ff 73 74             	pushl  0x74(%ebx)
  805a1d:	e8 9d fe ff ff       	call   8058bf <tcp_segs_free>
    tcp_segs_free(pcb->unacked);
  805a22:	83 c4 04             	add    $0x4,%esp
  805a25:	ff 73 78             	pushl  0x78(%ebx)
  805a28:	e8 92 fe ff ff       	call   8058bf <tcp_segs_free>
    pcb->unacked = pcb->unsent = NULL;
  805a2d:	c7 43 74 00 00 00 00 	movl   $0x0,0x74(%ebx)
  805a34:	c7 43 78 00 00 00 00 	movl   $0x0,0x78(%ebx)
  805a3b:	83 c4 10             	add    $0x10,%esp
}
  805a3e:	eb 9a                	jmp    8059da <tcp_pcb_purge+0x1b>

00805a40 <tcp_pcb_remove>:
 * @param pcblist PCB list to purge.
 * @param pcb tcp_pcb to purge. The pcb itself is also deallocated!
 */
void
tcp_pcb_remove(struct tcp_pcb **pcblist, struct tcp_pcb *pcb)
{
  805a40:	f3 0f 1e fb          	endbr32 
  805a44:	55                   	push   %ebp
  805a45:	89 e5                	mov    %esp,%ebp
  805a47:	56                   	push   %esi
  805a48:	53                   	push   %ebx
  805a49:	8b 45 08             	mov    0x8(%ebp),%eax
  805a4c:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  TCP_RMV(pcblist, pcb);
  805a4f:	8b 10                	mov    (%eax),%edx
  805a51:	39 da                	cmp    %ebx,%edx
  805a53:	74 12                	je     805a67 <tcp_pcb_remove+0x27>
  805a55:	89 15 48 b2 b3 00    	mov    %edx,0xb3b248
  805a5b:	b9 00 00 00 00       	mov    $0x0,%ecx
  805a60:	be 01 00 00 00       	mov    $0x1,%esi
  805a65:	eb 59                	jmp    805ac0 <tcp_pcb_remove+0x80>
  805a67:	8b 53 0c             	mov    0xc(%ebx),%edx
  805a6a:	89 10                	mov    %edx,(%eax)
  805a6c:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)

  tcp_pcb_purge(pcb);
  805a73:	83 ec 0c             	sub    $0xc,%esp
  805a76:	53                   	push   %ebx
  805a77:	e8 43 ff ff ff       	call   8059bf <tcp_pcb_purge>
  
  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
  805a7c:	8b 43 10             	mov    0x10(%ebx),%eax
  805a7f:	83 c4 10             	add    $0x10,%esp
  805a82:	83 f8 0a             	cmp    $0xa,%eax
  805a85:	74 7f                	je     805b06 <tcp_pcb_remove+0xc6>
  805a87:	83 f8 01             	cmp    $0x1,%eax
  805a8a:	74 7a                	je     805b06 <tcp_pcb_remove+0xc6>
     pcb->state != LISTEN &&
     pcb->flags & TF_ACK_DELAY) {
  805a8c:	0f b6 43 20          	movzbl 0x20(%ebx),%eax
     pcb->state != LISTEN &&
  805a90:	a8 01                	test   $0x1,%al
  805a92:	75 60                	jne    805af4 <tcp_pcb_remove+0xb4>
    pcb->flags |= TF_ACK_NOW;
    tcp_output(pcb);
  }

  if (pcb->state != LISTEN) {
    LWIP_ASSERT("unsent segments leaking", pcb->unsent == NULL);
  805a94:	83 7b 74 00          	cmpl   $0x0,0x74(%ebx)
  805a98:	75 74                	jne    805b0e <tcp_pcb_remove+0xce>
    LWIP_ASSERT("unacked segments leaking", pcb->unacked == NULL);
  805a9a:	83 7b 78 00          	cmpl   $0x0,0x78(%ebx)
  805a9e:	0f 85 81 00 00 00    	jne    805b25 <tcp_pcb_remove+0xe5>
#if TCP_QUEUE_OOSEQ
    LWIP_ASSERT("ooseq segments leaking", pcb->ooseq == NULL);
  805aa4:	83 7b 7c 00          	cmpl   $0x0,0x7c(%ebx)
  805aa8:	0f 85 8e 00 00 00    	jne    805b3c <tcp_pcb_remove+0xfc>
#endif /* TCP_QUEUE_OOSEQ */
  }

  pcb->state = CLOSED;
  805aae:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)

  LWIP_ASSERT("tcp_pcb_remove: tcp_pcbs_sane()", tcp_pcbs_sane());
}
  805ab5:	8d 65 f8             	lea    -0x8(%ebp),%esp
  805ab8:	5b                   	pop    %ebx
  805ab9:	5e                   	pop    %esi
  805aba:	5d                   	pop    %ebp
  805abb:	c3                   	ret    
  805abc:	89 f1                	mov    %esi,%ecx
  TCP_RMV(pcblist, pcb);
  805abe:	89 c2                	mov    %eax,%edx
  805ac0:	85 d2                	test   %edx,%edx
  805ac2:	74 1d                	je     805ae1 <tcp_pcb_remove+0xa1>
  805ac4:	8b 42 0c             	mov    0xc(%edx),%eax
  805ac7:	39 d8                	cmp    %ebx,%eax
  805ac9:	75 f1                	jne    805abc <tcp_pcb_remove+0x7c>
  805acb:	85 c0                	test   %eax,%eax
  805acd:	74 ed                	je     805abc <tcp_pcb_remove+0x7c>
  805acf:	84 c9                	test   %cl,%cl
  805ad1:	74 06                	je     805ad9 <tcp_pcb_remove+0x99>
  805ad3:	89 15 48 b2 b3 00    	mov    %edx,0xb3b248
  805ad9:	8b 43 0c             	mov    0xc(%ebx),%eax
  805adc:	89 42 0c             	mov    %eax,0xc(%edx)
  805adf:	eb 8b                	jmp    805a6c <tcp_pcb_remove+0x2c>
  805ae1:	84 c9                	test   %cl,%cl
  805ae3:	74 87                	je     805a6c <tcp_pcb_remove+0x2c>
  805ae5:	c7 05 48 b2 b3 00 00 	movl   $0x0,0xb3b248
  805aec:	00 00 00 
  805aef:	e9 78 ff ff ff       	jmp    805a6c <tcp_pcb_remove+0x2c>
    pcb->flags |= TF_ACK_NOW;
  805af4:	83 c8 02             	or     $0x2,%eax
  805af7:	88 43 20             	mov    %al,0x20(%ebx)
    tcp_output(pcb);
  805afa:	83 ec 0c             	sub    $0xc,%esp
  805afd:	53                   	push   %ebx
  805afe:	e8 e3 26 00 00       	call   8081e6 <tcp_output>
  805b03:	83 c4 10             	add    $0x10,%esp
  if (pcb->state != LISTEN) {
  805b06:	83 7b 10 01          	cmpl   $0x1,0x10(%ebx)
  805b0a:	74 a2                	je     805aae <tcp_pcb_remove+0x6e>
  805b0c:	eb 86                	jmp    805a94 <tcp_pcb_remove+0x54>
    LWIP_ASSERT("unsent segments leaking", pcb->unsent == NULL);
  805b0e:	83 ec 04             	sub    $0x4,%esp
  805b11:	68 22 22 81 00       	push   $0x812222
  805b16:	68 b4 04 00 00       	push   $0x4b4
  805b1b:	68 0e 22 81 00       	push   $0x81220e
  805b20:	e8 22 8d 00 00       	call   80e847 <_panic>
    LWIP_ASSERT("unacked segments leaking", pcb->unacked == NULL);
  805b25:	83 ec 04             	sub    $0x4,%esp
  805b28:	68 3a 22 81 00       	push   $0x81223a
  805b2d:	68 b5 04 00 00       	push   $0x4b5
  805b32:	68 0e 22 81 00       	push   $0x81220e
  805b37:	e8 0b 8d 00 00       	call   80e847 <_panic>
    LWIP_ASSERT("ooseq segments leaking", pcb->ooseq == NULL);
  805b3c:	83 ec 04             	sub    $0x4,%esp
  805b3f:	68 53 22 81 00       	push   $0x812253
  805b44:	68 b7 04 00 00       	push   $0x4b7
  805b49:	68 0e 22 81 00       	push   $0x81220e
  805b4e:	e8 f4 8c 00 00       	call   80e847 <_panic>

00805b53 <tcp_close>:
{
  805b53:	f3 0f 1e fb          	endbr32 
  805b57:	55                   	push   %ebp
  805b58:	89 e5                	mov    %esp,%ebp
  805b5a:	56                   	push   %esi
  805b5b:	53                   	push   %ebx
  805b5c:	8b 5d 08             	mov    0x8(%ebp),%ebx
  805b5f:	83 7b 10 07          	cmpl   $0x7,0x10(%ebx)
  805b63:	0f 87 30 01 00 00    	ja     805c99 <tcp_close+0x146>
  805b69:	8b 43 10             	mov    0x10(%ebx),%eax
  805b6c:	3e ff 24 85 6c 22 81 	notrack jmp *0x81226c(,%eax,4)
  805b73:	00 
    TCP_RMV(&tcp_bound_pcbs, pcb);
  805b74:	8b 15 4c b2 b3 00    	mov    0xb3b24c,%edx
  805b7a:	39 da                	cmp    %ebx,%edx
  805b7c:	74 12                	je     805b90 <tcp_close+0x3d>
  805b7e:	89 15 48 b2 b3 00    	mov    %edx,0xb3b248
  805b84:	b9 00 00 00 00       	mov    $0x0,%ecx
  805b89:	be 01 00 00 00       	mov    $0x1,%esi
  805b8e:	eb 2b                	jmp    805bbb <tcp_close+0x68>
  805b90:	8b 43 0c             	mov    0xc(%ebx),%eax
  805b93:	a3 4c b2 b3 00       	mov    %eax,0xb3b24c
  805b98:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
    memp_free(MEMP_TCP_PCB, pcb);
  805b9f:	83 ec 08             	sub    $0x8,%esp
  805ba2:	53                   	push   %ebx
  805ba3:	6a 02                	push   $0x2
  805ba5:	e8 fb e9 ff ff       	call   8045a5 <memp_free>
    break;
  805baa:	83 c4 10             	add    $0x10,%esp
    err = ERR_OK;
  805bad:	b8 00 00 00 00       	mov    $0x0,%eax
    break;
  805bb2:	e9 a5 00 00 00       	jmp    805c5c <tcp_close+0x109>
  805bb7:	89 f1                	mov    %esi,%ecx
    TCP_RMV(&tcp_bound_pcbs, pcb);
  805bb9:	89 c2                	mov    %eax,%edx
  805bbb:	85 d2                	test   %edx,%edx
  805bbd:	74 1d                	je     805bdc <tcp_close+0x89>
  805bbf:	8b 42 0c             	mov    0xc(%edx),%eax
  805bc2:	39 d8                	cmp    %ebx,%eax
  805bc4:	75 f1                	jne    805bb7 <tcp_close+0x64>
  805bc6:	85 c0                	test   %eax,%eax
  805bc8:	74 ed                	je     805bb7 <tcp_close+0x64>
  805bca:	84 c9                	test   %cl,%cl
  805bcc:	74 06                	je     805bd4 <tcp_close+0x81>
  805bce:	89 15 48 b2 b3 00    	mov    %edx,0xb3b248
  805bd4:	8b 43 0c             	mov    0xc(%ebx),%eax
  805bd7:	89 42 0c             	mov    %eax,0xc(%edx)
  805bda:	eb bc                	jmp    805b98 <tcp_close+0x45>
  805bdc:	84 c9                	test   %cl,%cl
  805bde:	74 b8                	je     805b98 <tcp_close+0x45>
  805be0:	c7 05 48 b2 b3 00 00 	movl   $0x0,0xb3b248
  805be7:	00 00 00 
  805bea:	eb ac                	jmp    805b98 <tcp_close+0x45>
    tcp_pcb_remove((struct tcp_pcb **)&tcp_listen_pcbs.pcbs, pcb);
  805bec:	83 ec 08             	sub    $0x8,%esp
  805bef:	53                   	push   %ebx
  805bf0:	68 44 b2 b3 00       	push   $0xb3b244
  805bf5:	e8 46 fe ff ff       	call   805a40 <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB_LISTEN, pcb);
  805bfa:	83 c4 08             	add    $0x8,%esp
  805bfd:	53                   	push   %ebx
  805bfe:	6a 03                	push   $0x3
  805c00:	e8 a0 e9 ff ff       	call   8045a5 <memp_free>
    break;
  805c05:	83 c4 10             	add    $0x10,%esp
    err = ERR_OK;
  805c08:	b8 00 00 00 00       	mov    $0x0,%eax
    break;
  805c0d:	eb 4d                	jmp    805c5c <tcp_close+0x109>
    tcp_pcb_remove(&tcp_active_pcbs, pcb);
  805c0f:	83 ec 08             	sub    $0x8,%esp
  805c12:	53                   	push   %ebx
  805c13:	68 3c b2 b3 00       	push   $0xb3b23c
  805c18:	e8 23 fe ff ff       	call   805a40 <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB, pcb);
  805c1d:	83 c4 08             	add    $0x8,%esp
  805c20:	53                   	push   %ebx
  805c21:	6a 02                	push   $0x2
  805c23:	e8 7d e9 ff ff       	call   8045a5 <memp_free>
    break;
  805c28:	83 c4 10             	add    $0x10,%esp
    err = ERR_OK;
  805c2b:	b8 00 00 00 00       	mov    $0x0,%eax
    break;
  805c30:	eb 2a                	jmp    805c5c <tcp_close+0x109>
    err = tcp_send_ctrl(pcb, TCP_FIN);
  805c32:	83 ec 08             	sub    $0x8,%esp
  805c35:	6a 01                	push   $0x1
  805c37:	53                   	push   %ebx
  805c38:	e8 2b 25 00 00       	call   808168 <tcp_send_ctrl>
    if (err == ERR_OK) {
  805c3d:	83 c4 10             	add    $0x10,%esp
  805c40:	84 c0                	test   %al,%al
  805c42:	75 18                	jne    805c5c <tcp_close+0x109>
      pcb->state = FIN_WAIT_1;
  805c44:	c7 43 10 05 00 00 00 	movl   $0x5,0x10(%ebx)
    tcp_output(pcb);
  805c4b:	83 ec 0c             	sub    $0xc,%esp
  805c4e:	53                   	push   %ebx
  805c4f:	e8 92 25 00 00       	call   8081e6 <tcp_output>
  805c54:	83 c4 10             	add    $0x10,%esp
  805c57:	b8 00 00 00 00       	mov    $0x0,%eax
}
  805c5c:	8d 65 f8             	lea    -0x8(%ebp),%esp
  805c5f:	5b                   	pop    %ebx
  805c60:	5e                   	pop    %esi
  805c61:	5d                   	pop    %ebp
  805c62:	c3                   	ret    
    err = tcp_send_ctrl(pcb, TCP_FIN);
  805c63:	83 ec 08             	sub    $0x8,%esp
  805c66:	6a 01                	push   $0x1
  805c68:	53                   	push   %ebx
  805c69:	e8 fa 24 00 00       	call   808168 <tcp_send_ctrl>
    if (err == ERR_OK) {
  805c6e:	83 c4 10             	add    $0x10,%esp
  805c71:	84 c0                	test   %al,%al
  805c73:	75 e7                	jne    805c5c <tcp_close+0x109>
      pcb->state = FIN_WAIT_1;
  805c75:	c7 43 10 05 00 00 00 	movl   $0x5,0x10(%ebx)
  805c7c:	eb cd                	jmp    805c4b <tcp_close+0xf8>
    err = tcp_send_ctrl(pcb, TCP_FIN);
  805c7e:	83 ec 08             	sub    $0x8,%esp
  805c81:	6a 01                	push   $0x1
  805c83:	53                   	push   %ebx
  805c84:	e8 df 24 00 00       	call   808168 <tcp_send_ctrl>
    if (err == ERR_OK) {
  805c89:	83 c4 10             	add    $0x10,%esp
  805c8c:	84 c0                	test   %al,%al
  805c8e:	75 cc                	jne    805c5c <tcp_close+0x109>
      pcb->state = LAST_ACK;
  805c90:	c7 43 10 09 00 00 00 	movl   $0x9,0x10(%ebx)
  805c97:	eb b2                	jmp    805c4b <tcp_close+0xf8>
  switch (pcb->state) {
  805c99:	b8 00 00 00 00       	mov    $0x0,%eax
  return err;
  805c9e:	eb bc                	jmp    805c5c <tcp_close+0x109>

00805ca0 <tcp_recv_null>:
{
  805ca0:	f3 0f 1e fb          	endbr32 
  805ca4:	55                   	push   %ebp
  805ca5:	89 e5                	mov    %esp,%ebp
  805ca7:	83 ec 08             	sub    $0x8,%esp
  805caa:	8b 45 10             	mov    0x10(%ebp),%eax
  805cad:	8b 55 14             	mov    0x14(%ebp),%edx
  if (p != NULL) {
  805cb0:	85 c0                	test   %eax,%eax
  805cb2:	74 13                	je     805cc7 <tcp_recv_null+0x27>
    pbuf_free(p);
  805cb4:	83 ec 0c             	sub    $0xc,%esp
  805cb7:	50                   	push   %eax
  805cb8:	e8 6b ec ff ff       	call   804928 <pbuf_free>
  805cbd:	83 c4 10             	add    $0x10,%esp
  return ERR_OK;
  805cc0:	b8 00 00 00 00       	mov    $0x0,%eax
}
  805cc5:	c9                   	leave  
  805cc6:	c3                   	ret    
  return ERR_OK;
  805cc7:	b8 00 00 00 00       	mov    $0x0,%eax
  } else if (err == ERR_OK) {
  805ccc:	84 d2                	test   %dl,%dl
  805cce:	75 f5                	jne    805cc5 <tcp_recv_null+0x25>
    return tcp_close(pcb);
  805cd0:	83 ec 0c             	sub    $0xc,%esp
  805cd3:	ff 75 0c             	pushl  0xc(%ebp)
  805cd6:	e8 78 fe ff ff       	call   805b53 <tcp_close>
  805cdb:	83 c4 10             	add    $0x10,%esp
  805cde:	eb e5                	jmp    805cc5 <tcp_recv_null+0x25>

00805ce0 <tcp_abort>:
{
  805ce0:	f3 0f 1e fb          	endbr32 
  805ce4:	55                   	push   %ebp
  805ce5:	89 e5                	mov    %esp,%ebp
  805ce7:	57                   	push   %edi
  805ce8:	56                   	push   %esi
  805ce9:	53                   	push   %ebx
  805cea:	83 ec 2c             	sub    $0x2c,%esp
  805ced:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (pcb->state == TIME_WAIT) {
  805cf0:	83 7b 10 0a          	cmpl   $0xa,0x10(%ebx)
  805cf4:	0f 84 c2 00 00 00    	je     805dbc <tcp_abort+0xdc>
    seqno = pcb->snd_nxt;
  805cfa:	8b 43 54             	mov    0x54(%ebx),%eax
  805cfd:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    ackno = pcb->rcv_nxt;
  805d00:	8b 7b 24             	mov    0x24(%ebx),%edi
    ip_addr_set(&local_ip, &(pcb->local_ip));
  805d03:	8b 03                	mov    (%ebx),%eax
  805d05:	89 45 e0             	mov    %eax,-0x20(%ebp)
    ip_addr_set(&remote_ip, &(pcb->remote_ip));
  805d08:	8b 43 04             	mov    0x4(%ebx),%eax
  805d0b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    local_port = pcb->local_port;
  805d0e:	0f b7 43 1c          	movzwl 0x1c(%ebx),%eax
  805d12:	66 89 45 d2          	mov    %ax,-0x2e(%ebp)
    remote_port = pcb->remote_port;
  805d16:	0f b7 43 1e          	movzwl 0x1e(%ebx),%eax
  805d1a:	66 89 45 d0          	mov    %ax,-0x30(%ebp)
    errf = pcb->errf;
  805d1e:	8b b3 98 00 00 00    	mov    0x98(%ebx),%esi
    errf_arg = pcb->callback_arg;
  805d24:	8b 43 18             	mov    0x18(%ebx),%eax
  805d27:	89 45 cc             	mov    %eax,-0x34(%ebp)
    tcp_pcb_remove(&tcp_active_pcbs, pcb);
  805d2a:	83 ec 08             	sub    $0x8,%esp
  805d2d:	53                   	push   %ebx
  805d2e:	68 3c b2 b3 00       	push   $0xb3b23c
  805d33:	e8 08 fd ff ff       	call   805a40 <tcp_pcb_remove>
    if (pcb->unacked != NULL) {
  805d38:	8b 43 78             	mov    0x78(%ebx),%eax
  805d3b:	83 c4 10             	add    $0x10,%esp
  805d3e:	85 c0                	test   %eax,%eax
  805d40:	74 0c                	je     805d4e <tcp_abort+0x6e>
      tcp_segs_free(pcb->unacked);
  805d42:	83 ec 0c             	sub    $0xc,%esp
  805d45:	50                   	push   %eax
  805d46:	e8 74 fb ff ff       	call   8058bf <tcp_segs_free>
  805d4b:	83 c4 10             	add    $0x10,%esp
    if (pcb->unsent != NULL) {
  805d4e:	8b 43 74             	mov    0x74(%ebx),%eax
  805d51:	85 c0                	test   %eax,%eax
  805d53:	74 0c                	je     805d61 <tcp_abort+0x81>
      tcp_segs_free(pcb->unsent);
  805d55:	83 ec 0c             	sub    $0xc,%esp
  805d58:	50                   	push   %eax
  805d59:	e8 61 fb ff ff       	call   8058bf <tcp_segs_free>
  805d5e:	83 c4 10             	add    $0x10,%esp
    if (pcb->ooseq != NULL) {
  805d61:	8b 43 7c             	mov    0x7c(%ebx),%eax
  805d64:	85 c0                	test   %eax,%eax
  805d66:	74 0c                	je     805d74 <tcp_abort+0x94>
      tcp_segs_free(pcb->ooseq);
  805d68:	83 ec 0c             	sub    $0xc,%esp
  805d6b:	50                   	push   %eax
  805d6c:	e8 4e fb ff ff       	call   8058bf <tcp_segs_free>
  805d71:	83 c4 10             	add    $0x10,%esp
    memp_free(MEMP_TCP_PCB, pcb);
  805d74:	83 ec 08             	sub    $0x8,%esp
  805d77:	53                   	push   %ebx
  805d78:	6a 02                	push   $0x2
  805d7a:	e8 26 e8 ff ff       	call   8045a5 <memp_free>
    TCP_EVENT_ERR(errf, errf_arg, ERR_ABRT);
  805d7f:	83 c4 10             	add    $0x10,%esp
  805d82:	85 f6                	test   %esi,%esi
  805d84:	74 0d                	je     805d93 <tcp_abort+0xb3>
  805d86:	83 ec 08             	sub    $0x8,%esp
  805d89:	6a fb                	push   $0xfffffffb
  805d8b:	ff 75 cc             	pushl  -0x34(%ebp)
  805d8e:	ff d6                	call   *%esi
  805d90:	83 c4 10             	add    $0x10,%esp
    tcp_rst(seqno, ackno, &local_ip, &remote_ip, local_port, remote_port);
  805d93:	83 ec 08             	sub    $0x8,%esp
  805d96:	0f b7 45 d0          	movzwl -0x30(%ebp),%eax
  805d9a:	50                   	push   %eax
  805d9b:	0f b7 45 d2          	movzwl -0x2e(%ebp),%eax
  805d9f:	50                   	push   %eax
  805da0:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  805da3:	50                   	push   %eax
  805da4:	8d 45 e0             	lea    -0x20(%ebp),%eax
  805da7:	50                   	push   %eax
  805da8:	57                   	push   %edi
  805da9:	ff 75 d4             	pushl  -0x2c(%ebp)
  805dac:	e8 db 28 00 00       	call   80868c <tcp_rst>
  805db1:	83 c4 20             	add    $0x20,%esp
}
  805db4:	8d 65 f4             	lea    -0xc(%ebp),%esp
  805db7:	5b                   	pop    %ebx
  805db8:	5e                   	pop    %esi
  805db9:	5f                   	pop    %edi
  805dba:	5d                   	pop    %ebp
  805dbb:	c3                   	ret    
    tcp_pcb_remove(&tcp_tw_pcbs, pcb);
  805dbc:	83 ec 08             	sub    $0x8,%esp
  805dbf:	53                   	push   %ebx
  805dc0:	68 50 b2 b3 00       	push   $0xb3b250
  805dc5:	e8 76 fc ff ff       	call   805a40 <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB, pcb);
  805dca:	83 c4 08             	add    $0x8,%esp
  805dcd:	53                   	push   %ebx
  805dce:	6a 02                	push   $0x2
  805dd0:	e8 d0 e7 ff ff       	call   8045a5 <memp_free>
  805dd5:	83 c4 10             	add    $0x10,%esp
  805dd8:	eb da                	jmp    805db4 <tcp_abort+0xd4>

00805dda <tcp_slowtmr>:
{
  805dda:	f3 0f 1e fb          	endbr32 
  805dde:	55                   	push   %ebp
  805ddf:	89 e5                	mov    %esp,%ebp
  805de1:	57                   	push   %edi
  805de2:	56                   	push   %esi
  805de3:	53                   	push   %ebx
  805de4:	83 ec 1c             	sub    $0x1c,%esp
  ++tcp_ticks;
  805de7:	83 05 40 b2 b3 00 01 	addl   $0x1,0xb3b240
  pcb = tcp_active_pcbs;
  805dee:	8b 1d 3c b2 b3 00    	mov    0xb3b23c,%ebx
  err = ERR_OK;
  805df4:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
  prev = NULL;
  805df8:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  805dff:	e9 8f 02 00 00       	jmp    806093 <tcp_slowtmr+0x2b9>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
  805e04:	83 ec 04             	sub    $0x4,%esp
  805e07:	68 7c 20 81 00       	push   $0x81207c
  805e0c:	68 36 02 00 00       	push   $0x236
  805e11:	68 0e 22 81 00       	push   $0x81220e
  805e16:	e8 2c 8a 00 00       	call   80e847 <_panic>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
  805e1b:	83 ec 04             	sub    $0x4,%esp
  805e1e:	68 a8 20 81 00       	push   $0x8120a8
  805e23:	68 37 02 00 00       	push   $0x237
  805e28:	68 0e 22 81 00       	push   $0x81220e
  805e2d:	e8 15 8a 00 00       	call   80e847 <_panic>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);
  805e32:	83 ec 04             	sub    $0x4,%esp
  805e35:	68 d4 20 81 00       	push   $0x8120d4
  805e3a:	68 38 02 00 00       	push   $0x238
  805e3f:	68 0e 22 81 00       	push   $0x81220e
  805e44:	e8 fe 89 00 00       	call   80e847 <_panic>
    if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
  805e49:	0f b6 53 46          	movzbl 0x46(%ebx),%edx
  805e4d:	80 fa 06             	cmp    $0x6,%dl
  805e50:	0f 84 35 01 00 00    	je     805f8b <tcp_slowtmr+0x1b1>
    else if (pcb->nrtx == TCP_MAXRTX) {
  805e56:	80 fa 0c             	cmp    $0xc,%dl
  805e59:	0f 85 74 02 00 00    	jne    8060d3 <tcp_slowtmr+0x2f9>
  805e5f:	be 01 00 00 00       	mov    $0x1,%esi
  805e64:	e9 27 01 00 00       	jmp    805f90 <tcp_slowtmr+0x1b6>
        if(pcb->rtime >= 0)
  805e69:	0f b7 4b 32          	movzwl 0x32(%ebx),%ecx
  805e6d:	66 85 c9             	test   %cx,%cx
  805e70:	78 07                	js     805e79 <tcp_slowtmr+0x9f>
          ++pcb->rtime;
  805e72:	83 c1 01             	add    $0x1,%ecx
  805e75:	66 89 4b 32          	mov    %cx,0x32(%ebx)
        if (pcb->unacked != NULL && pcb->rtime >= pcb->rto) {
  805e79:	83 7b 78 00          	cmpl   $0x0,0x78(%ebx)
  805e7d:	74 6c                	je     805eeb <tcp_slowtmr+0x111>
  805e7f:	0f b7 7b 44          	movzwl 0x44(%ebx),%edi
  805e83:	66 39 7b 32          	cmp    %di,0x32(%ebx)
  805e87:	7c 62                	jl     805eeb <tcp_slowtmr+0x111>
          if (pcb->state != SYN_SENT) {
  805e89:	83 f8 02             	cmp    $0x2,%eax
  805e8c:	74 1f                	je     805ead <tcp_slowtmr+0xd3>
            pcb->rto = ((pcb->sa >> 3) + pcb->sv) << tcp_backoff[pcb->nrtx];
  805e8e:	0f b7 43 40          	movzwl 0x40(%ebx),%eax
  805e92:	66 c1 f8 03          	sar    $0x3,%ax
  805e96:	98                   	cwtl   
  805e97:	0f bf 4b 42          	movswl 0x42(%ebx),%ecx
  805e9b:	01 c8                	add    %ecx,%eax
  805e9d:	0f b6 d2             	movzbl %dl,%edx
  805ea0:	0f b6 8a 94 22 81 00 	movzbl 0x812294(%edx),%ecx
  805ea7:	d3 e0                	shl    %cl,%eax
  805ea9:	66 89 43 44          	mov    %ax,0x44(%ebx)
          pcb->rtime = 0;
  805ead:	66 c7 43 32 00 00    	movw   $0x0,0x32(%ebx)
          eff_wnd = LWIP_MIN(pcb->cwnd, pcb->snd_wnd);
  805eb3:	0f b7 43 4e          	movzwl 0x4e(%ebx),%eax
  805eb7:	66 39 43 5c          	cmp    %ax,0x5c(%ebx)
  805ebb:	66 0f 46 43 5c       	cmovbe 0x5c(%ebx),%ax
          pcb->ssthresh = eff_wnd >> 1;
  805ec0:	66 d1 e8             	shr    %ax
          if (pcb->ssthresh < pcb->mss) {
  805ec3:	0f b7 53 34          	movzwl 0x34(%ebx),%edx
            pcb->ssthresh = pcb->mss * 2;
  805ec7:	8d 0c 12             	lea    (%edx,%edx,1),%ecx
  805eca:	66 39 d0             	cmp    %dx,%ax
  805ecd:	0f 42 c1             	cmovb  %ecx,%eax
  805ed0:	66 89 43 50          	mov    %ax,0x50(%ebx)
          pcb->cwnd = pcb->mss;
  805ed4:	66 89 53 4e          	mov    %dx,0x4e(%ebx)
          tcp_rexmit_rto(pcb);
  805ed8:	83 ec 0c             	sub    $0xc,%esp
  805edb:	53                   	push   %ebx
  805edc:	e8 d8 28 00 00       	call   8087b9 <tcp_rexmit_rto>
  805ee1:	83 c4 10             	add    $0x10,%esp
  805ee4:	eb 05                	jmp    805eeb <tcp_slowtmr+0x111>
    pcb_remove = 0;
  805ee6:	be 00 00 00 00       	mov    $0x0,%esi
    if (pcb->state == FIN_WAIT_2) {
  805eeb:	8b 43 10             	mov    0x10(%ebx),%eax
  805eee:	83 f8 06             	cmp    $0x6,%eax
  805ef1:	74 6d                	je     805f60 <tcp_slowtmr+0x186>
    if((pcb->so_options & SOF_KEEPALIVE) && 
  805ef3:	f6 43 08 08          	testb  $0x8,0x8(%ebx)
  805ef7:	0f 84 93 00 00 00    	je     805f90 <tcp_slowtmr+0x1b6>
  805efd:	83 f8 04             	cmp    $0x4,%eax
  805f00:	74 09                	je     805f0b <tcp_slowtmr+0x131>
  805f02:	83 f8 07             	cmp    $0x7,%eax
  805f05:	0f 85 85 00 00 00    	jne    805f90 <tcp_slowtmr+0x1b6>
      if((u32_t)(tcp_ticks - pcb->tmr) > 
  805f0b:	8b 0d 40 b2 b3 00    	mov    0xb3b240,%ecx
  805f11:	2b 4b 2c             	sub    0x2c(%ebx),%ecx
         (pcb->keep_idle + TCP_MAXIDLE) / TCP_SLOW_INTERVAL)
  805f14:	8b bb 9c 00 00 00    	mov    0x9c(%ebx),%edi
  805f1a:	8d 97 b8 4c 0a 00    	lea    0xa4cb8(%edi),%edx
  805f20:	b8 d3 4d 62 10       	mov    $0x10624dd3,%eax
  805f25:	f7 e2                	mul    %edx
  805f27:	c1 ea 05             	shr    $0x5,%edx
      if((u32_t)(tcp_ticks - pcb->tmr) > 
  805f2a:	39 d1                	cmp    %edx,%ecx
  805f2c:	77 4f                	ja     805f7d <tcp_slowtmr+0x1a3>
              (pcb->keep_idle + pcb->keep_cnt_sent * TCP_KEEPINTVL_DEFAULT) 
  805f2e:	0f b6 93 a5 00 00 00 	movzbl 0xa5(%ebx),%edx
  805f35:	69 d2 f8 24 01 00    	imul   $0x124f8,%edx,%edx
  805f3b:	01 fa                	add    %edi,%edx
              / TCP_SLOW_INTERVAL)
  805f3d:	b8 d3 4d 62 10       	mov    $0x10624dd3,%eax
  805f42:	f7 e2                	mul    %edx
  805f44:	c1 ea 05             	shr    $0x5,%edx
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
  805f47:	39 d1                	cmp    %edx,%ecx
  805f49:	76 45                	jbe    805f90 <tcp_slowtmr+0x1b6>
        tcp_keepalive(pcb);
  805f4b:	83 ec 0c             	sub    $0xc,%esp
  805f4e:	53                   	push   %ebx
  805f4f:	e8 11 29 00 00       	call   808865 <tcp_keepalive>
        pcb->keep_cnt_sent++;
  805f54:	80 83 a5 00 00 00 01 	addb   $0x1,0xa5(%ebx)
  805f5b:	83 c4 10             	add    $0x10,%esp
  805f5e:	eb 30                	jmp    805f90 <tcp_slowtmr+0x1b6>
      if ((u32_t)(tcp_ticks - pcb->tmr) >
  805f60:	a1 40 b2 b3 00       	mov    0xb3b240,%eax
  805f65:	2b 43 2c             	sub    0x2c(%ebx),%eax
        ++pcb_remove;
  805f68:	83 f8 29             	cmp    $0x29,%eax
  805f6b:	89 f0                	mov    %esi,%eax
  805f6d:	1c ff                	sbb    $0xff,%al
  805f6f:	89 c6                	mov    %eax,%esi
    if (pcb->ooseq != NULL &&
  805f71:	8b 4b 7c             	mov    0x7c(%ebx),%ecx
  805f74:	85 c9                	test   %ecx,%ecx
  805f76:	75 1f                	jne    805f97 <tcp_slowtmr+0x1bd>
  805f78:	e9 d0 00 00 00       	jmp    80604d <tcp_slowtmr+0x273>
        tcp_abort(pcb);
  805f7d:	83 ec 0c             	sub    $0xc,%esp
  805f80:	53                   	push   %ebx
  805f81:	e8 5a fd ff ff       	call   805ce0 <tcp_abort>
  805f86:	83 c4 10             	add    $0x10,%esp
  805f89:	eb 05                	jmp    805f90 <tcp_slowtmr+0x1b6>
  805f8b:	be 01 00 00 00       	mov    $0x1,%esi
    if (pcb->ooseq != NULL &&
  805f90:	8b 4b 7c             	mov    0x7c(%ebx),%ecx
  805f93:	85 c9                	test   %ecx,%ecx
  805f95:	74 16                	je     805fad <tcp_slowtmr+0x1d3>
        (u32_t)tcp_ticks - pcb->tmr >= pcb->rto * TCP_OOSEQ_TIMEOUT) {
  805f97:	8b 15 40 b2 b3 00    	mov    0xb3b240,%edx
  805f9d:	2b 53 2c             	sub    0x2c(%ebx),%edx
  805fa0:	0f bf 43 44          	movswl 0x44(%ebx),%eax
  805fa4:	8d 04 40             	lea    (%eax,%eax,2),%eax
  805fa7:	01 c0                	add    %eax,%eax
    if (pcb->ooseq != NULL &&
  805fa9:	39 c2                	cmp    %eax,%edx
  805fab:	73 7b                	jae    806028 <tcp_slowtmr+0x24e>
    if (pcb->state == SYN_RCVD) {
  805fad:	8b 43 10             	mov    0x10(%ebx),%eax
  805fb0:	83 f8 03             	cmp    $0x3,%eax
  805fb3:	0f 84 87 00 00 00    	je     806040 <tcp_slowtmr+0x266>
    if (pcb->state == LAST_ACK) {
  805fb9:	83 f8 09             	cmp    $0x9,%eax
  805fbc:	0f 85 8b 00 00 00    	jne    80604d <tcp_slowtmr+0x273>
      if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
  805fc2:	a1 40 b2 b3 00       	mov    0xb3b240,%eax
  805fc7:	2b 43 2c             	sub    0x2c(%ebx),%eax
  805fca:	3d f0 00 00 00       	cmp    $0xf0,%eax
  805fcf:	76 7c                	jbe    80604d <tcp_slowtmr+0x273>
      tcp_pcb_purge(pcb);      
  805fd1:	83 ec 0c             	sub    $0xc,%esp
  805fd4:	53                   	push   %ebx
  805fd5:	e8 e5 f9 ff ff       	call   8059bf <tcp_pcb_purge>
      if (prev != NULL) {
  805fda:	83 c4 10             	add    $0x10,%esp
  805fdd:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
  805fe1:	0f 84 66 01 00 00    	je     80614d <tcp_slowtmr+0x373>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_active_pcbs", pcb != tcp_active_pcbs);
  805fe7:	3b 1d 3c b2 b3 00    	cmp    0xb3b23c,%ebx
  805fed:	0f 84 43 01 00 00    	je     806136 <tcp_slowtmr+0x35c>
        prev->next = pcb->next;
  805ff3:	8b 43 0c             	mov    0xc(%ebx),%eax
  805ff6:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  805ff9:	89 47 0c             	mov    %eax,0xc(%edi)
      TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_ABRT);
  805ffc:	8b 83 98 00 00 00    	mov    0x98(%ebx),%eax
  806002:	85 c0                	test   %eax,%eax
  806004:	74 0d                	je     806013 <tcp_slowtmr+0x239>
  806006:	83 ec 08             	sub    $0x8,%esp
  806009:	6a fb                	push   $0xfffffffb
  80600b:	ff 73 18             	pushl  0x18(%ebx)
  80600e:	ff d0                	call   *%eax
  806010:	83 c4 10             	add    $0x10,%esp
      pcb2 = pcb->next;
  806013:	8b 73 0c             	mov    0xc(%ebx),%esi
      memp_free(MEMP_TCP_PCB, pcb);
  806016:	83 ec 08             	sub    $0x8,%esp
  806019:	53                   	push   %ebx
  80601a:	6a 02                	push   $0x2
  80601c:	e8 84 e5 ff ff       	call   8045a5 <memp_free>
  806021:	83 c4 10             	add    $0x10,%esp
      pcb = pcb2;
  806024:	89 f3                	mov    %esi,%ebx
  806026:	eb 6b                	jmp    806093 <tcp_slowtmr+0x2b9>
      tcp_segs_free(pcb->ooseq);
  806028:	83 ec 0c             	sub    $0xc,%esp
  80602b:	51                   	push   %ecx
  80602c:	e8 8e f8 ff ff       	call   8058bf <tcp_segs_free>
      pcb->ooseq = NULL;
  806031:	c7 43 7c 00 00 00 00 	movl   $0x0,0x7c(%ebx)
  806038:	83 c4 10             	add    $0x10,%esp
  80603b:	e9 6d ff ff ff       	jmp    805fad <tcp_slowtmr+0x1d3>
      if ((u32_t)(tcp_ticks - pcb->tmr) >
  806040:	a1 40 b2 b3 00       	mov    0xb3b240,%eax
  806045:	2b 43 2c             	sub    0x2c(%ebx),%eax
  806048:	83 f8 28             	cmp    $0x28,%eax
  80604b:	77 84                	ja     805fd1 <tcp_slowtmr+0x1f7>
    if (pcb_remove) {
  80604d:	89 f0                	mov    %esi,%eax
  80604f:	84 c0                	test   %al,%al
  806051:	0f 85 7a ff ff ff    	jne    805fd1 <tcp_slowtmr+0x1f7>
      ++pcb->polltmr;
  806057:	0f b6 43 30          	movzbl 0x30(%ebx),%eax
  80605b:	83 c0 01             	add    $0x1,%eax
  80605e:	88 43 30             	mov    %al,0x30(%ebx)
      if (pcb->polltmr >= pcb->pollinterval) {
  806061:	3a 43 31             	cmp    0x31(%ebx),%al
  806064:	72 27                	jb     80608d <tcp_slowtmr+0x2b3>
        pcb->polltmr = 0;
  806066:	c6 43 30 00          	movb   $0x0,0x30(%ebx)
        TCP_EVENT_POLL(pcb, err);
  80606a:	8b 83 94 00 00 00    	mov    0x94(%ebx),%eax
  806070:	85 c0                	test   %eax,%eax
  806072:	74 0f                	je     806083 <tcp_slowtmr+0x2a9>
  806074:	83 ec 08             	sub    $0x8,%esp
  806077:	53                   	push   %ebx
  806078:	ff 73 18             	pushl  0x18(%ebx)
  80607b:	ff d0                	call   *%eax
  80607d:	88 45 e3             	mov    %al,-0x1d(%ebp)
  806080:	83 c4 10             	add    $0x10,%esp
        if (err == ERR_OK) {
  806083:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
  806087:	0f 84 ec 00 00 00    	je     806179 <tcp_slowtmr+0x39f>
      prev = pcb;
  80608d:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
      pcb = pcb->next;
  806090:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  while (pcb != NULL) {
  806093:	85 db                	test   %ebx,%ebx
  806095:	0f 84 ef 00 00 00    	je     80618a <tcp_slowtmr+0x3b0>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
  80609b:	8b 43 10             	mov    0x10(%ebx),%eax
  80609e:	85 c0                	test   %eax,%eax
  8060a0:	0f 84 5e fd ff ff    	je     805e04 <tcp_slowtmr+0x2a>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
  8060a6:	83 f8 01             	cmp    $0x1,%eax
  8060a9:	0f 84 6c fd ff ff    	je     805e1b <tcp_slowtmr+0x41>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);
  8060af:	83 f8 0a             	cmp    $0xa,%eax
  8060b2:	0f 84 7a fd ff ff    	je     805e32 <tcp_slowtmr+0x58>
    if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
  8060b8:	83 f8 02             	cmp    $0x2,%eax
  8060bb:	0f 84 88 fd ff ff    	je     805e49 <tcp_slowtmr+0x6f>
    else if (pcb->nrtx == TCP_MAXRTX) {
  8060c1:	0f b6 53 46          	movzbl 0x46(%ebx),%edx
      ++pcb_remove;
  8060c5:	be 01 00 00 00       	mov    $0x1,%esi
    else if (pcb->nrtx == TCP_MAXRTX) {
  8060ca:	80 fa 0c             	cmp    $0xc,%dl
  8060cd:	0f 84 18 fe ff ff    	je     805eeb <tcp_slowtmr+0x111>
      if (pcb->persist_backoff > 0) {
  8060d3:	0f b6 b3 a4 00 00 00 	movzbl 0xa4(%ebx),%esi
  8060da:	89 f1                	mov    %esi,%ecx
  8060dc:	84 c9                	test   %cl,%cl
  8060de:	0f 84 85 fd ff ff    	je     805e69 <tcp_slowtmr+0x8f>
        pcb->persist_cnt++;
  8060e4:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
  8060ea:	83 c0 01             	add    $0x1,%eax
  8060ed:	89 83 a0 00 00 00    	mov    %eax,0xa0(%ebx)
        if (pcb->persist_cnt >= tcp_persist_backoff[pcb->persist_backoff-1]) {
  8060f3:	0f b6 d1             	movzbl %cl,%edx
  8060f6:	bf 8c 22 81 00       	mov    $0x81228c,%edi
  8060fb:	0f b6 54 17 ff       	movzbl -0x1(%edi,%edx,1),%edx
  806100:	39 d0                	cmp    %edx,%eax
  806102:	0f 82 de fd ff ff    	jb     805ee6 <tcp_slowtmr+0x10c>
          pcb->persist_cnt = 0;
  806108:	c7 83 a0 00 00 00 00 	movl   $0x0,0xa0(%ebx)
  80610f:	00 00 00 
          if (pcb->persist_backoff < sizeof(tcp_persist_backoff)) {
  806112:	80 f9 06             	cmp    $0x6,%cl
  806115:	77 09                	ja     806120 <tcp_slowtmr+0x346>
            pcb->persist_backoff++;
  806117:	8d 46 01             	lea    0x1(%esi),%eax
  80611a:	88 83 a4 00 00 00    	mov    %al,0xa4(%ebx)
          tcp_zero_window_probe(pcb);
  806120:	83 ec 0c             	sub    $0xc,%esp
  806123:	53                   	push   %ebx
  806124:	e8 66 28 00 00       	call   80898f <tcp_zero_window_probe>
  806129:	83 c4 10             	add    $0x10,%esp
    pcb_remove = 0;
  80612c:	be 00 00 00 00       	mov    $0x0,%esi
  806131:	e9 b5 fd ff ff       	jmp    805eeb <tcp_slowtmr+0x111>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_active_pcbs", pcb != tcp_active_pcbs);
  806136:	83 ec 04             	sub    $0x4,%esp
  806139:	68 04 21 81 00       	push   $0x812104
  80613e:	68 c1 02 00 00       	push   $0x2c1
  806143:	68 0e 22 81 00       	push   $0x81220e
  806148:	e8 fa 86 00 00       	call   80e847 <_panic>
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_active_pcbs", tcp_active_pcbs == pcb);
  80614d:	3b 1d 3c b2 b3 00    	cmp    0xb3b23c,%ebx
  806153:	75 0d                	jne    806162 <tcp_slowtmr+0x388>
        tcp_active_pcbs = pcb->next;
  806155:	8b 43 0c             	mov    0xc(%ebx),%eax
  806158:	a3 3c b2 b3 00       	mov    %eax,0xb3b23c
  80615d:	e9 9a fe ff ff       	jmp    805ffc <tcp_slowtmr+0x222>
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_active_pcbs", tcp_active_pcbs == pcb);
  806162:	83 ec 04             	sub    $0x4,%esp
  806165:	68 30 21 81 00       	push   $0x812130
  80616a:	68 c5 02 00 00       	push   $0x2c5
  80616f:	68 0e 22 81 00       	push   $0x81220e
  806174:	e8 ce 86 00 00       	call   80e847 <_panic>
          tcp_output(pcb);
  806179:	83 ec 0c             	sub    $0xc,%esp
  80617c:	53                   	push   %ebx
  80617d:	e8 64 20 00 00       	call   8081e6 <tcp_output>
  806182:	83 c4 10             	add    $0x10,%esp
  806185:	e9 03 ff ff ff       	jmp    80608d <tcp_slowtmr+0x2b3>
  pcb = tcp_tw_pcbs;
  80618a:	8b 35 50 b2 b3 00    	mov    0xb3b250,%esi
  while (pcb != NULL) {
  806190:	eb 48                	jmp    8061da <tcp_slowtmr+0x400>
    LWIP_ASSERT("tcp_slowtmr: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
  806192:	83 ec 04             	sub    $0x4,%esp
  806195:	68 5c 21 81 00       	push   $0x81215c
  80619a:	68 e5 02 00 00       	push   $0x2e5
  80619f:	68 0e 22 81 00       	push   $0x81220e
  8061a4:	e8 9e 86 00 00       	call   80e847 <_panic>
      tcp_pcb_purge(pcb);      
  8061a9:	83 ec 0c             	sub    $0xc,%esp
  8061ac:	56                   	push   %esi
  8061ad:	e8 0d f8 ff ff       	call   8059bf <tcp_pcb_purge>
      if (prev != NULL) {
  8061b2:	83 c4 10             	add    $0x10,%esp
  8061b5:	85 db                	test   %ebx,%ebx
  8061b7:	74 58                	je     806211 <tcp_slowtmr+0x437>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_tw_pcbs", pcb != tcp_tw_pcbs);
  8061b9:	3b 35 50 b2 b3 00    	cmp    0xb3b250,%esi
  8061bf:	74 39                	je     8061fa <tcp_slowtmr+0x420>
        prev->next = pcb->next;
  8061c1:	8b 46 0c             	mov    0xc(%esi),%eax
  8061c4:	89 43 0c             	mov    %eax,0xc(%ebx)
      pcb2 = pcb->next;
  8061c7:	8b 7e 0c             	mov    0xc(%esi),%edi
      memp_free(MEMP_TCP_PCB, pcb);
  8061ca:	83 ec 08             	sub    $0x8,%esp
  8061cd:	56                   	push   %esi
  8061ce:	6a 02                	push   $0x2
  8061d0:	e8 d0 e3 ff ff       	call   8045a5 <memp_free>
  8061d5:	83 c4 10             	add    $0x10,%esp
      pcb = pcb2;
  8061d8:	89 fe                	mov    %edi,%esi
  while (pcb != NULL) {
  8061da:	85 f6                	test   %esi,%esi
  8061dc:	74 5c                	je     80623a <tcp_slowtmr+0x460>
    LWIP_ASSERT("tcp_slowtmr: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
  8061de:	83 7e 10 0a          	cmpl   $0xa,0x10(%esi)
  8061e2:	75 ae                	jne    806192 <tcp_slowtmr+0x3b8>
    if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
  8061e4:	a1 40 b2 b3 00       	mov    0xb3b240,%eax
  8061e9:	2b 46 2c             	sub    0x2c(%esi),%eax
  8061ec:	3d f0 00 00 00       	cmp    $0xf0,%eax
  8061f1:	77 b6                	ja     8061a9 <tcp_slowtmr+0x3cf>
      prev = pcb;
  8061f3:	89 f3                	mov    %esi,%ebx
      pcb = pcb->next;
  8061f5:	8b 76 0c             	mov    0xc(%esi),%esi
  8061f8:	eb e0                	jmp    8061da <tcp_slowtmr+0x400>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_tw_pcbs", pcb != tcp_tw_pcbs);
  8061fa:	83 ec 04             	sub    $0x4,%esp
  8061fd:	68 8c 21 81 00       	push   $0x81218c
  806202:	68 f4 02 00 00       	push   $0x2f4
  806207:	68 0e 22 81 00       	push   $0x81220e
  80620c:	e8 36 86 00 00       	call   80e847 <_panic>
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_tw_pcbs", tcp_tw_pcbs == pcb);
  806211:	3b 35 50 b2 b3 00    	cmp    0xb3b250,%esi
  806217:	75 0a                	jne    806223 <tcp_slowtmr+0x449>
        tcp_tw_pcbs = pcb->next;
  806219:	8b 46 0c             	mov    0xc(%esi),%eax
  80621c:	a3 50 b2 b3 00       	mov    %eax,0xb3b250
  806221:	eb a4                	jmp    8061c7 <tcp_slowtmr+0x3ed>
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_tw_pcbs", tcp_tw_pcbs == pcb);
  806223:	83 ec 04             	sub    $0x4,%esp
  806226:	68 b4 21 81 00       	push   $0x8121b4
  80622b:	68 f8 02 00 00       	push   $0x2f8
  806230:	68 0e 22 81 00       	push   $0x81220e
  806235:	e8 0d 86 00 00       	call   80e847 <_panic>
}
  80623a:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80623d:	5b                   	pop    %ebx
  80623e:	5e                   	pop    %esi
  80623f:	5f                   	pop    %edi
  806240:	5d                   	pop    %ebp
  806241:	c3                   	ret    

00806242 <tcp_tmr>:
{
  806242:	f3 0f 1e fb          	endbr32 
  806246:	55                   	push   %ebp
  806247:	89 e5                	mov    %esp,%ebp
  806249:	83 ec 08             	sub    $0x8,%esp
  tcp_fasttmr();
  80624c:	e8 b2 f5 ff ff       	call   805803 <tcp_fasttmr>
  if (++tcp_timer & 1) {
  806251:	0f b6 05 f9 43 b3 00 	movzbl 0xb343f9,%eax
  806258:	83 c0 01             	add    $0x1,%eax
  80625b:	a2 f9 43 b3 00       	mov    %al,0xb343f9
  806260:	a8 01                	test   $0x1,%al
  806262:	75 02                	jne    806266 <tcp_tmr+0x24>
}
  806264:	c9                   	leave  
  806265:	c3                   	ret    
    tcp_slowtmr();
  806266:	e8 6f fb ff ff       	call   805dda <tcp_slowtmr>
}
  80626b:	eb f7                	jmp    806264 <tcp_tmr+0x22>

0080626d <tcp_next_iss>:
 *
 * @return u32_t pseudo random sequence number
 */
u32_t
tcp_next_iss(void)
{
  80626d:	f3 0f 1e fb          	endbr32 
  static u32_t iss = 6510;
  
  iss += tcp_ticks;       /* XXX */
  806271:	a1 40 b2 b3 00       	mov    0xb3b240,%eax
  806276:	03 05 08 40 81 00    	add    0x814008,%eax
  80627c:	a3 08 40 81 00       	mov    %eax,0x814008
  return iss;
}
  806281:	c3                   	ret    

00806282 <tcp_alloc>:
{
  806282:	f3 0f 1e fb          	endbr32 
  806286:	55                   	push   %ebp
  806287:	89 e5                	mov    %esp,%ebp
  806289:	57                   	push   %edi
  80628a:	56                   	push   %esi
  80628b:	53                   	push   %ebx
  80628c:	83 ec 28             	sub    $0x28,%esp
  80628f:	0f b6 75 08          	movzbl 0x8(%ebp),%esi
  pcb = memp_malloc(MEMP_TCP_PCB);
  806293:	6a 02                	push   $0x2
  806295:	e8 b1 e2 ff ff       	call   80454b <memp_malloc>
  80629a:	89 c3                	mov    %eax,%ebx
  if (pcb == NULL) {
  80629c:	83 c4 10             	add    $0x10,%esp
  80629f:	85 c0                	test   %eax,%eax
  8062a1:	0f 84 a0 00 00 00    	je     806347 <tcp_alloc+0xc5>
    memset(pcb, 0, sizeof(struct tcp_pcb));
  8062a7:	83 ec 04             	sub    $0x4,%esp
  8062aa:	68 a8 00 00 00       	push   $0xa8
  8062af:	6a 00                	push   $0x0
  8062b1:	53                   	push   %ebx
  8062b2:	e8 eb 8d 00 00       	call   80f0a2 <memset>
    pcb->prio = TCP_PRIO_NORMAL;
  8062b7:	c6 43 14 40          	movb   $0x40,0x14(%ebx)
    pcb->snd_buf = TCP_SND_BUF;
  8062bb:	66 c7 43 6e 40 5b    	movw   $0x5b40,0x6e(%ebx)
    pcb->snd_queuelen = 0;
  8062c1:	66 c7 43 70 00 00    	movw   $0x0,0x70(%ebx)
    pcb->rcv_wnd = TCP_WND;
  8062c7:	66 c7 43 28 c0 5d    	movw   $0x5dc0,0x28(%ebx)
    pcb->rcv_ann_wnd = TCP_WND;
  8062cd:	66 c7 43 2a c0 5d    	movw   $0x5dc0,0x2a(%ebx)
    pcb->tos = 0;
  8062d3:	c6 43 0a 00          	movb   $0x0,0xa(%ebx)
    pcb->ttl = TCP_TTL;
  8062d7:	c6 43 0b ff          	movb   $0xff,0xb(%ebx)
    pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
  8062db:	66 c7 43 34 18 02    	movw   $0x218,0x34(%ebx)
    pcb->rto = 3000 / TCP_SLOW_INTERVAL;
  8062e1:	66 c7 43 44 06 00    	movw   $0x6,0x44(%ebx)
    pcb->sa = 0;
  8062e7:	66 c7 43 40 00 00    	movw   $0x0,0x40(%ebx)
    pcb->sv = 3000 / TCP_SLOW_INTERVAL;
  8062ed:	66 c7 43 42 06 00    	movw   $0x6,0x42(%ebx)
    pcb->rtime = -1;
  8062f3:	66 c7 43 32 ff ff    	movw   $0xffff,0x32(%ebx)
    pcb->cwnd = 1;
  8062f9:	66 c7 43 4e 01 00    	movw   $0x1,0x4e(%ebx)
    iss = tcp_next_iss();
  8062ff:	e8 69 ff ff ff       	call   80626d <tcp_next_iss>
    pcb->snd_wl2 = iss;
  806304:	89 43 64             	mov    %eax,0x64(%ebx)
    pcb->snd_nxt = iss;
  806307:	89 43 54             	mov    %eax,0x54(%ebx)
    pcb->snd_max = iss;
  80630a:	89 43 58             	mov    %eax,0x58(%ebx)
    pcb->lastack = iss;
  80630d:	89 43 48             	mov    %eax,0x48(%ebx)
    pcb->snd_lbb = iss;   
  806310:	89 43 68             	mov    %eax,0x68(%ebx)
    pcb->tmr = tcp_ticks;
  806313:	a1 40 b2 b3 00       	mov    0xb3b240,%eax
  806318:	89 43 2c             	mov    %eax,0x2c(%ebx)
    pcb->polltmr = 0;
  80631b:	c6 43 30 00          	movb   $0x0,0x30(%ebx)
    pcb->recv = tcp_recv_null;
  80631f:	c7 83 88 00 00 00 a0 	movl   $0x805ca0,0x88(%ebx)
  806326:	5c 80 00 
    pcb->keep_idle  = TCP_KEEPIDLE_DEFAULT;
  806329:	c7 83 9c 00 00 00 00 	movl   $0x6ddd00,0x9c(%ebx)
  806330:	dd 6d 00 
    pcb->keep_cnt_sent = 0;
  806333:	c6 83 a5 00 00 00 00 	movb   $0x0,0xa5(%ebx)
  80633a:	83 c4 10             	add    $0x10,%esp
}
  80633d:	89 d8                	mov    %ebx,%eax
  80633f:	8d 65 f4             	lea    -0xc(%ebp),%esp
  806342:	5b                   	pop    %ebx
  806343:	5e                   	pop    %esi
  806344:	5f                   	pop    %edi
  806345:	5d                   	pop    %ebp
  806346:	c3                   	ret    
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  806347:	a1 50 b2 b3 00       	mov    0xb3b250,%eax
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
  80634c:	8b 3d 40 b2 b3 00    	mov    0xb3b240,%edi
  inactivity = 0;
  806352:	b9 00 00 00 00       	mov    $0x0,%ecx
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  806357:	eb 03                	jmp    80635c <tcp_alloc+0xda>
  806359:	8b 40 0c             	mov    0xc(%eax),%eax
  80635c:	85 c0                	test   %eax,%eax
  80635e:	74 0f                	je     80636f <tcp_alloc+0xed>
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
  806360:	89 fa                	mov    %edi,%edx
  806362:	2b 50 2c             	sub    0x2c(%eax),%edx
  806365:	39 ca                	cmp    %ecx,%edx
  806367:	72 f0                	jb     806359 <tcp_alloc+0xd7>
      inactivity = tcp_ticks - pcb->tmr;
  806369:	89 d1                	mov    %edx,%ecx
      inactive = pcb;
  80636b:	89 c3                	mov    %eax,%ebx
  80636d:	eb ea                	jmp    806359 <tcp_alloc+0xd7>
  if (inactive != NULL) {
  80636f:	85 db                	test   %ebx,%ebx
  806371:	74 0c                	je     80637f <tcp_alloc+0xfd>
    tcp_abort(inactive);
  806373:	83 ec 0c             	sub    $0xc,%esp
  806376:	53                   	push   %ebx
  806377:	e8 64 f9 ff ff       	call   805ce0 <tcp_abort>
  80637c:	83 c4 10             	add    $0x10,%esp
    pcb = memp_malloc(MEMP_TCP_PCB);
  80637f:	83 ec 0c             	sub    $0xc,%esp
  806382:	6a 02                	push   $0x2
  806384:	e8 c2 e1 ff ff       	call   80454b <memp_malloc>
  806389:	89 c3                	mov    %eax,%ebx
    if (pcb == NULL) {
  80638b:	83 c4 10             	add    $0x10,%esp
  80638e:	85 c0                	test   %eax,%eax
  806390:	0f 85 11 ff ff ff    	jne    8062a7 <tcp_alloc+0x25>
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  806396:	a1 3c b2 b3 00       	mov    0xb3b23c,%eax
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
  80639b:	8b 3d 40 b2 b3 00    	mov    0xb3b240,%edi
  8063a1:	89 7d dc             	mov    %edi,-0x24(%ebp)
  mprio = TCP_PRIO_MAX;
  8063a4:	ba 7f 00 00 00       	mov    $0x7f,%edx
  inactivity = 0;
  8063a9:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  8063b0:	89 df                	mov    %ebx,%edi
  8063b2:	89 f1                	mov    %esi,%ecx
  8063b4:	88 4d e7             	mov    %cl,-0x19(%ebp)
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  8063b7:	eb 03                	jmp    8063bc <tcp_alloc+0x13a>
  8063b9:	8b 40 0c             	mov    0xc(%eax),%eax
  8063bc:	85 c0                	test   %eax,%eax
  8063be:	74 29                	je     8063e9 <tcp_alloc+0x167>
    if (pcb->prio <= prio &&
  8063c0:	0f b6 48 14          	movzbl 0x14(%eax),%ecx
  8063c4:	0f b6 5d e7          	movzbl -0x19(%ebp),%ebx
  8063c8:	38 d3                	cmp    %dl,%bl
  8063ca:	89 d6                	mov    %edx,%esi
  8063cc:	0f 46 f3             	cmovbe %ebx,%esi
  8063cf:	89 f3                	mov    %esi,%ebx
  8063d1:	38 cb                	cmp    %cl,%bl
  8063d3:	72 e4                	jb     8063b9 <tcp_alloc+0x137>
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
  8063d5:	8b 75 dc             	mov    -0x24(%ebp),%esi
  8063d8:	2b 70 2c             	sub    0x2c(%eax),%esi
       pcb->prio <= mprio &&
  8063db:	3b 75 e0             	cmp    -0x20(%ebp),%esi
  8063de:	72 d9                	jb     8063b9 <tcp_alloc+0x137>
      mprio = pcb->prio;
  8063e0:	89 ca                	mov    %ecx,%edx
      inactivity = tcp_ticks - pcb->tmr;
  8063e2:	89 75 e0             	mov    %esi,-0x20(%ebp)
      inactive = pcb;
  8063e5:	89 c7                	mov    %eax,%edi
  8063e7:	eb d0                	jmp    8063b9 <tcp_alloc+0x137>
  if (inactive != NULL) {
  8063e9:	85 ff                	test   %edi,%edi
  8063eb:	74 0c                	je     8063f9 <tcp_alloc+0x177>
    tcp_abort(inactive);
  8063ed:	83 ec 0c             	sub    $0xc,%esp
  8063f0:	57                   	push   %edi
  8063f1:	e8 ea f8 ff ff       	call   805ce0 <tcp_abort>
  8063f6:	83 c4 10             	add    $0x10,%esp
      pcb = memp_malloc(MEMP_TCP_PCB);
  8063f9:	83 ec 0c             	sub    $0xc,%esp
  8063fc:	6a 02                	push   $0x2
  8063fe:	e8 48 e1 ff ff       	call   80454b <memp_malloc>
  806403:	89 c3                	mov    %eax,%ebx
  if (pcb != NULL) {
  806405:	83 c4 10             	add    $0x10,%esp
  806408:	85 c0                	test   %eax,%eax
  80640a:	0f 84 2d ff ff ff    	je     80633d <tcp_alloc+0xbb>
  806410:	e9 92 fe ff ff       	jmp    8062a7 <tcp_alloc+0x25>

00806415 <tcp_new>:
{
  806415:	f3 0f 1e fb          	endbr32 
  806419:	55                   	push   %ebp
  80641a:	89 e5                	mov    %esp,%ebp
  80641c:	83 ec 14             	sub    $0x14,%esp
  return tcp_alloc(TCP_PRIO_NORMAL);
  80641f:	6a 40                	push   $0x40
  806421:	e8 5c fe ff ff       	call   806282 <tcp_alloc>
}
  806426:	c9                   	leave  
  806427:	c3                   	ret    

00806428 <tcp_eff_send_mss>:
 * by using ip_route to determin the netif used to send to the address and
 * calculating the minimum of TCP_MSS and that netif's mtu (if set).
 */
u16_t
tcp_eff_send_mss(u16_t sendmss, struct ip_addr *addr)
{
  806428:	f3 0f 1e fb          	endbr32 
  80642c:	55                   	push   %ebp
  80642d:	89 e5                	mov    %esp,%ebp
  80642f:	56                   	push   %esi
  806430:	53                   	push   %ebx
  806431:	8b 5d 08             	mov    0x8(%ebp),%ebx
  806434:	89 de                	mov    %ebx,%esi
  u16_t mss_s;
  struct netif *outif;

  outif = ip_route(addr);
  806436:	83 ec 0c             	sub    $0xc,%esp
  806439:	ff 75 0c             	pushl  0xc(%ebp)
  80643c:	e8 ea 01 00 00       	call   80662b <ip_route>
  if ((outif != NULL) && (outif->mtu != 0)) {
  806441:	83 c4 10             	add    $0x10,%esp
  806444:	85 c0                	test   %eax,%eax
  806446:	74 12                	je     80645a <tcp_eff_send_mss+0x32>
  806448:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
  80644c:	66 85 c0             	test   %ax,%ax
  80644f:	74 09                	je     80645a <tcp_eff_send_mss+0x32>
    mss_s = outif->mtu - IP_HLEN - TCP_HLEN;
  806451:	8d 70 d8             	lea    -0x28(%eax),%esi
    /* RFC 1122, chap 4.2.2.6:
     * Eff.snd.MSS = min(SendMSS+20, MMS_S) - TCPhdrsize - IPoptionsize
     * but we only send options with SYN and that is never filled with data! */
    sendmss = LWIP_MIN(sendmss, mss_s);
  806454:	66 39 f3             	cmp    %si,%bx
  806457:	0f 46 f3             	cmovbe %ebx,%esi
  }
  return sendmss;
}
  80645a:	89 f0                	mov    %esi,%eax
  80645c:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80645f:	5b                   	pop    %ebx
  806460:	5e                   	pop    %esi
  806461:	5d                   	pop    %ebp
  806462:	c3                   	ret    

00806463 <tcp_connect>:
{
  806463:	f3 0f 1e fb          	endbr32 
  806467:	55                   	push   %ebp
  806468:	89 e5                	mov    %esp,%ebp
  80646a:	56                   	push   %esi
  80646b:	53                   	push   %ebx
  80646c:	83 ec 10             	sub    $0x10,%esp
  80646f:	8b 5d 08             	mov    0x8(%ebp),%ebx
  806472:	8b 75 0c             	mov    0xc(%ebp),%esi
  806475:	8b 45 10             	mov    0x10(%ebp),%eax
  LWIP_ERROR("tcp_connect: can only connected from state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
  806478:	83 7b 10 00          	cmpl   $0x0,0x10(%ebx)
  80647c:	0f 85 9c 00 00 00    	jne    80651e <tcp_connect+0xbb>
  if (ipaddr != NULL) {
  806482:	85 f6                	test   %esi,%esi
  806484:	0f 84 53 01 00 00    	je     8065dd <tcp_connect+0x17a>
    pcb->remote_ip = *ipaddr;
  80648a:	8b 16                	mov    (%esi),%edx
  80648c:	89 53 04             	mov    %edx,0x4(%ebx)
  pcb->remote_port = port;
  80648f:	66 89 43 1e          	mov    %ax,0x1e(%ebx)
  if (pcb->local_port == 0) {
  806493:	66 83 7b 1c 00       	cmpw   $0x0,0x1c(%ebx)
  806498:	0f 84 97 00 00 00    	je     806535 <tcp_connect+0xd2>
  iss = tcp_next_iss();
  80649e:	e8 ca fd ff ff       	call   80626d <tcp_next_iss>
  pcb->rcv_nxt = 0;
  8064a3:	c7 43 24 00 00 00 00 	movl   $0x0,0x24(%ebx)
  pcb->snd_nxt = iss;
  8064aa:	89 43 54             	mov    %eax,0x54(%ebx)
  pcb->lastack = iss - 1;
  8064ad:	83 e8 01             	sub    $0x1,%eax
  8064b0:	89 43 48             	mov    %eax,0x48(%ebx)
  pcb->snd_lbb = iss - 1;
  8064b3:	89 43 68             	mov    %eax,0x68(%ebx)
  pcb->rcv_wnd = TCP_WND;
  8064b6:	66 c7 43 28 c0 5d    	movw   $0x5dc0,0x28(%ebx)
  pcb->rcv_ann_wnd = TCP_WND;
  8064bc:	66 c7 43 2a c0 5d    	movw   $0x5dc0,0x2a(%ebx)
  pcb->snd_wnd = TCP_WND;
  8064c2:	66 c7 43 5c c0 5d    	movw   $0x5dc0,0x5c(%ebx)
  pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
  8064c8:	66 c7 43 34 18 02    	movw   $0x218,0x34(%ebx)
  pcb->mss = tcp_eff_send_mss(pcb->mss, ipaddr);
  8064ce:	83 ec 08             	sub    $0x8,%esp
  8064d1:	56                   	push   %esi
  8064d2:	68 18 02 00 00       	push   $0x218
  8064d7:	e8 4c ff ff ff       	call   806428 <tcp_eff_send_mss>
  8064dc:	66 89 43 34          	mov    %ax,0x34(%ebx)
  pcb->cwnd = 1;
  8064e0:	66 c7 43 4e 01 00    	movw   $0x1,0x4e(%ebx)
  pcb->ssthresh = pcb->mss * 10;
  8064e6:	8d 04 80             	lea    (%eax,%eax,4),%eax
  8064e9:	01 c0                	add    %eax,%eax
  8064eb:	66 89 43 50          	mov    %ax,0x50(%ebx)
  pcb->state = SYN_SENT;
  8064ef:	c7 43 10 02 00 00 00 	movl   $0x2,0x10(%ebx)
  pcb->connected = connected;
  8064f6:	8b 45 14             	mov    0x14(%ebp),%eax
  8064f9:	89 83 8c 00 00 00    	mov    %eax,0x8c(%ebx)
  TCP_RMV(&tcp_bound_pcbs, pcb);
  8064ff:	8b 15 4c b2 b3 00    	mov    0xb3b24c,%edx
  806505:	83 c4 10             	add    $0x10,%esp
  806508:	39 da                	cmp    %ebx,%edx
  80650a:	74 37                	je     806543 <tcp_connect+0xe0>
  80650c:	89 15 48 b2 b3 00    	mov    %edx,0xb3b248
  806512:	b9 00 00 00 00       	mov    $0x0,%ecx
  806517:	be 01 00 00 00       	mov    $0x1,%esi
  80651c:	eb 7d                	jmp    80659b <tcp_connect+0x138>
  LWIP_ERROR("tcp_connect: can only connected from state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
  80651e:	83 ec 04             	sub    $0x4,%esp
  806521:	68 dc 21 81 00       	push   $0x8121dc
  806526:	68 ec 01 00 00       	push   $0x1ec
  80652b:	68 0e 22 81 00       	push   $0x81220e
  806530:	e8 12 83 00 00       	call   80e847 <_panic>
    pcb->local_port = tcp_new_port();
  806535:	e8 72 ef ff ff       	call   8054ac <tcp_new_port>
  80653a:	66 89 43 1c          	mov    %ax,0x1c(%ebx)
  80653e:	e9 5b ff ff ff       	jmp    80649e <tcp_connect+0x3b>
  TCP_RMV(&tcp_bound_pcbs, pcb);
  806543:	8b 43 0c             	mov    0xc(%ebx),%eax
  806546:	a3 4c b2 b3 00       	mov    %eax,0xb3b24c
  TCP_REG(&tcp_active_pcbs, pcb);
  80654b:	a1 3c b2 b3 00       	mov    0xb3b23c,%eax
  806550:	89 43 0c             	mov    %eax,0xc(%ebx)
  806553:	89 1d 3c b2 b3 00    	mov    %ebx,0xb3b23c
  806559:	e8 f5 bc ff ff       	call   802253 <tcp_timer_needed>
  optdata = TCP_BUILD_MSS_OPTION();
  80655e:	83 ec 0c             	sub    $0xc,%esp
  806561:	68 b4 05 04 02       	push   $0x20405b4
  806566:	e8 17 13 00 00       	call   807882 <htonl>
  80656b:	89 45 f4             	mov    %eax,-0xc(%ebp)
  ret = tcp_enqueue(pcb, NULL, 0, TCP_SYN, 0, (u8_t *)&optdata, 4);
  80656e:	83 c4 0c             	add    $0xc,%esp
  806571:	6a 04                	push   $0x4
  806573:	8d 45 f4             	lea    -0xc(%ebp),%eax
  806576:	50                   	push   %eax
  806577:	6a 00                	push   $0x0
  806579:	6a 02                	push   $0x2
  80657b:	6a 00                	push   $0x0
  80657d:	6a 00                	push   $0x0
  80657f:	53                   	push   %ebx
  806580:	e8 41 15 00 00       	call   807ac6 <tcp_enqueue>
  806585:	89 c6                	mov    %eax,%esi
  if (ret == ERR_OK) { 
  806587:	83 c4 20             	add    $0x20,%esp
  80658a:	84 c0                	test   %al,%al
  80658c:	74 41                	je     8065cf <tcp_connect+0x16c>
} 
  80658e:	89 f0                	mov    %esi,%eax
  806590:	8d 65 f8             	lea    -0x8(%ebp),%esp
  806593:	5b                   	pop    %ebx
  806594:	5e                   	pop    %esi
  806595:	5d                   	pop    %ebp
  806596:	c3                   	ret    
  806597:	89 f1                	mov    %esi,%ecx
  TCP_RMV(&tcp_bound_pcbs, pcb);
  806599:	89 c2                	mov    %eax,%edx
  80659b:	85 d2                	test   %edx,%edx
  80659d:	74 1d                	je     8065bc <tcp_connect+0x159>
  80659f:	8b 42 0c             	mov    0xc(%edx),%eax
  8065a2:	39 d8                	cmp    %ebx,%eax
  8065a4:	75 f1                	jne    806597 <tcp_connect+0x134>
  8065a6:	85 c0                	test   %eax,%eax
  8065a8:	74 ed                	je     806597 <tcp_connect+0x134>
  8065aa:	84 c9                	test   %cl,%cl
  8065ac:	74 06                	je     8065b4 <tcp_connect+0x151>
  8065ae:	89 15 48 b2 b3 00    	mov    %edx,0xb3b248
  8065b4:	8b 43 0c             	mov    0xc(%ebx),%eax
  8065b7:	89 42 0c             	mov    %eax,0xc(%edx)
  8065ba:	eb 8f                	jmp    80654b <tcp_connect+0xe8>
  8065bc:	84 c9                	test   %cl,%cl
  8065be:	74 8b                	je     80654b <tcp_connect+0xe8>
  8065c0:	c7 05 48 b2 b3 00 00 	movl   $0x0,0xb3b248
  8065c7:	00 00 00 
  8065ca:	e9 7c ff ff ff       	jmp    80654b <tcp_connect+0xe8>
    tcp_output(pcb);
  8065cf:	83 ec 0c             	sub    $0xc,%esp
  8065d2:	53                   	push   %ebx
  8065d3:	e8 0e 1c 00 00       	call   8081e6 <tcp_output>
  8065d8:	83 c4 10             	add    $0x10,%esp
  8065db:	eb b1                	jmp    80658e <tcp_connect+0x12b>
    return ERR_VAL;
  8065dd:	be f7 ff ff ff       	mov    $0xfffffff7,%esi
  8065e2:	eb aa                	jmp    80658e <tcp_connect+0x12b>

008065e4 <ip_addr_isbroadcast>:
 * @param addr address to be checked
 * @param netif the network interface against which the address is checked
 * @return returns non-zero if the address is a broadcast address
 */
u8_t ip_addr_isbroadcast(struct ip_addr *addr, struct netif *netif)
{
  8065e4:	f3 0f 1e fb          	endbr32 
  8065e8:	55                   	push   %ebp
  8065e9:	89 e5                	mov    %esp,%ebp
  8065eb:	53                   	push   %ebx
  8065ec:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  u32_t addr2test;

  addr2test = addr->addr;
  8065ef:	8b 45 08             	mov    0x8(%ebp),%eax
  8065f2:	8b 10                	mov    (%eax),%edx
  /* all ones (broadcast) or all zeroes (old skool broadcast) */
  if ((~addr2test == IP_ADDR_ANY_VALUE) ||
  8065f4:	8d 5a ff             	lea    -0x1(%edx),%ebx
      (addr2test == IP_ADDR_ANY_VALUE))
    return 1;
  8065f7:	b8 01 00 00 00       	mov    $0x1,%eax
  if ((~addr2test == IP_ADDR_ANY_VALUE) ||
  8065fc:	83 fb fd             	cmp    $0xfffffffd,%ebx
  8065ff:	77 27                	ja     806628 <ip_addr_isbroadcast+0x44>
  /* no broadcast support on this network interface? */
  else if ((netif->flags & NETIF_FLAG_BROADCAST) == 0)
  806601:	0f b6 41 2e          	movzbl 0x2e(%ecx),%eax
  806605:	83 e0 02             	and    $0x2,%eax
  806608:	74 1e                	je     806628 <ip_addr_isbroadcast+0x44>
    /* the given address cannot be a broadcast address
     * nor can we check against any broadcast addresses */
    return 0;
  /* address matches network interface address exactly? => no broadcast */
  else if (addr2test == netif->ip_addr.addr)
  80660a:	8b 59 04             	mov    0x4(%ecx),%ebx
    return 0;
  80660d:	b8 00 00 00 00       	mov    $0x0,%eax
  else if (addr2test == netif->ip_addr.addr)
  806612:	39 d3                	cmp    %edx,%ebx
  806614:	74 12                	je     806628 <ip_addr_isbroadcast+0x44>
  /*  on the same (sub) network... */
  else if (ip_addr_netcmp(addr, &(netif->ip_addr), &(netif->netmask))
  806616:	8b 49 08             	mov    0x8(%ecx),%ecx
  806619:	31 d3                	xor    %edx,%ebx
  80661b:	85 cb                	test   %ecx,%ebx
  80661d:	75 09                	jne    806628 <ip_addr_isbroadcast+0x44>
         /* ...and host identifier bits are all ones? =>... */
          && ((addr2test & ~netif->netmask.addr) ==
  80661f:	f7 d1                	not    %ecx
  806621:	21 ca                	and    %ecx,%edx
  806623:	39 ca                	cmp    %ecx,%edx
  806625:	0f 94 c0             	sete   %al
           (IP_ADDR_BROADCAST_VALUE & ~netif->netmask.addr)))
    /* => network broadcast address */
    return 1;
  else
    return 0;
}
  806628:	5b                   	pop    %ebx
  806629:	5d                   	pop    %ebp
  80662a:	c3                   	ret    

0080662b <ip_route>:
 * @param dest the destination IP address for which to find the route
 * @return the netif on which to send to reach dest
 */
struct netif *
ip_route(struct ip_addr *dest)
{
  80662b:	f3 0f 1e fb          	endbr32 
  80662f:	55                   	push   %ebp
  806630:	89 e5                	mov    %esp,%ebp
  806632:	56                   	push   %esi
  806633:	53                   	push   %ebx
  806634:	8b 75 08             	mov    0x8(%ebp),%esi
  struct netif *netif;

  /* iterate through netifs */
  for(netif = netif_list; netif != NULL; netif = netif->next) {
  806637:	8b 1d 34 b2 b3 00    	mov    0xb3b234,%ebx
  80663d:	eb 02                	jmp    806641 <ip_route+0x16>
  80663f:	8b 1b                	mov    (%ebx),%ebx
  806641:	85 db                	test   %ebx,%ebx
  806643:	74 1c                	je     806661 <ip_route+0x36>
    /* network mask matches? */
    if (netif_is_up(netif)) {
  806645:	83 ec 0c             	sub    $0xc,%esp
  806648:	53                   	push   %ebx
  806649:	e8 f4 e1 ff ff       	call   804842 <netif_is_up>
  80664e:	83 c4 10             	add    $0x10,%esp
  806651:	84 c0                	test   %al,%al
  806653:	74 ea                	je     80663f <ip_route+0x14>
      if (ip_addr_netcmp(dest, &(netif->ip_addr), &(netif->netmask))) {
  806655:	8b 06                	mov    (%esi),%eax
  806657:	33 43 04             	xor    0x4(%ebx),%eax
  80665a:	85 43 08             	test   %eax,0x8(%ebx)
  80665d:	75 e0                	jne    80663f <ip_route+0x14>
  80665f:	eb 1e                	jmp    80667f <ip_route+0x54>
        /* return netif on which to forward IP packet */
        return netif;
      }
    }
  }
  if ((netif_default == NULL) || (!netif_is_up(netif_default))) {
  806661:	a1 38 b2 b3 00       	mov    0xb3b238,%eax
  806666:	85 c0                	test   %eax,%eax
  806668:	74 1e                	je     806688 <ip_route+0x5d>
  80666a:	83 ec 0c             	sub    $0xc,%esp
  80666d:	50                   	push   %eax
  80666e:	e8 cf e1 ff ff       	call   804842 <netif_is_up>
  806673:	83 c4 10             	add    $0x10,%esp
    IP_STATS_INC(ip.rterr);
    snmp_inc_ipoutnoroutes();
    return NULL;
  }
  /* no matching netif found, use default netif */
  return netif_default;
  806676:	84 c0                	test   %al,%al
  806678:	0f 45 1d 38 b2 b3 00 	cmovne 0xb3b238,%ebx
}
  80667f:	89 d8                	mov    %ebx,%eax
  806681:	8d 65 f8             	lea    -0x8(%ebp),%esp
  806684:	5b                   	pop    %ebx
  806685:	5e                   	pop    %esi
  806686:	5d                   	pop    %ebp
  806687:	c3                   	ret    
    return NULL;
  806688:	89 c3                	mov    %eax,%ebx
  80668a:	eb f3                	jmp    80667f <ip_route+0x54>

0080668c <ip_input>:
 * @return ERR_OK if the packet was processed (could return ERR_* if it wasn't
 *         processed, but currently always returns ERR_OK)
 */
err_t
ip_input(struct pbuf *p, struct netif *inp)
{
  80668c:	f3 0f 1e fb          	endbr32 
  806690:	55                   	push   %ebp
  806691:	89 e5                	mov    %esp,%ebp
  806693:	57                   	push   %edi
  806694:	56                   	push   %esi
  806695:	53                   	push   %ebx
  806696:	83 ec 28             	sub    $0x28,%esp

  IP_STATS_INC(ip.recv);
  snmp_inc_ipinreceives();

  /* identify the IP header */
  iphdr = p->payload;
  806699:	8b 45 08             	mov    0x8(%ebp),%eax
  80669c:	8b 78 04             	mov    0x4(%eax),%edi
  if (IPH_V(iphdr) != 4) {
  80669f:	0f b7 07             	movzwl (%edi),%eax
  8066a2:	50                   	push   %eax
  8066a3:	e8 c9 11 00 00       	call   807871 <ntohs>
  8066a8:	66 c1 e8 0c          	shr    $0xc,%ax
  8066ac:	83 c4 10             	add    $0x10,%esp
  8066af:	66 83 f8 04          	cmp    $0x4,%ax
  8066b3:	74 1b                	je     8066d0 <ip_input+0x44>
    LWIP_DEBUGF(IP_DEBUG | 1, ("IP packet dropped due to bad version number %"U16_F"\n", IPH_V(iphdr)));
    ip_debug_print(p);
    pbuf_free(p);
  8066b5:	83 ec 0c             	sub    $0xc,%esp
  8066b8:	ff 75 08             	pushl  0x8(%ebp)
  8066bb:	e8 68 e2 ff ff       	call   804928 <pbuf_free>
    IP_STATS_INC(ip.err);
    IP_STATS_INC(ip.drop);
    snmp_inc_ipinhdrerrors();
    return ERR_OK;
  8066c0:	83 c4 10             	add    $0x10,%esp
      snmp_inc_ipinunknownprotos();
    }
  }

  return ERR_OK;
}
  8066c3:	b8 00 00 00 00       	mov    $0x0,%eax
  8066c8:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8066cb:	5b                   	pop    %ebx
  8066cc:	5e                   	pop    %esi
  8066cd:	5f                   	pop    %edi
  8066ce:	5d                   	pop    %ebp
  8066cf:	c3                   	ret    
  iphdr_hlen = IPH_HL(iphdr);
  8066d0:	83 ec 0c             	sub    $0xc,%esp
  8066d3:	0f b7 07             	movzwl (%edi),%eax
  8066d6:	50                   	push   %eax
  8066d7:	e8 95 11 00 00       	call   807871 <ntohs>
  8066dc:	66 c1 e8 06          	shr    $0x6,%ax
  iphdr_hlen *= 4;
  8066e0:	83 e0 3c             	and    $0x3c,%eax
  8066e3:	89 c6                	mov    %eax,%esi
  8066e5:	66 89 45 e2          	mov    %ax,-0x1e(%ebp)
  iphdr_len = ntohs(IPH_LEN(iphdr));
  8066e9:	0f b7 47 02          	movzwl 0x2(%edi),%eax
  8066ed:	89 04 24             	mov    %eax,(%esp)
  8066f0:	e8 7c 11 00 00       	call   807871 <ntohs>
  8066f5:	89 c3                	mov    %eax,%ebx
  if ((iphdr_hlen > p->len) || (iphdr_len > p->tot_len)) {
  8066f7:	83 c4 10             	add    $0x10,%esp
  8066fa:	8b 45 08             	mov    0x8(%ebp),%eax
  8066fd:	66 39 70 0a          	cmp    %si,0xa(%eax)
  806701:	72 06                	jb     806709 <ip_input+0x7d>
  806703:	66 39 58 08          	cmp    %bx,0x8(%eax)
  806707:	73 10                	jae    806719 <ip_input+0x8d>
    pbuf_free(p);
  806709:	83 ec 0c             	sub    $0xc,%esp
  80670c:	ff 75 08             	pushl  0x8(%ebp)
  80670f:	e8 14 e2 ff ff       	call   804928 <pbuf_free>
    return ERR_OK;
  806714:	83 c4 10             	add    $0x10,%esp
  806717:	eb aa                	jmp    8066c3 <ip_input+0x37>
  if (inet_chksum(iphdr, iphdr_hlen) != 0) {
  806719:	83 ec 08             	sub    $0x8,%esp
  80671c:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
  806720:	50                   	push   %eax
  806721:	57                   	push   %edi
  806722:	e8 ff 0f 00 00       	call   807726 <inet_chksum>
  806727:	83 c4 10             	add    $0x10,%esp
  80672a:	66 85 c0             	test   %ax,%ax
  80672d:	75 27                	jne    806756 <ip_input+0xca>
  pbuf_realloc(p, iphdr_len);
  80672f:	83 ec 08             	sub    $0x8,%esp
  806732:	0f b7 db             	movzwl %bx,%ebx
  806735:	53                   	push   %ebx
  806736:	ff 75 08             	pushl  0x8(%ebp)
  806739:	e8 13 e5 ff ff       	call   804c51 <pbuf_realloc>
  80673e:	83 c4 10             	add    $0x10,%esp
    netif = inp;
  806741:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    int first = 1;
  806744:	be 01 00 00 00       	mov    $0x1,%esi
            ip_addr_isbroadcast(&(iphdr->dest), netif)) {
  806749:	8d 47 10             	lea    0x10(%edi),%eax
  80674c:	89 45 dc             	mov    %eax,-0x24(%ebp)
  80674f:	89 7d e4             	mov    %edi,-0x1c(%ebp)
  806752:	89 df                	mov    %ebx,%edi
  806754:	eb 2e                	jmp    806784 <ip_input+0xf8>
    pbuf_free(p);
  806756:	83 ec 0c             	sub    $0xc,%esp
  806759:	ff 75 08             	pushl  0x8(%ebp)
  80675c:	e8 c7 e1 ff ff       	call   804928 <pbuf_free>
    return ERR_OK;
  806761:	83 c4 10             	add    $0x10,%esp
  806764:	e9 5a ff ff ff       	jmp    8066c3 <ip_input+0x37>
      if (first) {
  806769:	85 f6                	test   %esi,%esi
  80676b:	74 51                	je     8067be <ip_input+0x132>
        netif = netif_list;
  80676d:	8b 1d 34 b2 b3 00    	mov    0xb3b234,%ebx
      if (netif == inp) {
  806773:	39 df                	cmp    %ebx,%edi
  806775:	74 4b                	je     8067c2 <ip_input+0x136>
  806777:	be 00 00 00 00       	mov    $0x0,%esi
    } while(netif != NULL);
  80677c:	85 db                	test   %ebx,%ebx
  80677e:	0f 84 1b 01 00 00    	je     80689f <ip_input+0x213>
      if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr)))) {
  806784:	83 ec 0c             	sub    $0xc,%esp
  806787:	53                   	push   %ebx
  806788:	e8 b5 e0 ff ff       	call   804842 <netif_is_up>
  80678d:	83 c4 10             	add    $0x10,%esp
  806790:	84 c0                	test   %al,%al
  806792:	74 d5                	je     806769 <ip_input+0xdd>
  806794:	8b 43 04             	mov    0x4(%ebx),%eax
  806797:	85 c0                	test   %eax,%eax
  806799:	74 ce                	je     806769 <ip_input+0xdd>
        if (ip_addr_cmp(&(iphdr->dest), &(netif->ip_addr)) ||
  80679b:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  80679e:	3b 41 10             	cmp    0x10(%ecx),%eax
  8067a1:	74 4a                	je     8067ed <ip_input+0x161>
            ip_addr_isbroadcast(&(iphdr->dest), netif)) {
  8067a3:	83 ec 08             	sub    $0x8,%esp
  8067a6:	53                   	push   %ebx
  8067a7:	ff 75 dc             	pushl  -0x24(%ebp)
  8067aa:	e8 35 fe ff ff       	call   8065e4 <ip_addr_isbroadcast>
        if (ip_addr_cmp(&(iphdr->dest), &(netif->ip_addr)) ||
  8067af:	83 c4 10             	add    $0x10,%esp
  8067b2:	84 c0                	test   %al,%al
  8067b4:	74 b3                	je     806769 <ip_input+0xdd>
  8067b6:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  8067b9:	e9 fc 00 00 00       	jmp    8068ba <ip_input+0x22e>
        netif = netif->next;
  8067be:	8b 1b                	mov    (%ebx),%ebx
  8067c0:	eb b1                	jmp    806773 <ip_input+0xe7>
        netif = netif->next;
  8067c2:	8b 1b                	mov    (%ebx),%ebx
  8067c4:	eb b1                	jmp    806777 <ip_input+0xeb>
      if (ntohs(((struct udp_hdr *)((u8_t *)iphdr + iphdr_hlen))->dest) == DHCP_CLIENT_PORT) {
  8067c6:	83 ec 0c             	sub    $0xc,%esp
  8067c9:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
  8067cd:	0f b7 44 07 02       	movzwl 0x2(%edi,%eax,1),%eax
  8067d2:	50                   	push   %eax
  8067d3:	e8 99 10 00 00       	call   807871 <ntohs>
  8067d8:	83 c4 10             	add    $0x10,%esp
  8067db:	66 83 f8 44          	cmp    $0x44,%ax
  8067df:	0f 85 d5 00 00 00    	jne    8068ba <ip_input+0x22e>
        netif = inp;
  8067e5:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  8067e8:	e9 10 01 00 00       	jmp    8068fd <ip_input+0x271>
  8067ed:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  8067f0:	e9 c5 00 00 00       	jmp    8068ba <ip_input+0x22e>
      pbuf_free(p);
  8067f5:	83 ec 0c             	sub    $0xc,%esp
  8067f8:	ff 75 08             	pushl  0x8(%ebp)
  8067fb:	e8 28 e1 ff ff       	call   804928 <pbuf_free>
      return ERR_OK;
  806800:	83 c4 10             	add    $0x10,%esp
  806803:	e9 bb fe ff ff       	jmp    8066c3 <ip_input+0x37>
    pbuf_free(p);
  806808:	83 ec 0c             	sub    $0xc,%esp
  80680b:	ff 75 08             	pushl  0x8(%ebp)
  80680e:	e8 15 e1 ff ff       	call   804928 <pbuf_free>
    return ERR_OK;
  806813:	83 c4 10             	add    $0x10,%esp
  806816:	e9 a8 fe ff ff       	jmp    8066c3 <ip_input+0x37>
      udp_input(p, inp);
  80681b:	83 ec 08             	sub    $0x8,%esp
  80681e:	ff 75 0c             	pushl  0xc(%ebp)
  806821:	ff 75 08             	pushl  0x8(%ebp)
  806824:	e8 ba 22 00 00       	call   808ae3 <udp_input>
      break;
  806829:	83 c4 10             	add    $0x10,%esp
  80682c:	e9 92 fe ff ff       	jmp    8066c3 <ip_input+0x37>
      tcp_input(p, inp);
  806831:	83 ec 08             	sub    $0x8,%esp
  806834:	ff 75 0c             	pushl  0xc(%ebp)
  806837:	ff 75 08             	pushl  0x8(%ebp)
  80683a:	e8 e8 6a 00 00       	call   80d327 <tcp_input>
      break;
  80683f:	83 c4 10             	add    $0x10,%esp
  806842:	e9 7c fe ff ff       	jmp    8066c3 <ip_input+0x37>
      icmp_input(p, inp);
  806847:	83 ec 08             	sub    $0x8,%esp
  80684a:	ff 75 0c             	pushl  0xc(%ebp)
  80684d:	ff 75 08             	pushl  0x8(%ebp)
  806850:	e8 9e 7a 00 00       	call   80e2f3 <icmp_input>
      break;
  806855:	83 c4 10             	add    $0x10,%esp
  806858:	e9 66 fe ff ff       	jmp    8066c3 <ip_input+0x37>
          !ip_addr_ismulticast(&(iphdr->dest))) {
  80685d:	8b 5f 10             	mov    0x10(%edi),%ebx
  806860:	83 ec 0c             	sub    $0xc,%esp
  806863:	68 00 00 00 f0       	push   $0xf0000000
  806868:	e8 42 12 00 00       	call   807aaf <ntohl>
  80686d:	21 c3                	and    %eax,%ebx
  80686f:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  806876:	e8 34 12 00 00       	call   807aaf <ntohl>
      if (!ip_addr_isbroadcast(&(iphdr->dest), inp) &&
  80687b:	83 c4 10             	add    $0x10,%esp
  80687e:	39 c3                	cmp    %eax,%ebx
  806880:	0f 84 19 01 00 00    	je     80699f <ip_input+0x313>
        p->payload = iphdr;
  806886:	8b 45 08             	mov    0x8(%ebp),%eax
  806889:	89 78 04             	mov    %edi,0x4(%eax)
        icmp_dest_unreach(p, ICMP_DUR_PROTO);
  80688c:	83 ec 08             	sub    $0x8,%esp
  80688f:	6a 02                	push   $0x2
  806891:	50                   	push   %eax
  806892:	e8 7a 7d 00 00       	call   80e611 <icmp_dest_unreach>
  806897:	83 c4 10             	add    $0x10,%esp
  80689a:	e9 00 01 00 00       	jmp    80699f <ip_input+0x313>
  80689f:	8b 7d e4             	mov    -0x1c(%ebp),%edi
    if (IPH_PROTO(iphdr) == IP_PROTO_UDP) {
  8068a2:	83 ec 0c             	sub    $0xc,%esp
  8068a5:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  8068a9:	50                   	push   %eax
  8068aa:	e8 c2 0f 00 00       	call   807871 <ntohs>
  8068af:	83 c4 10             	add    $0x10,%esp
  8068b2:	3c 11                	cmp    $0x11,%al
  8068b4:	0f 84 0c ff ff ff    	je     8067c6 <ip_input+0x13a>
  {  if ((ip_addr_isbroadcast(&(iphdr->src), inp)) ||
  8068ba:	83 ec 08             	sub    $0x8,%esp
  8068bd:	ff 75 0c             	pushl  0xc(%ebp)
  8068c0:	8d 47 0c             	lea    0xc(%edi),%eax
  8068c3:	50                   	push   %eax
  8068c4:	e8 1b fd ff ff       	call   8065e4 <ip_addr_isbroadcast>
  8068c9:	83 c4 10             	add    $0x10,%esp
  8068cc:	84 c0                	test   %al,%al
  8068ce:	0f 85 21 ff ff ff    	jne    8067f5 <ip_input+0x169>
         (ip_addr_ismulticast(&(iphdr->src)))) {
  8068d4:	8b 77 0c             	mov    0xc(%edi),%esi
  8068d7:	83 ec 0c             	sub    $0xc,%esp
  8068da:	68 00 00 00 f0       	push   $0xf0000000
  8068df:	e8 cb 11 00 00       	call   807aaf <ntohl>
  8068e4:	21 c6                	and    %eax,%esi
  8068e6:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  8068ed:	e8 bd 11 00 00       	call   807aaf <ntohl>
  {  if ((ip_addr_isbroadcast(&(iphdr->src), inp)) ||
  8068f2:	83 c4 10             	add    $0x10,%esp
  8068f5:	39 c6                	cmp    %eax,%esi
  8068f7:	0f 84 f8 fe ff ff    	je     8067f5 <ip_input+0x169>
  if (netif == NULL) {
  8068fd:	85 db                	test   %ebx,%ebx
  8068ff:	0f 84 03 ff ff ff    	je     806808 <ip_input+0x17c>
  if ((IPH_OFFSET(iphdr) & htons(IP_OFFMASK | IP_MF)) != 0) {
  806905:	0f b7 5f 06          	movzwl 0x6(%edi),%ebx
  806909:	83 ec 0c             	sub    $0xc,%esp
  80690c:	68 ff 3f 00 00       	push   $0x3fff
  806911:	e8 4a 0f 00 00       	call   807860 <htons>
  806916:	83 c4 10             	add    $0x10,%esp
  806919:	66 85 c3             	test   %ax,%bx
  80691c:	74 1c                	je     80693a <ip_input+0x2ae>
    p = ip_reass(p);
  80691e:	83 ec 0c             	sub    $0xc,%esp
  806921:	ff 75 08             	pushl  0x8(%ebp)
  806924:	e8 8f 04 00 00       	call   806db8 <ip_reass>
  806929:	89 45 08             	mov    %eax,0x8(%ebp)
    if (p == NULL) {
  80692c:	83 c4 10             	add    $0x10,%esp
  80692f:	85 c0                	test   %eax,%eax
  806931:	0f 84 8c fd ff ff    	je     8066c3 <ip_input+0x37>
    iphdr = p->payload;
  806937:	8b 78 04             	mov    0x4(%eax),%edi
  if (raw_input(p, inp) == 0)
  80693a:	83 ec 08             	sub    $0x8,%esp
  80693d:	ff 75 0c             	pushl  0xc(%ebp)
  806940:	ff 75 08             	pushl  0x8(%ebp)
  806943:	e8 e2 76 00 00       	call   80e02a <raw_input>
  806948:	83 c4 10             	add    $0x10,%esp
  80694b:	84 c0                	test   %al,%al
  80694d:	0f 85 70 fd ff ff    	jne    8066c3 <ip_input+0x37>
    switch (IPH_PROTO(iphdr)) {
  806953:	83 ec 0c             	sub    $0xc,%esp
  806956:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  80695a:	50                   	push   %eax
  80695b:	e8 11 0f 00 00       	call   807871 <ntohs>
  806960:	89 c2                	mov    %eax,%edx
  806962:	0f b6 c0             	movzbl %al,%eax
  806965:	83 c4 10             	add    $0x10,%esp
  806968:	80 fa 06             	cmp    $0x6,%dl
  80696b:	0f 84 c0 fe ff ff    	je     806831 <ip_input+0x1a5>
  806971:	66 83 f8 11          	cmp    $0x11,%ax
  806975:	0f 84 a0 fe ff ff    	je     80681b <ip_input+0x18f>
  80697b:	66 83 f8 01          	cmp    $0x1,%ax
  80697f:	0f 84 c2 fe ff ff    	je     806847 <ip_input+0x1bb>
      if (!ip_addr_isbroadcast(&(iphdr->dest), inp) &&
  806985:	83 ec 08             	sub    $0x8,%esp
  806988:	ff 75 0c             	pushl  0xc(%ebp)
  80698b:	8d 47 10             	lea    0x10(%edi),%eax
  80698e:	50                   	push   %eax
  80698f:	e8 50 fc ff ff       	call   8065e4 <ip_addr_isbroadcast>
  806994:	83 c4 10             	add    $0x10,%esp
  806997:	84 c0                	test   %al,%al
  806999:	0f 84 be fe ff ff    	je     80685d <ip_input+0x1d1>
      pbuf_free(p);
  80699f:	83 ec 0c             	sub    $0xc,%esp
  8069a2:	ff 75 08             	pushl  0x8(%ebp)
  8069a5:	e8 7e df ff ff       	call   804928 <pbuf_free>
  8069aa:	83 c4 10             	add    $0x10,%esp
  8069ad:	e9 11 fd ff ff       	jmp    8066c3 <ip_input+0x37>

008069b2 <ip_output_if>:
 */
err_t
ip_output_if(struct pbuf *p, struct ip_addr *src, struct ip_addr *dest,
             u8_t ttl, u8_t tos,
             u8_t proto, struct netif *netif)
{
  8069b2:	f3 0f 1e fb          	endbr32 
  8069b6:	55                   	push   %ebp
  8069b7:	89 e5                	mov    %esp,%ebp
  8069b9:	57                   	push   %edi
  8069ba:	56                   	push   %esi
  8069bb:	53                   	push   %ebx
  8069bc:	83 ec 1c             	sub    $0x1c,%esp
  8069bf:	8b 75 08             	mov    0x8(%ebp),%esi
  8069c2:	8b 7d 14             	mov    0x14(%ebp),%edi
  8069c5:	8b 45 18             	mov    0x18(%ebp),%eax
  8069c8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  8069cb:	8b 45 1c             	mov    0x1c(%ebp),%eax
  8069ce:	89 45 e0             	mov    %eax,-0x20(%ebp)
  static u16_t ip_id = 0;

  snmp_inc_ipoutrequests();

  /* Should the IP header be generated or is it already included in p? */
  if (dest != IP_HDRINCL) {
  8069d1:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  8069d5:	0f 84 37 01 00 00    	je     806b12 <ip_output_if+0x160>
    /* generate IP header */
    if (pbuf_header(p, IP_HLEN)) {
  8069db:	83 ec 08             	sub    $0x8,%esp
  8069de:	6a 14                	push   $0x14
  8069e0:	56                   	push   %esi
  8069e1:	e8 6f de ff ff       	call   804855 <pbuf_header>
  8069e6:	83 c4 10             	add    $0x10,%esp
  8069e9:	84 c0                	test   %al,%al
  8069eb:	0f 85 40 01 00 00    	jne    806b31 <ip_output_if+0x17f>
      IP_STATS_INC(ip.err);
      snmp_inc_ipoutdiscards();
      return ERR_BUF;
    }

    iphdr = p->payload;
  8069f1:	8b 5e 04             	mov    0x4(%esi),%ebx
    LWIP_ASSERT("check that first pbuf can hold struct ip_hdr",
  8069f4:	66 83 7e 0a 13       	cmpw   $0x13,0xa(%esi)
  8069f9:	0f 86 f7 00 00 00    	jbe    806af6 <ip_output_if+0x144>
               (p->len >= sizeof(struct ip_hdr)));

    IPH_TTL_SET(iphdr, ttl);
  8069ff:	83 ec 0c             	sub    $0xc,%esp
  806a02:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  806a06:	50                   	push   %eax
  806a07:	e8 65 0e 00 00       	call   807871 <ntohs>
  806a0c:	0f b6 c0             	movzbl %al,%eax
  806a0f:	c1 e7 08             	shl    $0x8,%edi
  806a12:	09 c7                	or     %eax,%edi
  806a14:	0f b7 ff             	movzwl %di,%edi
  806a17:	89 3c 24             	mov    %edi,(%esp)
  806a1a:	e8 41 0e 00 00       	call   807860 <htons>
  806a1f:	66 89 43 08          	mov    %ax,0x8(%ebx)
    IPH_PROTO_SET(iphdr, proto);
  806a23:	0f b7 c0             	movzwl %ax,%eax
  806a26:	89 04 24             	mov    %eax,(%esp)
  806a29:	e8 43 0e 00 00       	call   807871 <ntohs>
  806a2e:	89 c2                	mov    %eax,%edx
  806a30:	81 e2 00 ff 00 00    	and    $0xff00,%edx
  806a36:	0f b6 45 e0          	movzbl -0x20(%ebp),%eax
  806a3a:	09 d0                	or     %edx,%eax
  806a3c:	0f b7 c0             	movzwl %ax,%eax
  806a3f:	89 04 24             	mov    %eax,(%esp)
  806a42:	e8 19 0e 00 00       	call   807860 <htons>
  806a47:	66 89 43 08          	mov    %ax,0x8(%ebx)

    ip_addr_set(&(iphdr->dest), dest);
  806a4b:	8b 45 10             	mov    0x10(%ebp),%eax
  806a4e:	8b 00                	mov    (%eax),%eax
  806a50:	89 43 10             	mov    %eax,0x10(%ebx)

    IPH_VHLTOS_SET(iphdr, 4, IP_HLEN / 4, tos);
  806a53:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
  806a57:	80 cc 45             	or     $0x45,%ah
  806a5a:	89 04 24             	mov    %eax,(%esp)
  806a5d:	e8 fe 0d 00 00       	call   807860 <htons>
  806a62:	66 89 03             	mov    %ax,(%ebx)
    IPH_LEN_SET(iphdr, htons(p->tot_len));
  806a65:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  806a69:	89 04 24             	mov    %eax,(%esp)
  806a6c:	e8 ef 0d 00 00       	call   807860 <htons>
  806a71:	66 89 43 02          	mov    %ax,0x2(%ebx)
    IPH_OFFSET_SET(iphdr, 0);
  806a75:	66 c7 43 06 00 00    	movw   $0x0,0x6(%ebx)
    IPH_ID_SET(iphdr, htons(ip_id));
  806a7b:	0f b7 05 fa 43 b3 00 	movzwl 0xb343fa,%eax
  806a82:	89 04 24             	mov    %eax,(%esp)
  806a85:	e8 d6 0d 00 00       	call   807860 <htons>
  806a8a:	66 89 43 04          	mov    %ax,0x4(%ebx)
    ++ip_id;
  806a8e:	66 83 05 fa 43 b3 00 	addw   $0x1,0xb343fa
  806a95:	01 

    if (ip_addr_isany(src)) {
  806a96:	83 c4 10             	add    $0x10,%esp
  806a99:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  806a9d:	74 09                	je     806aa8 <ip_output_if+0xf6>
  806a9f:	8b 45 0c             	mov    0xc(%ebp),%eax
  806aa2:	8b 00                	mov    (%eax),%eax
  806aa4:	85 c0                	test   %eax,%eax
  806aa6:	75 65                	jne    806b0d <ip_output_if+0x15b>
      ip_addr_set(&(iphdr->src), &(netif->ip_addr));
  806aa8:	8b 45 20             	mov    0x20(%ebp),%eax
  806aab:	8b 40 04             	mov    0x4(%eax),%eax
  806aae:	89 43 0c             	mov    %eax,0xc(%ebx)
    } else {
      ip_addr_set(&(iphdr->src), src);
    }

    IPH_CHKSUM_SET(iphdr, 0);
  806ab1:	66 c7 43 0a 00 00    	movw   $0x0,0xa(%ebx)
#if CHECKSUM_GEN_IP
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
  806ab7:	83 ec 08             	sub    $0x8,%esp
  806aba:	6a 14                	push   $0x14
  806abc:	53                   	push   %ebx
  806abd:	e8 64 0c 00 00       	call   807726 <inet_chksum>
  806ac2:	66 89 43 0a          	mov    %ax,0xa(%ebx)
  806ac6:	83 c4 10             	add    $0x10,%esp
    dest = &(iphdr->dest);
  }

#if IP_FRAG
  /* don't fragment if interface has mtu set to 0 [loopif] */
  if (netif->mtu && (p->tot_len > netif->mtu))
  806ac9:	8b 45 20             	mov    0x20(%ebp),%eax
  806acc:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
  806ad0:	66 85 c0             	test   %ax,%ax
  806ad3:	74 06                	je     806adb <ip_output_if+0x129>
  806ad5:	66 3b 46 08          	cmp    0x8(%esi),%ax
  806ad9:	72 42                	jb     806b1d <ip_output_if+0x16b>
  } else
#endif /* (LWIP_NETIF_LOOPBACK || LWIP_HAVE_LOOPIF) */
  {
    LWIP_DEBUGF(IP_DEBUG, ("netif->output()"));

    return netif->output(netif, p, dest);
  806adb:	83 ec 04             	sub    $0x4,%esp
  806ade:	ff 75 10             	pushl  0x10(%ebp)
  806ae1:	56                   	push   %esi
  806ae2:	ff 75 20             	pushl  0x20(%ebp)
  806ae5:	8b 45 20             	mov    0x20(%ebp),%eax
  806ae8:	ff 50 14             	call   *0x14(%eax)
  806aeb:	83 c4 10             	add    $0x10,%esp
  }
}
  806aee:	8d 65 f4             	lea    -0xc(%ebp),%esp
  806af1:	5b                   	pop    %ebx
  806af2:	5e                   	pop    %esi
  806af3:	5f                   	pop    %edi
  806af4:	5d                   	pop    %ebp
  806af5:	c3                   	ret    
    LWIP_ASSERT("check that first pbuf can hold struct ip_hdr",
  806af6:	83 ec 04             	sub    $0x4,%esp
  806af9:	68 ac 22 81 00       	push   $0x8122ac
  806afe:	68 ed 01 00 00       	push   $0x1ed
  806b03:	68 d9 22 81 00       	push   $0x8122d9
  806b08:	e8 3a 7d 00 00       	call   80e847 <_panic>
      ip_addr_set(&(iphdr->src), src);
  806b0d:	89 43 0c             	mov    %eax,0xc(%ebx)
  806b10:	eb 9f                	jmp    806ab1 <ip_output_if+0xff>
    dest = &(iphdr->dest);
  806b12:	8b 46 04             	mov    0x4(%esi),%eax
  806b15:	83 c0 10             	add    $0x10,%eax
  806b18:	89 45 10             	mov    %eax,0x10(%ebp)
  806b1b:	eb ac                	jmp    806ac9 <ip_output_if+0x117>
    return ip_frag(p,netif,dest);
  806b1d:	83 ec 04             	sub    $0x4,%esp
  806b20:	ff 75 10             	pushl  0x10(%ebp)
  806b23:	ff 75 20             	pushl  0x20(%ebp)
  806b26:	56                   	push   %esi
  806b27:	e8 5f 07 00 00       	call   80728b <ip_frag>
  806b2c:	83 c4 10             	add    $0x10,%esp
  806b2f:	eb bd                	jmp    806aee <ip_output_if+0x13c>
      return ERR_BUF;
  806b31:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  806b36:	eb b6                	jmp    806aee <ip_output_if+0x13c>

00806b38 <ip_output>:
 *         see ip_output_if() for more return values
 */
err_t
ip_output(struct pbuf *p, struct ip_addr *src, struct ip_addr *dest,
          u8_t ttl, u8_t tos, u8_t proto)
{
  806b38:	f3 0f 1e fb          	endbr32 
  806b3c:	55                   	push   %ebp
  806b3d:	89 e5                	mov    %esp,%ebp
  806b3f:	57                   	push   %edi
  806b40:	56                   	push   %esi
  806b41:	53                   	push   %ebx
  806b42:	83 ec 18             	sub    $0x18,%esp
  806b45:	8b 5d 14             	mov    0x14(%ebp),%ebx
  806b48:	8b 75 18             	mov    0x18(%ebp),%esi
  806b4b:	8b 7d 1c             	mov    0x1c(%ebp),%edi
  struct netif *netif;

  if ((netif = ip_route(dest)) == NULL) {
  806b4e:	ff 75 10             	pushl  0x10(%ebp)
  806b51:	e8 d5 fa ff ff       	call   80662b <ip_route>
  806b56:	83 c4 10             	add    $0x10,%esp
  806b59:	85 c0                	test   %eax,%eax
  806b5b:	74 2d                	je     806b8a <ip_output+0x52>
    return ERR_RTE;
  }

  return ip_output_if(p, src, dest, ttl, tos, proto, netif);
  806b5d:	83 ec 04             	sub    $0x4,%esp
  806b60:	50                   	push   %eax
  806b61:	89 f8                	mov    %edi,%eax
  806b63:	0f b6 f8             	movzbl %al,%edi
  806b66:	57                   	push   %edi
  806b67:	89 f0                	mov    %esi,%eax
  806b69:	0f b6 f0             	movzbl %al,%esi
  806b6c:	56                   	push   %esi
  806b6d:	0f b6 db             	movzbl %bl,%ebx
  806b70:	53                   	push   %ebx
  806b71:	ff 75 10             	pushl  0x10(%ebp)
  806b74:	ff 75 0c             	pushl  0xc(%ebp)
  806b77:	ff 75 08             	pushl  0x8(%ebp)
  806b7a:	e8 33 fe ff ff       	call   8069b2 <ip_output_if>
  806b7f:	83 c4 20             	add    $0x20,%esp
}
  806b82:	8d 65 f4             	lea    -0xc(%ebp),%esp
  806b85:	5b                   	pop    %ebx
  806b86:	5e                   	pop    %esi
  806b87:	5f                   	pop    %edi
  806b88:	5d                   	pop    %ebp
  806b89:	c3                   	ret    
    return ERR_RTE;
  806b8a:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  806b8f:	eb f1                	jmp    806b82 <ip_output+0x4a>

00806b91 <ip_reass_dequeue_datagram>:
 * Dequeues a datagram from the datagram queue. Doesn't deallocate the pbufs.
 * @param ipr points to the queue entry to dequeue
 */
static void
ip_reass_dequeue_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
  806b91:	55                   	push   %ebp
  806b92:	89 e5                	mov    %esp,%ebp
  806b94:	83 ec 08             	sub    $0x8,%esp
  
  /* dequeue the reass struct  */
  if (reassdatagrams == ipr) {
  806b97:	39 05 e0 49 b3 00    	cmp    %eax,0xb349e0
  806b9d:	74 18                	je     806bb7 <ip_reass_dequeue_datagram+0x26>
    /* it was the first in the list */
    reassdatagrams = ipr->next;
  } else {
    /* it wasn't the first, so it must have a valid 'prev' */
    LWIP_ASSERT("sanity check linked list", prev != NULL);
  806b9f:	85 d2                	test   %edx,%edx
  806ba1:	74 1e                	je     806bc1 <ip_reass_dequeue_datagram+0x30>
    prev->next = ipr->next;
  806ba3:	8b 08                	mov    (%eax),%ecx
  806ba5:	89 0a                	mov    %ecx,(%edx)
  }

  /* now we can free the ip_reass struct */
  memp_free(MEMP_REASSDATA, ipr);
  806ba7:	83 ec 08             	sub    $0x8,%esp
  806baa:	50                   	push   %eax
  806bab:	6a 05                	push   $0x5
  806bad:	e8 f3 d9 ff ff       	call   8045a5 <memp_free>
}
  806bb2:	83 c4 10             	add    $0x10,%esp
  806bb5:	c9                   	leave  
  806bb6:	c3                   	ret    
    reassdatagrams = ipr->next;
  806bb7:	8b 10                	mov    (%eax),%edx
  806bb9:	89 15 e0 49 b3 00    	mov    %edx,0xb349e0
  806bbf:	eb e6                	jmp    806ba7 <ip_reass_dequeue_datagram+0x16>
    LWIP_ASSERT("sanity check linked list", prev != NULL);
  806bc1:	83 ec 04             	sub    $0x4,%esp
  806bc4:	68 f1 22 81 00       	push   $0x8122f1
  806bc9:	68 29 01 00 00       	push   $0x129
  806bce:	68 0a 23 81 00       	push   $0x81230a
  806bd3:	e8 6f 7c 00 00       	call   80e847 <_panic>

00806bd8 <ip_reass_free_complete_datagram>:
{
  806bd8:	55                   	push   %ebp
  806bd9:	89 e5                	mov    %esp,%ebp
  806bdb:	57                   	push   %edi
  806bdc:	56                   	push   %esi
  806bdd:	53                   	push   %ebx
  806bde:	83 ec 1c             	sub    $0x1c,%esp
  806be1:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  806be4:	89 55 e0             	mov    %edx,-0x20(%ebp)
  LWIP_ASSERT("prev != ipr", prev != ipr);
  806be7:	39 c2                	cmp    %eax,%edx
  806be9:	74 2e                	je     806c19 <ip_reass_free_complete_datagram+0x41>
  if (prev != NULL) {
  806beb:	8b 45 e0             	mov    -0x20(%ebp),%eax
  806bee:	85 c0                	test   %eax,%eax
  806bf0:	74 07                	je     806bf9 <ip_reass_free_complete_datagram+0x21>
    LWIP_ASSERT("prev->next == ipr", prev->next == ipr);
  806bf2:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  806bf5:	39 08                	cmp    %ecx,(%eax)
  806bf7:	75 37                	jne    806c30 <ip_reass_free_complete_datagram+0x58>
  iprh = (struct ip_reass_helper *)ipr->p->payload;
  806bf9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  806bfc:	8b 58 04             	mov    0x4(%eax),%ebx
  806bff:	8b 43 04             	mov    0x4(%ebx),%eax
  int pbufs_freed = 0;
  806c02:	be 00 00 00 00       	mov    $0x0,%esi
  if (iprh->start == 0) {
  806c07:	66 83 78 04 00       	cmpw   $0x0,0x4(%eax)
  806c0c:	74 39                	je     806c47 <ip_reass_free_complete_datagram+0x6f>
  p = ipr->p;
  806c0e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  806c11:	8b 58 04             	mov    0x4(%eax),%ebx
  while (p != NULL) {
  806c14:	e9 8a 00 00 00       	jmp    806ca3 <ip_reass_free_complete_datagram+0xcb>
  LWIP_ASSERT("prev != ipr", prev != ipr);
  806c19:	83 ec 04             	sub    $0x4,%esp
  806c1c:	68 27 23 81 00       	push   $0x812327
  806c21:	68 99 00 00 00       	push   $0x99
  806c26:	68 0a 23 81 00       	push   $0x81230a
  806c2b:	e8 17 7c 00 00       	call   80e847 <_panic>
    LWIP_ASSERT("prev->next == ipr", prev->next == ipr);
  806c30:	83 ec 04             	sub    $0x4,%esp
  806c33:	68 33 23 81 00       	push   $0x812333
  806c38:	68 9b 00 00 00       	push   $0x9b
  806c3d:	68 0a 23 81 00       	push   $0x81230a
  806c42:	e8 00 7c 00 00       	call   80e847 <_panic>
    ipr->p = iprh->next_pbuf;
  806c47:	8b 00                	mov    (%eax),%eax
  806c49:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  806c4c:	89 42 04             	mov    %eax,0x4(%edx)
    SMEMCPY(p->payload, &ipr->iphdr, IP_HLEN);
  806c4f:	83 ec 04             	sub    $0x4,%esp
  806c52:	6a 14                	push   $0x14
  806c54:	8d 42 08             	lea    0x8(%edx),%eax
  806c57:	50                   	push   %eax
  806c58:	ff 73 04             	pushl  0x4(%ebx)
  806c5b:	e8 f4 84 00 00       	call   80f154 <memcpy>
    icmp_time_exceeded(p, ICMP_TE_FRAG);
  806c60:	83 c4 08             	add    $0x8,%esp
  806c63:	6a 01                	push   $0x1
  806c65:	53                   	push   %ebx
  806c66:	e8 8d 7a 00 00       	call   80e6f8 <icmp_time_exceeded>
    pbufs_freed += pbuf_clen(p);
  806c6b:	89 1c 24             	mov    %ebx,(%esp)
  806c6e:	e8 f4 e0 ff ff       	call   804d67 <pbuf_clen>
  806c73:	0f b6 f0             	movzbl %al,%esi
    pbuf_free(p);
  806c76:	89 1c 24             	mov    %ebx,(%esp)
  806c79:	e8 aa dc ff ff       	call   804928 <pbuf_free>
  806c7e:	83 c4 10             	add    $0x10,%esp
  806c81:	eb 8b                	jmp    806c0e <ip_reass_free_complete_datagram+0x36>
    iprh = (struct ip_reass_helper *)p->payload;
  806c83:	8b 43 04             	mov    0x4(%ebx),%eax
    p = iprh->next_pbuf;
  806c86:	8b 38                	mov    (%eax),%edi
    pbufs_freed += pbuf_clen(pcur);
  806c88:	83 ec 0c             	sub    $0xc,%esp
  806c8b:	53                   	push   %ebx
  806c8c:	e8 d6 e0 ff ff       	call   804d67 <pbuf_clen>
  806c91:	0f b6 c0             	movzbl %al,%eax
  806c94:	01 c6                	add    %eax,%esi
    pbuf_free(pcur);    
  806c96:	89 1c 24             	mov    %ebx,(%esp)
  806c99:	e8 8a dc ff ff       	call   804928 <pbuf_free>
  806c9e:	83 c4 10             	add    $0x10,%esp
    p = iprh->next_pbuf;
  806ca1:	89 fb                	mov    %edi,%ebx
  while (p != NULL) {
  806ca3:	85 db                	test   %ebx,%ebx
  806ca5:	75 dc                	jne    806c83 <ip_reass_free_complete_datagram+0xab>
  ip_reass_dequeue_datagram(ipr, prev);
  806ca7:	8b 55 e0             	mov    -0x20(%ebp),%edx
  806caa:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  806cad:	e8 df fe ff ff       	call   806b91 <ip_reass_dequeue_datagram>
  LWIP_ASSERT("ip_reass_pbufcount >= clen", ip_reass_pbufcount >= pbufs_freed);
  806cb2:	0f b7 05 dc 49 b3 00 	movzwl 0xb349dc,%eax
  806cb9:	0f b7 d0             	movzwl %ax,%edx
  806cbc:	39 f2                	cmp    %esi,%edx
  806cbe:	7c 12                	jl     806cd2 <ip_reass_free_complete_datagram+0xfa>
  ip_reass_pbufcount -= pbufs_freed;
  806cc0:	29 f0                	sub    %esi,%eax
  806cc2:	66 a3 dc 49 b3 00    	mov    %ax,0xb349dc
}
  806cc8:	89 f0                	mov    %esi,%eax
  806cca:	8d 65 f4             	lea    -0xc(%ebp),%esp
  806ccd:	5b                   	pop    %ebx
  806cce:	5e                   	pop    %esi
  806ccf:	5f                   	pop    %edi
  806cd0:	5d                   	pop    %ebp
  806cd1:	c3                   	ret    
  LWIP_ASSERT("ip_reass_pbufcount >= clen", ip_reass_pbufcount >= pbufs_freed);
  806cd2:	83 ec 04             	sub    $0x4,%esp
  806cd5:	68 45 23 81 00       	push   $0x812345
  806cda:	68 bc 00 00 00       	push   $0xbc
  806cdf:	68 0a 23 81 00       	push   $0x81230a
  806ce4:	e8 5e 7b 00 00       	call   80e847 <_panic>

00806ce9 <ip_reass_remove_oldest_datagram>:
{
  806ce9:	55                   	push   %ebp
  806cea:	89 e5                	mov    %esp,%ebp
  806cec:	57                   	push   %edi
  806ced:	56                   	push   %esi
  806cee:	53                   	push   %ebx
  806cef:	83 ec 1c             	sub    $0x1c,%esp
  806cf2:	89 c6                	mov    %eax,%esi
  806cf4:	89 55 e0             	mov    %edx,-0x20(%ebp)
  int pbufs_freed = 0, pbufs_freed_current;
  806cf7:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  806cfe:	eb 5b                	jmp    806d5b <ip_reass_remove_oldest_datagram+0x72>
        other_datagrams++;
  806d00:	83 c3 01             	add    $0x1,%ebx
        if (oldest == NULL) {
  806d03:	85 c9                	test   %ecx,%ecx
  806d05:	74 33                	je     806d3a <ip_reass_remove_oldest_datagram+0x51>
          oldest = r;
  806d07:	0f b6 51 1f          	movzbl 0x1f(%ecx),%edx
  806d0b:	38 50 1f             	cmp    %dl,0x1f(%eax)
  806d0e:	0f 46 c8             	cmovbe %eax,%ecx
      if (r->next != NULL) {
  806d11:	8b 10                	mov    (%eax),%edx
        prev = r;
  806d13:	85 d2                	test   %edx,%edx
  806d15:	0f 45 f8             	cmovne %eax,%edi
  806d18:	89 d0                	mov    %edx,%eax
    while (r != NULL) {
  806d1a:	85 c0                	test   %eax,%eax
  806d1c:	74 20                	je     806d3e <ip_reass_remove_oldest_datagram+0x55>
      if (!IP_ADDRESSES_AND_ID_MATCH(&r->iphdr, fraghdr)) {
  806d1e:	8b 56 0c             	mov    0xc(%esi),%edx
  806d21:	39 50 14             	cmp    %edx,0x14(%eax)
  806d24:	75 da                	jne    806d00 <ip_reass_remove_oldest_datagram+0x17>
  806d26:	8b 56 10             	mov    0x10(%esi),%edx
  806d29:	39 50 18             	cmp    %edx,0x18(%eax)
  806d2c:	75 d2                	jne    806d00 <ip_reass_remove_oldest_datagram+0x17>
  806d2e:	0f b7 56 04          	movzwl 0x4(%esi),%edx
  806d32:	66 39 50 0c          	cmp    %dx,0xc(%eax)
  806d36:	75 c8                	jne    806d00 <ip_reass_remove_oldest_datagram+0x17>
  806d38:	eb d7                	jmp    806d11 <ip_reass_remove_oldest_datagram+0x28>
          oldest = r;
  806d3a:	89 c1                	mov    %eax,%ecx
  806d3c:	eb d3                	jmp    806d11 <ip_reass_remove_oldest_datagram+0x28>
    if (oldest != NULL) {
  806d3e:	85 c9                	test   %ecx,%ecx
  806d40:	74 0c                	je     806d4e <ip_reass_remove_oldest_datagram+0x65>
      pbufs_freed_current = ip_reass_free_complete_datagram(oldest, prev);
  806d42:	89 fa                	mov    %edi,%edx
  806d44:	89 c8                	mov    %ecx,%eax
  806d46:	e8 8d fe ff ff       	call   806bd8 <ip_reass_free_complete_datagram>
      pbufs_freed += pbufs_freed_current;
  806d4b:	01 45 e4             	add    %eax,-0x1c(%ebp)
  } while ((pbufs_freed < pbufs_needed) && (other_datagrams > 1));
  806d4e:	8b 7d e0             	mov    -0x20(%ebp),%edi
  806d51:	39 7d e4             	cmp    %edi,-0x1c(%ebp)
  806d54:	7d 1b                	jge    806d71 <ip_reass_remove_oldest_datagram+0x88>
  806d56:	83 fb 01             	cmp    $0x1,%ebx
  806d59:	7e 16                	jle    806d71 <ip_reass_remove_oldest_datagram+0x88>
    r = reassdatagrams;
  806d5b:	a1 e0 49 b3 00       	mov    0xb349e0,%eax
    other_datagrams = 0;
  806d60:	bb 00 00 00 00       	mov    $0x0,%ebx
    prev = NULL;
  806d65:	bf 00 00 00 00       	mov    $0x0,%edi
    oldest = NULL;
  806d6a:	b9 00 00 00 00       	mov    $0x0,%ecx
    while (r != NULL) {
  806d6f:	eb a9                	jmp    806d1a <ip_reass_remove_oldest_datagram+0x31>
}
  806d71:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  806d74:	83 c4 1c             	add    $0x1c,%esp
  806d77:	5b                   	pop    %ebx
  806d78:	5e                   	pop    %esi
  806d79:	5f                   	pop    %edi
  806d7a:	5d                   	pop    %ebp
  806d7b:	c3                   	ret    

00806d7c <ip_reass_tmr>:
{
  806d7c:	f3 0f 1e fb          	endbr32 
  806d80:	55                   	push   %ebp
  806d81:	89 e5                	mov    %esp,%ebp
  806d83:	56                   	push   %esi
  806d84:	53                   	push   %ebx
  r = reassdatagrams;
  806d85:	a1 e0 49 b3 00       	mov    0xb349e0,%eax
  struct ip_reassdata *r, *prev = NULL;
  806d8a:	bb 00 00 00 00       	mov    $0x0,%ebx
  while (r != NULL) {
  806d8f:	eb 0b                	jmp    806d9c <ip_reass_tmr+0x20>
      r = r->next;
  806d91:	8b 30                	mov    (%eax),%esi
      ip_reass_free_complete_datagram(tmp, prev);
  806d93:	89 da                	mov    %ebx,%edx
  806d95:	e8 3e fe ff ff       	call   806bd8 <ip_reass_free_complete_datagram>
      r = r->next;
  806d9a:	89 f0                	mov    %esi,%eax
  while (r != NULL) {
  806d9c:	85 c0                	test   %eax,%eax
  806d9e:	74 14                	je     806db4 <ip_reass_tmr+0x38>
    if (r->timer > 0) {
  806da0:	0f b6 50 1f          	movzbl 0x1f(%eax),%edx
  806da4:	84 d2                	test   %dl,%dl
  806da6:	74 e9                	je     806d91 <ip_reass_tmr+0x15>
      r->timer--;
  806da8:	83 ea 01             	sub    $0x1,%edx
  806dab:	88 50 1f             	mov    %dl,0x1f(%eax)
      prev = r;
  806dae:	89 c3                	mov    %eax,%ebx
      r = r->next;
  806db0:	8b 00                	mov    (%eax),%eax
  806db2:	eb e8                	jmp    806d9c <ip_reass_tmr+0x20>
}
  806db4:	5b                   	pop    %ebx
  806db5:	5e                   	pop    %esi
  806db6:	5d                   	pop    %ebp
  806db7:	c3                   	ret    

00806db8 <ip_reass>:
 * @param p points to a pbuf chain of the fragment
 * @return NULL if reassembly is incomplete, ? otherwise
 */
struct pbuf *
ip_reass(struct pbuf *p)
{
  806db8:	f3 0f 1e fb          	endbr32 
  806dbc:	55                   	push   %ebp
  806dbd:	89 e5                	mov    %esp,%ebp
  806dbf:	57                   	push   %edi
  806dc0:	56                   	push   %esi
  806dc1:	53                   	push   %ebx
  806dc2:	83 ec 38             	sub    $0x38,%esp
  struct ip_reassdata *ipr_prev = NULL;

  IPFRAG_STATS_INC(ip_frag.recv);
  snmp_inc_ipreasmreqds();

  fraghdr = (struct ip_hdr*)p->payload;
  806dc5:	8b 45 08             	mov    0x8(%ebp),%eax
  806dc8:	8b 58 04             	mov    0x4(%eax),%ebx

  if ((IPH_HL(fraghdr) * 4) != IP_HLEN) {
  806dcb:	0f b7 03             	movzwl (%ebx),%eax
  806dce:	50                   	push   %eax
  806dcf:	e8 9d 0a 00 00       	call   807871 <ntohs>
  806dd4:	66 c1 e8 08          	shr    $0x8,%ax
  806dd8:	83 e0 0f             	and    $0xf,%eax
  806ddb:	83 c4 10             	add    $0x10,%esp
  806dde:	83 f8 05             	cmp    $0x5,%eax
  806de1:	0f 85 de 01 00 00    	jne    806fc5 <ip_reass+0x20d>
    LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: IP options currently not supported!\n"));
    IPFRAG_STATS_INC(ip_frag.err);
    goto nullreturn;
  }

  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
  806de7:	83 ec 0c             	sub    $0xc,%esp
  806dea:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
  806dee:	50                   	push   %eax
  806def:	e8 7d 0a 00 00       	call   807871 <ntohs>
  806df4:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
  806df8:	0f b7 43 02          	movzwl 0x2(%ebx),%eax
  806dfc:	89 04 24             	mov    %eax,(%esp)
  806dff:	e8 6d 0a 00 00       	call   807871 <ntohs>
  806e04:	66 89 45 de          	mov    %ax,-0x22(%ebp)
  806e08:	0f b7 03             	movzwl (%ebx),%eax
  806e0b:	89 04 24             	mov    %eax,(%esp)
  806e0e:	e8 5e 0a 00 00       	call   807871 <ntohs>
  806e13:	66 89 45 d8          	mov    %ax,-0x28(%ebp)

  /* Check if we are allowed to enqueue more datagrams. */
  clen = pbuf_clen(p);
  806e17:	83 c4 04             	add    $0x4,%esp
  806e1a:	ff 75 08             	pushl  0x8(%ebp)
  806e1d:	e8 45 df ff ff       	call   804d67 <pbuf_clen>
  806e22:	88 45 e4             	mov    %al,-0x1c(%ebp)
  if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
  806e25:	0f b6 f0             	movzbl %al,%esi
  806e28:	0f b7 05 dc 49 b3 00 	movzwl 0xb349dc,%eax
  806e2f:	01 f0                	add    %esi,%eax
  806e31:	83 c4 10             	add    $0x10,%esp
  806e34:	83 f8 0a             	cmp    $0xa,%eax
  806e37:	7f 0d                	jg     806e46 <ip_reass+0x8e>
    }
  }

  /* Look for the datagram the fragment belongs to in the current datagram queue,
   * remembering the previous in the queue for later dequeueing. */
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
  806e39:	8b 3d e0 49 b3 00    	mov    0xb349e0,%edi
  struct ip_reassdata *ipr_prev = NULL;
  806e3f:	b8 00 00 00 00       	mov    $0x0,%eax
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
  806e44:	eb 28                	jmp    806e6e <ip_reass+0xb6>
    if (!ip_reass_remove_oldest_datagram(fraghdr, clen) ||
  806e46:	89 f2                	mov    %esi,%edx
  806e48:	89 d8                	mov    %ebx,%eax
  806e4a:	e8 9a fe ff ff       	call   806ce9 <ip_reass_remove_oldest_datagram>
  806e4f:	85 c0                	test   %eax,%eax
  806e51:	0f 84 6e 01 00 00    	je     806fc5 <ip_reass+0x20d>
        ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS))
  806e57:	0f b7 05 dc 49 b3 00 	movzwl 0xb349dc,%eax
  806e5e:	01 f0                	add    %esi,%eax
    if (!ip_reass_remove_oldest_datagram(fraghdr, clen) ||
  806e60:	83 f8 0a             	cmp    $0xa,%eax
  806e63:	7e d4                	jle    806e39 <ip_reass+0x81>
  806e65:	e9 5b 01 00 00       	jmp    806fc5 <ip_reass+0x20d>
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
  806e6a:	89 f8                	mov    %edi,%eax
  806e6c:	8b 3f                	mov    (%edi),%edi
  806e6e:	85 ff                	test   %edi,%edi
  806e70:	0f 84 f7 00 00 00    	je     806f6d <ip_reass+0x1b5>
    /* Check if the incoming fragment matches the one currently present
       in the reassembly buffer. If so, we proceed with copying the
       fragment into the buffer. */
    if (IP_ADDRESSES_AND_ID_MATCH(&ipr->iphdr, fraghdr)) {
  806e76:	8b 4b 0c             	mov    0xc(%ebx),%ecx
  806e79:	39 4f 14             	cmp    %ecx,0x14(%edi)
  806e7c:	75 ec                	jne    806e6a <ip_reass+0xb2>
  806e7e:	8b 53 10             	mov    0x10(%ebx),%edx
  806e81:	39 57 18             	cmp    %edx,0x18(%edi)
  806e84:	75 e4                	jne    806e6a <ip_reass+0xb2>
  806e86:	0f b7 53 04          	movzwl 0x4(%ebx),%edx
  806e8a:	66 39 57 0c          	cmp    %dx,0xc(%edi)
  806e8e:	75 da                	jne    806e6a <ip_reass+0xb2>
  806e90:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    /* Bail if unable to enqueue */
    if(ipr == NULL) {
      goto nullreturn;
    }
  } else {
    if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) && 
  806e93:	83 ec 0c             	sub    $0xc,%esp
  806e96:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
  806e9a:	50                   	push   %eax
  806e9b:	e8 d1 09 00 00       	call   807871 <ntohs>
  806ea0:	83 c4 10             	add    $0x10,%esp
  806ea3:	66 a9 ff 1f          	test   $0x1fff,%ax
  806ea7:	0f 84 4d 01 00 00    	je     806ffa <ip_reass+0x242>
      SMEMCPY(&ipr->iphdr, fraghdr, IP_HLEN);
    }
  }
  /* Track the current number of pbufs current 'in-flight', in order to limit 
  the number of fragments that may be enqueued at any one time */
  ip_reass_pbufcount += clen;
  806ead:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
  806eb1:	66 01 05 dc 49 b3 00 	add    %ax,0xb349dc

  /* At this point, we have either created a new entry or pointing 
   * to an existing one */

  /* check for 'no more fragments', and update queue entry*/
  if ((ntohs(IPH_OFFSET(fraghdr)) & IP_MF) == 0) {
  806eb8:	83 ec 0c             	sub    $0xc,%esp
  806ebb:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
  806ebf:	50                   	push   %eax
  806ec0:	e8 ac 09 00 00       	call   807871 <ntohs>
  806ec5:	83 c4 10             	add    $0x10,%esp
  806ec8:	f6 c4 20             	test   $0x20,%ah
  806ecb:	75 20                	jne    806eed <ip_reass+0x135>
    ipr->flags |= IP_REASS_FLAG_LASTFRAG;
  806ecd:	80 4f 1e 01          	orb    $0x1,0x1e(%edi)
    ipr->datagram_len = offset + len;
  806ed1:	0f b7 45 e0          	movzwl -0x20(%ebp),%eax
  806ed5:	0f b7 75 de          	movzwl -0x22(%ebp),%esi
  806ed9:	8d 04 c6             	lea    (%esi,%eax,8),%eax
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
  806edc:	0f b7 55 d8          	movzwl -0x28(%ebp),%edx
  806ee0:	66 c1 ea 06          	shr    $0x6,%dx
  806ee4:	83 e2 3c             	and    $0x3c,%edx
    ipr->datagram_len = offset + len;
  806ee7:	29 d0                	sub    %edx,%eax
  806ee9:	66 89 47 1c          	mov    %ax,0x1c(%edi)
  fraghdr = (struct ip_hdr*)new_p->payload; 
  806eed:	8b 45 08             	mov    0x8(%ebp),%eax
  806ef0:	8b 70 04             	mov    0x4(%eax),%esi
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
  806ef3:	83 ec 0c             	sub    $0xc,%esp
  806ef6:	0f b7 46 02          	movzwl 0x2(%esi),%eax
  806efa:	50                   	push   %eax
  806efb:	e8 71 09 00 00       	call   807871 <ntohs>
  806f00:	89 c3                	mov    %eax,%ebx
  806f02:	0f b7 06             	movzwl (%esi),%eax
  806f05:	89 04 24             	mov    %eax,(%esp)
  806f08:	e8 64 09 00 00       	call   807871 <ntohs>
  806f0d:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
  806f11:	0f b7 46 06          	movzwl 0x6(%esi),%eax
  806f15:	89 04 24             	mov    %eax,(%esp)
  806f18:	e8 54 09 00 00       	call   807871 <ntohs>
  806f1d:	8d 0c c5 00 00 00 00 	lea    0x0(,%eax,8),%ecx
  iprh = (struct ip_reass_helper*)new_p->payload;
  806f24:	8b 55 08             	mov    0x8(%ebp),%edx
  806f27:	8b 72 04             	mov    0x4(%edx),%esi
  806f2a:	89 75 e0             	mov    %esi,-0x20(%ebp)
  iprh->next_pbuf = NULL;
  806f2d:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
  iprh->start = offset;
  806f33:	66 89 4e 04          	mov    %cx,0x4(%esi)
  iprh->end = offset + len;
  806f37:	01 cb                	add    %ecx,%ebx
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
  806f39:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  806f3d:	66 c1 e8 06          	shr    $0x6,%ax
  806f41:	83 e0 3c             	and    $0x3c,%eax
  iprh->end = offset + len;
  806f44:	29 c3                	sub    %eax,%ebx
  806f46:	66 89 5d de          	mov    %bx,-0x22(%ebp)
  806f4a:	66 89 5e 06          	mov    %bx,0x6(%esi)
  for (q = ipr->p; q != NULL;) {
  806f4e:	8b 47 04             	mov    0x4(%edi),%eax
  806f51:	89 45 d8             	mov    %eax,-0x28(%ebp)
  806f54:	83 c4 10             	add    $0x10,%esp
  806f57:	89 c3                	mov    %eax,%ebx
  int valid = 1;
  806f59:	b8 01 00 00 00       	mov    $0x1,%eax
  struct ip_reass_helper *iprh, *iprh_tmp, *iprh_prev=NULL;
  806f5e:	be 00 00 00 00       	mov    $0x0,%esi
  806f63:	89 7d e4             	mov    %edi,-0x1c(%ebp)
  806f66:	89 c7                	mov    %eax,%edi
  for (q = ipr->p; q != NULL;) {
  806f68:	e9 25 01 00 00       	jmp    807092 <ip_reass+0x2da>
  806f6d:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  ipr = memp_malloc(MEMP_REASSDATA);
  806f70:	83 ec 0c             	sub    $0xc,%esp
  806f73:	6a 05                	push   $0x5
  806f75:	e8 d1 d5 ff ff       	call   80454b <memp_malloc>
  806f7a:	89 c7                	mov    %eax,%edi
  if (ipr == NULL) {
  806f7c:	83 c4 10             	add    $0x10,%esp
  806f7f:	85 c0                	test   %eax,%eax
  806f81:	74 35                	je     806fb8 <ip_reass+0x200>
  memset(ipr, 0, sizeof(struct ip_reassdata));
  806f83:	83 ec 04             	sub    $0x4,%esp
  806f86:	6a 20                	push   $0x20
  806f88:	6a 00                	push   $0x0
  806f8a:	57                   	push   %edi
  806f8b:	e8 12 81 00 00       	call   80f0a2 <memset>
  ipr->timer = IP_REASS_MAXAGE;
  806f90:	c6 47 1f 03          	movb   $0x3,0x1f(%edi)
  ipr->next = reassdatagrams;
  806f94:	a1 e0 49 b3 00       	mov    0xb349e0,%eax
  806f99:	89 07                	mov    %eax,(%edi)
  reassdatagrams = ipr;
  806f9b:	89 3d e0 49 b3 00    	mov    %edi,0xb349e0
  SMEMCPY(&(ipr->iphdr), fraghdr, IP_HLEN);
  806fa1:	83 c4 0c             	add    $0xc,%esp
  806fa4:	6a 14                	push   $0x14
  806fa6:	53                   	push   %ebx
  806fa7:	8d 47 08             	lea    0x8(%edi),%eax
  806faa:	50                   	push   %eax
  806fab:	e8 a4 81 00 00       	call   80f154 <memcpy>
  806fb0:	83 c4 10             	add    $0x10,%esp
  806fb3:	e9 f5 fe ff ff       	jmp    806ead <ip_reass+0xf5>
    if (ip_reass_remove_oldest_datagram(fraghdr, clen) >= clen) {
  806fb8:	89 f2                	mov    %esi,%edx
  806fba:	89 d8                	mov    %ebx,%eax
  806fbc:	e8 28 fd ff ff       	call   806ce9 <ip_reass_remove_oldest_datagram>
  806fc1:	39 c6                	cmp    %eax,%esi
  806fc3:	7e 20                	jle    806fe5 <ip_reass+0x22d>
  return NULL;

nullreturn:
  LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: nullreturn\n"));
  IPFRAG_STATS_INC(ip_frag.drop);
  pbuf_free(p);
  806fc5:	83 ec 0c             	sub    $0xc,%esp
  806fc8:	ff 75 08             	pushl  0x8(%ebp)
  806fcb:	e8 58 d9 ff ff       	call   804928 <pbuf_free>
  return NULL;
  806fd0:	83 c4 10             	add    $0x10,%esp
  806fd3:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
}
  806fda:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  806fdd:	8d 65 f4             	lea    -0xc(%ebp),%esp
  806fe0:	5b                   	pop    %ebx
  806fe1:	5e                   	pop    %esi
  806fe2:	5f                   	pop    %edi
  806fe3:	5d                   	pop    %ebp
  806fe4:	c3                   	ret    
      ipr = memp_malloc(MEMP_REASSDATA);
  806fe5:	83 ec 0c             	sub    $0xc,%esp
  806fe8:	6a 05                	push   $0x5
  806fea:	e8 5c d5 ff ff       	call   80454b <memp_malloc>
  806fef:	89 c7                	mov    %eax,%edi
    if (ipr == NULL)
  806ff1:	83 c4 10             	add    $0x10,%esp
  806ff4:	85 c0                	test   %eax,%eax
  806ff6:	75 8b                	jne    806f83 <ip_reass+0x1cb>
  806ff8:	eb cb                	jmp    806fc5 <ip_reass+0x20d>
      ((ntohs(IPH_OFFSET(&ipr->iphdr)) & IP_OFFMASK) != 0)) {
  806ffa:	83 ec 0c             	sub    $0xc,%esp
  806ffd:	0f b7 47 0e          	movzwl 0xe(%edi),%eax
  807001:	50                   	push   %eax
  807002:	e8 6a 08 00 00       	call   807871 <ntohs>
    if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) && 
  807007:	83 c4 10             	add    $0x10,%esp
  80700a:	66 a9 ff 1f          	test   $0x1fff,%ax
  80700e:	0f 84 99 fe ff ff    	je     806ead <ip_reass+0xf5>
      SMEMCPY(&ipr->iphdr, fraghdr, IP_HLEN);
  807014:	83 ec 04             	sub    $0x4,%esp
  807017:	6a 14                	push   $0x14
  807019:	53                   	push   %ebx
  80701a:	8d 47 08             	lea    0x8(%edi),%eax
  80701d:	50                   	push   %eax
  80701e:	e8 31 81 00 00       	call   80f154 <memcpy>
  807023:	83 c4 10             	add    $0x10,%esp
  807026:	e9 82 fe ff ff       	jmp    806ead <ip_reass+0xf5>
  80702b:	89 7d d0             	mov    %edi,-0x30(%ebp)
  80702e:	8b 7d e4             	mov    -0x1c(%ebp),%edi
      iprh->next_pbuf = q;
  807031:	8b 55 e0             	mov    -0x20(%ebp),%edx
  807034:	89 1a                	mov    %ebx,(%edx)
      if (iprh_prev != NULL) {
  807036:	85 f6                	test   %esi,%esi
  807038:	74 4c                	je     807086 <ip_reass+0x2ce>
        if ((iprh->start < iprh_prev->end) || (iprh->end > iprh_tmp->start)) {
  80703a:	66 3b 4e 06          	cmp    0x6(%esi),%cx
  80703e:	0f 82 9f 01 00 00    	jb     8071e3 <ip_reass+0x42b>
  807044:	0f b7 4d de          	movzwl -0x22(%ebp),%ecx
  807048:	66 3b 48 04          	cmp    0x4(%eax),%cx
  80704c:	0f 87 91 01 00 00    	ja     8071e3 <ip_reass+0x42b>
        iprh_prev->next_pbuf = new_p;
  807052:	8b 45 08             	mov    0x8(%ebp),%eax
  807055:	89 06                	mov    %eax,(%esi)
  if ((ipr->flags & IP_REASS_FLAG_LASTFRAG) != 0) {
  807057:	f6 47 1e 01          	testb  $0x1,0x1e(%edi)
  80705b:	0f 84 a5 01 00 00    	je     807206 <ip_reass+0x44e>
    if (valid) {
  807061:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
  807065:	0f 84 9b 01 00 00    	je     807206 <ip_reass+0x44e>
      if (((struct ip_reass_helper*)ipr->p->payload)->start != 0) {
  80706b:	8b 4f 04             	mov    0x4(%edi),%ecx
  80706e:	8b 59 04             	mov    0x4(%ecx),%ebx
  807071:	66 83 7b 04 00       	cmpw   $0x0,0x4(%ebx)
  807076:	0f 85 8a 01 00 00    	jne    807206 <ip_reass+0x44e>
        q = iprh->next_pbuf;
  80707c:	8b 75 e0             	mov    -0x20(%ebp),%esi
  80707f:	8b 16                	mov    (%esi),%edx
        while (q != NULL) {
  807081:	e9 85 00 00 00       	jmp    80710b <ip_reass+0x353>
        ipr->p = new_p;
  807086:	8b 45 08             	mov    0x8(%ebp),%eax
  807089:	89 47 04             	mov    %eax,0x4(%edi)
  80708c:	eb c9                	jmp    807057 <ip_reass+0x29f>
    q = iprh_tmp->next_pbuf;
  80708e:	8b 18                	mov    (%eax),%ebx
    iprh_tmp = (struct ip_reass_helper*)q->payload;
  807090:	89 c6                	mov    %eax,%esi
  for (q = ipr->p; q != NULL;) {
  807092:	85 db                	test   %ebx,%ebx
  807094:	0f 84 c3 01 00 00    	je     80725d <ip_reass+0x4a5>
    iprh_tmp = (struct ip_reass_helper*)q->payload;
  80709a:	8b 43 04             	mov    0x4(%ebx),%eax
    if (iprh->start < iprh_tmp->start) {
  80709d:	0f b7 50 04          	movzwl 0x4(%eax),%edx
  8070a1:	66 39 d1             	cmp    %dx,%cx
  8070a4:	72 85                	jb     80702b <ip_reass+0x273>
    } else if(iprh->start == iprh_tmp->start) {
  8070a6:	0f 84 37 01 00 00    	je     8071e3 <ip_reass+0x42b>
    } else if(iprh->start < iprh_tmp->end) {
  8070ac:	66 3b 48 06          	cmp    0x6(%eax),%cx
  8070b0:	0f 82 2d 01 00 00    	jb     8071e3 <ip_reass+0x42b>
      if (iprh_prev != NULL) {
  8070b6:	85 f6                	test   %esi,%esi
  8070b8:	74 d4                	je     80708e <ip_reass+0x2d6>
          valid = 0;
  8070ba:	66 3b 56 06          	cmp    0x6(%esi),%dx
  8070be:	ba 00 00 00 00       	mov    $0x0,%edx
  8070c3:	0f 45 fa             	cmovne %edx,%edi
  8070c6:	eb c6                	jmp    80708e <ip_reass+0x2d6>
      LWIP_ASSERT("check fragments don't overlap", iprh_prev->end <= iprh->start);
  8070c8:	83 ec 04             	sub    $0x4,%esp
  8070cb:	68 60 23 81 00       	push   $0x812360
  8070d0:	68 83 01 00 00       	push   $0x183
  8070d5:	68 0a 23 81 00       	push   $0x81230a
  8070da:	e8 68 77 00 00       	call   80e847 <_panic>
      LWIP_ASSERT("no previous fragment, this must be the first fragment!",
  8070df:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
  8070e3:	75 0b                	jne    8070f0 <ip_reass+0x338>
      ipr->p = new_p;
  8070e5:	8b 45 08             	mov    0x8(%ebp),%eax
  8070e8:	89 47 04             	mov    %eax,0x4(%edi)
  8070eb:	e9 67 ff ff ff       	jmp    807057 <ip_reass+0x29f>
      LWIP_ASSERT("no previous fragment, this must be the first fragment!",
  8070f0:	83 ec 04             	sub    $0x4,%esp
  8070f3:	68 8c 23 81 00       	push   $0x81238c
  8070f8:	68 8b 01 00 00       	push   $0x18b
  8070fd:	68 0a 23 81 00       	push   $0x81230a
  807102:	e8 40 77 00 00       	call   80e847 <_panic>
          q = iprh->next_pbuf;
  807107:	8b 10                	mov    (%eax),%edx
          iprh = (struct ip_reass_helper*)q->payload;
  807109:	89 c6                	mov    %eax,%esi
        while (q != NULL) {
  80710b:	85 d2                	test   %edx,%edx
  80710d:	74 12                	je     807121 <ip_reass+0x369>
          iprh = (struct ip_reass_helper*)q->payload;
  80710f:	8b 42 04             	mov    0x4(%edx),%eax
          if (iprh_prev->end != iprh->start) {
  807112:	0f b7 50 04          	movzwl 0x4(%eax),%edx
  807116:	66 39 56 06          	cmp    %dx,0x6(%esi)
  80711a:	74 eb                	je     807107 <ip_reass+0x34f>
  80711c:	e9 e5 00 00 00       	jmp    807206 <ip_reass+0x44e>
  807121:	89 75 e0             	mov    %esi,-0x20(%ebp)
          LWIP_ASSERT("sanity check",
  807124:	39 f3                	cmp    %esi,%ebx
  807126:	74 76                	je     80719e <ip_reass+0x3e6>
          LWIP_ASSERT("validate_datagram:next_pbuf!=NULL",
  807128:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80712b:	83 38 00             	cmpl   $0x0,(%eax)
  80712e:	0f 85 81 00 00 00    	jne    8071b5 <ip_reass+0x3fd>
          LWIP_ASSERT("validate_datagram:datagram end!=datagram len",
  807134:	0f b7 47 1c          	movzwl 0x1c(%edi),%eax
  807138:	8b 75 e0             	mov    -0x20(%ebp),%esi
  80713b:	66 39 46 06          	cmp    %ax,0x6(%esi)
  80713f:	0f 85 87 00 00 00    	jne    8071cc <ip_reass+0x414>
    ipr->datagram_len += IP_HLEN;
  807145:	83 c0 14             	add    $0x14,%eax
  807148:	66 89 47 1c          	mov    %ax,0x1c(%edi)
    r = ((struct ip_reass_helper*)ipr->p->payload)->next_pbuf;
  80714c:	8b 71 04             	mov    0x4(%ecx),%esi
  80714f:	8b 1e                	mov    (%esi),%ebx
    SMEMCPY(fraghdr, &ipr->iphdr, IP_HLEN);
  807151:	83 ec 04             	sub    $0x4,%esp
  807154:	6a 14                	push   $0x14
  807156:	8d 47 08             	lea    0x8(%edi),%eax
  807159:	50                   	push   %eax
  80715a:	56                   	push   %esi
  80715b:	e8 f4 7f 00 00       	call   80f154 <memcpy>
    IPH_LEN_SET(fraghdr, htons(ipr->datagram_len));
  807160:	0f b7 47 1c          	movzwl 0x1c(%edi),%eax
  807164:	89 04 24             	mov    %eax,(%esp)
  807167:	e8 f4 06 00 00       	call   807860 <htons>
  80716c:	66 89 46 02          	mov    %ax,0x2(%esi)
    IPH_OFFSET_SET(fraghdr, 0);
  807170:	66 c7 46 06 00 00    	movw   $0x0,0x6(%esi)
    IPH_CHKSUM_SET(fraghdr, 0);
  807176:	66 c7 46 0a 00 00    	movw   $0x0,0xa(%esi)
    IPH_CHKSUM_SET(fraghdr, inet_chksum(fraghdr, IP_HLEN));
  80717c:	83 c4 08             	add    $0x8,%esp
  80717f:	6a 14                	push   $0x14
  807181:	56                   	push   %esi
  807182:	e8 9f 05 00 00       	call   807726 <inet_chksum>
  807187:	66 89 46 0a          	mov    %ax,0xa(%esi)
    p = ipr->p;
  80718b:	8b 47 04             	mov    0x4(%edi),%eax
  80718e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    while(r != NULL) {
  807191:	83 c4 10             	add    $0x10,%esp
  807194:	89 7d e0             	mov    %edi,-0x20(%ebp)
  807197:	89 c7                	mov    %eax,%edi
  807199:	e9 91 00 00 00       	jmp    80722f <ip_reass+0x477>
          LWIP_ASSERT("sanity check",
  80719e:	83 ec 04             	sub    $0x4,%esp
  8071a1:	68 7e 23 81 00       	push   $0x81237e
  8071a6:	68 ad 01 00 00       	push   $0x1ad
  8071ab:	68 0a 23 81 00       	push   $0x81230a
  8071b0:	e8 92 76 00 00       	call   80e847 <_panic>
          LWIP_ASSERT("validate_datagram:next_pbuf!=NULL",
  8071b5:	83 ec 04             	sub    $0x4,%esp
  8071b8:	68 c4 23 81 00       	push   $0x8123c4
  8071bd:	68 af 01 00 00       	push   $0x1af
  8071c2:	68 0a 23 81 00       	push   $0x81230a
  8071c7:	e8 7b 76 00 00       	call   80e847 <_panic>
          LWIP_ASSERT("validate_datagram:datagram end!=datagram len",
  8071cc:	83 ec 04             	sub    $0x4,%esp
  8071cf:	68 e8 23 81 00       	push   $0x8123e8
  8071d4:	68 b1 01 00 00       	push   $0x1b1
  8071d9:	68 0a 23 81 00       	push   $0x81230a
  8071de:	e8 64 76 00 00       	call   80e847 <_panic>
  ip_reass_pbufcount -= pbuf_clen(new_p);
  8071e3:	83 ec 0c             	sub    $0xc,%esp
  8071e6:	ff 75 08             	pushl  0x8(%ebp)
  8071e9:	e8 79 db ff ff       	call   804d67 <pbuf_clen>
  8071ee:	0f b6 c0             	movzbl %al,%eax
  8071f1:	66 29 05 dc 49 b3 00 	sub    %ax,0xb349dc
  pbuf_free(new_p);
  8071f8:	83 c4 04             	add    $0x4,%esp
  8071fb:	ff 75 08             	pushl  0x8(%ebp)
  8071fe:	e8 25 d7 ff ff       	call   804928 <pbuf_free>
  return 0;
  807203:	83 c4 10             	add    $0x10,%esp
  return NULL;
  807206:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  80720d:	e9 c8 fd ff ff       	jmp    806fda <ip_reass+0x222>
      iprh = (struct ip_reass_helper*)r->payload;
  807212:	8b 73 04             	mov    0x4(%ebx),%esi
      pbuf_header(r, -IP_HLEN);
  807215:	83 ec 08             	sub    $0x8,%esp
  807218:	6a ec                	push   $0xffffffec
  80721a:	53                   	push   %ebx
  80721b:	e8 35 d6 ff ff       	call   804855 <pbuf_header>
      pbuf_cat(p, r);
  807220:	83 c4 08             	add    $0x8,%esp
  807223:	53                   	push   %ebx
  807224:	57                   	push   %edi
  807225:	e8 70 db ff ff       	call   804d9a <pbuf_cat>
      r = iprh->next_pbuf;
  80722a:	8b 1e                	mov    (%esi),%ebx
  80722c:	83 c4 10             	add    $0x10,%esp
    while(r != NULL) {
  80722f:	85 db                	test   %ebx,%ebx
  807231:	75 df                	jne    807212 <ip_reass+0x45a>
  807233:	8b 7d e0             	mov    -0x20(%ebp),%edi
    ip_reass_dequeue_datagram(ipr, ipr_prev);
  807236:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  807239:	89 f8                	mov    %edi,%eax
  80723b:	e8 51 f9 ff ff       	call   806b91 <ip_reass_dequeue_datagram>
    ip_reass_pbufcount -= pbuf_clen(p);
  807240:	83 ec 0c             	sub    $0xc,%esp
  807243:	ff 75 e4             	pushl  -0x1c(%ebp)
  807246:	e8 1c db ff ff       	call   804d67 <pbuf_clen>
  80724b:	0f b6 c0             	movzbl %al,%eax
  80724e:	66 29 05 dc 49 b3 00 	sub    %ax,0xb349dc
    return p;
  807255:	83 c4 10             	add    $0x10,%esp
  807258:	e9 7d fd ff ff       	jmp    806fda <ip_reass+0x222>
  80725d:	89 7d d0             	mov    %edi,-0x30(%ebp)
  807260:	8b 7d e4             	mov    -0x1c(%ebp),%edi
    if (iprh_prev != NULL) {
  807263:	85 f6                	test   %esi,%esi
  807265:	0f 84 74 fe ff ff    	je     8070df <ip_reass+0x327>
      LWIP_ASSERT("check fragments don't overlap", iprh_prev->end <= iprh->start);
  80726b:	0f b7 46 06          	movzwl 0x6(%esi),%eax
  80726f:	66 39 c1             	cmp    %ax,%cx
  807272:	0f 82 50 fe ff ff    	jb     8070c8 <ip_reass+0x310>
      iprh_prev->next_pbuf = new_p;
  807278:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80727b:	89 0e                	mov    %ecx,(%esi)
      if (iprh_prev->end != iprh->start) {
  80727d:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  807280:	66 3b 41 04          	cmp    0x4(%ecx),%ax
  807284:	75 80                	jne    807206 <ip_reass+0x44e>
  807286:	e9 cc fd ff ff       	jmp    807057 <ip_reass+0x29f>

0080728b <ip_frag>:
 *
 * @return ERR_OK if sent successfully, err_t otherwise
 */
err_t 
ip_frag(struct pbuf *p, struct netif *netif, struct ip_addr *dest)
{
  80728b:	f3 0f 1e fb          	endbr32 
  80728f:	55                   	push   %ebp
  807290:	89 e5                	mov    %esp,%ebp
  807292:	57                   	push   %edi
  807293:	56                   	push   %esi
  807294:	53                   	push   %ebx
  807295:	83 ec 30             	sub    $0x30,%esp
  struct ip_hdr *original_iphdr;
#endif
  struct ip_hdr *iphdr;
  u16_t nfb;
  u16_t left, cop;
  u16_t mtu = netif->mtu;
  807298:	8b 45 0c             	mov    0xc(%ebp),%eax
  80729b:	0f b7 58 2c          	movzwl 0x2c(%eax),%ebx
#if IP_FRAG_USES_STATIC_BUF
  /* When using a static buffer, we use a PBUF_REF, which we will
   * use to reference the packet (without link header).
   * Layer and length is irrelevant.
   */
  rambuf = pbuf_alloc(PBUF_LINK, 0, PBUF_REF);
  80729f:	6a 02                	push   $0x2
  8072a1:	6a 00                	push   $0x0
  8072a3:	6a 02                	push   $0x2
  8072a5:	e8 48 d7 ff ff       	call   8049f2 <pbuf_alloc>
  8072aa:	89 45 dc             	mov    %eax,-0x24(%ebp)
  if (rambuf == NULL) {
  8072ad:	83 c4 10             	add    $0x10,%esp
  8072b0:	85 c0                	test   %eax,%eax
  8072b2:	0f 84 c2 00 00 00    	je     80737a <ip_frag+0xef>
    LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_frag: pbuf_alloc(PBUF_LINK, 0, PBUF_REF) failed\n"));
    return ERR_MEM;
  }
  rambuf->tot_len = rambuf->len = mtu;
  8072b8:	66 89 58 0a          	mov    %bx,0xa(%eax)
  8072bc:	66 89 58 08          	mov    %bx,0x8(%eax)
  rambuf->payload = LWIP_MEM_ALIGN((void *)buf);
  8072c0:	be 03 44 b3 00       	mov    $0xb34403,%esi
  8072c5:	83 e6 fc             	and    $0xfffffffc,%esi
  8072c8:	89 70 04             	mov    %esi,0x4(%eax)

  /* Copy the IP header in it */
  iphdr = rambuf->payload;
  SMEMCPY(iphdr, p->payload, IP_HLEN);
  8072cb:	83 ec 04             	sub    $0x4,%esp
  8072ce:	6a 14                	push   $0x14
  8072d0:	8b 45 08             	mov    0x8(%ebp),%eax
  8072d3:	ff 70 04             	pushl  0x4(%eax)
  8072d6:	56                   	push   %esi
  8072d7:	e8 78 7e 00 00       	call   80f154 <memcpy>
  original_iphdr = p->payload;
  iphdr = original_iphdr;
#endif /* IP_FRAG_USES_STATIC_BUF */

  /* Save original offset */
  tmp = ntohs(IPH_OFFSET(iphdr));
  8072dc:	0f b7 46 06          	movzwl 0x6(%esi),%eax
  8072e0:	89 04 24             	mov    %eax,(%esp)
  8072e3:	e8 89 05 00 00       	call   807871 <ntohs>
  ofo = tmp & IP_OFFMASK;
  8072e8:	89 c7                	mov    %eax,%edi
  8072ea:	66 81 e7 ff 1f       	and    $0x1fff,%di
  8072ef:	66 89 7d e4          	mov    %di,-0x1c(%ebp)
  omf = tmp & IP_MF;
  8072f3:	66 25 00 20          	and    $0x2000,%ax
  8072f7:	66 89 45 e0          	mov    %ax,-0x20(%ebp)

  left = p->tot_len - IP_HLEN;
  8072fb:	8b 45 08             	mov    0x8(%ebp),%eax
  8072fe:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  807302:	8d 78 ec             	lea    -0x14(%eax),%edi

  nfb = (mtu - IP_HLEN) / 8;
  807305:	0f b7 db             	movzwl %bx,%ebx
  807308:	8d 43 f3             	lea    -0xd(%ebx),%eax
  80730b:	83 c4 10             	add    $0x10,%esp
  80730e:	89 da                	mov    %ebx,%edx
  807310:	83 ea 14             	sub    $0x14,%edx
  807313:	0f 49 c2             	cmovns %edx,%eax
  807316:	c1 f8 03             	sar    $0x3,%eax
  807319:	66 89 45 d2          	mov    %ax,-0x2e(%ebp)
    tmp = omf | (IP_OFFMASK & (ofo));
    if (!last)
      tmp = tmp | IP_MF;

    /* Fill this fragment */
    cop = last ? left : nfb * 8;
  80731d:	c1 e0 03             	shl    $0x3,%eax
  807320:	66 89 45 d0          	mov    %ax,-0x30(%ebp)

#if IP_FRAG_USES_STATIC_BUF
    poff += pbuf_copy_partial(p, (u8_t*)iphdr + IP_HLEN, cop, poff);
  807324:	0f b7 c8             	movzwl %ax,%ecx
  807327:	89 4d cc             	mov    %ecx,-0x34(%ebp)
    poff = newpbuflen;
#endif /* IP_FRAG_USES_STATIC_BUF */

    /* Correct header */
    IPH_OFFSET_SET(iphdr, htons(tmp));
    IPH_LEN_SET(iphdr, htons(cop + IP_HLEN));
  80732a:	83 c0 14             	add    $0x14,%eax
  80732d:	0f b7 c0             	movzwl %ax,%eax
  807330:	89 45 c8             	mov    %eax,-0x38(%ebp)
  u16_t poff = IP_HLEN;
  807333:	66 c7 45 e6 14 00    	movw   $0x14,-0x1a(%ebp)
    last = (left <= mtu - IP_HLEN);
  807339:	8d 43 ed             	lea    -0x13(%ebx),%eax
  80733c:	89 45 d8             	mov    %eax,-0x28(%ebp)
    poff += pbuf_copy_partial(p, (u8_t*)iphdr + IP_HLEN, cop, poff);
  80733f:	8d 46 14             	lea    0x14(%esi),%eax
  807342:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  while (left) {
  807345:	e9 e3 00 00 00       	jmp    80742d <ip_frag+0x1a2>
      IPFRAG_STATS_INC(ip_frag.xmit);
      snmp_inc_ipfragcreates();
      pbuf_free(header);
    } else {
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_frag: pbuf_alloc() for header failed\n"));
      pbuf_free(rambuf);
  80734a:	83 ec 0c             	sub    $0xc,%esp
  80734d:	ff 75 dc             	pushl  -0x24(%ebp)
  807350:	e8 d3 d5 ff ff       	call   804928 <pbuf_free>
      return ERR_MEM;
  807355:	83 c4 10             	add    $0x10,%esp
  807358:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80735d:	eb 13                	jmp    807372 <ip_frag+0xe7>
#endif /* IP_FRAG_USES_STATIC_BUF */
    left -= cop;
    ofo += nfb;
  }
#if IP_FRAG_USES_STATIC_BUF
  pbuf_free(rambuf);
  80735f:	83 ec 0c             	sub    $0xc,%esp
  807362:	ff 75 dc             	pushl  -0x24(%ebp)
  807365:	e8 be d5 ff ff       	call   804928 <pbuf_free>
#endif /* IP_FRAG_USES_STATIC_BUF */
  snmp_inc_ipfragoks();
  return ERR_OK;
  80736a:	83 c4 10             	add    $0x10,%esp
  80736d:	b8 00 00 00 00       	mov    $0x0,%eax
}
  807372:	8d 65 f4             	lea    -0xc(%ebp),%esp
  807375:	5b                   	pop    %ebx
  807376:	5e                   	pop    %esi
  807377:	5f                   	pop    %edi
  807378:	5d                   	pop    %ebp
  807379:	c3                   	ret    
    return ERR_MEM;
  80737a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80737f:	eb f1                	jmp    807372 <ip_frag+0xe7>
    poff += pbuf_copy_partial(p, (u8_t*)iphdr + IP_HLEN, cop, poff);
  807381:	0f b7 55 e6          	movzwl -0x1a(%ebp),%edx
  807385:	52                   	push   %edx
  807386:	50                   	push   %eax
  807387:	ff 75 d4             	pushl  -0x2c(%ebp)
  80738a:	ff 75 08             	pushl  0x8(%ebp)
  80738d:	e8 1f dd ff ff       	call   8050b1 <pbuf_copy_partial>
  807392:	66 01 45 e6          	add    %ax,-0x1a(%ebp)
    IPH_OFFSET_SET(iphdr, htons(tmp));
  807396:	0f b7 db             	movzwl %bx,%ebx
  807399:	89 1c 24             	mov    %ebx,(%esp)
  80739c:	e8 bf 04 00 00       	call   807860 <htons>
  8073a1:	66 89 46 06          	mov    %ax,0x6(%esi)
    IPH_LEN_SET(iphdr, htons(cop + IP_HLEN));
  8073a5:	8d 5f 14             	lea    0x14(%edi),%ebx
  8073a8:	0f b7 db             	movzwl %bx,%ebx
  8073ab:	89 1c 24             	mov    %ebx,(%esp)
  8073ae:	e8 ad 04 00 00       	call   807860 <htons>
  8073b3:	66 89 46 02          	mov    %ax,0x2(%esi)
    IPH_CHKSUM_SET(iphdr, 0);
  8073b7:	66 c7 46 0a 00 00    	movw   $0x0,0xa(%esi)
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
  8073bd:	83 c4 08             	add    $0x8,%esp
  8073c0:	6a 14                	push   $0x14
  8073c2:	56                   	push   %esi
  8073c3:	e8 5e 03 00 00       	call   807726 <inet_chksum>
  8073c8:	66 89 46 0a          	mov    %ax,0xa(%esi)
      pbuf_realloc(rambuf, left + IP_HLEN);
  8073cc:	83 c4 08             	add    $0x8,%esp
  8073cf:	53                   	push   %ebx
  8073d0:	ff 75 dc             	pushl  -0x24(%ebp)
  8073d3:	e8 79 d8 ff ff       	call   804c51 <pbuf_realloc>
  8073d8:	83 c4 10             	add    $0x10,%esp
    cop = last ? left : nfb * 8;
  8073db:	66 89 7d e2          	mov    %di,-0x1e(%ebp)
    header = pbuf_alloc(PBUF_LINK, 0, PBUF_RAM);
  8073df:	83 ec 04             	sub    $0x4,%esp
  8073e2:	6a 00                	push   $0x0
  8073e4:	6a 00                	push   $0x0
  8073e6:	6a 02                	push   $0x2
  8073e8:	e8 05 d6 ff ff       	call   8049f2 <pbuf_alloc>
  8073ed:	89 c3                	mov    %eax,%ebx
    if (header != NULL) {
  8073ef:	83 c4 10             	add    $0x10,%esp
  8073f2:	85 c0                	test   %eax,%eax
  8073f4:	0f 84 50 ff ff ff    	je     80734a <ip_frag+0xbf>
      pbuf_chain(header, rambuf);
  8073fa:	83 ec 08             	sub    $0x8,%esp
  8073fd:	ff 75 dc             	pushl  -0x24(%ebp)
  807400:	50                   	push   %eax
  807401:	e8 04 da ff ff       	call   804e0a <pbuf_chain>
      netif->output(netif, header, dest);
  807406:	83 c4 0c             	add    $0xc,%esp
  807409:	ff 75 10             	pushl  0x10(%ebp)
  80740c:	53                   	push   %ebx
  80740d:	ff 75 0c             	pushl  0xc(%ebp)
  807410:	8b 45 0c             	mov    0xc(%ebp),%eax
  807413:	ff 50 14             	call   *0x14(%eax)
      pbuf_free(header);
  807416:	89 1c 24             	mov    %ebx,(%esp)
  807419:	e8 0a d5 ff ff       	call   804928 <pbuf_free>
    left -= cop;
  80741e:	66 2b 7d e2          	sub    -0x1e(%ebp),%di
    ofo += nfb;
  807422:	0f b7 4d d2          	movzwl -0x2e(%ebp),%ecx
  807426:	66 01 4d e4          	add    %cx,-0x1c(%ebp)
  80742a:	83 c4 10             	add    $0x10,%esp
  while (left) {
  80742d:	66 85 ff             	test   %di,%di
  807430:	0f 84 29 ff ff ff    	je     80735f <ip_frag+0xd4>
    last = (left <= mtu - IP_HLEN);
  807436:	0f b7 c7             	movzwl %di,%eax
    tmp = omf | (IP_OFFMASK & (ofo));
  807439:	0f b7 5d e4          	movzwl -0x1c(%ebp),%ebx
  80743d:	66 81 e3 ff 1f       	and    $0x1fff,%bx
  807442:	66 0b 5d e0          	or     -0x20(%ebp),%bx
    if (!last)
  807446:	39 45 d8             	cmp    %eax,-0x28(%ebp)
  807449:	0f 8f 32 ff ff ff    	jg     807381 <ip_frag+0xf6>
    poff += pbuf_copy_partial(p, (u8_t*)iphdr + IP_HLEN, cop, poff);
  80744f:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  807453:	50                   	push   %eax
  807454:	ff 75 cc             	pushl  -0x34(%ebp)
  807457:	ff 75 d4             	pushl  -0x2c(%ebp)
  80745a:	ff 75 08             	pushl  0x8(%ebp)
  80745d:	e8 4f dc ff ff       	call   8050b1 <pbuf_copy_partial>
  807462:	66 01 45 e6          	add    %ax,-0x1a(%ebp)
      tmp = tmp | IP_MF;
  807466:	80 cf 20             	or     $0x20,%bh
    IPH_OFFSET_SET(iphdr, htons(tmp));
  807469:	0f b7 db             	movzwl %bx,%ebx
  80746c:	89 1c 24             	mov    %ebx,(%esp)
  80746f:	e8 ec 03 00 00       	call   807860 <htons>
  807474:	66 89 46 06          	mov    %ax,0x6(%esi)
    IPH_LEN_SET(iphdr, htons(cop + IP_HLEN));
  807478:	83 c4 04             	add    $0x4,%esp
  80747b:	ff 75 c8             	pushl  -0x38(%ebp)
  80747e:	e8 dd 03 00 00       	call   807860 <htons>
  807483:	66 89 46 02          	mov    %ax,0x2(%esi)
    IPH_CHKSUM_SET(iphdr, 0);
  807487:	66 c7 46 0a 00 00    	movw   $0x0,0xa(%esi)
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
  80748d:	83 c4 08             	add    $0x8,%esp
  807490:	6a 14                	push   $0x14
  807492:	56                   	push   %esi
  807493:	e8 8e 02 00 00       	call   807726 <inet_chksum>
  807498:	66 89 46 0a          	mov    %ax,0xa(%esi)
  80749c:	83 c4 10             	add    $0x10,%esp
    cop = last ? left : nfb * 8;
  80749f:	0f b7 45 d0          	movzwl -0x30(%ebp),%eax
  8074a3:	66 89 45 e2          	mov    %ax,-0x1e(%ebp)
  8074a7:	e9 33 ff ff ff       	jmp    8073df <ip_frag+0x154>

008074ac <lwip_standard_chksum>:
 * @note accumulator size limits summable length to 64k
 * @note host endianess is irrelevant (p3 RFC1071)
 */
static u16_t
lwip_standard_chksum(void *dataptr, u16_t len)
{
  8074ac:	55                   	push   %ebp
  8074ad:	89 e5                	mov    %esp,%ebp
  8074af:	57                   	push   %edi
  8074b0:	56                   	push   %esi
  8074b1:	53                   	push   %ebx
  8074b2:	83 ec 1c             	sub    $0x1c,%esp
  8074b5:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  8074b8:	89 d7                	mov    %edx,%edi
  8074ba:	66 d1 ef             	shr    %di
  8074bd:	0f b7 d7             	movzwl %di,%edx
  8074c0:	8d 34 50             	lea    (%eax,%edx,2),%esi
  u32_t acc;
  u16_t src;
  u8_t *octetptr;

  acc = 0;
  8074c3:	bb 00 00 00 00       	mov    $0x0,%ebx
  /* dataptr may be at odd or even addresses */
  octetptr = (u8_t*)dataptr;
  while (len > 1) {
  8074c8:	39 f0                	cmp    %esi,%eax
  8074ca:	74 18                	je     8074e4 <lwip_standard_chksum+0x38>
    /* declare first octet as most significant
       thus assume network order, ignoring host order */
    src = (*octetptr) << 8;
  8074cc:	0f b6 10             	movzbl (%eax),%edx
  8074cf:	89 d1                	mov    %edx,%ecx
  8074d1:	c1 e1 08             	shl    $0x8,%ecx
    octetptr++;
    /* declare second octet as least significant */
    src |= (*octetptr);
  8074d4:	0f b6 50 01          	movzbl 0x1(%eax),%edx
  8074d8:	09 ca                	or     %ecx,%edx
  8074da:	83 c0 02             	add    $0x2,%eax
    octetptr++;
    acc += src;
  8074dd:	0f b7 d2             	movzwl %dx,%edx
  8074e0:	01 d3                	add    %edx,%ebx
  8074e2:	eb e4                	jmp    8074c8 <lwip_standard_chksum+0x1c>
    len -= 2;
  }
  if (len > 0) {
  8074e4:	01 ff                	add    %edi,%edi
  8074e6:	66 3b 7d e4          	cmp    -0x1c(%ebp),%di
  8074ea:	74 0b                	je     8074f7 <lwip_standard_chksum+0x4b>
    /* accumulate remaining octet */
    src = (*octetptr) << 8;
  8074ec:	0f b6 00             	movzbl (%eax),%eax
  8074ef:	c1 e0 08             	shl    $0x8,%eax
    acc += src;
  8074f2:	0f b7 c0             	movzwl %ax,%eax
  8074f5:	01 c3                	add    %eax,%ebx
  }
  /* add deferred carry bits */
  acc = (acc >> 16) + (acc & 0x0000ffffUL);
  8074f7:	89 da                	mov    %ebx,%edx
  8074f9:	c1 ea 10             	shr    $0x10,%edx
  8074fc:	0f b7 db             	movzwl %bx,%ebx
  8074ff:	8d 04 1a             	lea    (%edx,%ebx,1),%eax
  if ((acc & 0xffff0000) != 0) {
    acc = (acc >> 16) + (acc & 0x0000ffffUL);
  807502:	0f b7 c8             	movzwl %ax,%ecx
  807505:	83 c1 01             	add    $0x1,%ecx
  807508:	89 c3                	mov    %eax,%ebx
  80750a:	a9 00 00 ff ff       	test   $0xffff0000,%eax
  80750f:	89 c8                	mov    %ecx,%eax
  807511:	0f 44 c3             	cmove  %ebx,%eax
  }
  /* This maybe a little confusing: reorder sum using htons()
     instead of ntohs() since it has a little less call overhead.
     The caller must invert bits for Internet sum ! */
  return htons((u16_t)acc);
  807514:	83 ec 0c             	sub    $0xc,%esp
  807517:	0f b7 c0             	movzwl %ax,%eax
  80751a:	50                   	push   %eax
  80751b:	e8 40 03 00 00       	call   807860 <htons>
}
  807520:	8d 65 f4             	lea    -0xc(%ebp),%esp
  807523:	5b                   	pop    %ebx
  807524:	5e                   	pop    %esi
  807525:	5f                   	pop    %edi
  807526:	5d                   	pop    %ebp
  807527:	c3                   	ret    

00807528 <inet_chksum_pseudo>:
 */
u16_t
inet_chksum_pseudo(struct pbuf *p,
       struct ip_addr *src, struct ip_addr *dest,
       u8_t proto, u16_t proto_len)
{
  807528:	f3 0f 1e fb          	endbr32 
  80752c:	55                   	push   %ebp
  80752d:	89 e5                	mov    %esp,%ebp
  80752f:	57                   	push   %edi
  807530:	56                   	push   %esi
  807531:	53                   	push   %ebx
  807532:	83 ec 1c             	sub    $0x1c,%esp
  807535:	8b 75 08             	mov    0x8(%ebp),%esi
  807538:	8b 45 14             	mov    0x14(%ebp),%eax
  80753b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80753e:	8b 45 18             	mov    0x18(%ebp),%eax
  807541:	89 45 e0             	mov    %eax,-0x20(%ebp)
  u32_t acc;
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  swapped = 0;
  807544:	bf 00 00 00 00       	mov    $0x0,%edi
  acc = 0;
  807549:	bb 00 00 00 00       	mov    $0x0,%ebx
  80754e:	89 f8                	mov    %edi,%eax
  807550:	89 df                	mov    %ebx,%edi
  807552:	89 c3                	mov    %eax,%ebx
  /* iterate through all pbuf in chain */
  for(q = p; q != NULL; q = q->next) {
  807554:	eb 02                	jmp    807558 <inet_chksum_pseudo+0x30>
  807556:	8b 36                	mov    (%esi),%esi
  807558:	85 f6                	test   %esi,%esi
  80755a:	74 3d                	je     807599 <inet_chksum_pseudo+0x71>
    LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): checksumming pbuf %p (has next %p) \n",
      (void *)q, (void *)q->next));
    acc += LWIP_CHKSUM(q->payload, q->len);
  80755c:	0f b7 56 0a          	movzwl 0xa(%esi),%edx
  807560:	8b 46 04             	mov    0x4(%esi),%eax
  807563:	e8 44 ff ff ff       	call   8074ac <lwip_standard_chksum>
  807568:	0f b7 c0             	movzwl %ax,%eax
  80756b:	01 f8                	add    %edi,%eax
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    /* just executing this next line is probably faster that the if statement needed
       to check whether we really need to execute it, and does no harm */
    acc = FOLD_U32T(acc);
  80756d:	89 c7                	mov    %eax,%edi
  80756f:	c1 ef 10             	shr    $0x10,%edi
  807572:	0f b7 c0             	movzwl %ax,%eax
  807575:	01 c7                	add    %eax,%edi
    if (q->len % 2 != 0) {
  807577:	f6 46 0a 01          	testb  $0x1,0xa(%esi)
  80757b:	74 d9                	je     807556 <inet_chksum_pseudo+0x2e>
      swapped = 1 - swapped;
  80757d:	b8 01 00 00 00       	mov    $0x1,%eax
  807582:	29 d8                	sub    %ebx,%eax
  807584:	89 c3                	mov    %eax,%ebx
      acc = SWAP_BYTES_IN_WORD(acc);
  807586:	89 fa                	mov    %edi,%edx
  807588:	c1 e2 08             	shl    $0x8,%edx
  80758b:	0f b7 d2             	movzwl %dx,%edx
  80758e:	89 f8                	mov    %edi,%eax
  807590:	0f b6 c4             	movzbl %ah,%eax
  807593:	09 c2                	or     %eax,%edx
  807595:	89 d7                	mov    %edx,%edi
  807597:	eb bd                	jmp    807556 <inet_chksum_pseudo+0x2e>
  807599:	89 d8                	mov    %ebx,%eax
  80759b:	89 fb                	mov    %edi,%ebx
    }
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): wrapped lwip_chksum()=%"X32_F" \n", acc));*/
  }

  if (swapped) {
  80759d:	84 c0                	test   %al,%al
  80759f:	74 0d                	je     8075ae <inet_chksum_pseudo+0x86>
    acc = SWAP_BYTES_IN_WORD(acc);
  8075a1:	89 f8                	mov    %edi,%eax
  8075a3:	c1 e0 08             	shl    $0x8,%eax
  8075a6:	0f b7 c0             	movzwl %ax,%eax
  8075a9:	0f b6 df             	movzbl %bh,%ebx
  8075ac:	09 c3                	or     %eax,%ebx
  }
  acc += (src->addr & 0xffffUL);
  8075ae:	8b 45 0c             	mov    0xc(%ebp),%eax
  8075b1:	8b 00                	mov    (%eax),%eax
  acc += ((src->addr >> 16) & 0xffffUL);
  acc += (dest->addr & 0xffffUL);
  8075b3:	8b 55 10             	mov    0x10(%ebp),%edx
  8075b6:	8b 12                	mov    (%edx),%edx
  8075b8:	0f b7 ca             	movzwl %dx,%ecx
  acc += ((dest->addr >> 16) & 0xffffUL);
  8075bb:	c1 ea 10             	shr    $0x10,%edx
  8075be:	01 ca                	add    %ecx,%edx
  acc += (src->addr & 0xffffUL);
  8075c0:	0f b7 c8             	movzwl %ax,%ecx
  acc += ((dest->addr >> 16) & 0xffffUL);
  8075c3:	01 ca                	add    %ecx,%edx
  acc += ((src->addr >> 16) & 0xffffUL);
  8075c5:	c1 e8 10             	shr    $0x10,%eax
  acc += ((dest->addr >> 16) & 0xffffUL);
  8075c8:	01 d0                	add    %edx,%eax
  8075ca:	01 c3                	add    %eax,%ebx
  acc += (u32_t)htons((u16_t)proto);
  8075cc:	83 ec 0c             	sub    $0xc,%esp
  8075cf:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
  8075d3:	50                   	push   %eax
  8075d4:	e8 87 02 00 00       	call   807860 <htons>
  8075d9:	0f b7 f0             	movzwl %ax,%esi
  8075dc:	01 de                	add    %ebx,%esi
  acc += (u32_t)htons(proto_len);
  8075de:	0f b7 45 e0          	movzwl -0x20(%ebp),%eax
  8075e2:	89 04 24             	mov    %eax,(%esp)
  8075e5:	e8 76 02 00 00       	call   807860 <htons>
  8075ea:	0f b7 d8             	movzwl %ax,%ebx
  8075ed:	01 f3                	add    %esi,%ebx

  /* Fold 32-bit sum to 16 bits
     calling this twice is propably faster than if statements... */
  acc = FOLD_U32T(acc);
  8075ef:	89 d8                	mov    %ebx,%eax
  8075f1:	c1 e8 10             	shr    $0x10,%eax
  8075f4:	0f b7 db             	movzwl %bx,%ebx
  8075f7:	01 c3                	add    %eax,%ebx
  acc = FOLD_U32T(acc);
  8075f9:	89 d8                	mov    %ebx,%eax
  8075fb:	c1 e8 10             	shr    $0x10,%eax
  8075fe:	01 d8                	add    %ebx,%eax
  LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%"X32_F"\n", acc));
  return (u16_t)~(acc & 0xffffUL);
  807600:	f7 d0                	not    %eax
}
  807602:	8d 65 f4             	lea    -0xc(%ebp),%esp
  807605:	5b                   	pop    %ebx
  807606:	5e                   	pop    %esi
  807607:	5f                   	pop    %edi
  807608:	5d                   	pop    %ebp
  807609:	c3                   	ret    

0080760a <inet_chksum_pseudo_partial>:
 */
u16_t
inet_chksum_pseudo_partial(struct pbuf *p,
       struct ip_addr *src, struct ip_addr *dest,
       u8_t proto, u16_t proto_len, u16_t chksum_len)
{
  80760a:	f3 0f 1e fb          	endbr32 
  80760e:	55                   	push   %ebp
  80760f:	89 e5                	mov    %esp,%ebp
  807611:	57                   	push   %edi
  807612:	56                   	push   %esi
  807613:	53                   	push   %ebx
  807614:	83 ec 1c             	sub    $0x1c,%esp
  807617:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80761a:	8b 45 14             	mov    0x14(%ebp),%eax
  80761d:	89 45 dc             	mov    %eax,-0x24(%ebp)
  807620:	8b 45 18             	mov    0x18(%ebp),%eax
  807623:	89 45 d8             	mov    %eax,-0x28(%ebp)
  807626:	0f b7 75 1c          	movzwl 0x1c(%ebp),%esi
  struct pbuf *q;
  u8_t swapped;
  u16_t chklen;

  acc = 0;
  swapped = 0;
  80762a:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
  acc = 0;
  80762e:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  /* iterate through all pbuf in chain */
  for(q = p; (q != NULL) && (chksum_len > 0); q = q->next) {
  807635:	eb 19                	jmp    807650 <inet_chksum_pseudo_partial+0x46>
    if (chklen > chksum_len) {
      chklen = chksum_len;
    }
    acc += LWIP_CHKSUM(q->payload, chklen);
    chksum_len -= chklen;
    LWIP_ASSERT("delete me", chksum_len < 0x7fff);
  807637:	83 ec 04             	sub    $0x4,%esp
  80763a:	68 15 24 81 00       	push   $0x812415
  80763f:	68 60 01 00 00       	push   $0x160
  807644:	68 20 24 81 00       	push   $0x812420
  807649:	e8 f9 71 00 00       	call   80e847 <_panic>
  for(q = p; (q != NULL) && (chksum_len > 0); q = q->next) {
  80764e:	8b 1b                	mov    (%ebx),%ebx
  807650:	85 db                	test   %ebx,%ebx
  807652:	74 5c                	je     8076b0 <inet_chksum_pseudo_partial+0xa6>
  807654:	66 85 f6             	test   %si,%si
  807657:	74 57                	je     8076b0 <inet_chksum_pseudo_partial+0xa6>
    chklen = q->len;
  807659:	0f b7 7b 0a          	movzwl 0xa(%ebx),%edi
  80765d:	66 39 fe             	cmp    %di,%si
  807660:	0f 46 fe             	cmovbe %esi,%edi
    acc += LWIP_CHKSUM(q->payload, chklen);
  807663:	0f b7 d7             	movzwl %di,%edx
  807666:	8b 43 04             	mov    0x4(%ebx),%eax
  807669:	e8 3e fe ff ff       	call   8074ac <lwip_standard_chksum>
  80766e:	0f b7 c0             	movzwl %ax,%eax
  807671:	03 45 e4             	add    -0x1c(%ebp),%eax
    chksum_len -= chklen;
  807674:	29 fe                	sub    %edi,%esi
    LWIP_ASSERT("delete me", chksum_len < 0x7fff);
  807676:	66 81 fe fe 7f       	cmp    $0x7ffe,%si
  80767b:	77 ba                	ja     807637 <inet_chksum_pseudo_partial+0x2d>
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    /* fold the upper bit down */
    acc = FOLD_U32T(acc);
  80767d:	89 c2                	mov    %eax,%edx
  80767f:	c1 ea 10             	shr    $0x10,%edx
  807682:	0f b7 c0             	movzwl %ax,%eax
  807685:	8d 3c 02             	lea    (%edx,%eax,1),%edi
  807688:	89 7d e4             	mov    %edi,-0x1c(%ebp)
    if (q->len % 2 != 0) {
  80768b:	f6 43 0a 01          	testb  $0x1,0xa(%ebx)
  80768f:	74 bd                	je     80764e <inet_chksum_pseudo_partial+0x44>
      swapped = 1 - swapped;
  807691:	b8 01 00 00 00       	mov    $0x1,%eax
  807696:	2a 45 e3             	sub    -0x1d(%ebp),%al
  807699:	88 45 e3             	mov    %al,-0x1d(%ebp)
      acc = SWAP_BYTES_IN_WORD(acc);
  80769c:	89 fa                	mov    %edi,%edx
  80769e:	c1 e2 08             	shl    $0x8,%edx
  8076a1:	0f b7 d2             	movzwl %dx,%edx
  8076a4:	89 f8                	mov    %edi,%eax
  8076a6:	0f b6 c4             	movzbl %ah,%eax
  8076a9:	09 c2                	or     %eax,%edx
  8076ab:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  8076ae:	eb 9e                	jmp    80764e <inet_chksum_pseudo_partial+0x44>
    }
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): wrapped lwip_chksum()=%"X32_F" \n", acc));*/
  }

  if (swapped) {
  8076b0:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
  8076b4:	74 13                	je     8076c9 <inet_chksum_pseudo_partial+0xbf>
    acc = SWAP_BYTES_IN_WORD(acc);
  8076b6:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  8076b9:	89 c8                	mov    %ecx,%eax
  8076bb:	c1 e0 08             	shl    $0x8,%eax
  8076be:	0f b7 c0             	movzwl %ax,%eax
  8076c1:	0f b6 d5             	movzbl %ch,%edx
  8076c4:	09 d0                	or     %edx,%eax
  8076c6:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  }
  acc += (src->addr & 0xffffUL);
  8076c9:	8b 45 0c             	mov    0xc(%ebp),%eax
  8076cc:	8b 18                	mov    (%eax),%ebx
  acc += ((src->addr >> 16) & 0xffffUL);
  acc += (dest->addr & 0xffffUL);
  8076ce:	8b 45 10             	mov    0x10(%ebp),%eax
  8076d1:	8b 00                	mov    (%eax),%eax
  8076d3:	0f b7 d0             	movzwl %ax,%edx
  acc += ((dest->addr >> 16) & 0xffffUL);
  8076d6:	c1 e8 10             	shr    $0x10,%eax
  8076d9:	01 d0                	add    %edx,%eax
  acc += (src->addr & 0xffffUL);
  8076db:	0f b7 d3             	movzwl %bx,%edx
  acc += ((dest->addr >> 16) & 0xffffUL);
  8076de:	01 d0                	add    %edx,%eax
  acc += ((src->addr >> 16) & 0xffffUL);
  8076e0:	c1 eb 10             	shr    $0x10,%ebx
  acc += ((dest->addr >> 16) & 0xffffUL);
  8076e3:	01 c3                	add    %eax,%ebx
  8076e5:	03 5d e4             	add    -0x1c(%ebp),%ebx
  acc += (u32_t)htons((u16_t)proto);
  8076e8:	83 ec 0c             	sub    $0xc,%esp
  8076eb:	0f b6 45 dc          	movzbl -0x24(%ebp),%eax
  8076ef:	50                   	push   %eax
  8076f0:	e8 6b 01 00 00       	call   807860 <htons>
  8076f5:	0f b7 f0             	movzwl %ax,%esi
  8076f8:	01 de                	add    %ebx,%esi
  acc += (u32_t)htons(proto_len);
  8076fa:	0f b7 45 d8          	movzwl -0x28(%ebp),%eax
  8076fe:	89 04 24             	mov    %eax,(%esp)
  807701:	e8 5a 01 00 00       	call   807860 <htons>
  807706:	0f b7 d8             	movzwl %ax,%ebx
  807709:	01 f3                	add    %esi,%ebx

  /* Fold 32-bit sum to 16 bits
     calling this twice is propably faster than if statements... */
  acc = FOLD_U32T(acc);
  80770b:	89 d8                	mov    %ebx,%eax
  80770d:	c1 e8 10             	shr    $0x10,%eax
  807710:	0f b7 db             	movzwl %bx,%ebx
  807713:	01 c3                	add    %eax,%ebx
  acc = FOLD_U32T(acc);
  807715:	89 d8                	mov    %ebx,%eax
  807717:	c1 e8 10             	shr    $0x10,%eax
  80771a:	01 d8                	add    %ebx,%eax
  LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%"X32_F"\n", acc));
  return (u16_t)~(acc & 0xffffUL);
  80771c:	f7 d0                	not    %eax
}
  80771e:	8d 65 f4             	lea    -0xc(%ebp),%esp
  807721:	5b                   	pop    %ebx
  807722:	5e                   	pop    %esi
  807723:	5f                   	pop    %edi
  807724:	5d                   	pop    %ebp
  807725:	c3                   	ret    

00807726 <inet_chksum>:
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */

u16_t
inet_chksum(void *dataptr, u16_t len)
{
  807726:	f3 0f 1e fb          	endbr32 
  80772a:	55                   	push   %ebp
  80772b:	89 e5                	mov    %esp,%ebp
  80772d:	83 ec 08             	sub    $0x8,%esp
  return ~LWIP_CHKSUM(dataptr, len);
  807730:	0f b7 55 0c          	movzwl 0xc(%ebp),%edx
  807734:	8b 45 08             	mov    0x8(%ebp),%eax
  807737:	e8 70 fd ff ff       	call   8074ac <lwip_standard_chksum>
  80773c:	f7 d0                	not    %eax
}
  80773e:	c9                   	leave  
  80773f:	c3                   	ret    

00807740 <inet_chksum_pbuf>:
 * @param p pbuf chain over that the checksum should be calculated
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */
u16_t
inet_chksum_pbuf(struct pbuf *p)
{
  807740:	f3 0f 1e fb          	endbr32 
  807744:	55                   	push   %ebp
  807745:	89 e5                	mov    %esp,%ebp
  807747:	57                   	push   %edi
  807748:	56                   	push   %esi
  807749:	53                   	push   %ebx
  80774a:	83 ec 0c             	sub    $0xc,%esp
  80774d:	8b 75 08             	mov    0x8(%ebp),%esi
  u32_t acc;
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  swapped = 0;
  807750:	bf 00 00 00 00       	mov    $0x0,%edi
  acc = 0;
  807755:	bb 00 00 00 00       	mov    $0x0,%ebx
  for(q = p; q != NULL; q = q->next) {
  80775a:	eb 02                	jmp    80775e <inet_chksum_pbuf+0x1e>
  80775c:	8b 36                	mov    (%esi),%esi
  80775e:	85 f6                	test   %esi,%esi
  807760:	74 3b                	je     80779d <inet_chksum_pbuf+0x5d>
    acc += LWIP_CHKSUM(q->payload, q->len);
  807762:	0f b7 56 0a          	movzwl 0xa(%esi),%edx
  807766:	8b 46 04             	mov    0x4(%esi),%eax
  807769:	e8 3e fd ff ff       	call   8074ac <lwip_standard_chksum>
  80776e:	0f b7 c0             	movzwl %ax,%eax
  807771:	01 c3                	add    %eax,%ebx
    acc = FOLD_U32T(acc);
  807773:	89 d8                	mov    %ebx,%eax
  807775:	c1 e8 10             	shr    $0x10,%eax
  807778:	0f b7 db             	movzwl %bx,%ebx
  80777b:	01 c3                	add    %eax,%ebx
    if (q->len % 2 != 0) {
  80777d:	f6 46 0a 01          	testb  $0x1,0xa(%esi)
  807781:	74 d9                	je     80775c <inet_chksum_pbuf+0x1c>
      swapped = 1 - swapped;
  807783:	b8 01 00 00 00       	mov    $0x1,%eax
  807788:	89 f9                	mov    %edi,%ecx
  80778a:	29 c8                	sub    %ecx,%eax
  80778c:	89 c7                	mov    %eax,%edi
      acc = SWAP_BYTES_IN_WORD(acc);
  80778e:	89 da                	mov    %ebx,%edx
  807790:	c1 e2 08             	shl    $0x8,%edx
  807793:	0f b7 d2             	movzwl %dx,%edx
  807796:	0f b6 df             	movzbl %bh,%ebx
  807799:	09 d3                	or     %edx,%ebx
  80779b:	eb bf                	jmp    80775c <inet_chksum_pbuf+0x1c>
    }
  }

  if (swapped) {
  80779d:	89 f8                	mov    %edi,%eax
  80779f:	84 c0                	test   %al,%al
  8077a1:	74 0d                	je     8077b0 <inet_chksum_pbuf+0x70>
    acc = SWAP_BYTES_IN_WORD(acc);
  8077a3:	89 da                	mov    %ebx,%edx
  8077a5:	c1 e2 08             	shl    $0x8,%edx
  8077a8:	0f b7 d2             	movzwl %dx,%edx
  8077ab:	0f b6 df             	movzbl %bh,%ebx
  8077ae:	09 d3                	or     %edx,%ebx
  }
  return (u16_t)~(acc & 0xffffUL);
  8077b0:	89 d8                	mov    %ebx,%eax
  8077b2:	f7 d0                	not    %eax
}
  8077b4:	83 c4 0c             	add    $0xc,%esp
  8077b7:	5b                   	pop    %ebx
  8077b8:	5e                   	pop    %esi
  8077b9:	5f                   	pop    %edi
  8077ba:	5d                   	pop    %ebp
  8077bb:	c3                   	ret    

008077bc <inet_ntoa>:
 * @return pointer to a global static (!) buffer that holds the ASCII
 *         represenation of addr
 */
char *
inet_ntoa(struct in_addr addr)
{
  8077bc:	f3 0f 1e fb          	endbr32 
  8077c0:	55                   	push   %ebp
  8077c1:	89 e5                	mov    %esp,%ebp
  8077c3:	57                   	push   %edi
  8077c4:	56                   	push   %esi
  8077c5:	53                   	push   %ebx
  8077c6:	83 ec 18             	sub    $0x18,%esp
  static char str[16];
  u32_t s_addr = addr.s_addr;
  8077c9:	8b 45 08             	mov    0x8(%ebp),%eax
  8077cc:	89 45 f0             	mov    %eax,-0x10(%ebp)
  u8_t n;
  u8_t i;

  rp = str;
  ap = (u8_t *)&s_addr;
  for(n = 0; n < 4; n++) {
  8077cf:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
  ap = (u8_t *)&s_addr;
  8077d3:	8d 75 f0             	lea    -0x10(%ebp),%esi
  rp = str;
  8077d6:	bf e4 49 b3 00       	mov    $0xb349e4,%edi
  8077db:	eb 2e                	jmp    80780b <inet_ntoa+0x4f>
      rem = *ap % (u8_t)10;
      *ap /= (u8_t)10;
      inv[i++] = '0' + rem;
    } while(*ap);
    while(i--)
      *rp++ = inv[i];
  8077dd:	0f b6 c8             	movzbl %al,%ecx
  8077e0:	0f b6 4c 0d ed       	movzbl -0x13(%ebp,%ecx,1),%ecx
  8077e5:	88 0a                	mov    %cl,(%edx)
  8077e7:	83 c2 01             	add    $0x1,%edx
    while(i--)
  8077ea:	83 e8 01             	sub    $0x1,%eax
  8077ed:	3c ff                	cmp    $0xff,%al
  8077ef:	75 ec                	jne    8077dd <inet_ntoa+0x21>
  8077f1:	0f b6 db             	movzbl %bl,%ebx
  8077f4:	01 fb                	add    %edi,%ebx
    *rp++ = '.';
  8077f6:	8d 7b 01             	lea    0x1(%ebx),%edi
  8077f9:	c6 03 2e             	movb   $0x2e,(%ebx)
  8077fc:	83 c6 01             	add    $0x1,%esi
  for(n = 0; n < 4; n++) {
  8077ff:	80 45 df 01          	addb   $0x1,-0x21(%ebp)
  807803:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
  807807:	3c 04                	cmp    $0x4,%al
  807809:	74 45                	je     807850 <inet_ntoa+0x94>
  rp = str;
  80780b:	bb 00 00 00 00       	mov    $0x0,%ebx
      rem = *ap % (u8_t)10;
  807810:	0f b6 16             	movzbl (%esi),%edx
      *ap /= (u8_t)10;
  807813:	0f b6 ca             	movzbl %dl,%ecx
  807816:	8d 04 89             	lea    (%ecx,%ecx,4),%eax
  807819:	8d 04 c1             	lea    (%ecx,%eax,8),%eax
  80781c:	8d 04 80             	lea    (%eax,%eax,4),%eax
  80781f:	66 c1 e8 0b          	shr    $0xb,%ax
  807823:	88 06                	mov    %al,(%esi)
  807825:	89 d9                	mov    %ebx,%ecx
      inv[i++] = '0' + rem;
  807827:	83 c3 01             	add    $0x1,%ebx
  80782a:	0f b6 c9             	movzbl %cl,%ecx
  80782d:	89 4d e0             	mov    %ecx,-0x20(%ebp)
      rem = *ap % (u8_t)10;
  807830:	8d 04 80             	lea    (%eax,%eax,4),%eax
  807833:	01 c0                	add    %eax,%eax
  807835:	89 d1                	mov    %edx,%ecx
  807837:	29 c1                	sub    %eax,%ecx
  807839:	89 c8                	mov    %ecx,%eax
      inv[i++] = '0' + rem;
  80783b:	83 c0 30             	add    $0x30,%eax
  80783e:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  807841:	88 44 0d ed          	mov    %al,-0x13(%ebp,%ecx,1)
    } while(*ap);
  807845:	80 fa 09             	cmp    $0x9,%dl
  807848:	77 c6                	ja     807810 <inet_ntoa+0x54>
  80784a:	89 fa                	mov    %edi,%edx
      inv[i++] = '0' + rem;
  80784c:	89 d8                	mov    %ebx,%eax
  80784e:	eb 9a                	jmp    8077ea <inet_ntoa+0x2e>
    ap++;
  }
  *--rp = 0;
  807850:	c6 03 00             	movb   $0x0,(%ebx)
  return str;
}
  807853:	b8 e4 49 b3 00       	mov    $0xb349e4,%eax
  807858:	83 c4 18             	add    $0x18,%esp
  80785b:	5b                   	pop    %ebx
  80785c:	5e                   	pop    %esi
  80785d:	5f                   	pop    %edi
  80785e:	5d                   	pop    %ebp
  80785f:	c3                   	ret    

00807860 <htons>:
 * @param n u16_t in host byte order
 * @return n in network byte order
 */
u16_t
htons(u16_t n)
{
  807860:	f3 0f 1e fb          	endbr32 
  807864:	55                   	push   %ebp
  807865:	89 e5                	mov    %esp,%ebp
  return ((n & 0xff) << 8) | ((n & 0xff00) >> 8);
  807867:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
  80786b:	66 c1 c0 08          	rol    $0x8,%ax
}
  80786f:	5d                   	pop    %ebp
  807870:	c3                   	ret    

00807871 <ntohs>:
 * @param n u16_t in network byte order
 * @return n in host byte order
 */
u16_t
ntohs(u16_t n)
{
  807871:	f3 0f 1e fb          	endbr32 
  807875:	55                   	push   %ebp
  807876:	89 e5                	mov    %esp,%ebp
  return ((n & 0xff) << 8) | ((n & 0xff00) >> 8);
  807878:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
  80787c:	66 c1 c0 08          	rol    $0x8,%ax
  return htons(n);
}
  807880:	5d                   	pop    %ebp
  807881:	c3                   	ret    

00807882 <htonl>:
 * @param n u32_t in host byte order
 * @return n in network byte order
 */
u32_t
htonl(u32_t n)
{
  807882:	f3 0f 1e fb          	endbr32 
  807886:	55                   	push   %ebp
  807887:	89 e5                	mov    %esp,%ebp
  807889:	8b 55 08             	mov    0x8(%ebp),%edx
  return ((n & 0xff) << 24) |
  80788c:	89 d0                	mov    %edx,%eax
  80788e:	c1 e0 18             	shl    $0x18,%eax
    ((n & 0xff00) << 8) |
    ((n & 0xff0000UL) >> 8) |
    ((n & 0xff000000UL) >> 24);
  807891:	89 d1                	mov    %edx,%ecx
  807893:	c1 e9 18             	shr    $0x18,%ecx
    ((n & 0xff0000UL) >> 8) |
  807896:	09 c8                	or     %ecx,%eax
    ((n & 0xff00) << 8) |
  807898:	89 d1                	mov    %edx,%ecx
  80789a:	c1 e1 08             	shl    $0x8,%ecx
  80789d:	81 e1 00 00 ff 00    	and    $0xff0000,%ecx
    ((n & 0xff0000UL) >> 8) |
  8078a3:	09 c8                	or     %ecx,%eax
  8078a5:	c1 ea 08             	shr    $0x8,%edx
  8078a8:	81 e2 00 ff 00 00    	and    $0xff00,%edx
  8078ae:	09 d0                	or     %edx,%eax
}
  8078b0:	5d                   	pop    %ebp
  8078b1:	c3                   	ret    

008078b2 <inet_aton>:
{
  8078b2:	f3 0f 1e fb          	endbr32 
  8078b6:	55                   	push   %ebp
  8078b7:	89 e5                	mov    %esp,%ebp
  8078b9:	57                   	push   %edi
  8078ba:	56                   	push   %esi
  8078bb:	53                   	push   %ebx
  8078bc:	83 ec 2c             	sub    $0x2c,%esp
  8078bf:	8b 55 08             	mov    0x8(%ebp),%edx
  c = *cp;
  8078c2:	0f be 02             	movsbl (%edx),%eax
  u32_t *pp = parts;
  8078c5:	8d 75 d8             	lea    -0x28(%ebp),%esi
  8078c8:	89 75 cc             	mov    %esi,-0x34(%ebp)
  8078cb:	e9 a7 00 00 00       	jmp    807977 <inet_aton+0xc5>
      c = *++cp;
  8078d0:	0f b6 42 01          	movzbl 0x1(%edx),%eax
      if (c == 'x' || c == 'X') {
  8078d4:	89 c1                	mov    %eax,%ecx
  8078d6:	83 e1 df             	and    $0xffffffdf,%ecx
  8078d9:	80 f9 58             	cmp    $0x58,%cl
  8078dc:	74 10                	je     8078ee <inet_aton+0x3c>
      c = *++cp;
  8078de:	83 c2 01             	add    $0x1,%edx
  8078e1:	0f be c0             	movsbl %al,%eax
        base = 8;
  8078e4:	be 08 00 00 00       	mov    $0x8,%esi
  8078e9:	e9 a3 00 00 00       	jmp    807991 <inet_aton+0xdf>
        c = *++cp;
  8078ee:	0f be 42 02          	movsbl 0x2(%edx),%eax
  8078f2:	8d 52 02             	lea    0x2(%edx),%edx
        base = 16;
  8078f5:	be 10 00 00 00       	mov    $0x10,%esi
  8078fa:	e9 92 00 00 00       	jmp    807991 <inet_aton+0xdf>
      } else if (base == 16 && isxdigit(c)) {
  8078ff:	83 fe 10             	cmp    $0x10,%esi
  807902:	75 4d                	jne    807951 <inet_aton+0x9f>
  807904:	8d 4f 9f             	lea    -0x61(%edi),%ecx
  807907:	88 4d d3             	mov    %cl,-0x2d(%ebp)
  80790a:	89 c1                	mov    %eax,%ecx
  80790c:	83 e1 df             	and    $0xffffffdf,%ecx
  80790f:	83 e9 41             	sub    $0x41,%ecx
  807912:	80 f9 05             	cmp    $0x5,%cl
  807915:	77 3a                	ja     807951 <inet_aton+0x9f>
        val = (val << 4) | (int)(c + 10 - (islower(c) ? 'a' : 'A'));
  807917:	c1 e3 04             	shl    $0x4,%ebx
  80791a:	83 c0 0a             	add    $0xa,%eax
  80791d:	80 7d d3 1a          	cmpb   $0x1a,-0x2d(%ebp)
  807921:	19 c9                	sbb    %ecx,%ecx
  807923:	83 e1 20             	and    $0x20,%ecx
  807926:	83 c1 41             	add    $0x41,%ecx
  807929:	29 c8                	sub    %ecx,%eax
  80792b:	09 c3                	or     %eax,%ebx
        c = *++cp;
  80792d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  807930:	0f be 40 01          	movsbl 0x1(%eax),%eax
  807934:	83 c2 01             	add    $0x1,%edx
  807937:	89 55 d4             	mov    %edx,-0x2c(%ebp)
      if (isdigit(c)) {
  80793a:	89 c7                	mov    %eax,%edi
  80793c:	8d 48 d0             	lea    -0x30(%eax),%ecx
  80793f:	80 f9 09             	cmp    $0x9,%cl
  807942:	77 bb                	ja     8078ff <inet_aton+0x4d>
        val = (val * base) + (int)(c - '0');
  807944:	0f af de             	imul   %esi,%ebx
  807947:	8d 5c 18 d0          	lea    -0x30(%eax,%ebx,1),%ebx
        c = *++cp;
  80794b:	0f be 42 01          	movsbl 0x1(%edx),%eax
  80794f:	eb e3                	jmp    807934 <inet_aton+0x82>
    if (c == '.') {
  807951:	83 f8 2e             	cmp    $0x2e,%eax
  807954:	75 42                	jne    807998 <inet_aton+0xe6>
      if (pp >= parts + 3)
  807956:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  807959:	8b 75 cc             	mov    -0x34(%ebp),%esi
  80795c:	39 c6                	cmp    %eax,%esi
  80795e:	0f 84 16 01 00 00    	je     807a7a <inet_aton+0x1c8>
      *pp++ = val;
  807964:	83 c6 04             	add    $0x4,%esi
  807967:	89 75 cc             	mov    %esi,-0x34(%ebp)
  80796a:	89 5e fc             	mov    %ebx,-0x4(%esi)
      c = *++cp;
  80796d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  807970:	8d 50 01             	lea    0x1(%eax),%edx
  807973:	0f be 40 01          	movsbl 0x1(%eax),%eax
    if (!isdigit(c))
  807977:	8d 48 d0             	lea    -0x30(%eax),%ecx
  80797a:	80 f9 09             	cmp    $0x9,%cl
  80797d:	0f 87 f0 00 00 00    	ja     807a73 <inet_aton+0x1c1>
    base = 10;
  807983:	be 0a 00 00 00       	mov    $0xa,%esi
    if (c == '0') {
  807988:	83 f8 30             	cmp    $0x30,%eax
  80798b:	0f 84 3f ff ff ff    	je     8078d0 <inet_aton+0x1e>
    base = 10;
  807991:	bb 00 00 00 00       	mov    $0x0,%ebx
  807996:	eb 9f                	jmp    807937 <inet_aton+0x85>
  if (c != '\0' && (!isprint(c) || !isspace(c)))
  807998:	85 c0                	test   %eax,%eax
  80799a:	74 29                	je     8079c5 <inet_aton+0x113>
    return (0);
  80799c:	ba 00 00 00 00       	mov    $0x0,%edx
  if (c != '\0' && (!isprint(c) || !isspace(c)))
  8079a1:	89 f9                	mov    %edi,%ecx
  8079a3:	80 f9 1f             	cmp    $0x1f,%cl
  8079a6:	0f 86 d3 00 00 00    	jbe    807a7f <inet_aton+0x1cd>
  8079ac:	84 c0                	test   %al,%al
  8079ae:	0f 88 cb 00 00 00    	js     807a7f <inet_aton+0x1cd>
  8079b4:	83 f8 20             	cmp    $0x20,%eax
  8079b7:	74 0c                	je     8079c5 <inet_aton+0x113>
  8079b9:	83 e8 09             	sub    $0x9,%eax
  8079bc:	83 f8 04             	cmp    $0x4,%eax
  8079bf:	0f 87 ba 00 00 00    	ja     807a7f <inet_aton+0x1cd>
  n = pp - parts + 1;
  8079c5:	8d 45 d8             	lea    -0x28(%ebp),%eax
  8079c8:	8b 75 cc             	mov    -0x34(%ebp),%esi
  8079cb:	29 c6                	sub    %eax,%esi
  8079cd:	89 f0                	mov    %esi,%eax
  8079cf:	c1 f8 02             	sar    $0x2,%eax
  8079d2:	8d 50 01             	lea    0x1(%eax),%edx
  switch (n) {
  8079d5:	83 f8 02             	cmp    $0x2,%eax
  8079d8:	74 7a                	je     807a54 <inet_aton+0x1a2>
  8079da:	83 fa 03             	cmp    $0x3,%edx
  8079dd:	7f 49                	jg     807a28 <inet_aton+0x176>
  8079df:	85 d2                	test   %edx,%edx
  8079e1:	0f 84 98 00 00 00    	je     807a7f <inet_aton+0x1cd>
  8079e7:	83 fa 02             	cmp    $0x2,%edx
  8079ea:	75 19                	jne    807a05 <inet_aton+0x153>
      return (0);
  8079ec:	ba 00 00 00 00       	mov    $0x0,%edx
    if (val > 0xffffffUL)
  8079f1:	81 fb ff ff ff 00    	cmp    $0xffffff,%ebx
  8079f7:	0f 87 82 00 00 00    	ja     807a7f <inet_aton+0x1cd>
    val |= parts[0] << 24;
  8079fd:	8b 45 d8             	mov    -0x28(%ebp),%eax
  807a00:	c1 e0 18             	shl    $0x18,%eax
  807a03:	09 c3                	or     %eax,%ebx
  return (1);
  807a05:	ba 01 00 00 00       	mov    $0x1,%edx
  if (addr)
  807a0a:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  807a0e:	74 6f                	je     807a7f <inet_aton+0x1cd>
    addr->s_addr = htonl(val);
  807a10:	83 ec 0c             	sub    $0xc,%esp
  807a13:	53                   	push   %ebx
  807a14:	e8 69 fe ff ff       	call   807882 <htonl>
  807a19:	83 c4 10             	add    $0x10,%esp
  807a1c:	8b 75 0c             	mov    0xc(%ebp),%esi
  807a1f:	89 06                	mov    %eax,(%esi)
  return (1);
  807a21:	ba 01 00 00 00       	mov    $0x1,%edx
  807a26:	eb 57                	jmp    807a7f <inet_aton+0x1cd>
  switch (n) {
  807a28:	83 fa 04             	cmp    $0x4,%edx
  807a2b:	75 d8                	jne    807a05 <inet_aton+0x153>
      return (0);
  807a2d:	ba 00 00 00 00       	mov    $0x0,%edx
    if (val > 0xff)
  807a32:	81 fb ff 00 00 00    	cmp    $0xff,%ebx
  807a38:	77 45                	ja     807a7f <inet_aton+0x1cd>
    val |= (parts[0] << 24) | (parts[1] << 16) | (parts[2] << 8);
  807a3a:	8b 45 d8             	mov    -0x28(%ebp),%eax
  807a3d:	c1 e0 18             	shl    $0x18,%eax
  807a40:	8b 55 dc             	mov    -0x24(%ebp),%edx
  807a43:	c1 e2 10             	shl    $0x10,%edx
  807a46:	09 d0                	or     %edx,%eax
  807a48:	8b 55 e0             	mov    -0x20(%ebp),%edx
  807a4b:	c1 e2 08             	shl    $0x8,%edx
  807a4e:	09 d0                	or     %edx,%eax
  807a50:	09 c3                	or     %eax,%ebx
    break;
  807a52:	eb b1                	jmp    807a05 <inet_aton+0x153>
      return (0);
  807a54:	ba 00 00 00 00       	mov    $0x0,%edx
    if (val > 0xffff)
  807a59:	81 fb ff ff 00 00    	cmp    $0xffff,%ebx
  807a5f:	77 1e                	ja     807a7f <inet_aton+0x1cd>
    val |= (parts[0] << 24) | (parts[1] << 16);
  807a61:	8b 45 d8             	mov    -0x28(%ebp),%eax
  807a64:	c1 e0 18             	shl    $0x18,%eax
  807a67:	8b 55 dc             	mov    -0x24(%ebp),%edx
  807a6a:	c1 e2 10             	shl    $0x10,%edx
  807a6d:	09 d0                	or     %edx,%eax
  807a6f:	09 c3                	or     %eax,%ebx
    break;
  807a71:	eb 92                	jmp    807a05 <inet_aton+0x153>
      return (0);
  807a73:	ba 00 00 00 00       	mov    $0x0,%edx
  807a78:	eb 05                	jmp    807a7f <inet_aton+0x1cd>
        return (0);
  807a7a:	ba 00 00 00 00       	mov    $0x0,%edx
}
  807a7f:	89 d0                	mov    %edx,%eax
  807a81:	8d 65 f4             	lea    -0xc(%ebp),%esp
  807a84:	5b                   	pop    %ebx
  807a85:	5e                   	pop    %esi
  807a86:	5f                   	pop    %edi
  807a87:	5d                   	pop    %ebp
  807a88:	c3                   	ret    

00807a89 <inet_addr>:
{
  807a89:	f3 0f 1e fb          	endbr32 
  807a8d:	55                   	push   %ebp
  807a8e:	89 e5                	mov    %esp,%ebp
  807a90:	83 ec 20             	sub    $0x20,%esp
  if (inet_aton(cp, &val)) {
  807a93:	8d 45 f4             	lea    -0xc(%ebp),%eax
  807a96:	50                   	push   %eax
  807a97:	ff 75 08             	pushl  0x8(%ebp)
  807a9a:	e8 13 fe ff ff       	call   8078b2 <inet_aton>
  807a9f:	83 c4 10             	add    $0x10,%esp
    return (val.s_addr);
  807aa2:	85 c0                	test   %eax,%eax
  807aa4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  807aa9:	0f 45 45 f4          	cmovne -0xc(%ebp),%eax
}
  807aad:	c9                   	leave  
  807aae:	c3                   	ret    

00807aaf <ntohl>:
 * @param n u32_t in network byte order
 * @return n in host byte order
 */
u32_t
ntohl(u32_t n)
{
  807aaf:	f3 0f 1e fb          	endbr32 
  807ab3:	55                   	push   %ebp
  807ab4:	89 e5                	mov    %esp,%ebp
  807ab6:	83 ec 14             	sub    $0x14,%esp
  return htonl(n);
  807ab9:	ff 75 08             	pushl  0x8(%ebp)
  807abc:	e8 c1 fd ff ff       	call   807882 <htonl>
  807ac1:	83 c4 10             	add    $0x10,%esp
}
  807ac4:	c9                   	leave  
  807ac5:	c3                   	ret    

00807ac6 <tcp_enqueue>:
 */
err_t
tcp_enqueue(struct tcp_pcb *pcb, void *arg, u16_t len,
  u8_t flags, u8_t apiflags,
  u8_t *optdata, u8_t optlen)
{
  807ac6:	f3 0f 1e fb          	endbr32 
  807aca:	55                   	push   %ebp
  807acb:	89 e5                	mov    %esp,%ebp
  807acd:	57                   	push   %edi
  807ace:	56                   	push   %esi
  807acf:	53                   	push   %ebx
  807ad0:	83 ec 3c             	sub    $0x3c,%esp
  807ad3:	8b 7d 08             	mov    0x8(%ebp),%edi
  807ad6:	8b 75 10             	mov    0x10(%ebp),%esi
  807ad9:	89 75 c4             	mov    %esi,-0x3c(%ebp)
  807adc:	8b 55 14             	mov    0x14(%ebp),%edx
  807adf:	89 55 bc             	mov    %edx,-0x44(%ebp)
  807ae2:	8b 5d 18             	mov    0x18(%ebp),%ebx
  807ae5:	89 5d b8             	mov    %ebx,-0x48(%ebp)
  807ae8:	8b 45 20             	mov    0x20(%ebp),%eax
  807aeb:	66 89 75 c2          	mov    %si,-0x3e(%ebp)
  807aef:	88 55 dd             	mov    %dl,-0x23(%ebp)
  807af2:	89 da                	mov    %ebx,%edx
  807af4:	88 45 dc             	mov    %al,-0x24(%ebp)
  void *ptr;
  u16_t queuelen;

  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_enqueue(pcb=%p, arg=%p, len=%"U16_F", flags=%"X16_F", apiflags=%"U16_F")\n",
    (void *)pcb, arg, len, (u16_t)flags, (u16_t)apiflags));
  LWIP_ERROR("tcp_enqueue: len == 0 || optlen == 0 (programmer violates API)",
  807af7:	66 85 f6             	test   %si,%si
  807afa:	74 04                	je     807b00 <tcp_enqueue+0x3a>
  807afc:	84 c0                	test   %al,%al
  807afe:	75 54                	jne    807b54 <tcp_enqueue+0x8e>
      ((len == 0) || (optlen == 0)), return ERR_ARG;);
  LWIP_ERROR("tcp_enqueue: arg == NULL || optdata == NULL (programmer violates API)",
  807b00:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  807b04:	74 06                	je     807b0c <tcp_enqueue+0x46>
  807b06:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  807b0a:	75 5f                	jne    807b6b <tcp_enqueue+0xa5>
      ((arg == NULL) || (optdata == NULL)), return ERR_ARG;);
  /* fail on too much data */
  if (len > pcb->snd_buf) {
  807b0c:	0f b7 4d c4          	movzwl -0x3c(%ebp),%ecx
  807b10:	66 39 4f 6e          	cmp    %cx,0x6e(%edi)
  807b14:	72 6c                	jb     807b82 <tcp_enqueue+0xbc>
  left = len;
  ptr = arg;

  /* seqno will be the sequence number of the first segment enqueued
   * by the call to this function. */
  seqno = pcb->snd_lbb;
  807b16:	8b 4f 68             	mov    0x68(%edi),%ecx
  807b19:	89 4d d8             	mov    %ecx,-0x28(%ebp)

  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue: queuelen: %"U16_F"\n", (u16_t)pcb->snd_queuelen));

  /* If total number of pbufs on the unsent/unacked queues exceeds the
   * configured maximum, return an error */
  queuelen = pcb->snd_queuelen;
  807b1c:	0f b7 4f 70          	movzwl 0x70(%edi),%ecx
  807b20:	66 89 4d e0          	mov    %cx,-0x20(%ebp)
  /* check for configured max queuelen and possible overflow */
  if ((queuelen >= TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
  807b24:	66 83 f9 1f          	cmp    $0x1f,%cx
  807b28:	77 66                	ja     807b90 <tcp_enqueue+0xca>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_enqueue: too long queue %"U16_F" (max %"U16_F")\n", queuelen, TCP_SND_QUEUELEN));
    TCP_STATS_INC(tcp.memerr);
    pcb->flags |= TF_NAGLEMEMERR;
    return ERR_MEM;
  }
  if (queuelen != 0) {
  807b2a:	66 83 7d e0 00       	cmpw   $0x0,-0x20(%ebp)
  807b2f:	74 6d                	je     807b9e <tcp_enqueue+0xd8>
    LWIP_ASSERT("tcp_enqueue: pbufs on queue => at least one queue non-empty",
  807b31:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  807b35:	75 7b                	jne    807bb2 <tcp_enqueue+0xec>
  807b37:	83 7f 74 00          	cmpl   $0x0,0x74(%edi)
  807b3b:	75 75                	jne    807bb2 <tcp_enqueue+0xec>
  807b3d:	83 ec 04             	sub    $0x4,%esp
  807b40:	68 cc 24 81 00       	push   $0x8124cc
  807b45:	68 ad 00 00 00       	push   $0xad
  807b4a:	68 e6 25 81 00       	push   $0x8125e6
  807b4f:	e8 f3 6c 00 00       	call   80e847 <_panic>
  LWIP_ERROR("tcp_enqueue: len == 0 || optlen == 0 (programmer violates API)",
  807b54:	83 ec 04             	sub    $0x4,%esp
  807b57:	68 44 24 81 00       	push   $0x812444
  807b5c:	68 8f 00 00 00       	push   $0x8f
  807b61:	68 e6 25 81 00       	push   $0x8125e6
  807b66:	e8 dc 6c 00 00       	call   80e847 <_panic>
  LWIP_ERROR("tcp_enqueue: arg == NULL || optdata == NULL (programmer violates API)",
  807b6b:	83 ec 04             	sub    $0x4,%esp
  807b6e:	68 84 24 81 00       	push   $0x812484
  807b73:	68 91 00 00 00       	push   $0x91
  807b78:	68 e6 25 81 00       	push   $0x8125e6
  807b7d:	e8 c5 6c 00 00       	call   80e847 <_panic>
    pcb->flags |= TF_NAGLEMEMERR;
  807b82:	80 4f 20 80          	orb    $0x80,0x20(%edi)
    return ERR_MEM;
  807b86:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  807b8b:	e9 64 04 00 00       	jmp    807ff4 <tcp_enqueue+0x52e>
    pcb->flags |= TF_NAGLEMEMERR;
  807b90:	80 4f 20 80          	orb    $0x80,0x20(%edi)
    return ERR_MEM;
  807b94:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  807b99:	e9 56 04 00 00       	jmp    807ff4 <tcp_enqueue+0x52e>
      pcb->unacked != NULL || pcb->unsent != NULL);
  } else {
    LWIP_ASSERT("tcp_enqueue: no pbufs on queue => both queues empty",
  807b9e:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  807ba2:	0f 85 c5 02 00 00    	jne    807e6d <tcp_enqueue+0x3a7>
  807ba8:	83 7f 74 00          	cmpl   $0x0,0x74(%edi)
  807bac:	0f 85 bb 02 00 00    	jne    807e6d <tcp_enqueue+0x3a7>
    /* Copy the options into the header, if they are present. */
    if (optdata == NULL) {
      TCPH_HDRLEN_SET(seg->tcphdr, 5);
    }
    else {
      TCPH_HDRLEN_SET(seg->tcphdr, (5 + optlen / 4));
  807bb2:	c0 e8 02             	shr    $0x2,%al
  807bb5:	c1 e0 0c             	shl    $0xc,%eax
  807bb8:	66 05 00 50          	add    $0x5000,%ax
  807bbc:	66 89 45 ca          	mov    %ax,-0x36(%ebp)
  807bc0:	0f b7 45 c4          	movzwl -0x3c(%ebp),%eax
  807bc4:	66 89 45 de          	mov    %ax,-0x22(%ebp)
  807bc8:	8b 45 0c             	mov    0xc(%ebp),%eax
  807bcb:	89 45 d0             	mov    %eax,-0x30(%ebp)
  807bce:	bb 00 00 00 00       	mov    $0x0,%ebx
  while (queue == NULL || left > 0) {
  807bd3:	c6 45 e4 01          	movb   $0x1,-0x1c(%ebp)
      TCPH_HDRLEN_SET(seg->tcphdr, (5 + optlen / 4));
  807bd7:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
    else if (apiflags & TCP_WRITE_FLAG_COPY) {
  807bde:	83 e2 01             	and    $0x1,%edx
  807be1:	88 55 c9             	mov    %dl,-0x37(%ebp)
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
  807be4:	0f b6 45 dc          	movzbl -0x24(%ebp),%eax
  807be8:	89 45 cc             	mov    %eax,-0x34(%ebp)
    seglen = left > pcb->mss? pcb->mss: left;
  807beb:	0f b7 45 de          	movzwl -0x22(%ebp),%eax
  807bef:	66 39 47 34          	cmp    %ax,0x34(%edi)
  807bf3:	66 0f 46 47 34       	cmovbe 0x34(%edi),%ax
  807bf8:	66 89 45 e2          	mov    %ax,-0x1e(%ebp)
  807bfc:	89 de                	mov    %ebx,%esi
    seg = memp_malloc(MEMP_TCP_SEG);
  807bfe:	83 ec 0c             	sub    $0xc,%esp
  807c01:	6a 04                	push   $0x4
  807c03:	e8 43 c9 ff ff       	call   80454b <memp_malloc>
  807c08:	89 c3                	mov    %eax,%ebx
    if (seg == NULL) {
  807c0a:	83 c4 10             	add    $0x10,%esp
  807c0d:	85 c0                	test   %eax,%eax
  807c0f:	0f 84 a4 03 00 00    	je     807fb9 <tcp_enqueue+0x4f3>
    seg->next = NULL;
  807c15:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    seg->p = NULL;
  807c1b:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    if (queue == NULL) {
  807c22:	80 7d e4 00          	cmpb   $0x0,-0x1c(%ebp)
  807c26:	0f 85 6f 02 00 00    	jne    807e9b <tcp_enqueue+0x3d5>
      LWIP_ASSERT("useg != NULL", useg != NULL);
  807c2c:	85 f6                	test   %esi,%esi
  807c2e:	0f 84 50 02 00 00    	je     807e84 <tcp_enqueue+0x3be>
      useg->next = seg;
  807c34:	89 06                	mov    %eax,(%esi)
    if (optdata != NULL) {
  807c36:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  807c3a:	0f 84 7a 02 00 00    	je     807eba <tcp_enqueue+0x3f4>
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
  807c40:	83 ec 04             	sub    $0x4,%esp
  807c43:	6a 00                	push   $0x0
  807c45:	ff 75 cc             	pushl  -0x34(%ebp)
  807c48:	6a 00                	push   $0x0
  807c4a:	e8 a3 cd ff ff       	call   8049f2 <pbuf_alloc>
  807c4f:	89 43 04             	mov    %eax,0x4(%ebx)
  807c52:	83 c4 10             	add    $0x10,%esp
  807c55:	85 c0                	test   %eax,%eax
  807c57:	0f 84 5c 03 00 00    	je     807fb9 <tcp_enqueue+0x4f3>
      LWIP_ASSERT("check that first pbuf can hold optlen",
  807c5d:	0f b6 55 dc          	movzbl -0x24(%ebp),%edx
  807c61:	66 39 50 0a          	cmp    %dx,0xa(%eax)
  807c65:	0f 82 38 02 00 00    	jb     807ea3 <tcp_enqueue+0x3dd>
      queuelen += pbuf_clen(seg->p);
  807c6b:	83 ec 0c             	sub    $0xc,%esp
  807c6e:	50                   	push   %eax
  807c6f:	e8 f3 d0 ff ff       	call   804d67 <pbuf_clen>
  807c74:	0f b6 c0             	movzbl %al,%eax
  807c77:	66 01 45 e0          	add    %ax,-0x20(%ebp)
      seg->dataptr = seg->p->payload;
  807c7b:	8b 43 04             	mov    0x4(%ebx),%eax
  807c7e:	8b 40 04             	mov    0x4(%eax),%eax
  807c81:	89 43 08             	mov    %eax,0x8(%ebx)
  807c84:	83 c4 10             	add    $0x10,%esp
    if ((queuelen > TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
  807c87:	66 83 7d e0 20       	cmpw   $0x20,-0x20(%ebp)
  807c8c:	0f 87 27 03 00 00    	ja     807fb9 <tcp_enqueue+0x4f3>
    seg->len = seglen;
  807c92:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
  807c96:	66 89 43 0c          	mov    %ax,0xc(%ebx)
    if (pbuf_header(seg->p, TCP_HLEN)) {
  807c9a:	83 ec 08             	sub    $0x8,%esp
  807c9d:	6a 14                	push   $0x14
  807c9f:	ff 73 04             	pushl  0x4(%ebx)
  807ca2:	e8 ae cb ff ff       	call   804855 <pbuf_header>
  807ca7:	83 c4 10             	add    $0x10,%esp
  807caa:	84 c0                	test   %al,%al
  807cac:	0f 85 07 03 00 00    	jne    807fb9 <tcp_enqueue+0x4f3>
    seg->tcphdr = seg->p->payload;
  807cb2:	8b 43 04             	mov    0x4(%ebx),%eax
  807cb5:	8b 70 04             	mov    0x4(%eax),%esi
  807cb8:	89 73 10             	mov    %esi,0x10(%ebx)
    seg->tcphdr->src = htons(pcb->local_port);
  807cbb:	83 ec 0c             	sub    $0xc,%esp
  807cbe:	0f b7 47 1c          	movzwl 0x1c(%edi),%eax
  807cc2:	50                   	push   %eax
  807cc3:	e8 98 fb ff ff       	call   807860 <htons>
  807cc8:	66 89 06             	mov    %ax,(%esi)
    seg->tcphdr->dest = htons(pcb->remote_port);
  807ccb:	8b 73 10             	mov    0x10(%ebx),%esi
  807cce:	0f b7 47 1e          	movzwl 0x1e(%edi),%eax
  807cd2:	89 04 24             	mov    %eax,(%esp)
  807cd5:	e8 86 fb ff ff       	call   807860 <htons>
  807cda:	66 89 46 02          	mov    %ax,0x2(%esi)
    seg->tcphdr->seqno = htonl(seqno);
  807cde:	8b 73 10             	mov    0x10(%ebx),%esi
  807ce1:	83 c4 04             	add    $0x4,%esp
  807ce4:	ff 75 d8             	pushl  -0x28(%ebp)
  807ce7:	e8 96 fb ff ff       	call   807882 <htonl>
  807cec:	89 46 04             	mov    %eax,0x4(%esi)
    seg->tcphdr->urgp = 0;
  807cef:	8b 43 10             	mov    0x10(%ebx),%eax
  807cf2:	66 c7 40 12 00 00    	movw   $0x0,0x12(%eax)
    TCPH_FLAGS_SET(seg->tcphdr, flags);
  807cf8:	8b 43 10             	mov    0x10(%ebx),%eax
  807cfb:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  807cff:	89 04 24             	mov    %eax,(%esp)
  807d02:	e8 6a fb ff ff       	call   807871 <ntohs>
  807d07:	8b 73 10             	mov    0x10(%ebx),%esi
  807d0a:	83 e0 c0             	and    $0xffffffc0,%eax
  807d0d:	0f b6 55 dd          	movzbl -0x23(%ebp),%edx
  807d11:	09 d0                	or     %edx,%eax
  807d13:	0f b7 c0             	movzwl %ax,%eax
  807d16:	89 04 24             	mov    %eax,(%esp)
  807d19:	e8 42 fb ff ff       	call   807860 <htons>
  807d1e:	66 89 46 0c          	mov    %ax,0xc(%esi)
    if (optdata == NULL) {
  807d22:	83 c4 10             	add    $0x10,%esp
  807d25:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  807d29:	0f 84 cd 02 00 00    	je     807ffc <tcp_enqueue+0x536>
      TCPH_HDRLEN_SET(seg->tcphdr, (5 + optlen / 4));
  807d2f:	83 ec 0c             	sub    $0xc,%esp
  807d32:	8b 43 10             	mov    0x10(%ebx),%eax
  807d35:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  807d39:	50                   	push   %eax
  807d3a:	e8 32 fb ff ff       	call   807871 <ntohs>
  807d3f:	8b 73 10             	mov    0x10(%ebx),%esi
  807d42:	83 e0 3f             	and    $0x3f,%eax
  807d45:	66 0b 45 ca          	or     -0x36(%ebp),%ax
  807d49:	0f b7 c0             	movzwl %ax,%eax
  807d4c:	89 04 24             	mov    %eax,(%esp)
  807d4f:	e8 0c fb ff ff       	call   807860 <htons>
  807d54:	66 89 46 0c          	mov    %ax,0xc(%esi)
      /* Copy options into data portion of segment.
       Options can thus only be sent in non data carrying
       segments such as SYN|ACK. */
      SMEMCPY(seg->dataptr, optdata, optlen);
  807d58:	83 c4 0c             	add    $0xc,%esp
  807d5b:	ff 75 cc             	pushl  -0x34(%ebp)
  807d5e:	ff 75 1c             	pushl  0x1c(%ebp)
  807d61:	ff 73 08             	pushl  0x8(%ebx)
  807d64:	e8 eb 73 00 00       	call   80f154 <memcpy>
  807d69:	83 c4 10             	add    $0x10,%esp
      ntohl(seg->tcphdr->seqno),
      ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg),
      (u16_t)flags));

    left -= seglen;
    seqno += seglen;
  807d6c:	0f b7 4d e2          	movzwl -0x1e(%ebp),%ecx
  807d70:	0f b7 c1             	movzwl %cx,%eax
  807d73:	01 45 d8             	add    %eax,-0x28(%ebp)
    ptr = (void *)((u8_t *)ptr + seglen);
  807d76:	01 45 d0             	add    %eax,-0x30(%ebp)
  while (queue == NULL || left > 0) {
  807d79:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
  807d7d:	0f 94 45 e4          	sete   -0x1c(%ebp)
  807d81:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
  807d85:	66 29 4d de          	sub    %cx,-0x22(%ebp)
  807d89:	0f 85 5c fe ff ff    	jne    807beb <tcp_enqueue+0x125>
  807d8f:	84 c0                	test   %al,%al
  807d91:	0f 85 54 fe ff ff    	jne    807beb <tcp_enqueue+0x125>
  }

  /* Now that the data to be enqueued has been broken up into TCP
  segments in the queue variable, we add them to the end of the
  pcb->unsent queue. */
  if (pcb->unsent == NULL) {
  807d97:	8b 77 74             	mov    0x74(%edi),%esi
  807d9a:	85 f6                	test   %esi,%esi
  807d9c:	0f 84 bb 03 00 00    	je     80815d <tcp_enqueue+0x697>
  807da2:	89 f0                	mov    %esi,%eax
    useg = NULL;
  }
  else {
    for (useg = pcb->unsent; useg->next != NULL; useg = useg->next);
  807da4:	8b 36                	mov    (%esi),%esi
  807da6:	85 f6                	test   %esi,%esi
  807da8:	75 f8                	jne    807da2 <tcp_enqueue+0x2dc>
  807daa:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  /* { useg is last segment on the unsent queue, NULL if list is empty } */

  /* If there is room in the last pbuf on the unsent queue,
  chain the first pbuf on the queue together with that. */
  if (useg != NULL &&
    TCP_TCPLEN(useg) != 0 &&
  807dad:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
  807db1:	66 89 55 de          	mov    %dx,-0x22(%ebp)
  807db5:	83 ec 0c             	sub    $0xc,%esp
  807db8:	8b 40 10             	mov    0x10(%eax),%eax
  807dbb:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  807dbf:	50                   	push   %eax
  807dc0:	e8 ac fa ff ff       	call   807871 <ntohs>
  807dc5:	83 c4 10             	add    $0x10,%esp
  807dc8:	a8 01                	test   $0x1,%al
  807dca:	0f 84 59 02 00 00    	je     808029 <tcp_enqueue+0x563>
    !(TCPH_FLAGS(useg->tcphdr) & (TCP_SYN | TCP_FIN)) &&
  807dd0:	83 ec 0c             	sub    $0xc,%esp
  807dd3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  807dd6:	8b 40 10             	mov    0x10(%eax),%eax
  807dd9:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  807ddd:	50                   	push   %eax
  807dde:	e8 8e fa ff ff       	call   807871 <ntohs>
    TCP_TCPLEN(useg) != 0 &&
  807de3:	83 c4 10             	add    $0x10,%esp
  807de6:	a8 03                	test   $0x3,%al
  807de8:	0f 85 63 02 00 00    	jne    808051 <tcp_enqueue+0x58b>
    !(TCPH_FLAGS(useg->tcphdr) & (TCP_SYN | TCP_FIN)) &&
  807dee:	f6 45 bc 03          	testb  $0x3,-0x44(%ebp)
  807df2:	0f 85 59 02 00 00    	jne    808051 <tcp_enqueue+0x58b>
    !(flags & (TCP_SYN | TCP_FIN)) &&
    /* fit within max seg size */
    useg->len + queue->len <= pcb->mss) {
  807df8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  807dfb:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  807dff:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  807e02:	0f b7 52 0c          	movzwl 0xc(%edx),%edx
  807e06:	01 d0                	add    %edx,%eax
  807e08:	0f b7 57 34          	movzwl 0x34(%edi),%edx
    !(flags & (TCP_SYN | TCP_FIN)) &&
  807e0c:	39 d0                	cmp    %edx,%eax
  807e0e:	0f 8f 3d 02 00 00    	jg     808051 <tcp_enqueue+0x58b>
    /* Remove TCP header from first segment of our to-be-queued list */
    if(pbuf_header(queue->p, -TCP_HLEN)) {
  807e14:	83 ec 08             	sub    $0x8,%esp
  807e17:	6a ec                	push   $0xffffffec
  807e19:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  807e1c:	ff 70 04             	pushl  0x4(%eax)
  807e1f:	e8 31 ca ff ff       	call   804855 <pbuf_header>
  807e24:	83 c4 10             	add    $0x10,%esp
  807e27:	84 c0                	test   %al,%al
  807e29:	0f 85 c5 02 00 00    	jne    8080f4 <tcp_enqueue+0x62e>
      /* Can we cope with this failing?  Just assert for now */
      LWIP_ASSERT("pbuf_header failed\n", 0);
      TCP_STATS_INC(tcp.err);
      goto memerr;
    }
    pbuf_cat(useg->p, queue->p);
  807e2f:	83 ec 08             	sub    $0x8,%esp
  807e32:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  807e35:	ff 72 04             	pushl  0x4(%edx)
  807e38:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  807e3b:	ff 71 04             	pushl  0x4(%ecx)
  807e3e:	e8 57 cf ff ff       	call   804d9a <pbuf_cat>
    useg->len += queue->len;
  807e43:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  807e46:	0f b7 42 0c          	movzwl 0xc(%edx),%eax
  807e4a:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  807e4d:	66 01 41 0c          	add    %ax,0xc(%ecx)
    useg->next = queue->next;
  807e51:	8b 02                	mov    (%edx),%eax
  807e53:	89 01                	mov    %eax,(%ecx)

    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("tcp_enqueue: chaining segments, new len %"U16_F"\n", useg->len));
    if (seg == queue) {
  807e55:	83 c4 08             	add    $0x8,%esp
      seg = NULL;
  807e58:	39 da                	cmp    %ebx,%edx
  807e5a:	0f 44 de             	cmove  %esi,%ebx
    }
    memp_free(MEMP_TCP_SEG, queue);
  807e5d:	52                   	push   %edx
  807e5e:	6a 04                	push   $0x4
  807e60:	e8 40 c7 ff ff       	call   8045a5 <memp_free>
  807e65:	83 c4 10             	add    $0x10,%esp
  807e68:	e9 00 02 00 00       	jmp    80806d <tcp_enqueue+0x5a7>
    LWIP_ASSERT("tcp_enqueue: no pbufs on queue => both queues empty",
  807e6d:	83 ec 04             	sub    $0x4,%esp
  807e70:	68 08 25 81 00       	push   $0x812508
  807e75:	68 b0 00 00 00       	push   $0xb0
  807e7a:	68 e6 25 81 00       	push   $0x8125e6
  807e7f:	e8 c3 69 00 00       	call   80e847 <_panic>
      LWIP_ASSERT("useg != NULL", useg != NULL);
  807e84:	83 ec 04             	sub    $0x4,%esp
  807e87:	68 fe 25 81 00       	push   $0x8125fe
  807e8c:	68 ce 00 00 00       	push   $0xce
  807e91:	68 e6 25 81 00       	push   $0x8125e6
  807e96:	e8 ac 69 00 00       	call   80e847 <_panic>
    seg = memp_malloc(MEMP_TCP_SEG);
  807e9b:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  807e9e:	e9 93 fd ff ff       	jmp    807c36 <tcp_enqueue+0x170>
      LWIP_ASSERT("check that first pbuf can hold optlen",
  807ea3:	83 ec 04             	sub    $0x4,%esp
  807ea6:	68 3c 25 81 00       	push   $0x81253c
  807eab:	68 de 00 00 00       	push   $0xde
  807eb0:	68 e6 25 81 00       	push   $0x8125e6
  807eb5:	e8 8d 69 00 00       	call   80e847 <_panic>
    else if (apiflags & TCP_WRITE_FLAG_COPY) {
  807eba:	80 7d c9 00          	cmpb   $0x0,-0x37(%ebp)
  807ebe:	74 7f                	je     807f3f <tcp_enqueue+0x479>
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_RAM)) == NULL) {
  807ec0:	83 ec 04             	sub    $0x4,%esp
  807ec3:	6a 00                	push   $0x0
  807ec5:	0f b7 75 e2          	movzwl -0x1e(%ebp),%esi
  807ec9:	0f b7 c6             	movzwl %si,%eax
  807ecc:	50                   	push   %eax
  807ecd:	6a 00                	push   $0x0
  807ecf:	e8 1e cb ff ff       	call   8049f2 <pbuf_alloc>
  807ed4:	89 43 04             	mov    %eax,0x4(%ebx)
  807ed7:	83 c4 10             	add    $0x10,%esp
  807eda:	85 c0                	test   %eax,%eax
  807edc:	0f 84 d7 00 00 00    	je     807fb9 <tcp_enqueue+0x4f3>
      LWIP_ASSERT("check that first pbuf can hold the complete seglen",
  807ee2:	66 39 70 0a          	cmp    %si,0xa(%eax)
  807ee6:	72 40                	jb     807f28 <tcp_enqueue+0x462>
      queuelen += pbuf_clen(seg->p);
  807ee8:	83 ec 0c             	sub    $0xc,%esp
  807eeb:	50                   	push   %eax
  807eec:	e8 76 ce ff ff       	call   804d67 <pbuf_clen>
  807ef1:	0f b6 c0             	movzbl %al,%eax
  807ef4:	66 01 45 e0          	add    %ax,-0x20(%ebp)
      if (arg != NULL) {
  807ef8:	83 c4 10             	add    $0x10,%esp
  807efb:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  807eff:	74 19                	je     807f1a <tcp_enqueue+0x454>
        MEMCPY(seg->p->payload, ptr, seglen);
  807f01:	83 ec 04             	sub    $0x4,%esp
  807f04:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
  807f08:	50                   	push   %eax
  807f09:	ff 75 d0             	pushl  -0x30(%ebp)
  807f0c:	8b 43 04             	mov    0x4(%ebx),%eax
  807f0f:	ff 70 04             	pushl  0x4(%eax)
  807f12:	e8 3d 72 00 00       	call   80f154 <memcpy>
  807f17:	83 c4 10             	add    $0x10,%esp
      seg->dataptr = seg->p->payload;
  807f1a:	8b 43 04             	mov    0x4(%ebx),%eax
  807f1d:	8b 40 04             	mov    0x4(%eax),%eax
  807f20:	89 43 08             	mov    %eax,0x8(%ebx)
  807f23:	e9 5f fd ff ff       	jmp    807c87 <tcp_enqueue+0x1c1>
      LWIP_ASSERT("check that first pbuf can hold the complete seglen",
  807f28:	83 ec 04             	sub    $0x4,%esp
  807f2b:	68 64 25 81 00       	push   $0x812564
  807f30:	68 e9 00 00 00       	push   $0xe9
  807f35:	68 e6 25 81 00       	push   $0x8125e6
  807f3a:	e8 08 69 00 00       	call   80e847 <_panic>
      if ((p = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_ROM)) == NULL) {
  807f3f:	83 ec 04             	sub    $0x4,%esp
  807f42:	6a 01                	push   $0x1
  807f44:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
  807f48:	50                   	push   %eax
  807f49:	6a 00                	push   $0x0
  807f4b:	e8 a2 ca ff ff       	call   8049f2 <pbuf_alloc>
  807f50:	89 c6                	mov    %eax,%esi
  807f52:	83 c4 10             	add    $0x10,%esp
  807f55:	85 c0                	test   %eax,%eax
  807f57:	74 60                	je     807fb9 <tcp_enqueue+0x4f3>
      ++queuelen;
  807f59:	0f b7 45 e0          	movzwl -0x20(%ebp),%eax
  807f5d:	83 c0 01             	add    $0x1,%eax
  807f60:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
      p->payload = ptr;
  807f64:	8b 45 d0             	mov    -0x30(%ebp),%eax
  807f67:	89 46 04             	mov    %eax,0x4(%esi)
      seg->dataptr = ptr;
  807f6a:	89 43 08             	mov    %eax,0x8(%ebx)
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, 0, PBUF_RAM)) == NULL) {
  807f6d:	83 ec 04             	sub    $0x4,%esp
  807f70:	6a 00                	push   $0x0
  807f72:	6a 00                	push   $0x0
  807f74:	6a 00                	push   $0x0
  807f76:	e8 77 ca ff ff       	call   8049f2 <pbuf_alloc>
  807f7b:	89 43 04             	mov    %eax,0x4(%ebx)
  807f7e:	83 c4 10             	add    $0x10,%esp
  807f81:	85 c0                	test   %eax,%eax
  807f83:	74 28                	je     807fad <tcp_enqueue+0x4e7>
      queuelen += pbuf_clen(seg->p);
  807f85:	83 ec 0c             	sub    $0xc,%esp
  807f88:	50                   	push   %eax
  807f89:	e8 d9 cd ff ff       	call   804d67 <pbuf_clen>
  807f8e:	0f b6 c0             	movzbl %al,%eax
  807f91:	66 03 45 e4          	add    -0x1c(%ebp),%ax
  807f95:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
      pbuf_cat(seg->p/*header*/, p/*data*/);
  807f99:	83 c4 08             	add    $0x8,%esp
  807f9c:	56                   	push   %esi
  807f9d:	ff 73 04             	pushl  0x4(%ebx)
  807fa0:	e8 f5 cd ff ff       	call   804d9a <pbuf_cat>
  807fa5:	83 c4 10             	add    $0x10,%esp
  807fa8:	e9 da fc ff ff       	jmp    807c87 <tcp_enqueue+0x1c1>
        pbuf_free(p);
  807fad:	83 ec 0c             	sub    $0xc,%esp
  807fb0:	56                   	push   %esi
  807fb1:	e8 72 c9 ff ff       	call   804928 <pbuf_free>
        goto memerr;
  807fb6:	83 c4 10             	add    $0x10,%esp
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
  }

  return ERR_OK;
memerr:
  pcb->flags |= TF_NAGLEMEMERR;
  807fb9:	80 4f 20 80          	orb    $0x80,0x20(%edi)
  TCP_STATS_INC(tcp.memerr);

  if (queue != NULL) {
  807fbd:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  807fc0:	85 c0                	test   %eax,%eax
  807fc2:	74 0c                	je     807fd0 <tcp_enqueue+0x50a>
    tcp_segs_free(queue);
  807fc4:	83 ec 0c             	sub    $0xc,%esp
  807fc7:	50                   	push   %eax
  807fc8:	e8 f2 d8 ff ff       	call   8058bf <tcp_segs_free>
  807fcd:	83 c4 10             	add    $0x10,%esp
  }
  if (pcb->snd_queuelen != 0) {
  807fd0:	66 83 7f 70 00       	cmpw   $0x0,0x70(%edi)
  807fd5:	0f 84 6e 01 00 00    	je     808149 <tcp_enqueue+0x683>
    LWIP_ASSERT("tcp_enqueue: valid queue length", pcb->unacked != NULL ||
  807fdb:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  807fdf:	0f 85 6e 01 00 00    	jne    808153 <tcp_enqueue+0x68d>
  807fe5:	83 7f 74 00          	cmpl   $0x0,0x74(%edi)
  807fe9:	0f 84 39 01 00 00    	je     808128 <tcp_enqueue+0x662>
      pcb->unsent != NULL);
  }
  LWIP_DEBUGF(TCP_QLEN_DEBUG | LWIP_DBG_STATE, ("tcp_enqueue: %"S16_F" (with mem err)\n", pcb->snd_queuelen));
  return ERR_MEM;
  807fef:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  807ff4:	8d 65 f4             	lea    -0xc(%ebp),%esp
  807ff7:	5b                   	pop    %ebx
  807ff8:	5e                   	pop    %esi
  807ff9:	5f                   	pop    %edi
  807ffa:	5d                   	pop    %ebp
  807ffb:	c3                   	ret    
      TCPH_HDRLEN_SET(seg->tcphdr, 5);
  807ffc:	83 ec 0c             	sub    $0xc,%esp
  807fff:	8b 43 10             	mov    0x10(%ebx),%eax
  808002:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  808006:	50                   	push   %eax
  808007:	e8 65 f8 ff ff       	call   807871 <ntohs>
  80800c:	8b 73 10             	mov    0x10(%ebx),%esi
  80800f:	83 e0 3f             	and    $0x3f,%eax
  808012:	80 cc 50             	or     $0x50,%ah
  808015:	89 04 24             	mov    %eax,(%esp)
  808018:	e8 43 f8 ff ff       	call   807860 <htons>
  80801d:	66 89 46 0c          	mov    %ax,0xc(%esi)
  808021:	83 c4 10             	add    $0x10,%esp
  808024:	e9 43 fd ff ff       	jmp    807d6c <tcp_enqueue+0x2a6>
    TCP_TCPLEN(useg) != 0 &&
  808029:	83 ec 0c             	sub    $0xc,%esp
  80802c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80802f:	8b 40 10             	mov    0x10(%eax),%eax
  808032:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  808036:	50                   	push   %eax
  808037:	e8 35 f8 ff ff       	call   807871 <ntohs>
  80803c:	66 d1 e8             	shr    %ax
  80803f:	83 e0 01             	and    $0x1,%eax
  808042:	0f b7 55 de          	movzwl -0x22(%ebp),%edx
  if (useg != NULL &&
  808046:	83 c4 10             	add    $0x10,%esp
  808049:	01 d0                	add    %edx,%eax
  80804b:	0f 85 7f fd ff ff    	jne    807dd0 <tcp_enqueue+0x30a>
      useg->next = queue;
  808051:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  808054:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  808057:	89 10                	mov    %edx,(%eax)
    ++len;
  808059:	0f b7 45 c4          	movzwl -0x3c(%ebp),%eax
  80805d:	83 c0 01             	add    $0x1,%eax
  808060:	f6 45 bc 03          	testb  $0x3,-0x44(%ebp)
  808064:	66 0f 44 45 c2       	cmove  -0x3e(%ebp),%ax
  808069:	66 89 45 c2          	mov    %ax,-0x3e(%ebp)
  if (flags & TCP_FIN) {
  80806d:	f6 45 bc 01          	testb  $0x1,-0x44(%ebp)
  808071:	74 04                	je     808077 <tcp_enqueue+0x5b1>
    pcb->flags |= TF_FIN;
  808073:	80 4f 20 20          	orb    $0x20,0x20(%edi)
  pcb->snd_lbb += len;
  808077:	0f b7 55 c2          	movzwl -0x3e(%ebp),%edx
  80807b:	0f b7 c2             	movzwl %dx,%eax
  80807e:	01 47 68             	add    %eax,0x68(%edi)
  pcb->snd_buf -= len;
  808081:	66 29 57 6e          	sub    %dx,0x6e(%edi)
  pcb->snd_queuelen = queuelen;
  808085:	0f b7 45 e0          	movzwl -0x20(%ebp),%eax
  808089:	66 89 47 70          	mov    %ax,0x70(%edi)
  if (pcb->snd_queuelen != 0) {
  80808d:	66 85 c0             	test   %ax,%ax
  808090:	74 06                	je     808098 <tcp_enqueue+0x5d2>
    LWIP_ASSERT("tcp_enqueue: valid queue length",
  808092:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  808096:	74 73                	je     80810b <tcp_enqueue+0x645>
  if (seg != NULL && seglen > 0 && seg->tcphdr != NULL && ((apiflags & TCP_WRITE_FLAG_MORE)==0)) {
  808098:	85 db                	test   %ebx,%ebx
  80809a:	0f 84 9f 00 00 00    	je     80813f <tcp_enqueue+0x679>
  8080a0:	66 83 7d e2 00       	cmpw   $0x0,-0x1e(%ebp)
  8080a5:	0f 84 94 00 00 00    	je     80813f <tcp_enqueue+0x679>
  8080ab:	8b 53 10             	mov    0x10(%ebx),%edx
  return ERR_OK;
  8080ae:	b8 00 00 00 00       	mov    $0x0,%eax
  if (seg != NULL && seglen > 0 && seg->tcphdr != NULL && ((apiflags & TCP_WRITE_FLAG_MORE)==0)) {
  8080b3:	85 d2                	test   %edx,%edx
  8080b5:	0f 84 39 ff ff ff    	je     807ff4 <tcp_enqueue+0x52e>
  8080bb:	f6 45 b8 02          	testb  $0x2,-0x48(%ebp)
  8080bf:	0f 85 2f ff ff ff    	jne    807ff4 <tcp_enqueue+0x52e>
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
  8080c5:	83 ec 0c             	sub    $0xc,%esp
  8080c8:	0f b7 42 0c          	movzwl 0xc(%edx),%eax
  8080cc:	50                   	push   %eax
  8080cd:	e8 9f f7 ff ff       	call   807871 <ntohs>
  8080d2:	8b 5b 10             	mov    0x10(%ebx),%ebx
  8080d5:	83 c8 08             	or     $0x8,%eax
  8080d8:	0f b7 c0             	movzwl %ax,%eax
  8080db:	89 04 24             	mov    %eax,(%esp)
  8080de:	e8 7d f7 ff ff       	call   807860 <htons>
  8080e3:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  8080e7:	83 c4 10             	add    $0x10,%esp
  return ERR_OK;
  8080ea:	b8 00 00 00 00       	mov    $0x0,%eax
  8080ef:	e9 00 ff ff ff       	jmp    807ff4 <tcp_enqueue+0x52e>
      LWIP_ASSERT("pbuf_header failed\n", 0);
  8080f4:	83 ec 04             	sub    $0x4,%esp
  8080f7:	68 0b 26 81 00       	push   $0x81260b
  8080fc:	68 52 01 00 00       	push   $0x152
  808101:	68 e6 25 81 00       	push   $0x8125e6
  808106:	e8 3c 67 00 00       	call   80e847 <_panic>
    LWIP_ASSERT("tcp_enqueue: valid queue length",
  80810b:	83 7f 74 00          	cmpl   $0x0,0x74(%edi)
  80810f:	75 87                	jne    808098 <tcp_enqueue+0x5d2>
  808111:	83 ec 04             	sub    $0x4,%esp
  808114:	68 98 25 81 00       	push   $0x812598
  808119:	68 79 01 00 00       	push   $0x179
  80811e:	68 e6 25 81 00       	push   $0x8125e6
  808123:	e8 1f 67 00 00       	call   80e847 <_panic>
    LWIP_ASSERT("tcp_enqueue: valid queue length", pcb->unacked != NULL ||
  808128:	83 ec 04             	sub    $0x4,%esp
  80812b:	68 98 25 81 00       	push   $0x812598
  808130:	68 8c 01 00 00       	push   $0x18c
  808135:	68 e6 25 81 00       	push   $0x8125e6
  80813a:	e8 08 67 00 00       	call   80e847 <_panic>
  return ERR_OK;
  80813f:	b8 00 00 00 00       	mov    $0x0,%eax
  808144:	e9 ab fe ff ff       	jmp    807ff4 <tcp_enqueue+0x52e>
  return ERR_MEM;
  808149:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80814e:	e9 a1 fe ff ff       	jmp    807ff4 <tcp_enqueue+0x52e>
  808153:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  808158:	e9 97 fe ff ff       	jmp    807ff4 <tcp_enqueue+0x52e>
      pcb->unsent = queue;
  80815d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  808160:	89 47 74             	mov    %eax,0x74(%edi)
  808163:	e9 f1 fe ff ff       	jmp    808059 <tcp_enqueue+0x593>

00808168 <tcp_send_ctrl>:
{
  808168:	f3 0f 1e fb          	endbr32 
  80816c:	55                   	push   %ebp
  80816d:	89 e5                	mov    %esp,%ebp
  80816f:	83 ec 0c             	sub    $0xc,%esp
  return tcp_enqueue(pcb, NULL, 0, flags, TCP_WRITE_FLAG_COPY, NULL, 0);
  808172:	6a 00                	push   $0x0
  808174:	6a 00                	push   $0x0
  808176:	6a 01                	push   $0x1
  808178:	0f b6 45 0c          	movzbl 0xc(%ebp),%eax
  80817c:	50                   	push   %eax
  80817d:	6a 00                	push   $0x0
  80817f:	6a 00                	push   $0x0
  808181:	ff 75 08             	pushl  0x8(%ebp)
  808184:	e8 3d f9 ff ff       	call   807ac6 <tcp_enqueue>
}
  808189:	c9                   	leave  
  80818a:	c3                   	ret    

0080818b <tcp_write>:
{
  80818b:	f3 0f 1e fb          	endbr32 
  80818f:	55                   	push   %ebp
  808190:	89 e5                	mov    %esp,%ebp
  808192:	56                   	push   %esi
  808193:	53                   	push   %ebx
  808194:	8b 4d 08             	mov    0x8(%ebp),%ecx
  808197:	8b 55 10             	mov    0x10(%ebp),%edx
  80819a:	8b 75 14             	mov    0x14(%ebp),%esi
  if (pcb->state == ESTABLISHED ||
  80819d:	8b 41 10             	mov    0x10(%ecx),%eax
     pcb->state == CLOSE_WAIT ||
  8081a0:	8d 58 fe             	lea    -0x2(%eax),%ebx
     pcb->state == SYN_SENT ||
  8081a3:	83 fb 02             	cmp    $0x2,%ebx
  8081a6:	76 05                	jbe    8081ad <tcp_write+0x22>
  8081a8:	83 f8 07             	cmp    $0x7,%eax
  8081ab:	75 32                	jne    8081df <tcp_write+0x54>
    return ERR_OK;
  8081ad:	b8 00 00 00 00       	mov    $0x0,%eax
    if (len > 0) {
  8081b2:	66 85 d2             	test   %dx,%dx
  8081b5:	75 07                	jne    8081be <tcp_write+0x33>
}
  8081b7:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8081ba:	5b                   	pop    %ebx
  8081bb:	5e                   	pop    %esi
  8081bc:	5d                   	pop    %ebp
  8081bd:	c3                   	ret    
      return tcp_enqueue(pcb, (void *)data, len, 0, apiflags, NULL, 0);
  8081be:	83 ec 04             	sub    $0x4,%esp
  8081c1:	6a 00                	push   $0x0
  8081c3:	6a 00                	push   $0x0
  8081c5:	89 f0                	mov    %esi,%eax
  8081c7:	0f b6 f0             	movzbl %al,%esi
  8081ca:	56                   	push   %esi
  8081cb:	6a 00                	push   $0x0
  8081cd:	0f b7 d2             	movzwl %dx,%edx
  8081d0:	52                   	push   %edx
  8081d1:	ff 75 0c             	pushl  0xc(%ebp)
  8081d4:	51                   	push   %ecx
  8081d5:	e8 ec f8 ff ff       	call   807ac6 <tcp_enqueue>
  8081da:	83 c4 20             	add    $0x20,%esp
  8081dd:	eb d8                	jmp    8081b7 <tcp_write+0x2c>
    return ERR_CONN;
  8081df:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
  8081e4:	eb d1                	jmp    8081b7 <tcp_write+0x2c>

008081e6 <tcp_output>:
 * @return ERR_OK if data has been sent or nothing to send
 *         another err_t on error
 */
err_t
tcp_output(struct tcp_pcb *pcb)
{
  8081e6:	f3 0f 1e fb          	endbr32 
  8081ea:	55                   	push   %ebp
  8081eb:	89 e5                	mov    %esp,%ebp
  8081ed:	57                   	push   %edi
  8081ee:	56                   	push   %esi
  8081ef:	53                   	push   %ebx
  8081f0:	83 ec 1c             	sub    $0x1c,%esp
  8081f3:	8b 7d 08             	mov    0x8(%ebp),%edi

  /* First, check if we are invoked by the TCP input processing
     code. If so, we do not output anything. Instead, we rely on the
     input processing code to call us when input processing is done
     with. */
  if (tcp_input_pcb == pcb) {
  8081f6:	39 3d 58 b2 b3 00    	cmp    %edi,0xb3b258
  8081fc:	0f 84 62 04 00 00    	je     808664 <tcp_output+0x47e>
    return ERR_OK;
  }

  wnd = LWIP_MIN(pcb->snd_wnd, pcb->cwnd);
  808202:	0f b7 47 5c          	movzwl 0x5c(%edi),%eax
  808206:	66 39 47 4e          	cmp    %ax,0x4e(%edi)
  80820a:	66 0f 46 47 4e       	cmovbe 0x4e(%edi),%ax
  80820f:	0f b7 c0             	movzwl %ax,%eax
  808212:	89 45 d8             	mov    %eax,-0x28(%ebp)

  seg = pcb->unsent;
  808215:	8b 5f 74             	mov    0x74(%edi),%ebx

  /* useg should point to last segment on unacked queue */
  useg = pcb->unacked;
  808218:	8b 47 78             	mov    0x78(%edi),%eax
  80821b:	89 45 dc             	mov    %eax,-0x24(%ebp)
  if (useg != NULL) {
  80821e:	85 c0                	test   %eax,%eax
  808220:	74 0b                	je     80822d <tcp_output+0x47>
  808222:	89 c2                	mov    %eax,%edx
    for (; useg->next != NULL; useg = useg->next);
  808224:	8b 00                	mov    (%eax),%eax
  808226:	85 c0                	test   %eax,%eax
  808228:	75 f8                	jne    808222 <tcp_output+0x3c>
  80822a:	89 55 dc             	mov    %edx,-0x24(%ebp)
   * because the ->unsent queue is empty or because the window does
   * not allow it), construct an empty ACK segment and send it.
   *
   * If data is to be sent, we will just piggyback the ACK (see below).
   */
  if (pcb->flags & TF_ACK_NOW &&
  80822d:	f6 47 20 02          	testb  $0x2,0x20(%edi)
  808231:	0f 84 eb 03 00 00    	je     808622 <tcp_output+0x43c>
  808237:	85 db                	test   %ebx,%ebx
  808239:	74 25                	je     808260 <tcp_output+0x7a>
     (seg == NULL ||
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
  80823b:	83 ec 0c             	sub    $0xc,%esp
  80823e:	8b 43 10             	mov    0x10(%ebx),%eax
  808241:	ff 70 04             	pushl  0x4(%eax)
  808244:	e8 66 f8 ff ff       	call   807aaf <ntohl>
  808249:	89 c2                	mov    %eax,%edx
  80824b:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80824f:	2b 47 48             	sub    0x48(%edi),%eax
  808252:	01 d0                	add    %edx,%eax
     (seg == NULL ||
  808254:	83 c4 10             	add    $0x10,%esp
  808257:	3b 45 d8             	cmp    -0x28(%ebp),%eax
  80825a:	0f 86 c2 03 00 00    	jbe    808622 <tcp_output+0x43c>
    p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  808260:	83 ec 04             	sub    $0x4,%esp
  808263:	6a 00                	push   $0x0
  808265:	6a 14                	push   $0x14
  808267:	6a 01                	push   $0x1
  808269:	e8 84 c7 ff ff       	call   8049f2 <pbuf_alloc>
  80826e:	89 c6                	mov    %eax,%esi
    if (p == NULL) {
  808270:	83 c4 10             	add    $0x10,%esp
  808273:	85 c0                	test   %eax,%eax
  808275:	0f 84 f0 03 00 00    	je     80866b <tcp_output+0x485>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: (ACK) could not allocate pbuf\n"));
      return ERR_BUF;
    }
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: sending ACK for %"U32_F"\n", pcb->rcv_nxt));
    /* remove ACK flags from the PCB, as we send an empty ACK now */
    pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
  80827b:	80 67 20 fc          	andb   $0xfc,0x20(%edi)

    tcphdr = p->payload;
  80827f:	8b 58 04             	mov    0x4(%eax),%ebx
    tcphdr->src = htons(pcb->local_port);
  808282:	83 ec 0c             	sub    $0xc,%esp
  808285:	0f b7 47 1c          	movzwl 0x1c(%edi),%eax
  808289:	50                   	push   %eax
  80828a:	e8 d1 f5 ff ff       	call   807860 <htons>
  80828f:	66 89 03             	mov    %ax,(%ebx)
    tcphdr->dest = htons(pcb->remote_port);
  808292:	0f b7 47 1e          	movzwl 0x1e(%edi),%eax
  808296:	89 04 24             	mov    %eax,(%esp)
  808299:	e8 c2 f5 ff ff       	call   807860 <htons>
  80829e:	66 89 43 02          	mov    %ax,0x2(%ebx)
    tcphdr->seqno = htonl(pcb->snd_nxt);
  8082a2:	83 c4 04             	add    $0x4,%esp
  8082a5:	ff 77 54             	pushl  0x54(%edi)
  8082a8:	e8 d5 f5 ff ff       	call   807882 <htonl>
  8082ad:	89 43 04             	mov    %eax,0x4(%ebx)
    tcphdr->ackno = htonl(pcb->rcv_nxt);
  8082b0:	83 c4 04             	add    $0x4,%esp
  8082b3:	ff 77 24             	pushl  0x24(%edi)
  8082b6:	e8 c7 f5 ff ff       	call   807882 <htonl>
  8082bb:	89 43 08             	mov    %eax,0x8(%ebx)
    TCPH_FLAGS_SET(tcphdr, TCP_ACK);
  8082be:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  8082c2:	89 04 24             	mov    %eax,(%esp)
  8082c5:	e8 a7 f5 ff ff       	call   807871 <ntohs>
  8082ca:	25 c0 ff 00 00       	and    $0xffc0,%eax
  8082cf:	83 c8 10             	or     $0x10,%eax
  8082d2:	89 04 24             	mov    %eax,(%esp)
  8082d5:	e8 86 f5 ff ff       	call   807860 <htons>
  8082da:	66 89 43 0c          	mov    %ax,0xc(%ebx)
    tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  8082de:	0f b7 47 2a          	movzwl 0x2a(%edi),%eax
  8082e2:	89 04 24             	mov    %eax,(%esp)
  8082e5:	e8 76 f5 ff ff       	call   807860 <htons>
  8082ea:	66 89 43 0e          	mov    %ax,0xe(%ebx)
    tcphdr->urgp = 0;
  8082ee:	66 c7 43 12 00 00    	movw   $0x0,0x12(%ebx)
    TCPH_HDRLEN_SET(tcphdr, 5);
  8082f4:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  8082f8:	89 04 24             	mov    %eax,(%esp)
  8082fb:	e8 71 f5 ff ff       	call   807871 <ntohs>
  808300:	83 e0 3f             	and    $0x3f,%eax
  808303:	80 cc 50             	or     $0x50,%ah
  808306:	89 04 24             	mov    %eax,(%esp)
  808309:	e8 52 f5 ff ff       	call   807860 <htons>
  80830e:	66 89 43 0c          	mov    %ax,0xc(%ebx)

    tcphdr->chksum = 0;
  808312:	66 c7 43 10 00 00    	movw   $0x0,0x10(%ebx)
#if CHECKSUM_GEN_TCP
    tcphdr->chksum = inet_chksum_pseudo(p, &(pcb->local_ip), &(pcb->remote_ip),
  808318:	8d 47 04             	lea    0x4(%edi),%eax
  80831b:	89 c1                	mov    %eax,%ecx
  80831d:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  808321:	89 04 24             	mov    %eax,(%esp)
  808324:	6a 06                	push   $0x6
  808326:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  808329:	51                   	push   %ecx
  80832a:	57                   	push   %edi
  80832b:	56                   	push   %esi
  80832c:	e8 f7 f1 ff ff       	call   807528 <inet_chksum_pseudo>
  808331:	66 89 43 10          	mov    %ax,0x10(%ebx)
                     pcb->tos, IP_PROTO_TCP, netif);
        netif->addr_hint = NULL;
      }
    }
#else /* LWIP_NETIF_HWADDRHINT*/
    ip_output(p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
  808335:	83 c4 18             	add    $0x18,%esp
  808338:	6a 06                	push   $0x6
  80833a:	0f b6 47 0a          	movzbl 0xa(%edi),%eax
  80833e:	50                   	push   %eax
  80833f:	0f b6 47 0b          	movzbl 0xb(%edi),%eax
  808343:	50                   	push   %eax
  808344:	ff 75 e4             	pushl  -0x1c(%ebp)
  808347:	57                   	push   %edi
  808348:	56                   	push   %esi
  808349:	e8 ea e7 ff ff       	call   806b38 <ip_output>
        IP_PROTO_TCP);
#endif /* LWIP_NETIF_HWADDRHINT*/
    pbuf_free(p);
  80834e:	83 c4 14             	add    $0x14,%esp
  808351:	56                   	push   %esi
  808352:	e8 d1 c5 ff ff       	call   804928 <pbuf_free>

    return ERR_OK;
  808357:	83 c4 10             	add    $0x10,%esp
  80835a:	b8 00 00 00 00       	mov    $0x0,%eax
  80835f:	e9 20 03 00 00       	jmp    808684 <tcp_output+0x49e>
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
         ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
    LWIP_ASSERT("RST not expected here!", 
  808364:	83 ec 04             	sub    $0x4,%esp
  808367:	68 1f 26 81 00       	push   $0x81261f
  80836c:	68 04 02 00 00       	push   $0x204
  808371:	68 e6 25 81 00       	push   $0x8125e6
  808376:	e8 cc 64 00 00       	call   80e847 <_panic>
#endif /* TCP_CWND_DEBUG */

    pcb->unsent = seg->next;

    if (pcb->state != SYN_SENT) {
      TCPH_SET_FLAG(seg->tcphdr, TCP_ACK);
  80837b:	83 ec 0c             	sub    $0xc,%esp
  80837e:	8b 43 10             	mov    0x10(%ebx),%eax
  808381:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  808385:	50                   	push   %eax
  808386:	e8 e6 f4 ff ff       	call   807871 <ntohs>
  80838b:	8b 73 10             	mov    0x10(%ebx),%esi
  80838e:	83 c8 10             	or     $0x10,%eax
  808391:	0f b7 c0             	movzwl %ax,%eax
  808394:	89 04 24             	mov    %eax,(%esp)
  808397:	e8 c4 f4 ff ff       	call   807860 <htons>
  80839c:	66 89 46 0c          	mov    %ax,0xc(%esi)
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
  8083a0:	80 67 20 fc          	andb   $0xfc,0x20(%edi)
  8083a4:	83 c4 10             	add    $0x10,%esp
  8083a7:	e9 06 01 00 00       	jmp    8084b2 <tcp_output+0x2cc>
    ip_addr_set(&(pcb->local_ip), &(netif->ip_addr));
  }

  /* Set retransmission timer running if it is not currently enabled */
  if(pcb->rtime == -1)
    pcb->rtime = 0;
  8083ac:	66 c7 47 32 00 00    	movw   $0x0,0x32(%edi)
  8083b2:	e9 49 01 00 00       	jmp    808500 <tcp_output+0x31a>

  if (pcb->rttest == 0) {
    pcb->rttest = tcp_ticks;
  8083b7:	a1 40 b2 b3 00       	mov    0xb3b240,%eax
  8083bc:	89 47 38             	mov    %eax,0x38(%edi)
    pcb->rtseq = ntohl(seg->tcphdr->seqno);
  8083bf:	83 ec 0c             	sub    $0xc,%esp
  8083c2:	8b 43 10             	mov    0x10(%ebx),%eax
  8083c5:	ff 70 04             	pushl  0x4(%eax)
  8083c8:	e8 e2 f6 ff ff       	call   807aaf <ntohl>
  8083cd:	89 47 3c             	mov    %eax,0x3c(%edi)
  8083d0:	83 c4 10             	add    $0x10,%esp
  8083d3:	e9 32 01 00 00       	jmp    80850a <tcp_output+0x324>
    pcb->snd_nxt = ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg);
  8083d8:	83 ec 0c             	sub    $0xc,%esp
  8083db:	8b 43 10             	mov    0x10(%ebx),%eax
  8083de:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  8083e2:	50                   	push   %eax
  8083e3:	e8 89 f4 ff ff       	call   807871 <ntohs>
  8083e8:	66 d1 e8             	shr    %ax
  8083eb:	83 e0 01             	and    $0x1,%eax
  8083ee:	83 c4 10             	add    $0x10,%esp
  8083f1:	e9 aa 01 00 00       	jmp    8085a0 <tcp_output+0x3ba>
      pcb->snd_max = pcb->snd_nxt;
  8083f6:	89 77 58             	mov    %esi,0x58(%edi)
  8083f9:	e9 b3 01 00 00       	jmp    8085b1 <tcp_output+0x3cb>
    if (TCP_TCPLEN(seg) > 0) {
  8083fe:	83 ec 0c             	sub    $0xc,%esp
  808401:	8b 43 10             	mov    0x10(%ebx),%eax
  808404:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  808408:	50                   	push   %eax
  808409:	e8 63 f4 ff ff       	call   807871 <ntohs>
  80840e:	66 d1 e8             	shr    %ax
  808411:	83 e0 01             	and    $0x1,%eax
  808414:	0f b7 f6             	movzwl %si,%esi
  808417:	83 c4 10             	add    $0x10,%esp
  80841a:	01 f0                	add    %esi,%eax
  80841c:	0f 85 ae 01 00 00    	jne    8085d0 <tcp_output+0x3ea>
      tcp_seg_free(seg);
  808422:	83 ec 0c             	sub    $0xc,%esp
  808425:	53                   	push   %ebx
  808426:	e8 53 d4 ff ff       	call   80587e <tcp_seg_free>
  80842b:	83 c4 10             	add    $0x10,%esp
  80842e:	eb 06                	jmp    808436 <tcp_output+0x250>
        pcb->unacked = seg;
  808430:	89 5f 78             	mov    %ebx,0x78(%edi)
  808433:	89 5d dc             	mov    %ebx,-0x24(%ebp)
    seg = pcb->unsent;
  808436:	8b 5f 74             	mov    0x74(%edi),%ebx
  while (seg != NULL &&
  808439:	85 db                	test   %ebx,%ebx
  80843b:	0f 84 3a 02 00 00    	je     80867b <tcp_output+0x495>
         ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
  808441:	83 ec 0c             	sub    $0xc,%esp
  808444:	8b 43 10             	mov    0x10(%ebx),%eax
  808447:	ff 70 04             	pushl  0x4(%eax)
  80844a:	e8 60 f6 ff ff       	call   807aaf <ntohl>
  80844f:	89 c2                	mov    %eax,%edx
  808451:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  808455:	2b 47 48             	sub    0x48(%edi),%eax
  808458:	01 d0                	add    %edx,%eax
  while (seg != NULL &&
  80845a:	83 c4 10             	add    $0x10,%esp
  80845d:	3b 45 d8             	cmp    -0x28(%ebp),%eax
  808460:	0f 87 0c 02 00 00    	ja     808672 <tcp_output+0x48c>
    LWIP_ASSERT("RST not expected here!", 
  808466:	83 ec 0c             	sub    $0xc,%esp
  808469:	8b 43 10             	mov    0x10(%ebx),%eax
  80846c:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  808470:	50                   	push   %eax
  808471:	e8 fb f3 ff ff       	call   807871 <ntohs>
  808476:	83 c4 10             	add    $0x10,%esp
  808479:	a8 04                	test   $0x4,%al
  80847b:	0f 85 e3 fe ff ff    	jne    808364 <tcp_output+0x17e>
    if((tcp_do_output_nagle(pcb) == 0) &&
  808481:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  808485:	74 1c                	je     8084a3 <tcp_output+0x2bd>
  808487:	0f b6 47 20          	movzbl 0x20(%edi),%eax
  80848b:	a8 40                	test   $0x40,%al
  80848d:	75 14                	jne    8084a3 <tcp_output+0x2bd>
  80848f:	8b 57 74             	mov    0x74(%edi),%edx
  808492:	85 d2                	test   %edx,%edx
  808494:	74 05                	je     80849b <tcp_output+0x2b5>
  808496:	83 3a 00             	cmpl   $0x0,(%edx)
  808499:	75 08                	jne    8084a3 <tcp_output+0x2bd>
  80849b:	a8 a0                	test   $0xa0,%al
  80849d:	0f 84 cf 01 00 00    	je     808672 <tcp_output+0x48c>
    pcb->unsent = seg->next;
  8084a3:	8b 03                	mov    (%ebx),%eax
  8084a5:	89 47 74             	mov    %eax,0x74(%edi)
    if (pcb->state != SYN_SENT) {
  8084a8:	83 7f 10 02          	cmpl   $0x2,0x10(%edi)
  8084ac:	0f 85 c9 fe ff ff    	jne    80837b <tcp_output+0x195>
  seg->tcphdr->ackno = htonl(pcb->rcv_nxt);
  8084b2:	8b 73 10             	mov    0x10(%ebx),%esi
  8084b5:	83 ec 0c             	sub    $0xc,%esp
  8084b8:	ff 77 24             	pushl  0x24(%edi)
  8084bb:	e8 c2 f3 ff ff       	call   807882 <htonl>
  8084c0:	89 46 08             	mov    %eax,0x8(%esi)
  seg->tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  8084c3:	8b 73 10             	mov    0x10(%ebx),%esi
  8084c6:	0f b7 47 2a          	movzwl 0x2a(%edi),%eax
  8084ca:	89 04 24             	mov    %eax,(%esp)
  8084cd:	e8 8e f3 ff ff       	call   807860 <htons>
  8084d2:	66 89 46 0e          	mov    %ax,0xe(%esi)
  if (ip_addr_isany(&(pcb->local_ip))) {
  8084d6:	83 c4 10             	add    $0x10,%esp
  8084d9:	83 3f 00             	cmpl   $0x0,(%edi)
  8084dc:	75 17                	jne    8084f5 <tcp_output+0x30f>
    netif = ip_route(&(pcb->remote_ip));
  8084de:	83 ec 0c             	sub    $0xc,%esp
  8084e1:	ff 75 e4             	pushl  -0x1c(%ebp)
  8084e4:	e8 42 e1 ff ff       	call   80662b <ip_route>
    if (netif == NULL) {
  8084e9:	83 c4 10             	add    $0x10,%esp
  8084ec:	85 c0                	test   %eax,%eax
  8084ee:	74 79                	je     808569 <tcp_output+0x383>
    ip_addr_set(&(pcb->local_ip), &(netif->ip_addr));
  8084f0:	8b 40 04             	mov    0x4(%eax),%eax
  8084f3:	89 07                	mov    %eax,(%edi)
  if(pcb->rtime == -1)
  8084f5:	66 83 7f 32 ff       	cmpw   $0xffff,0x32(%edi)
  8084fa:	0f 84 ac fe ff ff    	je     8083ac <tcp_output+0x1c6>
  if (pcb->rttest == 0) {
  808500:	83 7f 38 00          	cmpl   $0x0,0x38(%edi)
  808504:	0f 84 ad fe ff ff    	je     8083b7 <tcp_output+0x1d1>
  }
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output_segment: %"U32_F":%"U32_F"\n",
          htonl(seg->tcphdr->seqno), htonl(seg->tcphdr->seqno) +
          seg->len));

  len = (u16_t)((u8_t *)seg->tcphdr - (u8_t *)seg->p->payload);
  80850a:	8b 53 04             	mov    0x4(%ebx),%edx
  80850d:	8b 43 10             	mov    0x10(%ebx),%eax
  808510:	2b 42 04             	sub    0x4(%edx),%eax

  seg->p->len -= len;
  808513:	66 29 42 0a          	sub    %ax,0xa(%edx)
  seg->p->tot_len -= len;
  808517:	8b 53 04             	mov    0x4(%ebx),%edx
  80851a:	66 29 42 08          	sub    %ax,0x8(%edx)

  seg->p->payload = seg->tcphdr;
  80851e:	8b 53 04             	mov    0x4(%ebx),%edx
  808521:	8b 43 10             	mov    0x10(%ebx),%eax
  808524:	89 42 04             	mov    %eax,0x4(%edx)

  seg->tcphdr->chksum = 0;
  808527:	66 c7 40 10 00 00    	movw   $0x0,0x10(%eax)
#if CHECKSUM_GEN_TCP
  seg->tcphdr->chksum = inet_chksum_pseudo(seg->p,
             &(pcb->local_ip),
             &(pcb->remote_ip),
             IP_PROTO_TCP, seg->p->tot_len);
  80852d:	8b 43 04             	mov    0x4(%ebx),%eax
  seg->tcphdr->chksum = inet_chksum_pseudo(seg->p,
  808530:	8b 73 10             	mov    0x10(%ebx),%esi
  808533:	83 ec 0c             	sub    $0xc,%esp
  808536:	0f b7 50 08          	movzwl 0x8(%eax),%edx
  80853a:	52                   	push   %edx
  80853b:	6a 06                	push   $0x6
  80853d:	ff 75 e4             	pushl  -0x1c(%ebp)
  808540:	57                   	push   %edi
  808541:	50                   	push   %eax
  808542:	e8 e1 ef ff ff       	call   807528 <inet_chksum_pseudo>
  808547:	66 89 46 10          	mov    %ax,0x10(%esi)
                   pcb->tos, IP_PROTO_TCP, netif);
      netif->addr_hint = NULL;
    }
  }
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(seg->p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
  80854b:	83 c4 18             	add    $0x18,%esp
  80854e:	6a 06                	push   $0x6
  808550:	0f b6 47 0a          	movzbl 0xa(%edi),%eax
  808554:	50                   	push   %eax
  808555:	0f b6 47 0b          	movzbl 0xb(%edi),%eax
  808559:	50                   	push   %eax
  80855a:	ff 75 e4             	pushl  -0x1c(%ebp)
  80855d:	57                   	push   %edi
  80855e:	ff 73 04             	pushl  0x4(%ebx)
  808561:	e8 d2 e5 ff ff       	call   806b38 <ip_output>
  808566:	83 c4 20             	add    $0x20,%esp
    pcb->snd_nxt = ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg);
  808569:	83 ec 0c             	sub    $0xc,%esp
  80856c:	8b 43 10             	mov    0x10(%ebx),%eax
  80856f:	ff 70 04             	pushl  0x4(%eax)
  808572:	e8 38 f5 ff ff       	call   807aaf <ntohl>
  808577:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80857a:	0f b7 73 0c          	movzwl 0xc(%ebx),%esi
  80857e:	8b 43 10             	mov    0x10(%ebx),%eax
  808581:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  808585:	89 04 24             	mov    %eax,(%esp)
  808588:	e8 e4 f2 ff ff       	call   807871 <ntohs>
  80858d:	89 c2                	mov    %eax,%edx
  80858f:	83 c4 10             	add    $0x10,%esp
  808592:	b8 01 00 00 00       	mov    $0x1,%eax
  808597:	f6 c2 01             	test   $0x1,%dl
  80859a:	0f 84 38 fe ff ff    	je     8083d8 <tcp_output+0x1f2>
  8085a0:	01 c6                	add    %eax,%esi
  8085a2:	03 75 e0             	add    -0x20(%ebp),%esi
  8085a5:	89 77 54             	mov    %esi,0x54(%edi)
    if (TCP_SEQ_LT(pcb->snd_max, pcb->snd_nxt)) {
  8085a8:	39 77 58             	cmp    %esi,0x58(%edi)
  8085ab:	0f 88 45 fe ff ff    	js     8083f6 <tcp_output+0x210>
    if (TCP_TCPLEN(seg) > 0) {
  8085b1:	0f b7 73 0c          	movzwl 0xc(%ebx),%esi
  8085b5:	83 ec 0c             	sub    $0xc,%esp
  8085b8:	8b 43 10             	mov    0x10(%ebx),%eax
  8085bb:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  8085bf:	50                   	push   %eax
  8085c0:	e8 ac f2 ff ff       	call   807871 <ntohs>
  8085c5:	83 c4 10             	add    $0x10,%esp
  8085c8:	a8 01                	test   $0x1,%al
  8085ca:	0f 84 2e fe ff ff    	je     8083fe <tcp_output+0x218>
      seg->next = NULL;
  8085d0:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
      if (pcb->unacked == NULL) {
  8085d6:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  8085da:	0f 84 50 fe ff ff    	je     808430 <tcp_output+0x24a>
        if (TCP_SEQ_LT(ntohl(seg->tcphdr->seqno), ntohl(useg->tcphdr->seqno))){
  8085e0:	83 ec 0c             	sub    $0xc,%esp
  8085e3:	8b 43 10             	mov    0x10(%ebx),%eax
  8085e6:	ff 70 04             	pushl  0x4(%eax)
  8085e9:	e8 c1 f4 ff ff       	call   807aaf <ntohl>
  8085ee:	89 c6                	mov    %eax,%esi
  8085f0:	83 c4 04             	add    $0x4,%esp
  8085f3:	8b 45 dc             	mov    -0x24(%ebp),%eax
  8085f6:	8b 40 10             	mov    0x10(%eax),%eax
  8085f9:	ff 70 04             	pushl  0x4(%eax)
  8085fc:	e8 ae f4 ff ff       	call   807aaf <ntohl>
  808601:	83 c4 10             	add    $0x10,%esp
  808604:	39 c6                	cmp    %eax,%esi
  808606:	78 0d                	js     808615 <tcp_output+0x42f>
          useg->next = seg;
  808608:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80860b:	89 18                	mov    %ebx,(%eax)
  80860d:	89 5d dc             	mov    %ebx,-0x24(%ebp)
  808610:	e9 21 fe ff ff       	jmp    808436 <tcp_output+0x250>
          seg->next = pcb->unacked;
  808615:	8b 47 78             	mov    0x78(%edi),%eax
  808618:	89 03                	mov    %eax,(%ebx)
          pcb->unacked = seg;
  80861a:	89 5f 78             	mov    %ebx,0x78(%edi)
  80861d:	e9 14 fe ff ff       	jmp    808436 <tcp_output+0x250>
  seg->tcphdr->chksum = inet_chksum_pseudo(seg->p,
  808622:	8d 47 04             	lea    0x4(%edi),%eax
  808625:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  808628:	e9 0c fe ff ff       	jmp    808439 <tcp_output+0x253>
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > pcb->snd_wnd) {
  80862d:	83 ec 0c             	sub    $0xc,%esp
  808630:	8b 43 10             	mov    0x10(%ebx),%eax
  808633:	ff 70 04             	pushl  0x4(%eax)
  808636:	e8 74 f4 ff ff       	call   807aaf <ntohl>
  80863b:	89 c2                	mov    %eax,%edx
  80863d:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  808641:	2b 47 48             	sub    0x48(%edi),%eax
  808644:	01 d0                	add    %edx,%eax
  808646:	0f b7 57 5c          	movzwl 0x5c(%edi),%edx
  if (seg != NULL && pcb->persist_backoff == 0 && 
  80864a:	83 c4 10             	add    $0x10,%esp
  80864d:	39 d0                	cmp    %edx,%eax
  80864f:	76 2a                	jbe    80867b <tcp_output+0x495>
    pcb->persist_cnt = 0;
  808651:	c7 87 a0 00 00 00 00 	movl   $0x0,0xa0(%edi)
  808658:	00 00 00 
    pcb->persist_backoff = 1;
  80865b:	c6 87 a4 00 00 00 01 	movb   $0x1,0xa4(%edi)
  808662:	eb 17                	jmp    80867b <tcp_output+0x495>
    return ERR_OK;
  808664:	b8 00 00 00 00       	mov    $0x0,%eax
  808669:	eb 19                	jmp    808684 <tcp_output+0x49e>
      return ERR_BUF;
  80866b:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  808670:	eb 12                	jmp    808684 <tcp_output+0x49e>
  if (seg != NULL && pcb->persist_backoff == 0 && 
  808672:	80 bf a4 00 00 00 00 	cmpb   $0x0,0xa4(%edi)
  808679:	74 b2                	je     80862d <tcp_output+0x447>
  pcb->flags &= ~TF_NAGLEMEMERR;
  80867b:	80 67 20 7f          	andb   $0x7f,0x20(%edi)
  return ERR_OK;
  80867f:	b8 00 00 00 00       	mov    $0x0,%eax
}
  808684:	8d 65 f4             	lea    -0xc(%ebp),%esp
  808687:	5b                   	pop    %ebx
  808688:	5e                   	pop    %esi
  808689:	5f                   	pop    %edi
  80868a:	5d                   	pop    %ebp
  80868b:	c3                   	ret    

0080868c <tcp_rst>:
 */
void
tcp_rst(u32_t seqno, u32_t ackno,
  struct ip_addr *local_ip, struct ip_addr *remote_ip,
  u16_t local_port, u16_t remote_port)
{
  80868c:	f3 0f 1e fb          	endbr32 
  808690:	55                   	push   %ebp
  808691:	89 e5                	mov    %esp,%ebp
  808693:	57                   	push   %edi
  808694:	56                   	push   %esi
  808695:	53                   	push   %ebx
  808696:	83 ec 20             	sub    $0x20,%esp
  808699:	8b 7d 18             	mov    0x18(%ebp),%edi
  80869c:	8b 45 1c             	mov    0x1c(%ebp),%eax
  80869f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  struct pbuf *p;
  struct tcp_hdr *tcphdr;
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  8086a2:	6a 00                	push   $0x0
  8086a4:	6a 14                	push   $0x14
  8086a6:	6a 01                	push   $0x1
  8086a8:	e8 45 c3 ff ff       	call   8049f2 <pbuf_alloc>
  if (p == NULL) {
  8086ad:	83 c4 10             	add    $0x10,%esp
  8086b0:	85 c0                	test   %eax,%eax
  8086b2:	0f 84 e2 00 00 00    	je     80879a <tcp_rst+0x10e>
  8086b8:	89 c6                	mov    %eax,%esi
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_rst: could not allocate memory for pbuf\n"));
      return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  8086ba:	66 83 78 0a 13       	cmpw   $0x13,0xa(%eax)
  8086bf:	0f 86 dd 00 00 00    	jbe    8087a2 <tcp_rst+0x116>
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = p->payload;
  8086c5:	8b 58 04             	mov    0x4(%eax),%ebx
  tcphdr->src = htons(local_port);
  8086c8:	83 ec 0c             	sub    $0xc,%esp
  8086cb:	0f b7 ff             	movzwl %di,%edi
  8086ce:	57                   	push   %edi
  8086cf:	e8 8c f1 ff ff       	call   807860 <htons>
  8086d4:	66 89 03             	mov    %ax,(%ebx)
  tcphdr->dest = htons(remote_port);
  8086d7:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  8086db:	89 04 24             	mov    %eax,(%esp)
  8086de:	e8 7d f1 ff ff       	call   807860 <htons>
  8086e3:	66 89 43 02          	mov    %ax,0x2(%ebx)
  tcphdr->seqno = htonl(seqno);
  8086e7:	83 c4 04             	add    $0x4,%esp
  8086ea:	ff 75 08             	pushl  0x8(%ebp)
  8086ed:	e8 90 f1 ff ff       	call   807882 <htonl>
  8086f2:	89 43 04             	mov    %eax,0x4(%ebx)
  tcphdr->ackno = htonl(ackno);
  8086f5:	83 c4 04             	add    $0x4,%esp
  8086f8:	ff 75 0c             	pushl  0xc(%ebp)
  8086fb:	e8 82 f1 ff ff       	call   807882 <htonl>
  808700:	89 43 08             	mov    %eax,0x8(%ebx)
  TCPH_FLAGS_SET(tcphdr, TCP_RST | TCP_ACK);
  808703:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  808707:	89 04 24             	mov    %eax,(%esp)
  80870a:	e8 62 f1 ff ff       	call   807871 <ntohs>
  80870f:	25 c0 ff 00 00       	and    $0xffc0,%eax
  808714:	83 c8 14             	or     $0x14,%eax
  808717:	89 04 24             	mov    %eax,(%esp)
  80871a:	e8 41 f1 ff ff       	call   807860 <htons>
  80871f:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  tcphdr->wnd = htons(TCP_WND);
  808723:	c7 04 24 c0 5d 00 00 	movl   $0x5dc0,(%esp)
  80872a:	e8 31 f1 ff ff       	call   807860 <htons>
  80872f:	66 89 43 0e          	mov    %ax,0xe(%ebx)
  tcphdr->urgp = 0;
  808733:	66 c7 43 12 00 00    	movw   $0x0,0x12(%ebx)
  TCPH_HDRLEN_SET(tcphdr, 5);
  808739:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80873d:	89 04 24             	mov    %eax,(%esp)
  808740:	e8 2c f1 ff ff       	call   807871 <ntohs>
  808745:	83 e0 3f             	and    $0x3f,%eax
  808748:	80 cc 50             	or     $0x50,%ah
  80874b:	89 04 24             	mov    %eax,(%esp)
  80874e:	e8 0d f1 ff ff       	call   807860 <htons>
  808753:	66 89 43 0c          	mov    %ax,0xc(%ebx)

  tcphdr->chksum = 0;
  808757:	66 c7 43 10 00 00    	movw   $0x0,0x10(%ebx)
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, local_ip, remote_ip,
  80875d:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  808761:	89 04 24             	mov    %eax,(%esp)
  808764:	6a 06                	push   $0x6
  808766:	ff 75 14             	pushl  0x14(%ebp)
  808769:	ff 75 10             	pushl  0x10(%ebp)
  80876c:	56                   	push   %esi
  80876d:	e8 b6 ed ff ff       	call   807528 <inet_chksum_pseudo>
  808772:	66 89 43 10          	mov    %ax,0x10(%ebx)
              IP_PROTO_TCP, p->tot_len);
#endif
  TCP_STATS_INC(tcp.xmit);
  snmp_inc_tcpoutrsts();
   /* Send output with hardcoded TTL since we have no access to the pcb */
  ip_output(p, local_ip, remote_ip, TCP_TTL, 0, IP_PROTO_TCP);
  808776:	83 c4 18             	add    $0x18,%esp
  808779:	6a 06                	push   $0x6
  80877b:	6a 00                	push   $0x0
  80877d:	68 ff 00 00 00       	push   $0xff
  808782:	ff 75 14             	pushl  0x14(%ebp)
  808785:	ff 75 10             	pushl  0x10(%ebp)
  808788:	56                   	push   %esi
  808789:	e8 aa e3 ff ff       	call   806b38 <ip_output>
  pbuf_free(p);
  80878e:	83 c4 14             	add    $0x14,%esp
  808791:	56                   	push   %esi
  808792:	e8 91 c1 ff ff       	call   804928 <pbuf_free>
  808797:	83 c4 10             	add    $0x10,%esp
  LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_rst: seqno %"U32_F" ackno %"U32_F".\n", seqno, ackno));
}
  80879a:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80879d:	5b                   	pop    %ebx
  80879e:	5e                   	pop    %esi
  80879f:	5f                   	pop    %edi
  8087a0:	5d                   	pop    %ebp
  8087a1:	c3                   	ret    
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  8087a2:	83 ec 04             	sub    $0x4,%esp
  8087a5:	68 b8 25 81 00       	push   $0x8125b8
  8087aa:	68 bd 02 00 00       	push   $0x2bd
  8087af:	68 e6 25 81 00       	push   $0x8125e6
  8087b4:	e8 8e 60 00 00       	call   80e847 <_panic>

008087b9 <tcp_rexmit_rto>:
 *
 * @param pcb the tcp_pcb for which to re-enqueue all unacked segments
 */
void
tcp_rexmit_rto(struct tcp_pcb *pcb)
{
  8087b9:	f3 0f 1e fb          	endbr32 
  8087bd:	55                   	push   %ebp
  8087be:	89 e5                	mov    %esp,%ebp
  8087c0:	53                   	push   %ebx
  8087c1:	83 ec 04             	sub    $0x4,%esp
  8087c4:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct tcp_seg *seg;

  if (pcb->unacked == NULL) {
  8087c7:	8b 43 78             	mov    0x78(%ebx),%eax
  8087ca:	85 c0                	test   %eax,%eax
  8087cc:	74 41                	je     80880f <tcp_rexmit_rto+0x56>
  8087ce:	89 c2                	mov    %eax,%edx
    return;
  }

  /* Move all unacked segments to the head of the unsent queue */
  for (seg = pcb->unacked; seg->next != NULL; seg = seg->next);
  8087d0:	8b 00                	mov    (%eax),%eax
  8087d2:	85 c0                	test   %eax,%eax
  8087d4:	75 f8                	jne    8087ce <tcp_rexmit_rto+0x15>
  /* concatenate unsent queue after unacked queue */
  seg->next = pcb->unsent;
  8087d6:	8b 43 74             	mov    0x74(%ebx),%eax
  8087d9:	89 02                	mov    %eax,(%edx)
  /* unsent queue is the concatenated queue (of unacked, unsent) */
  pcb->unsent = pcb->unacked;
  8087db:	8b 43 78             	mov    0x78(%ebx),%eax
  8087de:	89 43 74             	mov    %eax,0x74(%ebx)
  /* unacked queue is now empty */
  pcb->unacked = NULL;
  8087e1:	c7 43 78 00 00 00 00 	movl   $0x0,0x78(%ebx)

  pcb->snd_nxt = ntohl(pcb->unsent->tcphdr->seqno);
  8087e8:	83 ec 0c             	sub    $0xc,%esp
  8087eb:	8b 40 10             	mov    0x10(%eax),%eax
  8087ee:	ff 70 04             	pushl  0x4(%eax)
  8087f1:	e8 b9 f2 ff ff       	call   807aaf <ntohl>
  8087f6:	89 43 54             	mov    %eax,0x54(%ebx)
  /* increment number of retransmissions */
  ++pcb->nrtx;
  8087f9:	80 43 46 01          	addb   $0x1,0x46(%ebx)

  /* Don't take any RTT measurements after retransmitting. */
  pcb->rttest = 0;
  8087fd:	c7 43 38 00 00 00 00 	movl   $0x0,0x38(%ebx)

  /* Do the actual retransmission */
  tcp_output(pcb);
  808804:	89 1c 24             	mov    %ebx,(%esp)
  808807:	e8 da f9 ff ff       	call   8081e6 <tcp_output>
  80880c:	83 c4 10             	add    $0x10,%esp
}
  80880f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  808812:	c9                   	leave  
  808813:	c3                   	ret    

00808814 <tcp_rexmit>:
 *
 * @param pcb the tcp_pcb for which to retransmit the first unacked segment
 */
void
tcp_rexmit(struct tcp_pcb *pcb)
{
  808814:	f3 0f 1e fb          	endbr32 
  808818:	55                   	push   %ebp
  808819:	89 e5                	mov    %esp,%ebp
  80881b:	53                   	push   %ebx
  80881c:	83 ec 04             	sub    $0x4,%esp
  80881f:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct tcp_seg *seg;

  if (pcb->unacked == NULL) {
  808822:	8b 43 78             	mov    0x78(%ebx),%eax
  808825:	85 c0                	test   %eax,%eax
  808827:	74 37                	je     808860 <tcp_rexmit+0x4c>
    return;
  }

  /* Move the first unacked segment to the unsent queue */
  seg = pcb->unacked->next;
  808829:	8b 10                	mov    (%eax),%edx
  pcb->unacked->next = pcb->unsent;
  80882b:	8b 4b 74             	mov    0x74(%ebx),%ecx
  80882e:	89 08                	mov    %ecx,(%eax)
  pcb->unsent = pcb->unacked;
  808830:	8b 43 78             	mov    0x78(%ebx),%eax
  808833:	89 43 74             	mov    %eax,0x74(%ebx)
  pcb->unacked = seg;
  808836:	89 53 78             	mov    %edx,0x78(%ebx)

  pcb->snd_nxt = ntohl(pcb->unsent->tcphdr->seqno);
  808839:	83 ec 0c             	sub    $0xc,%esp
  80883c:	8b 40 10             	mov    0x10(%eax),%eax
  80883f:	ff 70 04             	pushl  0x4(%eax)
  808842:	e8 68 f2 ff ff       	call   807aaf <ntohl>
  808847:	89 43 54             	mov    %eax,0x54(%ebx)

  ++pcb->nrtx;
  80884a:	80 43 46 01          	addb   $0x1,0x46(%ebx)

  /* Don't take any rtt measurements after retransmitting. */
  pcb->rttest = 0;
  80884e:	c7 43 38 00 00 00 00 	movl   $0x0,0x38(%ebx)

  /* Do the actual retransmission. */
  snmp_inc_tcpretranssegs();
  tcp_output(pcb);
  808855:	89 1c 24             	mov    %ebx,(%esp)
  808858:	e8 89 f9 ff ff       	call   8081e6 <tcp_output>
  80885d:	83 c4 10             	add    $0x10,%esp
}
  808860:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  808863:	c9                   	leave  
  808864:	c3                   	ret    

00808865 <tcp_keepalive>:
 *
 * @param pcb the tcp_pcb for which to send a keepalive packet
 */
void
tcp_keepalive(struct tcp_pcb *pcb)
{
  808865:	f3 0f 1e fb          	endbr32 
  808869:	55                   	push   %ebp
  80886a:	89 e5                	mov    %esp,%ebp
  80886c:	57                   	push   %edi
  80886d:	56                   	push   %esi
  80886e:	53                   	push   %ebx
  80886f:	83 ec 20             	sub    $0x20,%esp
  808872:	8b 7d 08             	mov    0x8(%ebp),%edi
                          ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip)));

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: tcp_ticks %"U32_F"   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
                          tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));
   
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  808875:	6a 00                	push   $0x0
  808877:	6a 14                	push   $0x14
  808879:	6a 01                	push   $0x1
  80887b:	e8 72 c1 ff ff       	call   8049f2 <pbuf_alloc>
   
  if(p == NULL) {
  808880:	83 c4 10             	add    $0x10,%esp
  808883:	85 c0                	test   %eax,%eax
  808885:	0f 84 e5 00 00 00    	je     808970 <tcp_keepalive+0x10b>
  80888b:	89 c6                	mov    %eax,%esi
    LWIP_DEBUGF(TCP_DEBUG, 
                ("tcp_keepalive: could not allocate memory for pbuf\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  80888d:	66 83 78 0a 13       	cmpw   $0x13,0xa(%eax)
  808892:	0f 86 e0 00 00 00    	jbe    808978 <tcp_keepalive+0x113>
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = p->payload;
  808898:	8b 58 04             	mov    0x4(%eax),%ebx
  tcphdr->src = htons(pcb->local_port);
  80889b:	83 ec 0c             	sub    $0xc,%esp
  80889e:	0f b7 47 1c          	movzwl 0x1c(%edi),%eax
  8088a2:	50                   	push   %eax
  8088a3:	e8 b8 ef ff ff       	call   807860 <htons>
  8088a8:	66 89 03             	mov    %ax,(%ebx)
  tcphdr->dest = htons(pcb->remote_port);
  8088ab:	0f b7 47 1e          	movzwl 0x1e(%edi),%eax
  8088af:	89 04 24             	mov    %eax,(%esp)
  8088b2:	e8 a9 ef ff ff       	call   807860 <htons>
  8088b7:	66 89 43 02          	mov    %ax,0x2(%ebx)
  tcphdr->seqno = htonl(pcb->snd_nxt - 1);
  8088bb:	8b 47 54             	mov    0x54(%edi),%eax
  8088be:	83 e8 01             	sub    $0x1,%eax
  8088c1:	89 04 24             	mov    %eax,(%esp)
  8088c4:	e8 b9 ef ff ff       	call   807882 <htonl>
  8088c9:	89 43 04             	mov    %eax,0x4(%ebx)
  tcphdr->ackno = htonl(pcb->rcv_nxt);
  8088cc:	83 c4 04             	add    $0x4,%esp
  8088cf:	ff 77 24             	pushl  0x24(%edi)
  8088d2:	e8 ab ef ff ff       	call   807882 <htonl>
  8088d7:	89 43 08             	mov    %eax,0x8(%ebx)
  TCPH_FLAGS_SET(tcphdr, 0);
  8088da:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  8088de:	89 04 24             	mov    %eax,(%esp)
  8088e1:	e8 8b ef ff ff       	call   807871 <ntohs>
  8088e6:	25 c0 ff 00 00       	and    $0xffc0,%eax
  8088eb:	89 04 24             	mov    %eax,(%esp)
  8088ee:	e8 6d ef ff ff       	call   807860 <htons>
  8088f3:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  8088f7:	0f b7 47 2a          	movzwl 0x2a(%edi),%eax
  8088fb:	89 04 24             	mov    %eax,(%esp)
  8088fe:	e8 5d ef ff ff       	call   807860 <htons>
  808903:	66 89 43 0e          	mov    %ax,0xe(%ebx)
  tcphdr->urgp = 0;
  808907:	66 c7 43 12 00 00    	movw   $0x0,0x12(%ebx)
  TCPH_HDRLEN_SET(tcphdr, 5);
  80890d:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  808911:	89 04 24             	mov    %eax,(%esp)
  808914:	e8 58 ef ff ff       	call   807871 <ntohs>
  808919:	83 e0 3f             	and    $0x3f,%eax
  80891c:	80 cc 50             	or     $0x50,%ah
  80891f:	89 04 24             	mov    %eax,(%esp)
  808922:	e8 39 ef ff ff       	call   807860 <htons>
  808927:	66 89 43 0c          	mov    %ax,0xc(%ebx)

  tcphdr->chksum = 0;
  80892b:	66 c7 43 10 00 00    	movw   $0x0,0x10(%ebx)
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
  808931:	8d 47 04             	lea    0x4(%edi),%eax
  808934:	89 c2                	mov    %eax,%edx
  808936:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  80893a:	89 04 24             	mov    %eax,(%esp)
  80893d:	6a 06                	push   $0x6
  80893f:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  808942:	52                   	push   %edx
  808943:	57                   	push   %edi
  808944:	56                   	push   %esi
  808945:	e8 de eb ff ff       	call   807528 <inet_chksum_pseudo>
  80894a:	66 89 43 10          	mov    %ax,0x10(%ebx)
                   0, IP_PROTO_TCP, netif);
      netif->addr_hint = NULL;
    }
  }
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
  80894e:	83 c4 18             	add    $0x18,%esp
  808951:	6a 06                	push   $0x6
  808953:	6a 00                	push   $0x0
  808955:	0f b6 47 0b          	movzbl 0xb(%edi),%eax
  808959:	50                   	push   %eax
  80895a:	ff 75 e4             	pushl  -0x1c(%ebp)
  80895d:	57                   	push   %edi
  80895e:	56                   	push   %esi
  80895f:	e8 d4 e1 ff ff       	call   806b38 <ip_output>
#endif /* LWIP_NETIF_HWADDRHINT*/

  pbuf_free(p);
  808964:	83 c4 14             	add    $0x14,%esp
  808967:	56                   	push   %esi
  808968:	e8 bb bf ff ff       	call   804928 <pbuf_free>
  80896d:	83 c4 10             	add    $0x10,%esp

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: seqno %"U32_F" ackno %"U32_F".\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt));
}
  808970:	8d 65 f4             	lea    -0xc(%ebp),%esp
  808973:	5b                   	pop    %ebx
  808974:	5e                   	pop    %esi
  808975:	5f                   	pop    %edi
  808976:	5d                   	pop    %ebp
  808977:	c3                   	ret    
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  808978:	83 ec 04             	sub    $0x4,%esp
  80897b:	68 b8 25 81 00       	push   $0x8125b8
  808980:	68 39 03 00 00       	push   $0x339
  808985:	68 e6 25 81 00       	push   $0x8125e6
  80898a:	e8 b8 5e 00 00       	call   80e847 <_panic>

0080898f <tcp_zero_window_probe>:
 *
 * @param pcb the tcp_pcb for which to send a zero-window probe packet
 */
void
tcp_zero_window_probe(struct tcp_pcb *pcb)
{
  80898f:	f3 0f 1e fb          	endbr32 
  808993:	55                   	push   %ebp
  808994:	89 e5                	mov    %esp,%ebp
  808996:	57                   	push   %edi
  808997:	56                   	push   %esi
  808998:	53                   	push   %ebx
  808999:	83 ec 1c             	sub    $0x1c,%esp
  80899c:	8b 75 08             	mov    0x8(%ebp),%esi
  LWIP_DEBUGF(TCP_DEBUG, 
              ("tcp_zero_window_probe: tcp_ticks %"U32_F
               "   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
               tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));

  seg = pcb->unacked;
  80899f:	8b 46 78             	mov    0x78(%esi),%eax
  8089a2:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  if(seg == NULL)
  8089a5:	85 c0                	test   %eax,%eax
  8089a7:	0f 84 10 01 00 00    	je     808abd <tcp_zero_window_probe+0x12e>
    seg = pcb->unsent;

  if(seg == NULL)
    return;

  p = pbuf_alloc(PBUF_IP, TCP_HLEN + 1, PBUF_RAM);
  8089ad:	83 ec 04             	sub    $0x4,%esp
  8089b0:	6a 00                	push   $0x0
  8089b2:	6a 15                	push   $0x15
  8089b4:	6a 01                	push   $0x1
  8089b6:	e8 37 c0 ff ff       	call   8049f2 <pbuf_alloc>
  8089bb:	89 c7                	mov    %eax,%edi
   
  if(p == NULL) {
  8089bd:	83 c4 10             	add    $0x10,%esp
  8089c0:	85 c0                	test   %eax,%eax
  8089c2:	0f 84 ed 00 00 00    	je     808ab5 <tcp_zero_window_probe+0x126>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: no memory for pbuf\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  8089c8:	66 83 78 0a 13       	cmpw   $0x13,0xa(%eax)
  8089cd:	0f 86 f9 00 00 00    	jbe    808acc <tcp_zero_window_probe+0x13d>
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = p->payload;
  8089d3:	8b 58 04             	mov    0x4(%eax),%ebx
  tcphdr->src = htons(pcb->local_port);
  8089d6:	83 ec 0c             	sub    $0xc,%esp
  8089d9:	0f b7 46 1c          	movzwl 0x1c(%esi),%eax
  8089dd:	50                   	push   %eax
  8089de:	e8 7d ee ff ff       	call   807860 <htons>
  8089e3:	66 89 03             	mov    %ax,(%ebx)
  tcphdr->dest = htons(pcb->remote_port);
  8089e6:	0f b7 46 1e          	movzwl 0x1e(%esi),%eax
  8089ea:	89 04 24             	mov    %eax,(%esp)
  8089ed:	e8 6e ee ff ff       	call   807860 <htons>
  8089f2:	66 89 43 02          	mov    %ax,0x2(%ebx)
  tcphdr->seqno = seg->tcphdr->seqno;
  8089f6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8089f9:	8b 40 10             	mov    0x10(%eax),%eax
  8089fc:	8b 40 04             	mov    0x4(%eax),%eax
  8089ff:	89 43 04             	mov    %eax,0x4(%ebx)
  tcphdr->ackno = htonl(pcb->rcv_nxt);
  808a02:	83 c4 04             	add    $0x4,%esp
  808a05:	ff 76 24             	pushl  0x24(%esi)
  808a08:	e8 75 ee ff ff       	call   807882 <htonl>
  808a0d:	89 43 08             	mov    %eax,0x8(%ebx)
  TCPH_FLAGS_SET(tcphdr, 0);
  808a10:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  808a14:	89 04 24             	mov    %eax,(%esp)
  808a17:	e8 55 ee ff ff       	call   807871 <ntohs>
  808a1c:	25 c0 ff 00 00       	and    $0xffc0,%eax
  808a21:	89 04 24             	mov    %eax,(%esp)
  808a24:	e8 37 ee ff ff       	call   807860 <htons>
  808a29:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  808a2d:	0f b7 46 2a          	movzwl 0x2a(%esi),%eax
  808a31:	89 04 24             	mov    %eax,(%esp)
  808a34:	e8 27 ee ff ff       	call   807860 <htons>
  808a39:	66 89 43 0e          	mov    %ax,0xe(%ebx)
  tcphdr->urgp = 0;
  808a3d:	66 c7 43 12 00 00    	movw   $0x0,0x12(%ebx)
  TCPH_HDRLEN_SET(tcphdr, 5);
  808a43:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  808a47:	89 04 24             	mov    %eax,(%esp)
  808a4a:	e8 22 ee ff ff       	call   807871 <ntohs>
  808a4f:	83 e0 3f             	and    $0x3f,%eax
  808a52:	80 cc 50             	or     $0x50,%ah
  808a55:	89 04 24             	mov    %eax,(%esp)
  808a58:	e8 03 ee ff ff       	call   807860 <htons>
  808a5d:	66 89 43 0c          	mov    %ax,0xc(%ebx)

  /* Copy in one byte from the head of the unacked queue */
  *((char *)p->payload + sizeof(struct tcp_hdr)) = *(char *)seg->dataptr;
  808a61:	8b 47 04             	mov    0x4(%edi),%eax
  808a64:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  808a67:	8b 51 08             	mov    0x8(%ecx),%edx
  808a6a:	0f b6 12             	movzbl (%edx),%edx
  808a6d:	88 50 14             	mov    %dl,0x14(%eax)

  tcphdr->chksum = 0;
  808a70:	66 c7 43 10 00 00    	movw   $0x0,0x10(%ebx)
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
  808a76:	8d 46 04             	lea    0x4(%esi),%eax
  808a79:	89 c1                	mov    %eax,%ecx
  808a7b:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  808a7f:	89 04 24             	mov    %eax,(%esp)
  808a82:	6a 06                	push   $0x6
  808a84:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  808a87:	51                   	push   %ecx
  808a88:	56                   	push   %esi
  808a89:	57                   	push   %edi
  808a8a:	e8 99 ea ff ff       	call   807528 <inet_chksum_pseudo>
  808a8f:	66 89 43 10          	mov    %ax,0x10(%ebx)
                   0, IP_PROTO_TCP, netif);
      netif->addr_hint = NULL;
    }
  }
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
  808a93:	83 c4 18             	add    $0x18,%esp
  808a96:	6a 06                	push   $0x6
  808a98:	6a 00                	push   $0x0
  808a9a:	0f b6 46 0b          	movzbl 0xb(%esi),%eax
  808a9e:	50                   	push   %eax
  808a9f:	ff 75 e4             	pushl  -0x1c(%ebp)
  808aa2:	56                   	push   %esi
  808aa3:	57                   	push   %edi
  808aa4:	e8 8f e0 ff ff       	call   806b38 <ip_output>
#endif /* LWIP_NETIF_HWADDRHINT*/

  pbuf_free(p);
  808aa9:	83 c4 14             	add    $0x14,%esp
  808aac:	57                   	push   %edi
  808aad:	e8 76 be ff ff       	call   804928 <pbuf_free>
  808ab2:	83 c4 10             	add    $0x10,%esp

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: seqno %"U32_F
                          " ackno %"U32_F".\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt));
}
  808ab5:	8d 65 f4             	lea    -0xc(%ebp),%esp
  808ab8:	5b                   	pop    %ebx
  808ab9:	5e                   	pop    %esi
  808aba:	5f                   	pop    %edi
  808abb:	5d                   	pop    %ebp
  808abc:	c3                   	ret    
    seg = pcb->unsent;
  808abd:	8b 46 74             	mov    0x74(%esi),%eax
  808ac0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  if(seg == NULL)
  808ac3:	85 c0                	test   %eax,%eax
  808ac5:	74 ee                	je     808ab5 <tcp_zero_window_probe+0x126>
  808ac7:	e9 e1 fe ff ff       	jmp    8089ad <tcp_zero_window_probe+0x1e>
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  808acc:	83 ec 04             	sub    $0x4,%esp
  808acf:	68 b8 25 81 00       	push   $0x8125b8
  808ad4:	68 8c 03 00 00       	push   $0x38c
  808ad9:	68 e6 25 81 00       	push   $0x8125e6
  808ade:	e8 64 5d 00 00       	call   80e847 <_panic>

00808ae3 <udp_input>:
 * @param inp network interface on which the datagram was received.
 *
 */
void
udp_input(struct pbuf *p, struct netif *inp)
{
  808ae3:	f3 0f 1e fb          	endbr32 
  808ae7:	55                   	push   %ebp
  808ae8:	89 e5                	mov    %esp,%ebp
  808aea:	57                   	push   %edi
  808aeb:	56                   	push   %esi
  808aec:	53                   	push   %ebx
  808aed:	83 ec 38             	sub    $0x38,%esp

  PERF_START;

  UDP_STATS_INC(udp.recv);

  iphdr = p->payload;
  808af0:	8b 45 08             	mov    0x8(%ebp),%eax
  808af3:	8b 78 04             	mov    0x4(%eax),%edi

  /* Check minimum length (IP header + UDP header)
   * and move payload pointer to UDP header */
  if (p->tot_len < (IPH_HL(iphdr) * 4 + UDP_HLEN) || pbuf_header(p, -(s16_t)(IPH_HL(iphdr) * 4))) {
  808af6:	0f b7 58 08          	movzwl 0x8(%eax),%ebx
  808afa:	0f b7 07             	movzwl (%edi),%eax
  808afd:	50                   	push   %eax
  808afe:	e8 6e ed ff ff       	call   807871 <ntohs>
  808b03:	66 c1 e8 08          	shr    $0x8,%ax
  808b07:	83 e0 0f             	and    $0xf,%eax
  808b0a:	8d 04 85 08 00 00 00 	lea    0x8(,%eax,4),%eax
  808b11:	83 c4 10             	add    $0x10,%esp
  808b14:	39 c3                	cmp    %eax,%ebx
  808b16:	7c 29                	jl     808b41 <udp_input+0x5e>
  808b18:	83 ec 0c             	sub    $0xc,%esp
  808b1b:	0f b7 07             	movzwl (%edi),%eax
  808b1e:	50                   	push   %eax
  808b1f:	e8 4d ed ff ff       	call   807871 <ntohs>
  808b24:	83 c4 08             	add    $0x8,%esp
  808b27:	66 c1 e8 06          	shr    $0x6,%ax
  808b2b:	83 e0 3c             	and    $0x3c,%eax
  808b2e:	f7 d8                	neg    %eax
  808b30:	98                   	cwtl   
  808b31:	50                   	push   %eax
  808b32:	ff 75 08             	pushl  0x8(%ebp)
  808b35:	e8 1b bd ff ff       	call   804855 <pbuf_header>
  808b3a:	83 c4 10             	add    $0x10,%esp
  808b3d:	84 c0                	test   %al,%al
  808b3f:	74 16                	je     808b57 <udp_input+0x74>
    LWIP_DEBUGF(UDP_DEBUG,
                ("udp_input: short UDP datagram (%"U16_F" bytes) discarded\n", p->tot_len));
    UDP_STATS_INC(udp.lenerr);
    UDP_STATS_INC(udp.drop);
    snmp_inc_udpinerrors();
    pbuf_free(p);
  808b41:	83 ec 0c             	sub    $0xc,%esp
  808b44:	ff 75 08             	pushl  0x8(%ebp)
  808b47:	e8 dc bd ff ff       	call   804928 <pbuf_free>
    goto end;
  808b4c:	83 c4 10             	add    $0x10,%esp
  } else {
    pbuf_free(p);
  }
end:
  PERF_STOP("udp_input");
}
  808b4f:	8d 65 f4             	lea    -0xc(%ebp),%esp
  808b52:	5b                   	pop    %ebx
  808b53:	5e                   	pop    %esi
  808b54:	5f                   	pop    %edi
  808b55:	5d                   	pop    %ebp
  808b56:	c3                   	ret    
  udphdr = (struct udp_hdr *)p->payload;
  808b57:	8b 45 08             	mov    0x8(%ebp),%eax
  808b5a:	8b 70 04             	mov    0x4(%eax),%esi
  808b5d:	89 75 d8             	mov    %esi,-0x28(%ebp)
  src = ntohs(udphdr->src);
  808b60:	83 ec 0c             	sub    $0xc,%esp
  808b63:	0f b7 06             	movzwl (%esi),%eax
  808b66:	50                   	push   %eax
  808b67:	e8 05 ed ff ff       	call   807871 <ntohs>
  808b6c:	66 89 45 e2          	mov    %ax,-0x1e(%ebp)
  dest = ntohs(udphdr->dest);
  808b70:	0f b7 46 02          	movzwl 0x2(%esi),%eax
  808b74:	89 04 24             	mov    %eax,(%esp)
  808b77:	e8 f5 ec ff ff       	call   807871 <ntohs>
  808b7c:	89 c6                	mov    %eax,%esi
  if (dest == DHCP_CLIENT_PORT) {
  808b7e:	83 c4 10             	add    $0x10,%esp
  808b81:	66 83 f8 44          	cmp    $0x44,%ax
  808b85:	74 1f                	je     808ba6 <udp_input+0xc3>
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
  808b87:	8b 1d 54 b2 b3 00    	mov    0xb3b254,%ebx
    uncon_pcb = NULL;
  808b8d:	b9 00 00 00 00       	mov    $0x0,%ecx
    prev = NULL;
  808b92:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
           ip_addr_isbroadcast(&(iphdr->dest), inp))) {
  808b99:	8d 47 10             	lea    0x10(%edi),%eax
  808b9c:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  808b9f:	89 7d dc             	mov    %edi,-0x24(%ebp)
  808ba2:	89 cf                	mov    %ecx,%edi
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
  808ba4:	eb 51                	jmp    808bf7 <udp_input+0x114>
    if (src == DHCP_SERVER_PORT) {
  808ba6:	66 83 7d e2 43       	cmpw   $0x43,-0x1e(%ebp)
  808bab:	0f 85 c9 01 00 00    	jne    808d7a <udp_input+0x297>
      if ((inp->dhcp != NULL) && (inp->dhcp->pcb != NULL)) {
  808bb1:	8b 45 0c             	mov    0xc(%ebp),%eax
  808bb4:	8b 40 20             	mov    0x20(%eax),%eax
  808bb7:	85 c0                	test   %eax,%eax
  808bb9:	0f 84 bb 01 00 00    	je     808d7a <udp_input+0x297>
  808bbf:	8b 58 08             	mov    0x8(%eax),%ebx
  808bc2:	85 db                	test   %ebx,%ebx
  808bc4:	0f 84 b0 01 00 00    	je     808d7a <udp_input+0x297>
        if ((ip_addr_isany(&inp->dhcp->pcb->remote_ip) ||
  808bca:	8b 43 04             	mov    0x4(%ebx),%eax
  808bcd:	85 c0                	test   %eax,%eax
  808bcf:	0f 84 b5 01 00 00    	je     808d8a <udp_input+0x2a7>
  808bd5:	3b 47 0c             	cmp    0xc(%edi),%eax
  808bd8:	0f 85 9c 01 00 00    	jne    808d7a <udp_input+0x297>
  808bde:	e9 a7 01 00 00       	jmp    808d8a <udp_input+0x2a7>
        if ((uncon_pcb == NULL) && 
  808be3:	85 ff                	test   %edi,%edi
  808be5:	74 43                	je     808c2a <udp_input+0x147>
      if ((local_match != 0) &&
  808be7:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
  808beb:	66 3b 43 14          	cmp    0x14(%ebx),%ax
  808bef:	74 42                	je     808c33 <udp_input+0x150>
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
  808bf1:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
  808bf4:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  808bf7:	85 db                	test   %ebx,%ebx
  808bf9:	0f 84 6e 01 00 00    	je     808d6d <udp_input+0x28a>
      if ((pcb->local_port == dest) &&
  808bff:	66 3b 73 12          	cmp    0x12(%ebx),%si
  808c03:	75 ec                	jne    808bf1 <udp_input+0x10e>
          (ip_addr_isany(&pcb->local_ip) ||
  808c05:	8b 03                	mov    (%ebx),%eax
  808c07:	85 c0                	test   %eax,%eax
  808c09:	74 d8                	je     808be3 <udp_input+0x100>
  808c0b:	8b 4d dc             	mov    -0x24(%ebp),%ecx
  808c0e:	3b 41 10             	cmp    0x10(%ecx),%eax
  808c11:	74 d0                	je     808be3 <udp_input+0x100>
           ip_addr_isbroadcast(&(iphdr->dest), inp))) {
  808c13:	83 ec 08             	sub    $0x8,%esp
  808c16:	ff 75 0c             	pushl  0xc(%ebp)
  808c19:	ff 75 d4             	pushl  -0x2c(%ebp)
  808c1c:	e8 c3 d9 ff ff       	call   8065e4 <ip_addr_isbroadcast>
           ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest)) || 
  808c21:	83 c4 10             	add    $0x10,%esp
  808c24:	84 c0                	test   %al,%al
  808c26:	74 c9                	je     808bf1 <udp_input+0x10e>
  808c28:	eb b9                	jmp    808be3 <udp_input+0x100>
  808c2a:	f6 43 10 04          	testb  $0x4,0x10(%ebx)
  808c2e:	0f 44 fb             	cmove  %ebx,%edi
  808c31:	eb b4                	jmp    808be7 <udp_input+0x104>
          (ip_addr_isany(&pcb->remote_ip) ||
  808c33:	8b 43 04             	mov    0x4(%ebx),%eax
  808c36:	85 c0                	test   %eax,%eax
  808c38:	74 08                	je     808c42 <udp_input+0x15f>
  808c3a:	8b 55 dc             	mov    -0x24(%ebp),%edx
  808c3d:	3b 42 0c             	cmp    0xc(%edx),%eax
  808c40:	75 af                	jne    808bf1 <udp_input+0x10e>
  808c42:	8b 7d dc             	mov    -0x24(%ebp),%edi
        if (prev != NULL) {
  808c45:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  808c48:	85 d2                	test   %edx,%edx
  808c4a:	0f 84 3a 01 00 00    	je     808d8a <udp_input+0x2a7>
          prev->next = pcb->next;
  808c50:	8b 43 0c             	mov    0xc(%ebx),%eax
  808c53:	89 42 0c             	mov    %eax,0xc(%edx)
          pcb->next = udp_pcbs;
  808c56:	a1 54 b2 b3 00       	mov    0xb3b254,%eax
  808c5b:	89 43 0c             	mov    %eax,0xc(%ebx)
          udp_pcbs = pcb;
  808c5e:	89 1d 54 b2 b3 00    	mov    %ebx,0xb3b254
  808c64:	e9 21 01 00 00       	jmp    808d8a <udp_input+0x2a7>
  808c69:	89 c3                	mov    %eax,%ebx
  808c6b:	e9 1a 01 00 00       	jmp    808d8a <udp_input+0x2a7>
          pbuf_free(p);
  808c70:	83 ec 0c             	sub    $0xc,%esp
  808c73:	ff 75 08             	pushl  0x8(%ebp)
  808c76:	e8 ad bc ff ff       	call   804928 <pbuf_free>
          goto end;
  808c7b:	83 c4 10             	add    $0x10,%esp
  808c7e:	e9 cc fe ff ff       	jmp    808b4f <udp_input+0x6c>
      LWIP_ASSERT("pbuf_header failed\n", 0);
  808c83:	83 ec 04             	sub    $0x4,%esp
  808c86:	68 0b 26 81 00       	push   $0x81260b
  808c8b:	68 0a 01 00 00       	push   $0x10a
  808c90:	68 36 26 81 00       	push   $0x812636
  808c95:	e8 ad 5b 00 00       	call   80e847 <_panic>
        pbuf_free(p);
  808c9a:	83 ec 0c             	sub    $0xc,%esp
  808c9d:	ff 75 08             	pushl  0x8(%ebp)
  808ca0:	e8 83 bc ff ff       	call   804928 <pbuf_free>
        goto end;
  808ca5:	83 c4 10             	add    $0x10,%esp
  808ca8:	e9 a2 fe ff ff       	jmp    808b4f <udp_input+0x6c>
      if (!ip_addr_isbroadcast(&iphdr->dest, inp) &&
  808cad:	83 ec 08             	sub    $0x8,%esp
  808cb0:	ff 75 0c             	pushl  0xc(%ebp)
  808cb3:	8d 47 10             	lea    0x10(%edi),%eax
  808cb6:	50                   	push   %eax
  808cb7:	e8 28 d9 ff ff       	call   8065e4 <ip_addr_isbroadcast>
  808cbc:	83 c4 10             	add    $0x10,%esp
  808cbf:	84 c0                	test   %al,%al
  808cc1:	75 25                	jne    808ce8 <udp_input+0x205>
          !ip_addr_ismulticast(&iphdr->dest)) {
  808cc3:	8b 5f 10             	mov    0x10(%edi),%ebx
  808cc6:	83 ec 0c             	sub    $0xc,%esp
  808cc9:	68 00 00 00 f0       	push   $0xf0000000
  808cce:	e8 dc ed ff ff       	call   807aaf <ntohl>
  808cd3:	21 c3                	and    %eax,%ebx
  808cd5:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  808cdc:	e8 ce ed ff ff       	call   807aaf <ntohl>
      if (!ip_addr_isbroadcast(&iphdr->dest, inp) &&
  808ce1:	83 c4 10             	add    $0x10,%esp
  808ce4:	39 c3                	cmp    %eax,%ebx
  808ce6:	75 13                	jne    808cfb <udp_input+0x218>
      pbuf_free(p);
  808ce8:	83 ec 0c             	sub    $0xc,%esp
  808ceb:	ff 75 08             	pushl  0x8(%ebp)
  808cee:	e8 35 bc ff ff       	call   804928 <pbuf_free>
  808cf3:	83 c4 10             	add    $0x10,%esp
  808cf6:	e9 54 fe ff ff       	jmp    808b4f <udp_input+0x6c>
        pbuf_header(p, (IPH_HL(iphdr) * 4) + UDP_HLEN);
  808cfb:	83 ec 0c             	sub    $0xc,%esp
  808cfe:	0f b7 07             	movzwl (%edi),%eax
  808d01:	50                   	push   %eax
  808d02:	e8 6a eb ff ff       	call   807871 <ntohs>
  808d07:	83 c4 08             	add    $0x8,%esp
  808d0a:	66 c1 e8 08          	shr    $0x8,%ax
  808d0e:	83 e0 0f             	and    $0xf,%eax
  808d11:	8d 04 85 08 00 00 00 	lea    0x8(,%eax,4),%eax
  808d18:	98                   	cwtl   
  808d19:	50                   	push   %eax
  808d1a:	ff 75 08             	pushl  0x8(%ebp)
  808d1d:	e8 33 bb ff ff       	call   804855 <pbuf_header>
        LWIP_ASSERT("p->payload == iphdr", (p->payload == iphdr));
  808d22:	83 c4 10             	add    $0x10,%esp
  808d25:	8b 45 08             	mov    0x8(%ebp),%eax
  808d28:	3b 78 04             	cmp    0x4(%eax),%edi
  808d2b:	75 12                	jne    808d3f <udp_input+0x25c>
        icmp_dest_unreach(p, ICMP_DUR_PORT);
  808d2d:	83 ec 08             	sub    $0x8,%esp
  808d30:	6a 03                	push   $0x3
  808d32:	ff 75 08             	pushl  0x8(%ebp)
  808d35:	e8 d7 58 00 00       	call   80e611 <icmp_dest_unreach>
  808d3a:	83 c4 10             	add    $0x10,%esp
  808d3d:	eb a9                	jmp    808ce8 <udp_input+0x205>
        LWIP_ASSERT("p->payload == iphdr", (p->payload == iphdr));
  808d3f:	83 ec 04             	sub    $0x4,%esp
  808d42:	68 4a 26 81 00       	push   $0x81264a
  808d47:	68 25 01 00 00       	push   $0x125
  808d4c:	68 36 26 81 00       	push   $0x812636
  808d51:	e8 f1 5a 00 00       	call   80e847 <_panic>
    pbuf_free(p);
  808d56:	83 ec 0c             	sub    $0xc,%esp
  808d59:	ff 75 08             	pushl  0x8(%ebp)
  808d5c:	e8 c7 bb ff ff       	call   804928 <pbuf_free>
  808d61:	83 c4 10             	add    $0x10,%esp
  808d64:	f3 0f 1e fb          	endbr32 
}
  808d68:	e9 e2 fd ff ff       	jmp    808b4f <udp_input+0x6c>
  808d6d:	89 f8                	mov    %edi,%eax
  808d6f:	8b 7d dc             	mov    -0x24(%ebp),%edi
  if (pcb != NULL || ip_addr_cmp(&inp->ip_addr, &iphdr->dest)) {
  808d72:	85 c0                	test   %eax,%eax
  808d74:	0f 85 ef fe ff ff    	jne    808c69 <udp_input+0x186>
  808d7a:	8b 45 0c             	mov    0xc(%ebp),%eax
  808d7d:	8b 57 10             	mov    0x10(%edi),%edx
  808d80:	bb 00 00 00 00       	mov    $0x0,%ebx
  808d85:	39 50 04             	cmp    %edx,0x4(%eax)
  808d88:	75 cc                	jne    808d56 <udp_input+0x273>
      if (udphdr->chksum != 0) {
  808d8a:	8b 45 d8             	mov    -0x28(%ebp),%eax
  808d8d:	66 83 78 06 00       	cmpw   $0x0,0x6(%eax)
  808d92:	74 29                	je     808dbd <udp_input+0x2da>
        if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
  808d94:	83 ec 0c             	sub    $0xc,%esp
  808d97:	8b 45 08             	mov    0x8(%ebp),%eax
  808d9a:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  808d9e:	50                   	push   %eax
  808d9f:	6a 11                	push   $0x11
  808da1:	8d 47 10             	lea    0x10(%edi),%eax
  808da4:	50                   	push   %eax
  808da5:	8d 47 0c             	lea    0xc(%edi),%eax
  808da8:	50                   	push   %eax
  808da9:	ff 75 08             	pushl  0x8(%ebp)
  808dac:	e8 77 e7 ff ff       	call   807528 <inet_chksum_pseudo>
  808db1:	83 c4 20             	add    $0x20,%esp
  808db4:	66 85 c0             	test   %ax,%ax
  808db7:	0f 85 b3 fe ff ff    	jne    808c70 <udp_input+0x18d>
    if(pbuf_header(p, -UDP_HLEN)) {
  808dbd:	83 ec 08             	sub    $0x8,%esp
  808dc0:	6a f8                	push   $0xfffffff8
  808dc2:	ff 75 08             	pushl  0x8(%ebp)
  808dc5:	e8 8b ba ff ff       	call   804855 <pbuf_header>
  808dca:	83 c4 10             	add    $0x10,%esp
  808dcd:	84 c0                	test   %al,%al
  808dcf:	0f 85 ae fe ff ff    	jne    808c83 <udp_input+0x1a0>
    if (pcb != NULL) {
  808dd5:	85 db                	test   %ebx,%ebx
  808dd7:	0f 84 d0 fe ff ff    	je     808cad <udp_input+0x1ca>
      if (pcb->recv != NULL) {
  808ddd:	8b 43 18             	mov    0x18(%ebx),%eax
  808de0:	85 c0                	test   %eax,%eax
  808de2:	0f 84 b2 fe ff ff    	je     808c9a <udp_input+0x1b7>
        pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src), src);
  808de8:	83 ec 0c             	sub    $0xc,%esp
  808deb:	0f b7 55 e2          	movzwl -0x1e(%ebp),%edx
  808def:	52                   	push   %edx
  808df0:	83 c7 0c             	add    $0xc,%edi
  808df3:	57                   	push   %edi
  808df4:	ff 75 08             	pushl  0x8(%ebp)
  808df7:	53                   	push   %ebx
  808df8:	ff 73 1c             	pushl  0x1c(%ebx)
  808dfb:	ff d0                	call   *%eax
  808dfd:	83 c4 20             	add    $0x20,%esp
  808e00:	e9 4a fd ff ff       	jmp    808b4f <udp_input+0x6c>

00808e05 <udp_bind>:
 *
 * @see udp_disconnect()
 */
err_t
udp_bind(struct udp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)
{
  808e05:	f3 0f 1e fb          	endbr32 
  808e09:	55                   	push   %ebp
  808e0a:	89 e5                	mov    %esp,%ebp
  808e0c:	57                   	push   %edi
  808e0d:	56                   	push   %esi
  808e0e:	53                   	push   %ebx
  808e0f:	83 ec 0c             	sub    $0xc,%esp
  808e12:	8b 55 08             	mov    0x8(%ebp),%edx
  808e15:	8b 7d 10             	mov    0x10(%ebp),%edi
  808e18:	89 f9                	mov    %edi,%ecx
  ip_addr_debug_print(UDP_DEBUG, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 3, (", port = %"U16_F")\n", port));

  rebind = 0;
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  808e1a:	a1 54 b2 b3 00       	mov    0xb3b254,%eax
  rebind = 0;
  808e1f:	bb 00 00 00 00       	mov    $0x0,%ebx
    /* is this UDP PCB already on active list? */
    if (pcb == ipcb) {
      /* pcb may occur at most once in active list */
      LWIP_ASSERT("rebind == 0", rebind == 0);
      /* pcb already in list, just rebind */
      rebind = 1;
  808e24:	be 01 00 00 00       	mov    $0x1,%esi
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  808e29:	eb 1a                	jmp    808e45 <udp_bind+0x40>
      LWIP_ASSERT("rebind == 0", rebind == 0);
  808e2b:	83 ec 04             	sub    $0x4,%esp
  808e2e:	68 5e 26 81 00       	push   $0x81265e
  808e33:	68 41 02 00 00       	push   $0x241
  808e38:	68 36 26 81 00       	push   $0x812636
  808e3d:	e8 05 5a 00 00       	call   80e847 <_panic>
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  808e42:	8b 40 0c             	mov    0xc(%eax),%eax
  808e45:	85 c0                	test   %eax,%eax
  808e47:	74 0c                	je     808e55 <udp_bind+0x50>
    if (pcb == ipcb) {
  808e49:	39 d0                	cmp    %edx,%eax
  808e4b:	75 f5                	jne    808e42 <udp_bind+0x3d>
      LWIP_ASSERT("rebind == 0", rebind == 0);
  808e4d:	84 db                	test   %bl,%bl
  808e4f:	75 da                	jne    808e2b <udp_bind+0x26>
      rebind = 1;
  808e51:	89 f3                	mov    %esi,%ebx
  808e53:	eb ed                	jmp    808e42 <udp_bind+0x3d>
        return ERR_USE;
      }
#endif
  }

  ip_addr_set(&pcb->local_ip, ipaddr);
  808e55:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  808e59:	74 05                	je     808e60 <udp_bind+0x5b>
  808e5b:	8b 45 0c             	mov    0xc(%ebp),%eax
  808e5e:	8b 00                	mov    (%eax),%eax
  808e60:	89 02                	mov    %eax,(%edx)

  /* no port specified? */
  if (port == 0) {
  808e62:	66 85 ff             	test   %di,%di
  808e65:	75 2e                	jne    808e95 <udp_bind+0x90>
#ifndef UDP_LOCAL_PORT_RANGE_START
#define UDP_LOCAL_PORT_RANGE_START 4096
#define UDP_LOCAL_PORT_RANGE_END   0x7fff
#endif
    port = UDP_LOCAL_PORT_RANGE_START;
    ipcb = udp_pcbs;
  808e67:	8b 35 54 b2 b3 00    	mov    0xb3b254,%esi
  808e6d:	89 f0                	mov    %esi,%eax
    port = UDP_LOCAL_PORT_RANGE_START;
  808e6f:	b9 00 10 00 00       	mov    $0x1000,%ecx
    while ((ipcb != NULL) && (port != UDP_LOCAL_PORT_RANGE_END)) {
  808e74:	eb 03                	jmp    808e79 <udp_bind+0x74>
        port++;
        /* restart scanning all udp pcbs */
        ipcb = udp_pcbs;
      } else
        /* go on with next udp pcb */
        ipcb = ipcb->next;
  808e76:	8b 40 0c             	mov    0xc(%eax),%eax
    while ((ipcb != NULL) && (port != UDP_LOCAL_PORT_RANGE_END)) {
  808e79:	85 c0                	test   %eax,%eax
  808e7b:	74 14                	je     808e91 <udp_bind+0x8c>
  808e7d:	66 81 f9 ff 7f       	cmp    $0x7fff,%cx
  808e82:	74 0d                	je     808e91 <udp_bind+0x8c>
      if (ipcb->local_port == port) {
  808e84:	66 39 48 12          	cmp    %cx,0x12(%eax)
  808e88:	75 ec                	jne    808e76 <udp_bind+0x71>
        port++;
  808e8a:	83 c1 01             	add    $0x1,%ecx
        ipcb = udp_pcbs;
  808e8d:	89 f0                	mov    %esi,%eax
  808e8f:	eb e8                	jmp    808e79 <udp_bind+0x74>
    }
    if (ipcb != NULL) {
  808e91:	85 c0                	test   %eax,%eax
  808e93:	75 28                	jne    808ebd <udp_bind+0xb8>
      /* no more ports available in local range */
      LWIP_DEBUGF(UDP_DEBUG, ("udp_bind: out of free UDP ports\n"));
      return ERR_USE;
    }
  }
  pcb->local_port = port;
  808e95:	66 89 4a 12          	mov    %cx,0x12(%edx)
              ("udp_bind: bound to %"U16_F".%"U16_F".%"U16_F".%"U16_F", port %"U16_F"\n",
               (u16_t)(ntohl(pcb->local_ip.addr) >> 24 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) >> 16 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) >> 8 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) & 0xff), pcb->local_port));
  return ERR_OK;
  808e99:	b8 00 00 00 00       	mov    $0x0,%eax
  if (rebind == 0) {
  808e9e:	84 db                	test   %bl,%bl
  808ea0:	75 13                	jne    808eb5 <udp_bind+0xb0>
    pcb->next = udp_pcbs;
  808ea2:	a1 54 b2 b3 00       	mov    0xb3b254,%eax
  808ea7:	89 42 0c             	mov    %eax,0xc(%edx)
    udp_pcbs = pcb;
  808eaa:	89 15 54 b2 b3 00    	mov    %edx,0xb3b254
  return ERR_OK;
  808eb0:	b8 00 00 00 00       	mov    $0x0,%eax
}
  808eb5:	8d 65 f4             	lea    -0xc(%ebp),%esp
  808eb8:	5b                   	pop    %ebx
  808eb9:	5e                   	pop    %esi
  808eba:	5f                   	pop    %edi
  808ebb:	5d                   	pop    %ebp
  808ebc:	c3                   	ret    
      return ERR_USE;
  808ebd:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  808ec2:	eb f1                	jmp    808eb5 <udp_bind+0xb0>

00808ec4 <udp_sendto_if>:
{
  808ec4:	f3 0f 1e fb          	endbr32 
  808ec8:	55                   	push   %ebp
  808ec9:	89 e5                	mov    %esp,%ebp
  808ecb:	57                   	push   %edi
  808ecc:	56                   	push   %esi
  808ecd:	53                   	push   %ebx
  808ece:	83 ec 1c             	sub    $0x1c,%esp
  808ed1:	8b 7d 08             	mov    0x8(%ebp),%edi
  808ed4:	8b 45 14             	mov    0x14(%ebp),%eax
  808ed7:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  if (pcb->local_port == 0) {
  808eda:	66 83 7f 12 00       	cmpw   $0x0,0x12(%edi)
  808edf:	75 19                	jne    808efa <udp_sendto_if+0x36>
    err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
  808ee1:	83 ec 04             	sub    $0x4,%esp
  808ee4:	6a 00                	push   $0x0
  808ee6:	57                   	push   %edi
  808ee7:	57                   	push   %edi
  808ee8:	e8 18 ff ff ff       	call   808e05 <udp_bind>
  808eed:	89 c6                	mov    %eax,%esi
    if (err != ERR_OK) {
  808eef:	83 c4 10             	add    $0x10,%esp
  808ef2:	84 c0                	test   %al,%al
  808ef4:	0f 85 b7 00 00 00    	jne    808fb1 <udp_sendto_if+0xed>
  if (pbuf_header(p, UDP_HLEN)) {
  808efa:	83 ec 08             	sub    $0x8,%esp
  808efd:	6a 08                	push   $0x8
  808eff:	ff 75 0c             	pushl  0xc(%ebp)
  808f02:	e8 4e b9 ff ff       	call   804855 <pbuf_header>
  808f07:	83 c4 10             	add    $0x10,%esp
    q = p;
  808f0a:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  if (pbuf_header(p, UDP_HLEN)) {
  808f0d:	84 c0                	test   %al,%al
  808f0f:	0f 85 a6 00 00 00    	jne    808fbb <udp_sendto_if+0xf7>
  LWIP_ASSERT("check that first pbuf can hold struct udp_hdr",
  808f15:	66 83 7b 0a 07       	cmpw   $0x7,0xa(%ebx)
  808f1a:	0f 86 ca 00 00 00    	jbe    808fea <udp_sendto_if+0x126>
  udphdr = q->payload;
  808f20:	8b 73 04             	mov    0x4(%ebx),%esi
  udphdr->src = htons(pcb->local_port);
  808f23:	83 ec 0c             	sub    $0xc,%esp
  808f26:	0f b7 47 12          	movzwl 0x12(%edi),%eax
  808f2a:	50                   	push   %eax
  808f2b:	e8 30 e9 ff ff       	call   807860 <htons>
  808f30:	66 89 06             	mov    %ax,(%esi)
  udphdr->dest = htons(dst_port);
  808f33:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  808f37:	89 04 24             	mov    %eax,(%esp)
  808f3a:	e8 21 e9 ff ff       	call   807860 <htons>
  808f3f:	66 89 46 02          	mov    %ax,0x2(%esi)
  udphdr->chksum = 0x0000; 
  808f43:	66 c7 46 06 00 00    	movw   $0x0,0x6(%esi)
  if (ip_addr_isany(&pcb->local_ip)) {
  808f49:	8b 07                	mov    (%edi),%eax
  808f4b:	83 c4 10             	add    $0x10,%esp
  808f4e:	85 c0                	test   %eax,%eax
  808f50:	0f 85 ab 00 00 00    	jne    809001 <udp_sendto_if+0x13d>
    src_ip = &(netif->ip_addr);
  808f56:	8b 45 18             	mov    0x18(%ebp),%eax
  808f59:	83 c0 04             	add    $0x4,%eax
  808f5c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    udphdr->len = htons(q->tot_len);
  808f5f:	83 ec 0c             	sub    $0xc,%esp
  808f62:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  808f66:	50                   	push   %eax
  808f67:	e8 f4 e8 ff ff       	call   807860 <htons>
  808f6c:	66 89 46 04          	mov    %ax,0x4(%esi)
    if ((pcb->flags & UDP_FLAGS_NOCHKSUM) == 0) {
  808f70:	83 c4 10             	add    $0x10,%esp
  808f73:	f6 47 10 01          	testb  $0x1,0x10(%edi)
  808f77:	0f 84 ac 00 00 00    	je     809029 <udp_sendto_if+0x165>
    err = ip_output_if(q, src_ip, dst_ip, pcb->ttl, pcb->tos, IP_PROTO_UDP, netif);    
  808f7d:	83 ec 04             	sub    $0x4,%esp
  808f80:	ff 75 18             	pushl  0x18(%ebp)
  808f83:	6a 11                	push   $0x11
  808f85:	0f b6 47 0a          	movzbl 0xa(%edi),%eax
  808f89:	50                   	push   %eax
  808f8a:	0f b6 47 0b          	movzbl 0xb(%edi),%eax
  808f8e:	50                   	push   %eax
  808f8f:	ff 75 10             	pushl  0x10(%ebp)
  808f92:	ff 75 e4             	pushl  -0x1c(%ebp)
  808f95:	53                   	push   %ebx
  808f96:	e8 17 da ff ff       	call   8069b2 <ip_output_if>
  808f9b:	89 c6                	mov    %eax,%esi
  if (q != p) {
  808f9d:	83 c4 20             	add    $0x20,%esp
  808fa0:	3b 5d 0c             	cmp    0xc(%ebp),%ebx
  808fa3:	74 0c                	je     808fb1 <udp_sendto_if+0xed>
    pbuf_free(q);
  808fa5:	83 ec 0c             	sub    $0xc,%esp
  808fa8:	53                   	push   %ebx
  808fa9:	e8 7a b9 ff ff       	call   804928 <pbuf_free>
  808fae:	83 c4 10             	add    $0x10,%esp
}
  808fb1:	89 f0                	mov    %esi,%eax
  808fb3:	8d 65 f4             	lea    -0xc(%ebp),%esp
  808fb6:	5b                   	pop    %ebx
  808fb7:	5e                   	pop    %esi
  808fb8:	5f                   	pop    %edi
  808fb9:	5d                   	pop    %ebp
  808fba:	c3                   	ret    
    q = pbuf_alloc(PBUF_IP, UDP_HLEN, PBUF_RAM);
  808fbb:	83 ec 04             	sub    $0x4,%esp
  808fbe:	6a 00                	push   $0x0
  808fc0:	6a 08                	push   $0x8
  808fc2:	6a 01                	push   $0x1
  808fc4:	e8 29 ba ff ff       	call   8049f2 <pbuf_alloc>
  808fc9:	89 c3                	mov    %eax,%ebx
    if (q == NULL) {
  808fcb:	83 c4 10             	add    $0x10,%esp
  808fce:	85 c0                	test   %eax,%eax
  808fd0:	0f 84 80 00 00 00    	je     809056 <udp_sendto_if+0x192>
    pbuf_chain(q, p);
  808fd6:	83 ec 08             	sub    $0x8,%esp
  808fd9:	ff 75 0c             	pushl  0xc(%ebp)
  808fdc:	50                   	push   %eax
  808fdd:	e8 28 be ff ff       	call   804e0a <pbuf_chain>
  808fe2:	83 c4 10             	add    $0x10,%esp
  808fe5:	e9 2b ff ff ff       	jmp    808f15 <udp_sendto_if+0x51>
  LWIP_ASSERT("check that first pbuf can hold struct udp_hdr",
  808fea:	83 ec 04             	sub    $0x4,%esp
  808fed:	68 6c 26 81 00       	push   $0x81266c
  808ff2:	68 b1 01 00 00       	push   $0x1b1
  808ff7:	68 36 26 81 00       	push   $0x812636
  808ffc:	e8 46 58 00 00       	call   80e847 <_panic>
    if (!ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))) {
  809001:	8b 4d 18             	mov    0x18(%ebp),%ecx
  809004:	3b 41 04             	cmp    0x4(%ecx),%eax
  809007:	75 08                	jne    809011 <udp_sendto_if+0x14d>
  if (ip_addr_isany(&pcb->local_ip)) {
  809009:	89 7d e4             	mov    %edi,-0x1c(%ebp)
  80900c:	e9 4e ff ff ff       	jmp    808f5f <udp_sendto_if+0x9b>
      return ERR_VAL;
  809011:	be f7 ff ff ff       	mov    $0xfffffff7,%esi
      if (q != p) {
  809016:	3b 5d 0c             	cmp    0xc(%ebp),%ebx
  809019:	74 96                	je     808fb1 <udp_sendto_if+0xed>
        pbuf_free(q);
  80901b:	83 ec 0c             	sub    $0xc,%esp
  80901e:	53                   	push   %ebx
  80901f:	e8 04 b9 ff ff       	call   804928 <pbuf_free>
  809024:	83 c4 10             	add    $0x10,%esp
  809027:	eb 88                	jmp    808fb1 <udp_sendto_if+0xed>
      udphdr->chksum = inet_chksum_pseudo(q, src_ip, dst_ip, IP_PROTO_UDP, q->tot_len);
  809029:	83 ec 0c             	sub    $0xc,%esp
  80902c:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  809030:	50                   	push   %eax
  809031:	6a 11                	push   $0x11
  809033:	ff 75 10             	pushl  0x10(%ebp)
  809036:	ff 75 e4             	pushl  -0x1c(%ebp)
  809039:	53                   	push   %ebx
  80903a:	e8 e9 e4 ff ff       	call   807528 <inet_chksum_pseudo>
      if (udphdr->chksum == 0x0000) udphdr->chksum = 0xffff;
  80903f:	83 c4 20             	add    $0x20,%esp
      udphdr->chksum = inet_chksum_pseudo(q, src_ip, dst_ip, IP_PROTO_UDP, q->tot_len);
  809042:	66 85 c0             	test   %ax,%ax
  809045:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  80904a:	0f 44 c2             	cmove  %edx,%eax
  80904d:	66 89 46 06          	mov    %ax,0x6(%esi)
  809051:	e9 27 ff ff ff       	jmp    808f7d <udp_sendto_if+0xb9>
      return ERR_MEM;
  809056:	be ff ff ff ff       	mov    $0xffffffff,%esi
  80905b:	e9 51 ff ff ff       	jmp    808fb1 <udp_sendto_if+0xed>

00809060 <udp_sendto>:
{
  809060:	f3 0f 1e fb          	endbr32 
  809064:	55                   	push   %ebp
  809065:	89 e5                	mov    %esp,%ebp
  809067:	56                   	push   %esi
  809068:	53                   	push   %ebx
  809069:	8b 75 10             	mov    0x10(%ebp),%esi
  80906c:	8b 5d 14             	mov    0x14(%ebp),%ebx
  netif = ip_route(dst_ip);
  80906f:	83 ec 0c             	sub    $0xc,%esp
  809072:	56                   	push   %esi
  809073:	e8 b3 d5 ff ff       	call   80662b <ip_route>
  if (netif == NULL) {
  809078:	83 c4 10             	add    $0x10,%esp
  80907b:	85 c0                	test   %eax,%eax
  80907d:	74 1e                	je     80909d <udp_sendto+0x3d>
  return udp_sendto_if(pcb, p, dst_ip, dst_port, netif);
  80907f:	83 ec 0c             	sub    $0xc,%esp
  809082:	50                   	push   %eax
  809083:	0f b7 db             	movzwl %bx,%ebx
  809086:	53                   	push   %ebx
  809087:	56                   	push   %esi
  809088:	ff 75 0c             	pushl  0xc(%ebp)
  80908b:	ff 75 08             	pushl  0x8(%ebp)
  80908e:	e8 31 fe ff ff       	call   808ec4 <udp_sendto_if>
  809093:	83 c4 20             	add    $0x20,%esp
}
  809096:	8d 65 f8             	lea    -0x8(%ebp),%esp
  809099:	5b                   	pop    %ebx
  80909a:	5e                   	pop    %esi
  80909b:	5d                   	pop    %ebp
  80909c:	c3                   	ret    
    return ERR_RTE;
  80909d:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  8090a2:	eb f2                	jmp    809096 <udp_sendto+0x36>

008090a4 <udp_send>:
{
  8090a4:	f3 0f 1e fb          	endbr32 
  8090a8:	55                   	push   %ebp
  8090a9:	89 e5                	mov    %esp,%ebp
  8090ab:	83 ec 08             	sub    $0x8,%esp
  8090ae:	8b 45 08             	mov    0x8(%ebp),%eax
  return udp_sendto(pcb, p, &pcb->remote_ip, pcb->remote_port);
  8090b1:	0f b7 50 14          	movzwl 0x14(%eax),%edx
  8090b5:	52                   	push   %edx
  8090b6:	8d 50 04             	lea    0x4(%eax),%edx
  8090b9:	52                   	push   %edx
  8090ba:	ff 75 0c             	pushl  0xc(%ebp)
  8090bd:	50                   	push   %eax
  8090be:	e8 9d ff ff ff       	call   809060 <udp_sendto>
}
  8090c3:	c9                   	leave  
  8090c4:	c3                   	ret    

008090c5 <udp_connect>:
 *
 * @see udp_disconnect()
 */
err_t
udp_connect(struct udp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)
{
  8090c5:	f3 0f 1e fb          	endbr32 
  8090c9:	55                   	push   %ebp
  8090ca:	89 e5                	mov    %esp,%ebp
  8090cc:	57                   	push   %edi
  8090cd:	56                   	push   %esi
  8090ce:	53                   	push   %ebx
  8090cf:	83 ec 0c             	sub    $0xc,%esp
  8090d2:	8b 5d 08             	mov    0x8(%ebp),%ebx
  8090d5:	8b 75 0c             	mov    0xc(%ebp),%esi
  8090d8:	8b 7d 10             	mov    0x10(%ebp),%edi
  struct udp_pcb *ipcb;

  if (pcb->local_port == 0) {
  8090db:	66 83 7b 12 00       	cmpw   $0x0,0x12(%ebx)
  8090e0:	74 2b                	je     80910d <udp_connect+0x48>
    err_t err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
    if (err != ERR_OK)
      return err;
  }

  ip_addr_set(&pcb->remote_ip, ipaddr);
  8090e2:	b8 00 00 00 00       	mov    $0x0,%eax
  8090e7:	85 f6                	test   %esi,%esi
  8090e9:	74 02                	je     8090ed <udp_connect+0x28>
  8090eb:	8b 06                	mov    (%esi),%eax
  8090ed:	89 43 04             	mov    %eax,0x4(%ebx)
  pcb->remote_port = port;
  8090f0:	66 89 7b 14          	mov    %di,0x14(%ebx)
  pcb->flags |= UDP_FLAGS_CONNECTED;
  8090f4:	80 4b 10 04          	orb    $0x4,0x10(%ebx)
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 16 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 8 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) & 0xff), pcb->remote_port));

  /* Insert UDP PCB into the list of active UDP PCBs. */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  8090f8:	8b 15 54 b2 b3 00    	mov    0xb3b254,%edx
  8090fe:	89 d0                	mov    %edx,%eax
  809100:	85 c0                	test   %eax,%eax
  809102:	74 1e                	je     809122 <udp_connect+0x5d>
    if (pcb == ipcb) {
  809104:	39 d8                	cmp    %ebx,%eax
  809106:	74 2b                	je     809133 <udp_connect+0x6e>
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  809108:	8b 40 0c             	mov    0xc(%eax),%eax
  80910b:	eb f3                	jmp    809100 <udp_connect+0x3b>
    err_t err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
  80910d:	83 ec 04             	sub    $0x4,%esp
  809110:	6a 00                	push   $0x0
  809112:	53                   	push   %ebx
  809113:	53                   	push   %ebx
  809114:	e8 ec fc ff ff       	call   808e05 <udp_bind>
    if (err != ERR_OK)
  809119:	83 c4 10             	add    $0x10,%esp
  80911c:	84 c0                	test   %al,%al
  80911e:	74 c2                	je     8090e2 <udp_connect+0x1d>
  809120:	eb 09                	jmp    80912b <udp_connect+0x66>
      /* already on the list, just return */
      return ERR_OK;
    }
  }
  /* PCB not yet on the list, add PCB now */
  pcb->next = udp_pcbs;
  809122:	89 53 0c             	mov    %edx,0xc(%ebx)
  udp_pcbs = pcb;
  809125:	89 1d 54 b2 b3 00    	mov    %ebx,0xb3b254
  return ERR_OK;
}
  80912b:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80912e:	5b                   	pop    %ebx
  80912f:	5e                   	pop    %esi
  809130:	5f                   	pop    %edi
  809131:	5d                   	pop    %ebp
  809132:	c3                   	ret    
      return ERR_OK;
  809133:	b8 00 00 00 00       	mov    $0x0,%eax
  809138:	eb f1                	jmp    80912b <udp_connect+0x66>

0080913a <udp_disconnect>:
 *
 * @param pcb the udp pcb to disconnect.
 */
void
udp_disconnect(struct udp_pcb *pcb)
{
  80913a:	f3 0f 1e fb          	endbr32 
  80913e:	55                   	push   %ebp
  80913f:	89 e5                	mov    %esp,%ebp
  809141:	8b 45 08             	mov    0x8(%ebp),%eax
  /* reset remote address association */
  ip_addr_set(&pcb->remote_ip, IP_ADDR_ANY);
  809144:	8b 15 a8 22 81 00    	mov    0x8122a8,%edx
  80914a:	89 50 04             	mov    %edx,0x4(%eax)
  pcb->remote_port = 0;
  80914d:	66 c7 40 14 00 00    	movw   $0x0,0x14(%eax)
  /* mark PCB as unconnected */
  pcb->flags &= ~UDP_FLAGS_CONNECTED;
  809153:	80 60 10 fb          	andb   $0xfb,0x10(%eax)
}
  809157:	5d                   	pop    %ebp
  809158:	c3                   	ret    

00809159 <udp_recv>:
void
udp_recv(struct udp_pcb *pcb,
         void (* recv)(void *arg, struct udp_pcb *upcb, struct pbuf *p,
                       struct ip_addr *addr, u16_t port),
         void *recv_arg)
{
  809159:	f3 0f 1e fb          	endbr32 
  80915d:	55                   	push   %ebp
  80915e:	89 e5                	mov    %esp,%ebp
  809160:	8b 45 08             	mov    0x8(%ebp),%eax
  /* remember recv() callback and user data */
  pcb->recv = recv;
  809163:	8b 55 0c             	mov    0xc(%ebp),%edx
  809166:	89 50 18             	mov    %edx,0x18(%eax)
  pcb->recv_arg = recv_arg;
  809169:	8b 55 10             	mov    0x10(%ebp),%edx
  80916c:	89 50 1c             	mov    %edx,0x1c(%eax)
}
  80916f:	5d                   	pop    %ebp
  809170:	c3                   	ret    

00809171 <udp_remove>:
 *
 * @see udp_new()
 */
void
udp_remove(struct udp_pcb *pcb)
{
  809171:	f3 0f 1e fb          	endbr32 
  809175:	55                   	push   %ebp
  809176:	89 e5                	mov    %esp,%ebp
  809178:	83 ec 08             	sub    $0x8,%esp
  80917b:	8b 4d 08             	mov    0x8(%ebp),%ecx
  struct udp_pcb *pcb2;

  snmp_delete_udpidx_tree(pcb);
  /* pcb to be removed is first in list? */
  if (udp_pcbs == pcb) {
  80917e:	a1 54 b2 b3 00       	mov    0xb3b254,%eax
  809183:	39 c8                	cmp    %ecx,%eax
  809185:	75 1b                	jne    8091a2 <udp_remove+0x31>
    /* make list start at 2nd pcb */
    udp_pcbs = udp_pcbs->next;
  809187:	8b 41 0c             	mov    0xc(%ecx),%eax
  80918a:	a3 54 b2 b3 00       	mov    %eax,0xb3b254
      if (pcb2->next != NULL && pcb2->next == pcb) {
        /* remove pcb from list */
        pcb2->next = pcb->next;
      }
    }
  memp_free(MEMP_UDP_PCB, pcb);
  80918f:	83 ec 08             	sub    $0x8,%esp
  809192:	51                   	push   %ecx
  809193:	6a 01                	push   $0x1
  809195:	e8 0b b4 ff ff       	call   8045a5 <memp_free>
}
  80919a:	83 c4 10             	add    $0x10,%esp
  80919d:	c9                   	leave  
  80919e:	c3                   	ret    
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
  80919f:	8b 40 0c             	mov    0xc(%eax),%eax
  8091a2:	85 c0                	test   %eax,%eax
  8091a4:	74 e9                	je     80918f <udp_remove+0x1e>
      if (pcb2->next != NULL && pcb2->next == pcb) {
  8091a6:	8b 50 0c             	mov    0xc(%eax),%edx
  8091a9:	39 ca                	cmp    %ecx,%edx
  8091ab:	75 f2                	jne    80919f <udp_remove+0x2e>
  8091ad:	85 d2                	test   %edx,%edx
  8091af:	74 ee                	je     80919f <udp_remove+0x2e>
        pcb2->next = pcb->next;
  8091b1:	8b 51 0c             	mov    0xc(%ecx),%edx
  8091b4:	89 50 0c             	mov    %edx,0xc(%eax)
  8091b7:	eb e6                	jmp    80919f <udp_remove+0x2e>

008091b9 <udp_new>:
 *
 * @see udp_remove()
 */
struct udp_pcb *
udp_new(void)
{
  8091b9:	f3 0f 1e fb          	endbr32 
  8091bd:	55                   	push   %ebp
  8091be:	89 e5                	mov    %esp,%ebp
  8091c0:	53                   	push   %ebx
  8091c1:	83 ec 10             	sub    $0x10,%esp
  struct udp_pcb *pcb;
  pcb = memp_malloc(MEMP_UDP_PCB);
  8091c4:	6a 01                	push   $0x1
  8091c6:	e8 80 b3 ff ff       	call   80454b <memp_malloc>
  8091cb:	89 c3                	mov    %eax,%ebx
  /* could allocate UDP PCB? */
  if (pcb != NULL) {
  8091cd:	83 c4 10             	add    $0x10,%esp
  8091d0:	85 c0                	test   %eax,%eax
  8091d2:	74 14                	je     8091e8 <udp_new+0x2f>
    /* UDP Lite: by initializing to all zeroes, chksum_len is set to 0
     * which means checksum is generated over the whole datagram per default
     * (recommended as default by RFC 3828). */
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct udp_pcb));
  8091d4:	83 ec 04             	sub    $0x4,%esp
  8091d7:	6a 20                	push   $0x20
  8091d9:	6a 00                	push   $0x0
  8091db:	50                   	push   %eax
  8091dc:	e8 c1 5e 00 00       	call   80f0a2 <memset>
    pcb->ttl = UDP_TTL;
  8091e1:	c6 43 0b ff          	movb   $0xff,0xb(%ebx)
  8091e5:	83 c4 10             	add    $0x10,%esp
  }
  return pcb;
}
  8091e8:	89 d8                	mov    %ebx,%eax
  8091ea:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  8091ed:	c9                   	leave  
  8091ee:	c3                   	ret    

008091ef <free_etharp_q>:
 *
 * @param q a qeueue of etharp_q_entry's to free
 */
static void
free_etharp_q(struct etharp_q_entry *q)
{
  8091ef:	55                   	push   %ebp
  8091f0:	89 e5                	mov    %esp,%ebp
  8091f2:	56                   	push   %esi
  8091f3:	53                   	push   %ebx
  struct etharp_q_entry *r;
  LWIP_ASSERT("q != NULL", q != NULL);
  8091f4:	85 c0                	test   %eax,%eax
  8091f6:	74 35                	je     80922d <free_etharp_q+0x3e>
  8091f8:	89 c3                	mov    %eax,%ebx
  LWIP_ASSERT("q->p != NULL", q->p != NULL);
  8091fa:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
  8091fe:	74 44                	je     809244 <free_etharp_q+0x55>
  809200:	89 de                	mov    %ebx,%esi
  while (q) {
    r = q;
    q = q->next;
  809202:	8b 1b                	mov    (%ebx),%ebx
    LWIP_ASSERT("r->p != NULL", (r->p != NULL));
  809204:	8b 46 04             	mov    0x4(%esi),%eax
  809207:	85 c0                	test   %eax,%eax
  809209:	74 50                	je     80925b <free_etharp_q+0x6c>
    pbuf_free(r->p);
  80920b:	83 ec 0c             	sub    $0xc,%esp
  80920e:	50                   	push   %eax
  80920f:	e8 14 b7 ff ff       	call   804928 <pbuf_free>
    memp_free(MEMP_ARP_QUEUE, r);
  809214:	83 c4 08             	add    $0x8,%esp
  809217:	56                   	push   %esi
  809218:	6a 0a                	push   $0xa
  80921a:	e8 86 b3 ff ff       	call   8045a5 <memp_free>
  while (q) {
  80921f:	83 c4 10             	add    $0x10,%esp
  809222:	85 db                	test   %ebx,%ebx
  809224:	75 da                	jne    809200 <free_etharp_q+0x11>
  }
}
  809226:	8d 65 f8             	lea    -0x8(%ebp),%esp
  809229:	5b                   	pop    %ebx
  80922a:	5e                   	pop    %esi
  80922b:	5d                   	pop    %ebp
  80922c:	c3                   	ret    
  LWIP_ASSERT("q != NULL", q != NULL);
  80922d:	83 ec 04             	sub    $0x4,%esp
  809230:	68 ac 1d 81 00       	push   $0x811dac
  809235:	68 93 00 00 00       	push   $0x93
  80923a:	68 9a 26 81 00       	push   $0x81269a
  80923f:	e8 03 56 00 00       	call   80e847 <_panic>
  LWIP_ASSERT("q->p != NULL", q->p != NULL);
  809244:	83 ec 04             	sub    $0x4,%esp
  809247:	68 b2 26 81 00       	push   $0x8126b2
  80924c:	68 94 00 00 00       	push   $0x94
  809251:	68 9a 26 81 00       	push   $0x81269a
  809256:	e8 ec 55 00 00       	call   80e847 <_panic>
    LWIP_ASSERT("r->p != NULL", (r->p != NULL));
  80925b:	83 ec 04             	sub    $0x4,%esp
  80925e:	68 bf 26 81 00       	push   $0x8126bf
  809263:	68 98 00 00 00       	push   $0x98
  809268:	68 9a 26 81 00       	push   $0x81269a
  80926d:	e8 d5 55 00 00       	call   80e847 <_panic>

00809272 <find_entry>:
#if LWIP_NETIF_HWADDRHINT
find_entry(struct ip_addr *ipaddr, u8_t flags, struct netif *netif)
#else /* LWIP_NETIF_HWADDRHINT */
find_entry(struct ip_addr *ipaddr, u8_t flags)
#endif /* LWIP_NETIF_HWADDRHINT */
{
  809272:	55                   	push   %ebp
  809273:	89 e5                	mov    %esp,%ebp
  809275:	57                   	push   %edi
  809276:	56                   	push   %esi
  809277:	53                   	push   %ebx
  809278:	83 ec 1c             	sub    $0x1c,%esp
  80927b:	89 c3                	mov    %eax,%ebx
  80927d:	89 55 e0             	mov    %edx,-0x20(%ebp)
  u8_t age_queue = 0;
#endif

  /* First, test if the last call to this function asked for the
   * same address. If so, we're really fast! */
  if (ipaddr) {
  809280:	85 c0                	test   %eax,%eax
  809282:	0f 84 86 00 00 00    	je     80930e <find_entry+0x9c>
          return per_pcb_cache;
        }
      }
    }
#else /* #if LWIP_NETIF_HWADDRHINT */
    if (arp_table[etharp_cached_entry].state == ETHARP_STATE_STABLE) {
  809288:	0f b6 05 00 4a b3 00 	movzbl 0xb34a00,%eax
  80928f:	0f b6 d0             	movzbl %al,%edx
  809292:	6b ca 1c             	imul   $0x1c,%edx,%ecx
  809295:	83 b9 30 4a b3 00 02 	cmpl   $0x2,0xb34a30(%ecx)
  80929c:	74 42                	je     8092e0 <find_entry+0x6e>
  80929e:	bf 00 00 00 00       	mov    $0x0,%edi
  8092a3:	c6 45 df 0a          	movb   $0xa,-0x21(%ebp)
  8092a7:	c6 45 e6 00          	movb   $0x0,-0x1a(%ebp)
  8092ab:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
  8092af:	c6 45 de 0a          	movb   $0xa,-0x22(%ebp)
  8092b3:	c6 45 e5 0a          	movb   $0xa,-0x1b(%ebp)
  8092b7:	b8 00 00 00 00       	mov    $0x0,%eax
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (arp_table[i].state == ETHARP_STATE_EMPTY)) {
  8092bc:	0f b6 d0             	movzbl %al,%edx
  8092bf:	6b d2 1c             	imul   $0x1c,%edx,%edx
  8092c2:	83 ba 30 4a b3 00 00 	cmpl   $0x0,0xb34a30(%edx)
  8092c9:	75 63                	jne    80932e <find_entry+0xbc>
      LWIP_DEBUGF(ETHARP_DEBUG, ("find_entry: found empty entry %"U16_F"\n", (u16_t)i));
      /* remember first empty entry */
      empty = i;
  8092cb:	89 c2                	mov    %eax,%edx
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
  8092cd:	83 c0 01             	add    $0x1,%eax
  8092d0:	3c 09                	cmp    $0x9,%al
  8092d2:	0f 87 07 01 00 00    	ja     8093df <find_entry+0x16d>
  8092d8:	88 55 e7             	mov    %dl,-0x19(%ebp)
  8092db:	e9 98 00 00 00       	jmp    809378 <find_entry+0x106>
      if (ip_addr_cmp(ipaddr, &arp_table[etharp_cached_entry].ipaddr)) {
  8092e0:	8b b9 24 4a b3 00    	mov    0xb34a24(%ecx),%edi
  8092e6:	39 3b                	cmp    %edi,(%ebx)
  8092e8:	0f 84 3e 01 00 00    	je     80942c <find_entry+0x1ba>
  8092ee:	bf 00 00 00 00       	mov    $0x0,%edi
  8092f3:	c6 45 df 0a          	movb   $0xa,-0x21(%ebp)
  8092f7:	c6 45 e6 00          	movb   $0x0,-0x1a(%ebp)
  8092fb:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
  8092ff:	c6 45 de 0a          	movb   $0xa,-0x22(%ebp)
  809303:	c6 45 e5 0a          	movb   $0xa,-0x1b(%ebp)
  809307:	b8 00 00 00 00       	mov    $0x0,%eax
  80930c:	eb ae                	jmp    8092bc <find_entry+0x4a>
  80930e:	bf 00 00 00 00       	mov    $0x0,%edi
  809313:	c6 45 df 0a          	movb   $0xa,-0x21(%ebp)
  809317:	c6 45 e6 00          	movb   $0x0,-0x1a(%ebp)
  80931b:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
  80931f:	c6 45 de 0a          	movb   $0xa,-0x22(%ebp)
  809323:	c6 45 e5 0a          	movb   $0xa,-0x1b(%ebp)
  809327:	b8 00 00 00 00       	mov    $0x0,%eax
  80932c:	eb 8e                	jmp    8092bc <find_entry+0x4a>
  80932e:	ba 0a 00 00 00       	mov    $0xa,%edx
  809333:	88 55 e7             	mov    %dl,-0x19(%ebp)
  809336:	eb 40                	jmp    809378 <find_entry+0x106>
    }
    /* pending entry? */
    else if (arp_table[i].state == ETHARP_STATE_PENDING) {
      /* if given, does IP address match IP address in ARP entry? */
      if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
  809338:	85 db                	test   %ebx,%ebx
  80933a:	74 0d                	je     809349 <find_entry+0xd7>
  80933c:	6b f1 1c             	imul   $0x1c,%ecx,%esi
  80933f:	8b 96 24 4a b3 00    	mov    0xb34a24(%esi),%edx
  809345:	39 13                	cmp    %edx,(%ebx)
  809347:	74 6d                	je     8093b6 <find_entry+0x144>
        etharp_cached_entry = i;
#endif /* #if LWIP_NETIF_HWADDRHINT */
        return i;
#if ARP_QUEUEING
      /* pending with queued packets? */
      } else if (arp_table[i].q != NULL) {
  809349:	6b f1 1c             	imul   $0x1c,%ecx,%esi
  80934c:	83 be 20 4a b3 00 00 	cmpl   $0x0,0xb34a20(%esi)
  809353:	74 68                	je     8093bd <find_entry+0x14b>
        if (arp_table[i].ctime >= age_queue) {
  809355:	0f b6 8e 34 4a b3 00 	movzbl 0xb34a34(%esi),%ecx
  80935c:	89 fa                	mov    %edi,%edx
  80935e:	38 d1                	cmp    %dl,%cl
  809360:	72 05                	jb     809367 <find_entry+0xf5>
          old_queue = i;
  809362:	88 45 df             	mov    %al,-0x21(%ebp)
          age_queue = arp_table[i].ctime;
  809365:	89 cf                	mov    %ecx,%edi
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
  809367:	83 c0 01             	add    $0x1,%eax
  80936a:	3c 09                	cmp    $0x9,%al
  80936c:	77 6d                	ja     8093db <find_entry+0x169>
    if ((empty == ARP_TABLE_SIZE) && (arp_table[i].state == ETHARP_STATE_EMPTY)) {
  80936e:	80 7d e7 0a          	cmpb   $0xa,-0x19(%ebp)
  809372:	0f 84 44 ff ff ff    	je     8092bc <find_entry+0x4a>
    else if (arp_table[i].state == ETHARP_STATE_PENDING) {
  809378:	0f b6 c8             	movzbl %al,%ecx
  80937b:	6b f1 1c             	imul   $0x1c,%ecx,%esi
  80937e:	8b b6 30 4a b3 00    	mov    0xb34a30(%esi),%esi
  809384:	83 fe 01             	cmp    $0x1,%esi
  809387:	74 af                	je     809338 <find_entry+0xc6>
          age_pending = arp_table[i].ctime;
        }
      }        
    }
    /* stable entry? */
    else if (arp_table[i].state == ETHARP_STATE_STABLE) {
  809389:	83 fe 02             	cmp    $0x2,%esi
  80938c:	75 d9                	jne    809367 <find_entry+0xf5>
      /* if given, does IP address match IP address in ARP entry? */
      if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
  80938e:	85 db                	test   %ebx,%ebx
  809390:	74 0d                	je     80939f <find_entry+0x12d>
  809392:	6b f1 1c             	imul   $0x1c,%ecx,%esi
  809395:	8b 96 24 4a b3 00    	mov    0xb34a24(%esi),%edx
  80939b:	39 13                	cmp    %edx,(%ebx)
  80939d:	74 35                	je     8093d4 <find_entry+0x162>
#else /* #if LWIP_NETIF_HWADDRHINT */
        etharp_cached_entry = i;
#endif /* #if LWIP_NETIF_HWADDRHINT */
        return i;
      /* remember entry with oldest stable entry in oldest, its age in maxtime */
      } else if (arp_table[i].ctime >= age_stable) {
  80939f:	6b c9 1c             	imul   $0x1c,%ecx,%ecx
  8093a2:	0f b6 89 34 4a b3 00 	movzbl 0xb34a34(%ecx),%ecx
  8093a9:	3a 4d e6             	cmp    -0x1a(%ebp),%cl
  8093ac:	72 b9                	jb     809367 <find_entry+0xf5>
        old_stable = i;
  8093ae:	88 45 e5             	mov    %al,-0x1b(%ebp)
        age_stable = arp_table[i].ctime;
  8093b1:	88 4d e6             	mov    %cl,-0x1a(%ebp)
  8093b4:	eb b1                	jmp    809367 <find_entry+0xf5>
        etharp_cached_entry = i;
  8093b6:	a2 00 4a b3 00       	mov    %al,0xb34a00
        return i;
  8093bb:	eb 6f                	jmp    80942c <find_entry+0x1ba>
        if (arp_table[i].ctime >= age_pending) {
  8093bd:	6b c9 1c             	imul   $0x1c,%ecx,%ecx
  8093c0:	0f b6 89 34 4a b3 00 	movzbl 0xb34a34(%ecx),%ecx
  8093c7:	3a 4d e4             	cmp    -0x1c(%ebp),%cl
  8093ca:	72 9b                	jb     809367 <find_entry+0xf5>
          old_pending = i;
  8093cc:	88 45 de             	mov    %al,-0x22(%ebp)
          age_pending = arp_table[i].ctime;
  8093cf:	88 4d e4             	mov    %cl,-0x1c(%ebp)
  8093d2:	eb 93                	jmp    809367 <find_entry+0xf5>
        etharp_cached_entry = i;
  8093d4:	a2 00 4a b3 00       	mov    %al,0xb34a00
        return i;
  8093d9:	eb 51                	jmp    80942c <find_entry+0x1ba>
  8093db:	0f b6 55 e7          	movzbl -0x19(%ebp),%edx
    }
  }
  /* { we have no match } => try to create a new entry */
   
  /* no empty entry found and not allowed to recycle? */
  if (((empty == ARP_TABLE_SIZE) && ((flags & ETHARP_TRY_HARD) == 0))
  8093df:	80 fa 0a             	cmp    $0xa,%dl
  8093e2:	74 50                	je     809434 <find_entry+0x1c2>
      /* or don't create new entry, only search? */
      || ((flags & ETHARP_FIND_ONLY) != 0)) {
  8093e4:	f6 45 e0 02          	testb  $0x2,-0x20(%ebp)
  8093e8:	0f 85 e3 00 00 00    	jne    8094d1 <find_entry+0x25f>
   * { ETHARP_TRY_HARD is set at this point }
   */ 

  /* 1) empty entry available? */
  if (empty < ARP_TABLE_SIZE) {
    i = empty;
  8093ee:	89 d6                	mov    %edx,%esi
  if (empty < ARP_TABLE_SIZE) {
  8093f0:	80 fa 09             	cmp    $0x9,%dl
  8093f3:	7f 53                	jg     809448 <find_entry+0x1d6>
  } else {
    return (s8_t)ERR_MEM;
  }

  /* { empty or recyclable entry found } */
  LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
  8093f5:	89 f0                	mov    %esi,%eax
  8093f7:	3c 09                	cmp    $0x9,%al
  8093f9:	0f 87 b1 00 00 00    	ja     8094b0 <find_entry+0x23e>

  if (arp_table[i].state != ETHARP_STATE_EMPTY)
  8093ff:	0f b6 c0             	movzbl %al,%eax
  {
    snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
  }
  /* recycle entry (no-op for an already empty entry) */
  arp_table[i].state = ETHARP_STATE_EMPTY;
  809402:	6b d0 1c             	imul   $0x1c,%eax,%edx
  809405:	c7 82 30 4a b3 00 00 	movl   $0x0,0xb34a30(%edx)
  80940c:	00 00 00 

  /* IP address given? */
  if (ipaddr != NULL) {
  80940f:	85 db                	test   %ebx,%ebx
  809411:	74 08                	je     80941b <find_entry+0x1a9>
    /* set IP address */
    ip_addr_set(&arp_table[i].ipaddr, ipaddr);
  809413:	8b 0b                	mov    (%ebx),%ecx
  809415:	89 8a 24 4a b3 00    	mov    %ecx,0xb34a24(%edx)
  }
  arp_table[i].ctime = 0;
  80941b:	6b c0 1c             	imul   $0x1c,%eax,%eax
  80941e:	c6 80 34 4a b3 00 00 	movb   $0x0,0xb34a34(%eax)
#if LWIP_NETIF_HWADDRHINT
  NETIF_SET_HINT(netif, i);
#else /* #if LWIP_NETIF_HWADDRHINT */
  etharp_cached_entry = i;
  809425:	89 f0                	mov    %esi,%eax
  809427:	a2 00 4a b3 00       	mov    %al,0xb34a00
#endif /* #if LWIP_NETIF_HWADDRHINT */
  return (err_t)i;
}
  80942c:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80942f:	5b                   	pop    %ebx
  809430:	5e                   	pop    %esi
  809431:	5f                   	pop    %edi
  809432:	5d                   	pop    %ebp
  809433:	c3                   	ret    
  if (((empty == ARP_TABLE_SIZE) && ((flags & ETHARP_TRY_HARD) == 0))
  809434:	f6 45 e0 01          	testb  $0x1,-0x20(%ebp)
  809438:	0f 84 89 00 00 00    	je     8094c7 <find_entry+0x255>
      || ((flags & ETHARP_FIND_ONLY) != 0)) {
  80943e:	f6 45 e0 02          	testb  $0x2,-0x20(%ebp)
  809442:	0f 85 9d 00 00 00    	jne    8094e5 <find_entry+0x273>
  else if (old_stable < ARP_TABLE_SIZE) {
  809448:	0f b6 45 e5          	movzbl -0x1b(%ebp),%eax
  80944c:	3c 09                	cmp    $0x9,%al
  80944e:	7f 28                	jg     809478 <find_entry+0x206>
    i = old_stable;
  809450:	89 c6                	mov    %eax,%esi
    LWIP_ASSERT("arp_table[i].q == NULL", arp_table[i].q == NULL);
  809452:	0f b6 c0             	movzbl %al,%eax
  809455:	6b c0 1c             	imul   $0x1c,%eax,%eax
  809458:	83 b8 20 4a b3 00 00 	cmpl   $0x0,0xb34a20(%eax)
  80945f:	74 94                	je     8093f5 <find_entry+0x183>
  809461:	83 ec 04             	sub    $0x4,%esp
  809464:	68 cc 26 81 00       	push   $0x8126cc
  809469:	68 75 01 00 00       	push   $0x175
  80946e:	68 9a 26 81 00       	push   $0x81269a
  809473:	e8 cf 53 00 00       	call   80e847 <_panic>
  } else if (old_pending < ARP_TABLE_SIZE) {
  809478:	0f b6 45 de          	movzbl -0x22(%ebp),%eax
    i = old_pending;
  80947c:	89 c6                	mov    %eax,%esi
  } else if (old_pending < ARP_TABLE_SIZE) {
  80947e:	3c 09                	cmp    $0x9,%al
  809480:	0f 8e 6f ff ff ff    	jle    8093f5 <find_entry+0x183>
  } else if (old_queue < ARP_TABLE_SIZE) {
  809486:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
  80948a:	3c 09                	cmp    $0x9,%al
  80948c:	7f 4d                	jg     8094db <find_entry+0x269>
    i = old_queue;
  80948e:	89 c6                	mov    %eax,%esi
    free_etharp_q(arp_table[i].q);
  809490:	0f b6 f8             	movzbl %al,%edi
  809493:	6b ff 1c             	imul   $0x1c,%edi,%edi
  809496:	8b 87 20 4a b3 00    	mov    0xb34a20(%edi),%eax
  80949c:	e8 4e fd ff ff       	call   8091ef <free_etharp_q>
    arp_table[i].q = NULL;
  8094a1:	c7 87 20 4a b3 00 00 	movl   $0x0,0xb34a20(%edi)
  8094a8:	00 00 00 
  8094ab:	e9 45 ff ff ff       	jmp    8093f5 <find_entry+0x183>
  LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
  8094b0:	83 ec 04             	sub    $0x4,%esp
  8094b3:	68 e3 26 81 00       	push   $0x8126e3
  8094b8:	68 8b 01 00 00       	push   $0x18b
  8094bd:	68 9a 26 81 00       	push   $0x81269a
  8094c2:	e8 80 53 00 00       	call   80e847 <_panic>
    return (s8_t)ERR_MEM;
  8094c7:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8094cc:	e9 5b ff ff ff       	jmp    80942c <find_entry+0x1ba>
  8094d1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8094d6:	e9 51 ff ff ff       	jmp    80942c <find_entry+0x1ba>
    return (s8_t)ERR_MEM;
  8094db:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8094e0:	e9 47 ff ff ff       	jmp    80942c <find_entry+0x1ba>
    return (s8_t)ERR_MEM;
  8094e5:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8094ea:	e9 3d ff ff ff       	jmp    80942c <find_entry+0x1ba>

008094ef <etharp_send_ip>:
 * @params dst the destination MAC address to be copied into the ethernet header
 * @return ERR_OK if the packet was sent, any other err_t on failure
 */
static err_t
etharp_send_ip(struct netif *netif, struct pbuf *p, struct eth_addr *src, struct eth_addr *dst)
{
  8094ef:	55                   	push   %ebp
  8094f0:	89 e5                	mov    %esp,%ebp
  8094f2:	57                   	push   %edi
  8094f3:	56                   	push   %esi
  8094f4:	53                   	push   %ebx
  8094f5:	83 ec 1c             	sub    $0x1c,%esp
  8094f8:	89 d7                	mov    %edx,%edi
  8094fa:	8b 55 08             	mov    0x8(%ebp),%edx
  struct eth_hdr *ethhdr = p->payload;
  8094fd:	8b 5f 04             	mov    0x4(%edi),%ebx
  u8_t k;

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  809500:	80 78 24 06          	cmpb   $0x6,0x24(%eax)
  809504:	75 45                	jne    80954b <etharp_send_ip+0x5c>
  809506:	89 c6                	mov    %eax,%esi
  809508:	b8 05 00 00 00       	mov    $0x5,%eax
  80950d:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
              (netif->hwaddr_len == ETHARP_HWADDR_LEN));
  k = ETHARP_HWADDR_LEN;
  while(k > 0) {
    k--;
    ethhdr->dest.addr[k] = dst->addr[k];
  809510:	0f b6 0c 02          	movzbl (%edx,%eax,1),%ecx
  809514:	88 0c 03             	mov    %cl,(%ebx,%eax,1)
    ethhdr->src.addr[k]  = src->addr[k];
  809517:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  80951a:	0f b6 0c 01          	movzbl (%ecx,%eax,1),%ecx
  80951e:	88 4c 03 06          	mov    %cl,0x6(%ebx,%eax,1)
  809522:	83 e8 01             	sub    $0x1,%eax
  while(k > 0) {
  809525:	83 f8 ff             	cmp    $0xffffffff,%eax
  809528:	75 e6                	jne    809510 <etharp_send_ip+0x21>
  }
  ethhdr->type = htons(ETHTYPE_IP);
  80952a:	83 ec 0c             	sub    $0xc,%esp
  80952d:	68 00 08 00 00       	push   $0x800
  809532:	e8 29 e3 ff ff       	call   807860 <htons>
  809537:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_send_ip: sending packet %p\n", (void *)p));
  /* send the packet */
  return netif->linkoutput(netif, p);
  80953b:	83 c4 08             	add    $0x8,%esp
  80953e:	57                   	push   %edi
  80953f:	56                   	push   %esi
  809540:	ff 56 18             	call   *0x18(%esi)
}
  809543:	8d 65 f4             	lea    -0xc(%ebp),%esp
  809546:	5b                   	pop    %ebx
  809547:	5e                   	pop    %esi
  809548:	5f                   	pop    %edi
  809549:	5d                   	pop    %ebp
  80954a:	c3                   	ret    
  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  80954b:	83 ec 04             	sub    $0x4,%esp
  80954e:	68 10 27 81 00       	push   $0x812710
  809553:	68 b2 01 00 00       	push   $0x1b2
  809558:	68 9a 26 81 00       	push   $0x81269a
  80955d:	e8 e5 52 00 00       	call   80e847 <_panic>

00809562 <update_arp_entry>:
 *
 * @see pbuf_free()
 */
static err_t
update_arp_entry(struct netif *netif, struct ip_addr *ipaddr, struct eth_addr *ethaddr, u8_t flags)
{
  809562:	55                   	push   %ebp
  809563:	89 e5                	mov    %esp,%ebp
  809565:	57                   	push   %edi
  809566:	56                   	push   %esi
  809567:	53                   	push   %ebx
  809568:	83 ec 1c             	sub    $0x1c,%esp
  80956b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80956e:	89 cb                	mov    %ecx,%ebx
  809570:	8b 4d 08             	mov    0x8(%ebp),%ecx
  809573:	89 4d e0             	mov    %ecx,-0x20(%ebp)
  s8_t i;
  u8_t k;
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 3, ("update_arp_entry()\n"));
  LWIP_ASSERT("netif->hwaddr_len == ETHARP_HWADDR_LEN", netif->hwaddr_len == ETHARP_HWADDR_LEN);
  809576:	80 78 24 06          	cmpb   $0x6,0x24(%eax)
  80957a:	0f 85 ae 00 00 00    	jne    80962e <update_arp_entry+0xcc>
  809580:	89 d6                	mov    %edx,%esi
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: %"U16_F".%"U16_F".%"U16_F".%"U16_F" - %02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F"\n",
                                        ip4_addr1(ipaddr), ip4_addr2(ipaddr), ip4_addr3(ipaddr), ip4_addr4(ipaddr), 
                                        ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
                                        ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
  809582:	85 d2                	test   %edx,%edx
  809584:	0f 84 fe 00 00 00    	je     809688 <update_arp_entry+0x126>
  80958a:	83 3a 00             	cmpl   $0x0,(%edx)
  80958d:	0f 84 fc 00 00 00    	je     80968f <update_arp_entry+0x12d>
      ip_addr_isbroadcast(ipaddr, netif) ||
  809593:	83 ec 08             	sub    $0x8,%esp
  809596:	ff 75 e4             	pushl  -0x1c(%ebp)
  809599:	52                   	push   %edx
  80959a:	e8 45 d0 ff ff       	call   8065e4 <ip_addr_isbroadcast>
  if (ip_addr_isany(ipaddr) ||
  80959f:	83 c4 10             	add    $0x10,%esp
  8095a2:	84 c0                	test   %al,%al
  8095a4:	0f 85 ec 00 00 00    	jne    809696 <update_arp_entry+0x134>
      ip_addr_ismulticast(ipaddr)) {
  8095aa:	8b 3e                	mov    (%esi),%edi
  8095ac:	83 ec 0c             	sub    $0xc,%esp
  8095af:	68 00 00 00 f0       	push   $0xf0000000
  8095b4:	e8 f6 e4 ff ff       	call   807aaf <ntohl>
  8095b9:	21 c7                	and    %eax,%edi
  8095bb:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  8095c2:	e8 e8 e4 ff ff       	call   807aaf <ntohl>
      ip_addr_isbroadcast(ipaddr, netif) ||
  8095c7:	83 c4 10             	add    $0x10,%esp
  8095ca:	39 c7                	cmp    %eax,%edi
  8095cc:	0f 84 cb 00 00 00    	je     80969d <update_arp_entry+0x13b>
  }
  /* find or create ARP entry */
#if LWIP_NETIF_HWADDRHINT
  i = find_entry(ipaddr, flags, netif);
#else /* LWIP_NETIF_HWADDRHINT */
  i = find_entry(ipaddr, flags);
  8095d2:	0f b6 55 e0          	movzbl -0x20(%ebp),%edx
  8095d6:	89 f0                	mov    %esi,%eax
  8095d8:	e8 95 fc ff ff       	call   809272 <find_entry>
#endif /* LWIP_NETIF_HWADDRHINT */
  /* bail out if no entry could be found */
  if (i < 0)
  8095dd:	84 c0                	test   %al,%al
  8095df:	0f 88 9b 00 00 00    	js     809680 <update_arp_entry+0x11e>
    return (err_t)i;
  
  /* mark it stable */
  arp_table[i].state = ETHARP_STATE_STABLE;
  8095e5:	0f be c0             	movsbl %al,%eax
  8095e8:	6b f0 1c             	imul   $0x1c,%eax,%esi
  8095eb:	c7 86 30 4a b3 00 02 	movl   $0x2,0xb34a30(%esi)
  8095f2:	00 00 00 
  /* record network interface */
  arp_table[i].netif = netif;
  8095f5:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  8095f8:	89 8e 38 4a b3 00    	mov    %ecx,0xb34a38(%esi)
  8095fe:	ba 00 00 00 00       	mov    $0x0,%edx
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: updating stable entry %"S16_F"\n", (s16_t)i));
  /* update address */
  k = ETHARP_HWADDR_LEN;
  while (k > 0) {
    k--;
    arp_table[i].ethaddr.addr[k] = ethaddr->addr[k];
  809603:	0f b6 4c 13 05       	movzbl 0x5(%ebx,%edx,1),%ecx
  809608:	88 8c 16 2d 4a b3 00 	mov    %cl,0xb34a2d(%esi,%edx,1)
  80960f:	83 ea 01             	sub    $0x1,%edx
  while (k > 0) {
  809612:	83 fa fa             	cmp    $0xfffffffa,%edx
  809615:	75 ec                	jne    809603 <update_arp_entry+0xa1>
  }
  /* reset time stamp */
  arp_table[i].ctime = 0;
  809617:	6b d0 1c             	imul   $0x1c,%eax,%edx
  80961a:	c6 82 34 4a b3 00 00 	movb   $0x0,0xb34a34(%edx)
#if ARP_QUEUEING
  /* this is where we will send out queued packets! */
  while (arp_table[i].q != NULL) {
  809621:	89 d6                	mov    %edx,%esi
    /* get the packet pointer */
    p = q->p;
    /* now queue entry can be freed */
    memp_free(MEMP_ARP_QUEUE, q);
    /* send the queued IP packet */
    etharp_send_ip(netif, p, (struct eth_addr*)(netif->hwaddr), ethaddr);
  809623:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  809626:	83 c0 25             	add    $0x25,%eax
  809629:	89 45 e0             	mov    %eax,-0x20(%ebp)
  while (arp_table[i].q != NULL) {
  80962c:	eb 48                	jmp    809676 <update_arp_entry+0x114>
  LWIP_ASSERT("netif->hwaddr_len == ETHARP_HWADDR_LEN", netif->hwaddr_len == ETHARP_HWADDR_LEN);
  80962e:	83 ec 04             	sub    $0x4,%esp
  809631:	68 54 27 81 00       	push   $0x812754
  809636:	68 d9 01 00 00       	push   $0x1d9
  80963b:	68 9a 26 81 00       	push   $0x81269a
  809640:	e8 02 52 00 00       	call   80e847 <_panic>
    arp_table[i].q = q->next;
  809645:	8b 10                	mov    (%eax),%edx
  809647:	89 96 20 4a b3 00    	mov    %edx,0xb34a20(%esi)
    p = q->p;
  80964d:	8b 78 04             	mov    0x4(%eax),%edi
    memp_free(MEMP_ARP_QUEUE, q);
  809650:	83 ec 08             	sub    $0x8,%esp
  809653:	50                   	push   %eax
  809654:	6a 0a                	push   $0xa
  809656:	e8 4a af ff ff       	call   8045a5 <memp_free>
    etharp_send_ip(netif, p, (struct eth_addr*)(netif->hwaddr), ethaddr);
  80965b:	89 1c 24             	mov    %ebx,(%esp)
  80965e:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  809661:	89 fa                	mov    %edi,%edx
  809663:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  809666:	e8 84 fe ff ff       	call   8094ef <etharp_send_ip>
    /* free the queued IP packet */
    pbuf_free(p);
  80966b:	89 3c 24             	mov    %edi,(%esp)
  80966e:	e8 b5 b2 ff ff       	call   804928 <pbuf_free>
  809673:	83 c4 10             	add    $0x10,%esp
  while (arp_table[i].q != NULL) {
  809676:	8b 86 20 4a b3 00    	mov    0xb34a20(%esi),%eax
  80967c:	85 c0                	test   %eax,%eax
  80967e:	75 c5                	jne    809645 <update_arp_entry+0xe3>
  }
#endif
  return ERR_OK;
}
  809680:	8d 65 f4             	lea    -0xc(%ebp),%esp
  809683:	5b                   	pop    %ebx
  809684:	5e                   	pop    %esi
  809685:	5f                   	pop    %edi
  809686:	5d                   	pop    %ebp
  809687:	c3                   	ret    
    return ERR_ARG;
  809688:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  80968d:	eb f1                	jmp    809680 <update_arp_entry+0x11e>
  80968f:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  809694:	eb ea                	jmp    809680 <update_arp_entry+0x11e>
  809696:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  80969b:	eb e3                	jmp    809680 <update_arp_entry+0x11e>
  80969d:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  8096a2:	eb dc                	jmp    809680 <update_arp_entry+0x11e>

008096a4 <etharp_tmr>:
{
  8096a4:	f3 0f 1e fb          	endbr32 
  8096a8:	55                   	push   %ebp
  8096a9:	89 e5                	mov    %esp,%ebp
  8096ab:	57                   	push   %edi
  8096ac:	56                   	push   %esi
  8096ad:	53                   	push   %ebx
  8096ae:	83 ec 0c             	sub    $0xc,%esp
  8096b1:	bb 20 4a b3 00       	mov    $0xb34a20,%ebx
  8096b6:	bf 38 4b b3 00       	mov    $0xb34b38,%edi
  8096bb:	eb 1f                	jmp    8096dc <etharp_tmr+0x38>
      if (arp_table[i].q != NULL) {
  8096bd:	8b 06                	mov    (%esi),%eax
  8096bf:	85 c0                	test   %eax,%eax
  8096c1:	74 0b                	je     8096ce <etharp_tmr+0x2a>
        free_etharp_q(arp_table[i].q);
  8096c3:	e8 27 fb ff ff       	call   8091ef <free_etharp_q>
        arp_table[i].q = NULL;
  8096c8:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
      arp_table[i].state = ETHARP_STATE_EMPTY;
  8096ce:	c7 46 10 00 00 00 00 	movl   $0x0,0x10(%esi)
  8096d5:	83 c3 1c             	add    $0x1c,%ebx
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
  8096d8:	39 fb                	cmp    %edi,%ebx
  8096da:	74 23                	je     8096ff <etharp_tmr+0x5b>
  8096dc:	89 de                	mov    %ebx,%esi
    arp_table[i].ctime++;
  8096de:	0f b6 43 14          	movzbl 0x14(%ebx),%eax
  8096e2:	83 c0 01             	add    $0x1,%eax
  8096e5:	88 43 14             	mov    %al,0x14(%ebx)
    if (((arp_table[i].state == ETHARP_STATE_STABLE) &&
  8096e8:	8b 53 10             	mov    0x10(%ebx),%edx
  8096eb:	3c ef                	cmp    $0xef,%al
  8096ed:	76 05                	jbe    8096f4 <etharp_tmr+0x50>
  8096ef:	83 fa 02             	cmp    $0x2,%edx
  8096f2:	74 c9                	je     8096bd <etharp_tmr+0x19>
        ((arp_table[i].state == ETHARP_STATE_PENDING)  &&
  8096f4:	3c 01                	cmp    $0x1,%al
  8096f6:	76 dd                	jbe    8096d5 <etharp_tmr+0x31>
  8096f8:	83 fa 01             	cmp    $0x1,%edx
  8096fb:	75 d8                	jne    8096d5 <etharp_tmr+0x31>
  8096fd:	eb be                	jmp    8096bd <etharp_tmr+0x19>
}
  8096ff:	83 c4 0c             	add    $0xc,%esp
  809702:	5b                   	pop    %ebx
  809703:	5e                   	pop    %esi
  809704:	5f                   	pop    %edi
  809705:	5d                   	pop    %ebp
  809706:	c3                   	ret    

00809707 <etharp_find_addr>:
 * @return table index if found, -1 otherwise
 */
s8_t
etharp_find_addr(struct netif *netif, struct ip_addr *ipaddr,
         struct eth_addr **eth_ret, struct ip_addr **ip_ret)
{
  809707:	f3 0f 1e fb          	endbr32 
  80970b:	55                   	push   %ebp
  80970c:	89 e5                	mov    %esp,%ebp
  80970e:	53                   	push   %ebx
  80970f:	83 ec 04             	sub    $0x4,%esp
  LWIP_UNUSED_ARG(netif);

#if LWIP_NETIF_HWADDRHINT
  i = find_entry(ipaddr, ETHARP_FIND_ONLY, NULL);
#else /* LWIP_NETIF_HWADDRHINT */
  i = find_entry(ipaddr, ETHARP_FIND_ONLY);
  809712:	ba 02 00 00 00       	mov    $0x2,%edx
  809717:	8b 45 0c             	mov    0xc(%ebp),%eax
  80971a:	e8 53 fb ff ff       	call   809272 <find_entry>
#endif /* LWIP_NETIF_HWADDRHINT */
  if((i >= 0) && arp_table[i].state == ETHARP_STATE_STABLE) {
  80971f:	84 c0                	test   %al,%al
  809721:	78 31                	js     809754 <etharp_find_addr+0x4d>
  809723:	0f be d0             	movsbl %al,%edx
  809726:	6b d2 1c             	imul   $0x1c,%edx,%edx
  809729:	83 ba 30 4a b3 00 02 	cmpl   $0x2,0xb34a30(%edx)
  809730:	75 29                	jne    80975b <etharp_find_addr+0x54>
  809732:	0f be d0             	movsbl %al,%edx
  809735:	6b d2 1c             	imul   $0x1c,%edx,%edx
      *eth_ret = &arp_table[i].ethaddr;
  809738:	8d 9a 28 4a b3 00    	lea    0xb34a28(%edx),%ebx
  80973e:	8b 4d 10             	mov    0x10(%ebp),%ecx
  809741:	89 19                	mov    %ebx,(%ecx)
      *ip_ret = &arp_table[i].ipaddr;
  809743:	81 c2 24 4a b3 00    	add    $0xb34a24,%edx
  809749:	8b 4d 14             	mov    0x14(%ebp),%ecx
  80974c:	89 11                	mov    %edx,(%ecx)
      return i;
  }
  return -1;
}
  80974e:	83 c4 04             	add    $0x4,%esp
  809751:	5b                   	pop    %ebx
  809752:	5d                   	pop    %ebp
  809753:	c3                   	ret    
  return -1;
  809754:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  809759:	eb f3                	jmp    80974e <etharp_find_addr+0x47>
  80975b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  809760:	eb ec                	jmp    80974e <etharp_find_addr+0x47>

00809762 <etharp_ip_input>:
 *
 * @see pbuf_free()
 */
void
etharp_ip_input(struct netif *netif, struct pbuf *p)
{
  809762:	f3 0f 1e fb          	endbr32 
  809766:	55                   	push   %ebp
  809767:	89 e5                	mov    %esp,%ebp
  809769:	83 ec 08             	sub    $0x8,%esp
  80976c:	8b 45 08             	mov    0x8(%ebp),%eax
  struct ethip_hdr *hdr;
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  80976f:	85 c0                	test   %eax,%eax
  809771:	74 13                	je     809786 <etharp_ip_input+0x24>
  /* Only insert an entry if the source IP address of the
     incoming IP packet comes from a host on the local network. */
  hdr = p->payload;
  809773:	8b 55 0c             	mov    0xc(%ebp),%edx
  809776:	8b 52 04             	mov    0x4(%edx),%edx
  /* source is not on the local network? */
  if (!ip_addr_netcmp(&(hdr->ip.src), &(netif->ip_addr), &(netif->netmask))) {
  809779:	8b 4a 1c             	mov    0x1c(%edx),%ecx
  80977c:	33 48 04             	xor    0x4(%eax),%ecx
  80977f:	85 48 08             	test   %ecx,0x8(%eax)
  809782:	74 19                	je     80979d <etharp_ip_input+0x3b>
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_ip_input: updating ETHARP table.\n"));
  /* update ARP table */
  /* @todo We could use ETHARP_TRY_HARD if we think we are going to talk
   * back soon (for example, if the destination IP address is ours. */
  update_arp_entry(netif, &(hdr->ip.src), &(hdr->eth.src), 0);
}
  809784:	c9                   	leave  
  809785:	c3                   	ret    
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  809786:	83 ec 04             	sub    $0x4,%esp
  809789:	68 22 1a 81 00       	push   $0x811a22
  80978e:	68 48 02 00 00       	push   $0x248
  809793:	68 9a 26 81 00       	push   $0x81269a
  809798:	e8 aa 50 00 00       	call   80e847 <_panic>
  update_arp_entry(netif, &(hdr->ip.src), &(hdr->eth.src), 0);
  80979d:	8d 4a 06             	lea    0x6(%edx),%ecx
  8097a0:	83 c2 1c             	add    $0x1c,%edx
  8097a3:	83 ec 0c             	sub    $0xc,%esp
  8097a6:	6a 00                	push   $0x0
  8097a8:	e8 b5 fd ff ff       	call   809562 <update_arp_entry>
  8097ad:	83 c4 10             	add    $0x10,%esp
  8097b0:	eb d2                	jmp    809784 <etharp_ip_input+0x22>

008097b2 <etharp_arp_input>:
 *
 * @see pbuf_free()
 */
void
etharp_arp_input(struct netif *netif, struct eth_addr *ethaddr, struct pbuf *p)
{
  8097b2:	f3 0f 1e fb          	endbr32 
  8097b6:	55                   	push   %ebp
  8097b7:	89 e5                	mov    %esp,%ebp
  8097b9:	57                   	push   %edi
  8097ba:	56                   	push   %esi
  8097bb:	53                   	push   %ebx
  8097bc:	83 ec 1c             	sub    $0x1c,%esp
  8097bf:	8b 5d 10             	mov    0x10(%ebp),%ebx
  u8_t for_us;
#if LWIP_AUTOIP
  const u8_t * ethdst_hwaddr;
#endif /* LWIP_AUTOIP */

  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  8097c2:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  8097c6:	74 4d                	je     809815 <etharp_arp_input+0x63>
  
  /* drop short ARP packets: we have to check for p->len instead of p->tot_len here
     since a struct etharp_hdr is pointed to p->payload, so it musn't be chained! */
  if (p->len < sizeof(struct etharp_hdr)) {
  8097c8:	66 83 7b 0a 29       	cmpw   $0x29,0xa(%ebx)
  8097cd:	76 5d                	jbe    80982c <etharp_arp_input+0x7a>
    ETHARP_STATS_INC(etharp.drop);
    pbuf_free(p);
    return;
  }

  hdr = p->payload;
  8097cf:	8b 73 04             	mov    0x4(%ebx),%esi

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
  8097d2:	0f b7 7e 0e          	movzwl 0xe(%esi),%edi
  8097d6:	83 ec 0c             	sub    $0xc,%esp
  8097d9:	6a 01                	push   $0x1
  8097db:	e8 80 e0 ff ff       	call   807860 <htons>
  8097e0:	83 c4 10             	add    $0x10,%esp
  8097e3:	66 39 c7             	cmp    %ax,%di
  8097e6:	75 19                	jne    809801 <etharp_arp_input+0x4f>
      (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
  8097e8:	0f b7 7e 12          	movzwl 0x12(%esi),%edi
  8097ec:	83 ec 0c             	sub    $0xc,%esp
  8097ef:	68 04 06 00 00       	push   $0x604
  8097f4:	e8 67 e0 ff ff       	call   807860 <htons>
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
  8097f9:	83 c4 10             	add    $0x10,%esp
  8097fc:	66 39 c7             	cmp    %ax,%di
  8097ff:	74 39                	je     80983a <etharp_arp_input+0x88>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 1,
      ("etharp_arp_input: packet dropped, wrong hw type, hwlen, proto, protolen or ethernet type (%"U16_F"/%"U16_F"/%"U16_F"/%"U16_F"/%"U16_F")\n",
      hdr->hwtype, ARPH_HWLEN(hdr), hdr->proto, ARPH_PROTOLEN(hdr), hdr->ethhdr.type));
    ETHARP_STATS_INC(etharp.proterr);
    ETHARP_STATS_INC(etharp.drop);
    pbuf_free(p);
  809801:	83 ec 0c             	sub    $0xc,%esp
  809804:	53                   	push   %ebx
  809805:	e8 1e b1 ff ff       	call   804928 <pbuf_free>
    return;
  80980a:	83 c4 10             	add    $0x10,%esp
    ETHARP_STATS_INC(etharp.err);
    break;
  }
  /* free ARP packet */
  pbuf_free(p);
}
  80980d:	8d 65 f4             	lea    -0xc(%ebp),%esp
  809810:	5b                   	pop    %ebx
  809811:	5e                   	pop    %esi
  809812:	5f                   	pop    %edi
  809813:	5d                   	pop    %ebp
  809814:	c3                   	ret    
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  809815:	83 ec 04             	sub    $0x4,%esp
  809818:	68 22 1a 81 00       	push   $0x811a22
  80981d:	68 75 02 00 00       	push   $0x275
  809822:	68 9a 26 81 00       	push   $0x81269a
  809827:	e8 1b 50 00 00       	call   80e847 <_panic>
    pbuf_free(p);
  80982c:	83 ec 0c             	sub    $0xc,%esp
  80982f:	53                   	push   %ebx
  809830:	e8 f3 b0 ff ff       	call   804928 <pbuf_free>
    return;
  809835:	83 c4 10             	add    $0x10,%esp
  809838:	eb d3                	jmp    80980d <etharp_arp_input+0x5b>
      (hdr->proto != htons(ETHTYPE_IP)) ||
  80983a:	0f b7 7e 10          	movzwl 0x10(%esi),%edi
  80983e:	83 ec 0c             	sub    $0xc,%esp
  809841:	68 00 08 00 00       	push   $0x800
  809846:	e8 15 e0 ff ff       	call   807860 <htons>
      (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
  80984b:	83 c4 10             	add    $0x10,%esp
  80984e:	66 39 c7             	cmp    %ax,%di
  809851:	75 ae                	jne    809801 <etharp_arp_input+0x4f>
      (hdr->ethhdr.type != htons(ETHTYPE_ARP)))  {
  809853:	0f b7 7e 0c          	movzwl 0xc(%esi),%edi
  809857:	83 ec 0c             	sub    $0xc,%esp
  80985a:	68 06 08 00 00       	push   $0x806
  80985f:	e8 fc df ff ff       	call   807860 <htons>
      (hdr->proto != htons(ETHTYPE_IP)) ||
  809864:	83 c4 10             	add    $0x10,%esp
  809867:	66 39 c7             	cmp    %ax,%di
  80986a:	75 95                	jne    809801 <etharp_arp_input+0x4f>
  SMEMCPY(&sipaddr, &hdr->sipaddr, sizeof(sipaddr));
  80986c:	83 ec 04             	sub    $0x4,%esp
  80986f:	6a 04                	push   $0x4
  809871:	8d 46 1c             	lea    0x1c(%esi),%eax
  809874:	50                   	push   %eax
  809875:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  809878:	50                   	push   %eax
  809879:	e8 d6 58 00 00       	call   80f154 <memcpy>
  SMEMCPY(&dipaddr, &hdr->dipaddr, sizeof(dipaddr));
  80987e:	83 c4 0c             	add    $0xc,%esp
  809881:	6a 04                	push   $0x4
  809883:	8d 46 26             	lea    0x26(%esi),%eax
  809886:	50                   	push   %eax
  809887:	8d 45 e0             	lea    -0x20(%ebp),%eax
  80988a:	50                   	push   %eax
  80988b:	e8 c4 58 00 00       	call   80f154 <memcpy>
  if (netif->ip_addr.addr == 0) {
  809890:	8b 45 08             	mov    0x8(%ebp),%eax
  809893:	8b 40 04             	mov    0x4(%eax),%eax
  809896:	83 c4 10             	add    $0x10,%esp
  809899:	85 c0                	test   %eax,%eax
  80989b:	74 05                	je     8098a2 <etharp_arp_input+0xf0>
  if (for_us) {
  80989d:	3b 45 e0             	cmp    -0x20(%ebp),%eax
  8098a0:	74 3f                	je     8098e1 <etharp_arp_input+0x12f>
    update_arp_entry(netif, &sipaddr, &(hdr->shwaddr), 0);
  8098a2:	8d 4e 16             	lea    0x16(%esi),%ecx
  8098a5:	83 ec 0c             	sub    $0xc,%esp
  8098a8:	6a 00                	push   $0x0
  8098aa:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  8098ad:	8b 45 08             	mov    0x8(%ebp),%eax
  8098b0:	e8 ad fc ff ff       	call   809562 <update_arp_entry>
  switch (htons(hdr->opcode)) {
  8098b5:	0f b7 46 14          	movzwl 0x14(%esi),%eax
  8098b9:	89 04 24             	mov    %eax,(%esp)
  8098bc:	e8 9f df ff ff       	call   807860 <htons>
  8098c1:	83 c4 10             	add    $0x10,%esp
  8098c4:	66 83 f8 01          	cmp    $0x1,%ax
  8098c8:	74 06                	je     8098d0 <etharp_arp_input+0x11e>
  8098ca:	66 83 f8 02          	cmp    $0x2,%ax
  8098ce:	74 3f                	je     80990f <etharp_arp_input+0x15d>
  pbuf_free(p);
  8098d0:	83 ec 0c             	sub    $0xc,%esp
  8098d3:	53                   	push   %ebx
  8098d4:	e8 4f b0 ff ff       	call   804928 <pbuf_free>
  8098d9:	83 c4 10             	add    $0x10,%esp
  8098dc:	e9 2c ff ff ff       	jmp    80980d <etharp_arp_input+0x5b>
    update_arp_entry(netif, &sipaddr, &(hdr->shwaddr), ETHARP_TRY_HARD);
  8098e1:	8d 4e 16             	lea    0x16(%esi),%ecx
  8098e4:	83 ec 0c             	sub    $0xc,%esp
  8098e7:	6a 01                	push   $0x1
  8098e9:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  8098ec:	8b 45 08             	mov    0x8(%ebp),%eax
  8098ef:	e8 6e fc ff ff       	call   809562 <update_arp_entry>
  switch (htons(hdr->opcode)) {
  8098f4:	0f b7 46 14          	movzwl 0x14(%esi),%eax
  8098f8:	89 04 24             	mov    %eax,(%esp)
  8098fb:	e8 60 df ff ff       	call   807860 <htons>
  809900:	83 c4 10             	add    $0x10,%esp
  809903:	66 83 f8 01          	cmp    $0x1,%ax
  809907:	74 1a                	je     809923 <etharp_arp_input+0x171>
  809909:	66 83 f8 02          	cmp    $0x2,%ax
  80990d:	75 c1                	jne    8098d0 <etharp_arp_input+0x11e>
    dhcp_arp_reply(netif, &sipaddr);
  80990f:	83 ec 08             	sub    $0x8,%esp
  809912:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  809915:	50                   	push   %eax
  809916:	ff 75 08             	pushl  0x8(%ebp)
  809919:	e8 48 a0 ff ff       	call   803966 <dhcp_arp_reply>
    break;
  80991e:	83 c4 10             	add    $0x10,%esp
  809921:	eb ad                	jmp    8098d0 <etharp_arp_input+0x11e>
      hdr->opcode = htons(ARP_REPLY);
  809923:	83 ec 0c             	sub    $0xc,%esp
  809926:	6a 02                	push   $0x2
  809928:	e8 33 df ff ff       	call   807860 <htons>
  80992d:	66 89 46 14          	mov    %ax,0x14(%esi)
      hdr->dipaddr = hdr->sipaddr;
  809931:	8b 46 1c             	mov    0x1c(%esi),%eax
  809934:	89 46 26             	mov    %eax,0x26(%esi)
      hdr->sipaddr = *(struct ip_addr2 *)&netif->ip_addr;
  809937:	8b 45 08             	mov    0x8(%ebp),%eax
  80993a:	8b 40 04             	mov    0x4(%eax),%eax
  80993d:	89 46 1c             	mov    %eax,0x1c(%esi)
      LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  809940:	83 c4 10             	add    $0x10,%esp
  809943:	8b 45 08             	mov    0x8(%ebp),%eax
  809946:	80 78 24 06          	cmpb   $0x6,0x24(%eax)
  80994a:	75 3e                	jne    80998a <etharp_arp_input+0x1d8>
  80994c:	8d 46 05             	lea    0x5(%esi),%eax
  80994f:	8b 55 0c             	mov    0xc(%ebp),%edx
  809952:	83 c2 05             	add    $0x5,%edx
  809955:	89 f7                	mov    %esi,%edi
  809957:	89 c6                	mov    %eax,%esi
        hdr->dhwaddr.addr[i] = hdr->shwaddr.addr[i];
  809959:	0f b6 48 16          	movzbl 0x16(%eax),%ecx
  80995d:	88 48 20             	mov    %cl,0x20(%eax)
        hdr->ethhdr.dest.addr[i] = hdr->shwaddr.addr[i];
  809960:	88 08                	mov    %cl,(%eax)
        hdr->shwaddr.addr[i] = ethaddr->addr[i];
  809962:	0f b6 0a             	movzbl (%edx),%ecx
  809965:	88 48 16             	mov    %cl,0x16(%eax)
        hdr->ethhdr.src.addr[i] = ethaddr->addr[i];
  809968:	88 48 06             	mov    %cl,0x6(%eax)
  80996b:	83 e8 01             	sub    $0x1,%eax
  80996e:	83 ea 01             	sub    $0x1,%edx
      while(i > 0) {
  809971:	39 fe                	cmp    %edi,%esi
  809973:	75 e2                	jne    809957 <etharp_arp_input+0x1a5>
      netif->linkoutput(netif, p);
  809975:	83 ec 08             	sub    $0x8,%esp
  809978:	53                   	push   %ebx
  809979:	ff 75 08             	pushl  0x8(%ebp)
  80997c:	8b 45 08             	mov    0x8(%ebp),%eax
  80997f:	ff 50 18             	call   *0x18(%eax)
  809982:	83 c4 10             	add    $0x10,%esp
  809985:	e9 46 ff ff ff       	jmp    8098d0 <etharp_arp_input+0x11e>
      LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  80998a:	83 ec 04             	sub    $0x4,%esp
  80998d:	68 10 27 81 00       	push   $0x812710
  809992:	68 c6 02 00 00       	push   $0x2c6
  809997:	68 9a 26 81 00       	push   $0x81269a
  80999c:	e8 a6 4e 00 00       	call   80e847 <_panic>

008099a1 <etharp_request>:
 *         ERR_MEM if the ARP packet couldn't be allocated
 *         any other err_t on failure
 */
err_t
etharp_request(struct netif *netif, struct ip_addr *ipaddr)
{
  8099a1:	f3 0f 1e fb          	endbr32 
  8099a5:	55                   	push   %ebp
  8099a6:	89 e5                	mov    %esp,%ebp
  8099a8:	57                   	push   %edi
  8099a9:	56                   	push   %esi
  8099aa:	53                   	push   %ebx
  8099ab:	83 ec 10             	sub    $0x10,%esp
  8099ae:	8b 7d 08             	mov    0x8(%ebp),%edi
  p = pbuf_alloc(PBUF_LINK, sizeof(struct etharp_hdr), PBUF_RAM);
  8099b1:	6a 00                	push   $0x0
  8099b3:	6a 2a                	push   $0x2a
  8099b5:	6a 02                	push   $0x2
  8099b7:	e8 36 b0 ff ff       	call   8049f2 <pbuf_alloc>
  if (p == NULL) {
  8099bc:	83 c4 10             	add    $0x10,%esp
  8099bf:	85 c0                	test   %eax,%eax
  8099c1:	0f 84 f8 00 00 00    	je     809abf <etharp_request+0x11e>
  8099c7:	89 c6                	mov    %eax,%esi
  LWIP_ASSERT("check that first pbuf can hold struct etharp_hdr",
  8099c9:	66 83 78 0a 29       	cmpw   $0x29,0xa(%eax)
  8099ce:	0f 86 bd 00 00 00    	jbe    809a91 <etharp_request+0xf0>
  hdr = p->payload;
  8099d4:	8b 58 04             	mov    0x4(%eax),%ebx
  hdr->opcode = htons(opcode);
  8099d7:	83 ec 0c             	sub    $0xc,%esp
  8099da:	6a 01                	push   $0x1
  8099dc:	e8 7f de ff ff       	call   807860 <htons>
  8099e1:	66 89 43 14          	mov    %ax,0x14(%ebx)
  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  8099e5:	83 c4 10             	add    $0x10,%esp
  8099e8:	80 7f 24 06          	cmpb   $0x6,0x24(%edi)
  8099ec:	0f 85 b6 00 00 00    	jne    809aa8 <etharp_request+0x107>
  8099f2:	b8 05 00 00 00       	mov    $0x5,%eax
    hdr->shwaddr.addr[k] = hwsrc_addr->addr[k];
  8099f7:	0f b6 54 07 25       	movzbl 0x25(%edi,%eax,1),%edx
  8099fc:	88 54 03 16          	mov    %dl,0x16(%ebx,%eax,1)
    hdr->dhwaddr.addr[k] = hwdst_addr->addr[k];
  809a00:	0f b6 90 fc 27 81 00 	movzbl 0x8127fc(%eax),%edx
  809a07:	88 54 03 20          	mov    %dl,0x20(%ebx,%eax,1)
    hdr->ethhdr.dest.addr[k] = ethdst_addr->addr[k];
  809a0b:	0f b6 90 04 28 81 00 	movzbl 0x812804(%eax),%edx
  809a12:	88 14 03             	mov    %dl,(%ebx,%eax,1)
    hdr->ethhdr.src.addr[k]  = ethsrc_addr->addr[k];
  809a15:	0f b6 54 07 25       	movzbl 0x25(%edi,%eax,1),%edx
  809a1a:	88 54 03 06          	mov    %dl,0x6(%ebx,%eax,1)
  809a1e:	83 e8 01             	sub    $0x1,%eax
  while(k > 0) {
  809a21:	83 f8 ff             	cmp    $0xffffffff,%eax
  809a24:	75 d1                	jne    8099f7 <etharp_request+0x56>
  hdr->sipaddr = *(struct ip_addr2 *)ipsrc_addr;
  809a26:	8b 47 04             	mov    0x4(%edi),%eax
  809a29:	89 43 1c             	mov    %eax,0x1c(%ebx)
  hdr->dipaddr = *(struct ip_addr2 *)ipdst_addr;
  809a2c:	8b 45 0c             	mov    0xc(%ebp),%eax
  809a2f:	8b 00                	mov    (%eax),%eax
  809a31:	89 43 26             	mov    %eax,0x26(%ebx)
  hdr->hwtype = htons(HWTYPE_ETHERNET);
  809a34:	83 ec 0c             	sub    $0xc,%esp
  809a37:	6a 01                	push   $0x1
  809a39:	e8 22 de ff ff       	call   807860 <htons>
  809a3e:	66 89 43 0e          	mov    %ax,0xe(%ebx)
  hdr->proto = htons(ETHTYPE_IP);
  809a42:	c7 04 24 00 08 00 00 	movl   $0x800,(%esp)
  809a49:	e8 12 de ff ff       	call   807860 <htons>
  809a4e:	66 89 43 10          	mov    %ax,0x10(%ebx)
  hdr->_hwlen_protolen = htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr));
  809a52:	c7 04 24 04 06 00 00 	movl   $0x604,(%esp)
  809a59:	e8 02 de ff ff       	call   807860 <htons>
  809a5e:	66 89 43 12          	mov    %ax,0x12(%ebx)
  hdr->ethhdr.type = htons(ETHTYPE_ARP);
  809a62:	c7 04 24 06 08 00 00 	movl   $0x806,(%esp)
  809a69:	e8 f2 dd ff ff       	call   807860 <htons>
  809a6e:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  result = netif->linkoutput(netif, p);
  809a72:	83 c4 08             	add    $0x8,%esp
  809a75:	56                   	push   %esi
  809a76:	57                   	push   %edi
  809a77:	ff 57 18             	call   *0x18(%edi)
  809a7a:	89 c3                	mov    %eax,%ebx
  pbuf_free(p);
  809a7c:	89 34 24             	mov    %esi,(%esp)
  809a7f:	e8 a4 ae ff ff       	call   804928 <pbuf_free>
  return result;
  809a84:	83 c4 10             	add    $0x10,%esp
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_request: sending ARP request.\n"));
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
                    (struct eth_addr *)netif->hwaddr, &netif->ip_addr, &ethzero,
                    ipaddr, ARP_REQUEST);
}
  809a87:	89 d8                	mov    %ebx,%eax
  809a89:	8d 65 f4             	lea    -0xc(%ebp),%esp
  809a8c:	5b                   	pop    %ebx
  809a8d:	5e                   	pop    %esi
  809a8e:	5f                   	pop    %edi
  809a8f:	5d                   	pop    %ebp
  809a90:	c3                   	ret    
  LWIP_ASSERT("check that first pbuf can hold struct etharp_hdr",
  809a91:	83 ec 04             	sub    $0x4,%esp
  809a94:	68 7c 27 81 00       	push   $0x81277c
  809a99:	68 1b 04 00 00       	push   $0x41b
  809a9e:	68 9a 26 81 00       	push   $0x81269a
  809aa3:	e8 9f 4d 00 00       	call   80e847 <_panic>
  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  809aa8:	83 ec 04             	sub    $0x4,%esp
  809aab:	68 10 27 81 00       	push   $0x812710
  809ab0:	68 22 04 00 00       	push   $0x422
  809ab5:	68 9a 26 81 00       	push   $0x81269a
  809aba:	e8 88 4d 00 00       	call   80e847 <_panic>
    return ERR_MEM;
  809abf:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
  809ac4:	eb c1                	jmp    809a87 <etharp_request+0xe6>

00809ac6 <etharp_query>:
{
  809ac6:	f3 0f 1e fb          	endbr32 
  809aca:	55                   	push   %ebp
  809acb:	89 e5                	mov    %esp,%ebp
  809acd:	57                   	push   %edi
  809ace:	56                   	push   %esi
  809acf:	53                   	push   %ebx
  809ad0:	83 ec 14             	sub    $0x14,%esp
  809ad3:	8b 75 0c             	mov    0xc(%ebp),%esi
  if (ip_addr_isbroadcast(ipaddr, netif) ||
  809ad6:	ff 75 08             	pushl  0x8(%ebp)
  809ad9:	56                   	push   %esi
  809ada:	e8 05 cb ff ff       	call   8065e4 <ip_addr_isbroadcast>
  809adf:	83 c4 10             	add    $0x10,%esp
  809ae2:	84 c0                	test   %al,%al
  809ae4:	0f 85 9f 01 00 00    	jne    809c89 <etharp_query+0x1c3>
      ip_addr_ismulticast(ipaddr) ||
  809aea:	8b 1e                	mov    (%esi),%ebx
  809aec:	83 ec 0c             	sub    $0xc,%esp
  809aef:	68 00 00 00 f0       	push   $0xf0000000
  809af4:	e8 b6 df ff ff       	call   807aaf <ntohl>
  809af9:	21 c3                	and    %eax,%ebx
  809afb:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  809b02:	e8 a8 df ff ff       	call   807aaf <ntohl>
  809b07:	83 c4 10             	add    $0x10,%esp
  809b0a:	39 c3                	cmp    %eax,%ebx
  809b0c:	0f 84 81 01 00 00    	je     809c93 <etharp_query+0x1cd>
      ip_addr_isany(ipaddr)) {
  809b12:	83 3e 00             	cmpl   $0x0,(%esi)
  809b15:	0f 84 82 01 00 00    	je     809c9d <etharp_query+0x1d7>
  i = find_entry(ipaddr, ETHARP_TRY_HARD);
  809b1b:	ba 01 00 00 00       	mov    $0x1,%edx
  809b20:	89 f0                	mov    %esi,%eax
  809b22:	e8 4b f7 ff ff       	call   809272 <find_entry>
  809b27:	89 c3                	mov    %eax,%ebx
  if (i < 0) {
  809b29:	84 c0                	test   %al,%al
  809b2b:	0f 88 76 01 00 00    	js     809ca7 <etharp_query+0x1e1>
  if (arp_table[i].state == ETHARP_STATE_EMPTY) {
  809b31:	0f be f8             	movsbl %al,%edi
  809b34:	6b c7 1c             	imul   $0x1c,%edi,%eax
  809b37:	8b 80 30 4a b3 00    	mov    0xb34a30(%eax),%eax
  809b3d:	85 c0                	test   %eax,%eax
  809b3f:	75 26                	jne    809b67 <etharp_query+0xa1>
    arp_table[i].state = ETHARP_STATE_PENDING;
  809b41:	6b c7 1c             	imul   $0x1c,%edi,%eax
  809b44:	c7 80 30 4a b3 00 01 	movl   $0x1,0xb34a30(%eax)
  809b4b:	00 00 00 
    result = etharp_request(netif, ipaddr);
  809b4e:	83 ec 08             	sub    $0x8,%esp
  809b51:	56                   	push   %esi
  809b52:	ff 75 08             	pushl  0x8(%ebp)
  809b55:	e8 47 fe ff ff       	call   8099a1 <etharp_request>
  809b5a:	89 c6                	mov    %eax,%esi
  if (q != NULL) {
  809b5c:	83 c4 10             	add    $0x10,%esp
  809b5f:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  809b63:	74 2d                	je     809b92 <etharp_query+0xcc>
  809b65:	eb 18                	jmp    809b7f <etharp_query+0xb9>
  LWIP_ASSERT("arp_table[i].state == PENDING or STABLE",
  809b67:	8d 50 ff             	lea    -0x1(%eax),%edx
  809b6a:	83 fa 01             	cmp    $0x1,%edx
  809b6d:	77 2d                	ja     809b9c <etharp_query+0xd6>
  if ((arp_table[i].state == ETHARP_STATE_PENDING) || (q == NULL)) {
  809b6f:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  809b73:	74 d9                	je     809b4e <etharp_query+0x88>
  809b75:	83 f8 01             	cmp    $0x1,%eax
  809b78:	74 d4                	je     809b4e <etharp_query+0x88>
  err_t result = ERR_MEM;
  809b7a:	be ff ff ff ff       	mov    $0xffffffff,%esi
    if (arp_table[i].state == ETHARP_STATE_STABLE) {
  809b7f:	6b c7 1c             	imul   $0x1c,%edi,%eax
  809b82:	8b 80 30 4a b3 00    	mov    0xb34a30(%eax),%eax
  809b88:	83 f8 02             	cmp    $0x2,%eax
  809b8b:	74 26                	je     809bb3 <etharp_query+0xed>
    } else if (arp_table[i].state == ETHARP_STATE_PENDING) {
  809b8d:	83 f8 01             	cmp    $0x1,%eax
  809b90:	74 48                	je     809bda <etharp_query+0x114>
}
  809b92:	89 f0                	mov    %esi,%eax
  809b94:	8d 65 f4             	lea    -0xc(%ebp),%esp
  809b97:	5b                   	pop    %ebx
  809b98:	5e                   	pop    %esi
  809b99:	5f                   	pop    %edi
  809b9a:	5d                   	pop    %ebp
  809b9b:	c3                   	ret    
  LWIP_ASSERT("arp_table[i].state == PENDING or STABLE",
  809b9c:	83 ec 04             	sub    $0x4,%esp
  809b9f:	68 b0 27 81 00       	push   $0x8127b0
  809ba4:	68 90 03 00 00       	push   $0x390
  809ba9:	68 9a 26 81 00       	push   $0x81269a
  809bae:	e8 94 4c 00 00       	call   80e847 <_panic>
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
  809bb3:	8b 45 08             	mov    0x8(%ebp),%eax
  809bb6:	8d 48 25             	lea    0x25(%eax),%ecx
      result = etharp_send_ip(netif, q, srcaddr, &(arp_table[i].ethaddr));
  809bb9:	83 ec 0c             	sub    $0xc,%esp
  809bbc:	0f be c3             	movsbl %bl,%eax
  809bbf:	6b c0 1c             	imul   $0x1c,%eax,%eax
  809bc2:	05 28 4a b3 00       	add    $0xb34a28,%eax
  809bc7:	50                   	push   %eax
  809bc8:	8b 55 10             	mov    0x10(%ebp),%edx
  809bcb:	8b 45 08             	mov    0x8(%ebp),%eax
  809bce:	e8 1c f9 ff ff       	call   8094ef <etharp_send_ip>
  809bd3:	89 c6                	mov    %eax,%esi
  809bd5:	83 c4 10             	add    $0x10,%esp
  809bd8:	eb b8                	jmp    809b92 <etharp_query+0xcc>
      p = q;
  809bda:	8b 45 10             	mov    0x10(%ebp),%eax
  809bdd:	eb 27                	jmp    809c06 <etharp_query+0x140>
        LWIP_ASSERT("no packet queues allowed!", (p->len != p->tot_len) || (p->next == 0));
  809bdf:	83 ec 04             	sub    $0x4,%esp
  809be2:	68 f6 26 81 00       	push   $0x8126f6
  809be7:	68 b1 03 00 00       	push   $0x3b1
  809bec:	68 9a 26 81 00       	push   $0x81269a
  809bf1:	e8 51 4c 00 00       	call   80e847 <_panic>
        if(p->type != PBUF_ROM) {
  809bf6:	80 78 0c 01          	cmpb   $0x1,0xc(%eax)
  809bfa:	75 23                	jne    809c1f <etharp_query+0x159>
        p = p->next;
  809bfc:	8b 00                	mov    (%eax),%eax
      while (p) {
  809bfe:	85 c0                	test   %eax,%eax
  809c00:	0f 84 a8 00 00 00    	je     809cae <etharp_query+0x1e8>
        LWIP_ASSERT("no packet queues allowed!", (p->len != p->tot_len) || (p->next == 0));
  809c06:	0f b7 50 08          	movzwl 0x8(%eax),%edx
  809c0a:	66 39 50 0a          	cmp    %dx,0xa(%eax)
  809c0e:	75 e6                	jne    809bf6 <etharp_query+0x130>
  809c10:	83 38 00             	cmpl   $0x0,(%eax)
  809c13:	75 ca                	jne    809bdf <etharp_query+0x119>
        if(p->type != PBUF_ROM) {
  809c15:	80 78 0c 01          	cmpb   $0x1,0xc(%eax)
  809c19:	0f 84 8f 00 00 00    	je     809cae <etharp_query+0x1e8>
        p = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
  809c1f:	83 ec 04             	sub    $0x4,%esp
  809c22:	6a 00                	push   $0x0
  809c24:	0f b7 d2             	movzwl %dx,%edx
  809c27:	52                   	push   %edx
  809c28:	6a 03                	push   $0x3
  809c2a:	e8 c3 ad ff ff       	call   8049f2 <pbuf_alloc>
  809c2f:	89 c3                	mov    %eax,%ebx
        if(p != NULL) {
  809c31:	83 c4 10             	add    $0x10,%esp
  809c34:	85 c0                	test   %eax,%eax
  809c36:	0f 84 56 ff ff ff    	je     809b92 <etharp_query+0xcc>
          if (pbuf_copy(p, q) != ERR_OK) {
  809c3c:	83 ec 08             	sub    $0x8,%esp
  809c3f:	ff 75 10             	pushl  0x10(%ebp)
  809c42:	53                   	push   %ebx
  809c43:	e8 91 b2 ff ff       	call   804ed9 <pbuf_copy>
  809c48:	83 c4 10             	add    $0x10,%esp
        p = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
  809c4b:	89 5d 10             	mov    %ebx,0x10(%ebp)
          if (pbuf_copy(p, q) != ERR_OK) {
  809c4e:	84 c0                	test   %al,%al
  809c50:	74 6a                	je     809cbc <etharp_query+0x1f6>
            pbuf_free(p);
  809c52:	83 ec 0c             	sub    $0xc,%esp
  809c55:	53                   	push   %ebx
  809c56:	e8 cd ac ff ff       	call   804928 <pbuf_free>
  809c5b:	83 c4 10             	add    $0x10,%esp
  809c5e:	e9 2f ff ff ff       	jmp    809b92 <etharp_query+0xcc>
            arp_table[i].q = new_entry;
  809c63:	6b ff 1c             	imul   $0x1c,%edi,%edi
  809c66:	89 87 20 4a b3 00    	mov    %eax,0xb34a20(%edi)
          result = ERR_OK;
  809c6c:	be 00 00 00 00       	mov    $0x0,%esi
  809c71:	e9 1c ff ff ff       	jmp    809b92 <etharp_query+0xcc>
          pbuf_free(p);
  809c76:	83 ec 0c             	sub    $0xc,%esp
  809c79:	ff 75 10             	pushl  0x10(%ebp)
  809c7c:	e8 a7 ac ff ff       	call   804928 <pbuf_free>
  809c81:	83 c4 10             	add    $0x10,%esp
  809c84:	e9 09 ff ff ff       	jmp    809b92 <etharp_query+0xcc>
    return ERR_ARG;
  809c89:	be f6 ff ff ff       	mov    $0xfffffff6,%esi
  809c8e:	e9 ff fe ff ff       	jmp    809b92 <etharp_query+0xcc>
  809c93:	be f6 ff ff ff       	mov    $0xfffffff6,%esi
  809c98:	e9 f5 fe ff ff       	jmp    809b92 <etharp_query+0xcc>
  809c9d:	be f6 ff ff ff       	mov    $0xfffffff6,%esi
  809ca2:	e9 eb fe ff ff       	jmp    809b92 <etharp_query+0xcc>
    return (err_t)i;
  809ca7:	89 c6                	mov    %eax,%esi
  809ca9:	e9 e4 fe ff ff       	jmp    809b92 <etharp_query+0xcc>
        pbuf_ref(p);
  809cae:	83 ec 0c             	sub    $0xc,%esp
  809cb1:	ff 75 10             	pushl  0x10(%ebp)
  809cb4:	e8 cc b0 ff ff       	call   804d85 <pbuf_ref>
  809cb9:	83 c4 10             	add    $0x10,%esp
        new_entry = memp_malloc(MEMP_ARP_QUEUE);
  809cbc:	83 ec 0c             	sub    $0xc,%esp
  809cbf:	6a 0a                	push   $0xa
  809cc1:	e8 85 a8 ff ff       	call   80454b <memp_malloc>
        if (new_entry != NULL) {
  809cc6:	83 c4 10             	add    $0x10,%esp
  809cc9:	85 c0                	test   %eax,%eax
  809ccb:	74 a9                	je     809c76 <etharp_query+0x1b0>
          new_entry->next = 0;
  809ccd:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
          new_entry->p = p;
  809cd3:	8b 4d 10             	mov    0x10(%ebp),%ecx
  809cd6:	89 48 04             	mov    %ecx,0x4(%eax)
          if(arp_table[i].q != NULL) {
  809cd9:	6b d7 1c             	imul   $0x1c,%edi,%edx
  809cdc:	8b 92 20 4a b3 00    	mov    0xb34a20(%edx),%edx
  809ce2:	85 d2                	test   %edx,%edx
  809ce4:	0f 84 79 ff ff ff    	je     809c63 <etharp_query+0x19d>
  809cea:	89 d1                	mov    %edx,%ecx
            while (r->next != NULL) {
  809cec:	8b 12                	mov    (%edx),%edx
  809cee:	85 d2                	test   %edx,%edx
  809cf0:	75 f8                	jne    809cea <etharp_query+0x224>
            r->next = new_entry;
  809cf2:	89 01                	mov    %eax,(%ecx)
          result = ERR_OK;
  809cf4:	be 00 00 00 00       	mov    $0x0,%esi
  809cf9:	e9 94 fe ff ff       	jmp    809b92 <etharp_query+0xcc>

00809cfe <etharp_output>:
{
  809cfe:	f3 0f 1e fb          	endbr32 
  809d02:	55                   	push   %ebp
  809d03:	89 e5                	mov    %esp,%ebp
  809d05:	57                   	push   %edi
  809d06:	56                   	push   %esi
  809d07:	53                   	push   %ebx
  809d08:	83 ec 24             	sub    $0x24,%esp
  809d0b:	8b 5d 08             	mov    0x8(%ebp),%ebx
  809d0e:	8b 75 10             	mov    0x10(%ebp),%esi
  if (pbuf_header(q, sizeof(struct eth_hdr)) != 0) {
  809d11:	6a 0e                	push   $0xe
  809d13:	ff 75 0c             	pushl  0xc(%ebp)
  809d16:	e8 3a ab ff ff       	call   804855 <pbuf_header>
  809d1b:	83 c4 10             	add    $0x10,%esp
  809d1e:	84 c0                	test   %al,%al
  809d20:	0f 85 c0 00 00 00    	jne    809de6 <etharp_output+0xe8>
  if (ip_addr_isbroadcast(ipaddr, netif)) {
  809d26:	83 ec 08             	sub    $0x8,%esp
  809d29:	53                   	push   %ebx
  809d2a:	56                   	push   %esi
  809d2b:	e8 b4 c8 ff ff       	call   8065e4 <ip_addr_isbroadcast>
  809d30:	83 c4 10             	add    $0x10,%esp
  809d33:	84 c0                	test   %al,%al
  809d35:	0f 85 8a 00 00 00    	jne    809dc5 <etharp_output+0xc7>
  } else if (ip_addr_ismulticast(ipaddr)) {
  809d3b:	8b 3e                	mov    (%esi),%edi
  809d3d:	83 ec 0c             	sub    $0xc,%esp
  809d40:	68 00 00 00 f0       	push   $0xf0000000
  809d45:	e8 65 dd ff ff       	call   807aaf <ntohl>
  809d4a:	21 c7                	and    %eax,%edi
  809d4c:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  809d53:	e8 57 dd ff ff       	call   807aaf <ntohl>
  809d58:	83 c4 10             	add    $0x10,%esp
  809d5b:	39 c7                	cmp    %eax,%edi
  809d5d:	74 25                	je     809d84 <etharp_output+0x86>
    if (!ip_addr_netcmp(ipaddr, &(netif->ip_addr), &(netif->netmask))) {
  809d5f:	8b 06                	mov    (%esi),%eax
  809d61:	33 43 04             	xor    0x4(%ebx),%eax
  809d64:	85 43 08             	test   %eax,0x8(%ebx)
  809d67:	74 09                	je     809d72 <etharp_output+0x74>
      if (netif->gw.addr != 0) {
  809d69:	83 7b 0c 00          	cmpl   $0x0,0xc(%ebx)
  809d6d:	74 7e                	je     809ded <etharp_output+0xef>
        ipaddr = &(netif->gw);
  809d6f:	8d 73 0c             	lea    0xc(%ebx),%esi
    return etharp_query(netif, ipaddr, q);
  809d72:	83 ec 04             	sub    $0x4,%esp
  809d75:	ff 75 0c             	pushl  0xc(%ebp)
  809d78:	56                   	push   %esi
  809d79:	53                   	push   %ebx
  809d7a:	e8 47 fd ff ff       	call   809ac6 <etharp_query>
  809d7f:	83 c4 10             	add    $0x10,%esp
  809d82:	eb 5a                	jmp    809dde <etharp_output+0xe0>
    mcastaddr.addr[0] = 0x01;
  809d84:	c6 45 e2 01          	movb   $0x1,-0x1e(%ebp)
    mcastaddr.addr[1] = 0x00;
  809d88:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
    mcastaddr.addr[2] = 0x5e;
  809d8c:	c6 45 e4 5e          	movb   $0x5e,-0x1c(%ebp)
    mcastaddr.addr[3] = ip4_addr2(ipaddr) & 0x7f;
  809d90:	83 ec 0c             	sub    $0xc,%esp
  809d93:	ff 36                	pushl  (%esi)
  809d95:	e8 15 dd ff ff       	call   807aaf <ntohl>
  809d9a:	c1 e8 10             	shr    $0x10,%eax
  809d9d:	83 e0 7f             	and    $0x7f,%eax
  809da0:	88 45 e5             	mov    %al,-0x1b(%ebp)
    mcastaddr.addr[4] = ip4_addr3(ipaddr);
  809da3:	83 c4 04             	add    $0x4,%esp
  809da6:	ff 36                	pushl  (%esi)
  809da8:	e8 02 dd ff ff       	call   807aaf <ntohl>
  809dad:	88 65 e6             	mov    %ah,-0x1a(%ebp)
    mcastaddr.addr[5] = ip4_addr4(ipaddr);
  809db0:	83 c4 04             	add    $0x4,%esp
  809db3:	ff 36                	pushl  (%esi)
  809db5:	e8 f5 dc ff ff       	call   807aaf <ntohl>
  809dba:	88 45 e7             	mov    %al,-0x19(%ebp)
  809dbd:	83 c4 10             	add    $0x10,%esp
    dest = &mcastaddr;
  809dc0:	8d 45 e2             	lea    -0x1e(%ebp),%eax
  809dc3:	eb 05                	jmp    809dca <etharp_output+0xcc>
    dest = (struct eth_addr *)&ethbroadcast;
  809dc5:	b8 04 28 81 00       	mov    $0x812804,%eax
  return etharp_send_ip(netif, q, (struct eth_addr*)(netif->hwaddr), dest);
  809dca:	8d 4b 25             	lea    0x25(%ebx),%ecx
  809dcd:	83 ec 0c             	sub    $0xc,%esp
  809dd0:	50                   	push   %eax
  809dd1:	8b 55 0c             	mov    0xc(%ebp),%edx
  809dd4:	89 d8                	mov    %ebx,%eax
  809dd6:	e8 14 f7 ff ff       	call   8094ef <etharp_send_ip>
  809ddb:	83 c4 10             	add    $0x10,%esp
}
  809dde:	8d 65 f4             	lea    -0xc(%ebp),%esp
  809de1:	5b                   	pop    %ebx
  809de2:	5e                   	pop    %esi
  809de3:	5f                   	pop    %edi
  809de4:	5d                   	pop    %ebp
  809de5:	c3                   	ret    
    return ERR_BUF;
  809de6:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  809deb:	eb f1                	jmp    809dde <etharp_output+0xe0>
        return ERR_RTE;
  809ded:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  809df2:	eb ea                	jmp    809dde <etharp_output+0xe0>

00809df4 <ethernet_input>:
 * @param p the recevied packet, p->payload pointing to the ethernet header
 * @param netif the network interface on which the packet was received
 */
err_t
ethernet_input(struct pbuf *p, struct netif *netif)
{
  809df4:	f3 0f 1e fb          	endbr32 
  809df8:	55                   	push   %ebp
  809df9:	89 e5                	mov    %esp,%ebp
  809dfb:	56                   	push   %esi
  809dfc:	53                   	push   %ebx
  809dfd:	8b 5d 08             	mov    0x8(%ebp),%ebx
  809e00:	8b 75 0c             	mov    0xc(%ebp),%esi
     (unsigned)ethhdr->dest.addr[3], (unsigned)ethhdr->dest.addr[4], (unsigned)ethhdr->dest.addr[5],
     (unsigned)ethhdr->src.addr[0], (unsigned)ethhdr->src.addr[1], (unsigned)ethhdr->src.addr[2],
     (unsigned)ethhdr->src.addr[3], (unsigned)ethhdr->src.addr[4], (unsigned)ethhdr->src.addr[5],
     (unsigned)htons(ethhdr->type)));

  switch (htons(ethhdr->type)) {
  809e03:	83 ec 0c             	sub    $0xc,%esp
  809e06:	8b 43 04             	mov    0x4(%ebx),%eax
  809e09:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  809e0d:	50                   	push   %eax
  809e0e:	e8 4d da ff ff       	call   807860 <htons>
  809e13:	83 c4 10             	add    $0x10,%esp
  809e16:	66 3d 00 08          	cmp    $0x800,%ax
  809e1a:	74 14                	je     809e30 <ethernet_input+0x3c>
  809e1c:	66 3d 06 08          	cmp    $0x806,%ax
  809e20:	74 50                	je     809e72 <ethernet_input+0x7e>
#endif /* PPPOE_SUPPORT */

    default:
      ETHARP_STATS_INC(etharp.proterr);
      ETHARP_STATS_INC(etharp.drop);
      pbuf_free(p);
  809e22:	83 ec 0c             	sub    $0xc,%esp
  809e25:	53                   	push   %ebx
  809e26:	e8 fd aa ff ff       	call   804928 <pbuf_free>
      p = NULL;
      break;
  809e2b:	83 c4 10             	add    $0x10,%esp
  809e2e:	eb 53                	jmp    809e83 <ethernet_input+0x8f>
      etharp_ip_input(netif, p);
  809e30:	83 ec 08             	sub    $0x8,%esp
  809e33:	53                   	push   %ebx
  809e34:	56                   	push   %esi
  809e35:	e8 28 f9 ff ff       	call   809762 <etharp_ip_input>
      if(pbuf_header(p, -(s16_t)sizeof(struct eth_hdr))) {
  809e3a:	83 c4 08             	add    $0x8,%esp
  809e3d:	6a f2                	push   $0xfffffff2
  809e3f:	53                   	push   %ebx
  809e40:	e8 10 aa ff ff       	call   804855 <pbuf_header>
  809e45:	83 c4 10             	add    $0x10,%esp
  809e48:	84 c0                	test   %al,%al
  809e4a:	75 0f                	jne    809e5b <ethernet_input+0x67>
        ip_input(p, netif);
  809e4c:	83 ec 08             	sub    $0x8,%esp
  809e4f:	56                   	push   %esi
  809e50:	53                   	push   %ebx
  809e51:	e8 36 c8 ff ff       	call   80668c <ip_input>
      break;
  809e56:	83 c4 10             	add    $0x10,%esp
  809e59:	eb 28                	jmp    809e83 <ethernet_input+0x8f>
        LWIP_ASSERT("Can't move over header in packet", 0);
  809e5b:	83 ec 04             	sub    $0x4,%esp
  809e5e:	68 d8 27 81 00       	push   $0x8127d8
  809e63:	68 7e 04 00 00       	push   $0x47e
  809e68:	68 9a 26 81 00       	push   $0x81269a
  809e6d:	e8 d5 49 00 00       	call   80e847 <_panic>
      etharp_arp_input(netif, (struct eth_addr*)(netif->hwaddr), p);
  809e72:	83 ec 04             	sub    $0x4,%esp
  809e75:	53                   	push   %ebx
  809e76:	8d 46 25             	lea    0x25(%esi),%eax
  809e79:	50                   	push   %eax
  809e7a:	56                   	push   %esi
  809e7b:	e8 32 f9 ff ff       	call   8097b2 <etharp_arp_input>
      break;
  809e80:	83 c4 10             	add    $0x10,%esp
  }

  /* This means the pbuf is freed or consumed,
     so the caller doesn't have to free it again */
  return ERR_OK;
}
  809e83:	b8 00 00 00 00       	mov    $0x0,%eax
  809e88:	8d 65 f8             	lea    -0x8(%ebp),%esp
  809e8b:	5b                   	pop    %ebx
  809e8c:	5e                   	pop    %esi
  809e8d:	5d                   	pop    %ebp
  809e8e:	c3                   	ret    

00809e8f <lwip_thread_entry>:
    void *arg;
};

static void
lwip_thread_entry(uint32_t arg)
{
  809e8f:	f3 0f 1e fb          	endbr32 
  809e93:	55                   	push   %ebp
  809e94:	89 e5                	mov    %esp,%ebp
  809e96:	53                   	push   %ebx
  809e97:	83 ec 10             	sub    $0x10,%esp
  809e9a:	8b 5d 08             	mov    0x8(%ebp),%ebx
    struct lwip_thread *lt = (struct lwip_thread *)arg;
    lwip_core_lock();
    lt->func(lt->arg);
  809e9d:	ff 73 04             	pushl  0x4(%ebx)
  809ea0:	ff 13                	call   *(%ebx)
    lwip_core_unlock();
    free(lt);
  809ea2:	89 1c 24             	mov    %ebx,(%esp)
  809ea5:	e8 52 68 00 00       	call   8106fc <free>
}
  809eaa:	83 c4 10             	add    $0x10,%esp
  809ead:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  809eb0:	c9                   	leave  
  809eb1:	c3                   	ret    

00809eb2 <timeout_cleanup>:
    return tid;
}

static void
timeout_cleanup(thread_id_t tid)
{
  809eb2:	f3 0f 1e fb          	endbr32 
  809eb6:	55                   	push   %ebp
  809eb7:	89 e5                	mov    %esp,%ebp
  809eb9:	83 ec 08             	sub    $0x8,%esp
  809ebc:	8b 4d 08             	mov    0x8(%ebp),%ecx
    lwip_core_lock();

    struct sys_thread *t;
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  809ebf:	ba 01 ff 00 ff       	mov    $0xff00ff01,%edx
  809ec4:	89 c8                	mov    %ecx,%eax
  809ec6:	f7 e2                	mul    %edx
  809ec8:	89 d0                	mov    %edx,%eax
  809eca:	c1 e8 08             	shr    $0x8,%eax
  809ecd:	b2 00                	mov    $0x0,%dl
  809ecf:	01 c2                	add    %eax,%edx
  809ed1:	89 c8                	mov    %ecx,%eax
  809ed3:	29 d0                	sub    %edx,%eax
  809ed5:	8b 04 85 40 4b b3 00 	mov    0xb34b40(,%eax,4),%eax
  809edc:	85 c0                	test   %eax,%eax
  809ede:	74 2a                	je     809f0a <timeout_cleanup+0x58>
	if (t->tid == tid) {
  809ee0:	39 08                	cmp    %ecx,(%eax)
  809ee2:	74 05                	je     809ee9 <timeout_cleanup+0x37>
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  809ee4:	8b 40 08             	mov    0x8(%eax),%eax
  809ee7:	eb f3                	jmp    809edc <timeout_cleanup+0x2a>
	    LIST_REMOVE(t, link);
  809ee9:	8b 50 08             	mov    0x8(%eax),%edx
  809eec:	85 d2                	test   %edx,%edx
  809eee:	74 06                	je     809ef6 <timeout_cleanup+0x44>
  809ef0:	8b 48 0c             	mov    0xc(%eax),%ecx
  809ef3:	89 4a 0c             	mov    %ecx,0xc(%edx)
  809ef6:	8b 50 0c             	mov    0xc(%eax),%edx
  809ef9:	8b 48 08             	mov    0x8(%eax),%ecx
  809efc:	89 0a                	mov    %ecx,(%edx)
	    free(t);
  809efe:	83 ec 0c             	sub    $0xc,%esp
  809f01:	50                   	push   %eax
  809f02:	e8 f5 67 00 00       	call   8106fc <free>
	    goto done;
  809f07:	83 c4 10             	add    $0x10,%esp
	}

    if (debug) cprintf("timeout_cleanup: bogus tid %ld\n", tid);
 done:
    lwip_core_unlock();
}
  809f0a:	c9                   	leave  
  809f0b:	c3                   	ret    

00809f0c <sys_init>:
{
  809f0c:	f3 0f 1e fb          	endbr32 
  809f10:	55                   	push   %ebp
  809f11:	89 e5                	mov    %esp,%ebp
  809f13:	56                   	push   %esi
  809f14:	53                   	push   %ebx
  809f15:	8b 0d 60 9d b3 00    	mov    0xb39d60,%ecx
  809f1b:	b8 80 9d b3 00       	mov    $0xb39d80,%eax
  809f20:	be 80 b1 b3 00       	mov    $0xb3b180,%esi
  809f25:	eb 0e                	jmp    809f35 <sys_init+0x29>
	LIST_INSERT_HEAD(&sem_free, &sems[i], link);
  809f27:	c7 41 10 60 9d b3 00 	movl   $0xb39d60,0x10(%ecx)
  809f2e:	83 c0 14             	add    $0x14,%eax
    for (i = 0; i < NSEM; i++) {
  809f31:	39 f0                	cmp    %esi,%eax
  809f33:	74 19                	je     809f4e <sys_init+0x42>
  809f35:	89 ca                	mov    %ecx,%edx
  809f37:	89 c1                	mov    %eax,%ecx
	sems[i].freed = 1;
  809f39:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
	LIST_INSERT_HEAD(&sem_free, &sems[i], link);
  809f3f:	89 50 0c             	mov    %edx,0xc(%eax)
  809f42:	85 d2                	test   %edx,%edx
  809f44:	74 e1                	je     809f27 <sys_init+0x1b>
  809f46:	8d 58 0c             	lea    0xc(%eax),%ebx
  809f49:	89 5a 10             	mov    %ebx,0x10(%edx)
  809f4c:	eb d9                	jmp    809f27 <sys_init+0x1b>
  809f4e:	c7 05 60 9d b3 00 6c 	movl   $0xb3b16c,0xb39d60
  809f55:	b1 b3 00 
  809f58:	8b 0d 44 4f b3 00    	mov    0xb34f44,%ecx
  809f5e:	b8 60 4f b3 00       	mov    $0xb34f60,%eax
  809f63:	be 60 9d b3 00       	mov    $0xb39d60,%esi
  809f68:	eb 13                	jmp    809f7d <sys_init+0x71>
	LIST_INSERT_HEAD(&mbox_free, &mboxes[i], link);
  809f6a:	c7 81 98 00 00 00 44 	movl   $0xb34f44,0x98(%ecx)
  809f71:	4f b3 00 
  809f74:	05 9c 00 00 00       	add    $0x9c,%eax
    for (i = 0; i < NMBOX; i++) {
  809f79:	39 f0                	cmp    %esi,%eax
  809f7b:	74 22                	je     809f9f <sys_init+0x93>
  809f7d:	89 ca                	mov    %ecx,%edx
  809f7f:	89 c1                	mov    %eax,%ecx
	mboxes[i].freed = 1;
  809f81:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
	LIST_INSERT_HEAD(&mbox_free, &mboxes[i], link);
  809f87:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
  809f8d:	85 d2                	test   %edx,%edx
  809f8f:	74 d9                	je     809f6a <sys_init+0x5e>
  809f91:	8d 98 94 00 00 00    	lea    0x94(%eax),%ebx
  809f97:	89 9a 98 00 00 00    	mov    %ebx,0x98(%edx)
  809f9d:	eb cb                	jmp    809f6a <sys_init+0x5e>
  809f9f:	c7 05 44 4f b3 00 c4 	movl   $0xb39cc4,0xb34f44
  809fa6:	9c b3 00 
}
  809fa9:	5b                   	pop    %ebx
  809faa:	5e                   	pop    %esi
  809fab:	5d                   	pop    %ebp
  809fac:	c3                   	ret    

00809fad <sys_sem_new>:
{
  809fad:	f3 0f 1e fb          	endbr32 
  809fb1:	55                   	push   %ebp
  809fb2:	89 e5                	mov    %esp,%ebp
  809fb4:	53                   	push   %ebx
  809fb5:	83 ec 04             	sub    $0x4,%esp
  809fb8:	8b 55 08             	mov    0x8(%ebp),%edx
    struct sys_sem_entry *se = LIST_FIRST(&sem_free);
  809fbb:	a1 60 9d b3 00       	mov    0xb39d60,%eax
    if (!se) {
  809fc0:	85 c0                	test   %eax,%eax
  809fc2:	74 3e                	je     80a002 <sys_sem_new+0x55>
    LIST_REMOVE(se, link);
  809fc4:	8b 48 0c             	mov    0xc(%eax),%ecx
  809fc7:	85 c9                	test   %ecx,%ecx
  809fc9:	74 06                	je     809fd1 <sys_sem_new+0x24>
  809fcb:	8b 58 10             	mov    0x10(%eax),%ebx
  809fce:	89 59 10             	mov    %ebx,0x10(%ecx)
  809fd1:	8b 48 10             	mov    0x10(%eax),%ecx
  809fd4:	8b 58 0c             	mov    0xc(%eax),%ebx
  809fd7:	89 19                	mov    %ebx,(%ecx)
    assert(se->freed);
  809fd9:	83 38 00             	cmpl   $0x0,(%eax)
  809fdc:	74 3b                	je     80a019 <sys_sem_new+0x6c>
    se->freed = 0;
  809fde:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    se->counter = count;
  809fe4:	0f b6 d2             	movzbl %dl,%edx
  809fe7:	66 89 50 08          	mov    %dx,0x8(%eax)
    se->gen++;
  809feb:	83 40 04 01          	addl   $0x1,0x4(%eax)
    return se - &sems[0];
  809fef:	2d 80 9d b3 00       	sub    $0xb39d80,%eax
  809ff4:	c1 f8 02             	sar    $0x2,%eax
  809ff7:	69 c0 cd cc cc cc    	imul   $0xcccccccd,%eax,%eax
}
  809ffd:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80a000:	c9                   	leave  
  80a001:	c3                   	ret    
	cprintf("lwip: sys_sem_new: out of semaphores\n");
  80a002:	83 ec 0c             	sub    $0xc,%esp
  80a005:	68 0c 28 81 00       	push   $0x81280c
  80a00a:	e8 1f 49 00 00       	call   80e92e <cprintf>
	return SYS_SEM_NULL;
  80a00f:	83 c4 10             	add    $0x10,%esp
  80a012:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80a017:	eb e4                	jmp    809ffd <sys_sem_new+0x50>
    assert(se->freed);
  80a019:	68 81 29 81 00       	push   $0x812981
  80a01e:	68 8b 29 81 00       	push   $0x81298b
  80a023:	68 8d 00 00 00       	push   $0x8d
  80a028:	68 a0 29 81 00       	push   $0x8129a0
  80a02d:	e8 15 48 00 00       	call   80e847 <_panic>

0080a032 <sys_sem_free>:
{
  80a032:	f3 0f 1e fb          	endbr32 
  80a036:	55                   	push   %ebp
  80a037:	89 e5                	mov    %esp,%ebp
  80a039:	83 ec 08             	sub    $0x8,%esp
  80a03c:	8b 45 08             	mov    0x8(%ebp),%eax
    assert(!sems[sem].freed);
  80a03f:	8d 14 80             	lea    (%eax,%eax,4),%edx
  80a042:	83 3c 95 80 9d b3 00 	cmpl   $0x0,0xb39d80(,%edx,4)
  80a049:	00 
  80a04a:	75 5a                	jne    80a0a6 <sys_sem_free+0x74>
    sems[sem].freed = 1;
  80a04c:	8d 14 80             	lea    (%eax,%eax,4),%edx
  80a04f:	c1 e2 02             	shl    $0x2,%edx
  80a052:	c7 82 80 9d b3 00 01 	movl   $0x1,0xb39d80(%edx)
  80a059:	00 00 00 
    sems[sem].gen++;
  80a05c:	83 82 84 9d b3 00 01 	addl   $0x1,0xb39d84(%edx)
    LIST_INSERT_HEAD(&sem_free, &sems[sem], link);
  80a063:	8b 0d 60 9d b3 00    	mov    0xb39d60,%ecx
  80a069:	89 8a 8c 9d b3 00    	mov    %ecx,0xb39d8c(%edx)
  80a06f:	85 c9                	test   %ecx,%ecx
  80a071:	74 0d                	je     80a080 <sys_sem_free+0x4e>
  80a073:	8d 14 80             	lea    (%eax,%eax,4),%edx
  80a076:	8d 14 95 8c 9d b3 00 	lea    0xb39d8c(,%edx,4),%edx
  80a07d:	89 51 10             	mov    %edx,0x10(%ecx)
  80a080:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  80a087:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
  80a08a:	8d 0c 8d 80 9d b3 00 	lea    0xb39d80(,%ecx,4),%ecx
  80a091:	89 0d 60 9d b3 00    	mov    %ecx,0xb39d60
  80a097:	01 d0                	add    %edx,%eax
  80a099:	c7 04 85 90 9d b3 00 	movl   $0xb39d60,0xb39d90(,%eax,4)
  80a0a0:	60 9d b3 00 
}
  80a0a4:	c9                   	leave  
  80a0a5:	c3                   	ret    
    assert(!sems[sem].freed);
  80a0a6:	68 bd 29 81 00       	push   $0x8129bd
  80a0ab:	68 8b 29 81 00       	push   $0x81298b
  80a0b0:	68 98 00 00 00       	push   $0x98
  80a0b5:	68 a0 29 81 00       	push   $0x8129a0
  80a0ba:	e8 88 47 00 00       	call   80e847 <_panic>

0080a0bf <sys_mbox_free>:
{
  80a0bf:	f3 0f 1e fb          	endbr32 
  80a0c3:	55                   	push   %ebp
  80a0c4:	89 e5                	mov    %esp,%ebp
  80a0c6:	56                   	push   %esi
  80a0c7:	53                   	push   %ebx
  80a0c8:	8b 5d 08             	mov    0x8(%ebp),%ebx
    assert(!mboxes[mbox].freed);
  80a0cb:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80a0d1:	83 b8 60 4f b3 00 00 	cmpl   $0x0,0xb34f60(%eax)
  80a0d8:	75 72                	jne    80a14c <sys_mbox_free+0x8d>
    sys_sem_free(mboxes[mbox].queued_msg);
  80a0da:	83 ec 0c             	sub    $0xc,%esp
  80a0dd:	69 f3 9c 00 00 00    	imul   $0x9c,%ebx,%esi
  80a0e3:	ff b6 ec 4f b3 00    	pushl  0xb34fec(%esi)
  80a0e9:	e8 44 ff ff ff       	call   80a032 <sys_sem_free>
    sys_sem_free(mboxes[mbox].free_msg);
  80a0ee:	83 c4 04             	add    $0x4,%esp
  80a0f1:	ff b6 f0 4f b3 00    	pushl  0xb34ff0(%esi)
  80a0f7:	e8 36 ff ff ff       	call   80a032 <sys_sem_free>
    LIST_INSERT_HEAD(&mbox_free, &mboxes[mbox], link);
  80a0fc:	a1 44 4f b3 00       	mov    0xb34f44,%eax
  80a101:	89 86 f4 4f b3 00    	mov    %eax,0xb34ff4(%esi)
  80a107:	83 c4 10             	add    $0x10,%esp
  80a10a:	85 c0                	test   %eax,%eax
  80a10c:	74 12                	je     80a120 <sys_mbox_free+0x61>
  80a10e:	69 d3 9c 00 00 00    	imul   $0x9c,%ebx,%edx
  80a114:	81 c2 f4 4f b3 00    	add    $0xb34ff4,%edx
  80a11a:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
  80a120:	69 db 9c 00 00 00    	imul   $0x9c,%ebx,%ebx
  80a126:	8d 83 60 4f b3 00    	lea    0xb34f60(%ebx),%eax
  80a12c:	a3 44 4f b3 00       	mov    %eax,0xb34f44
  80a131:	c7 83 f8 4f b3 00 44 	movl   $0xb34f44,0xb34ff8(%ebx)
  80a138:	4f b3 00 
    mboxes[mbox].freed = 1;
  80a13b:	c7 83 60 4f b3 00 01 	movl   $0x1,0xb34f60(%ebx)
  80a142:	00 00 00 
}
  80a145:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80a148:	5b                   	pop    %ebx
  80a149:	5e                   	pop    %esi
  80a14a:	5d                   	pop    %ebp
  80a14b:	c3                   	ret    
    assert(!mboxes[mbox].freed);
  80a14c:	68 ce 29 81 00       	push   $0x8129ce
  80a151:	68 8b 29 81 00       	push   $0x81298b
  80a156:	6a 62                	push   $0x62
  80a158:	68 a0 29 81 00       	push   $0x8129a0
  80a15d:	e8 e5 46 00 00       	call   80e847 <_panic>

0080a162 <sys_mbox_new>:
{
  80a162:	f3 0f 1e fb          	endbr32 
  80a166:	55                   	push   %ebp
  80a167:	89 e5                	mov    %esp,%ebp
  80a169:	57                   	push   %edi
  80a16a:	56                   	push   %esi
  80a16b:	53                   	push   %ebx
  80a16c:	83 ec 0c             	sub    $0xc,%esp
    assert(size < MBOXSLOTS);
  80a16f:	83 7d 08 1f          	cmpl   $0x1f,0x8(%ebp)
  80a173:	0f 8f 9f 00 00 00    	jg     80a218 <sys_mbox_new+0xb6>
    struct sys_mbox_entry *mbe = LIST_FIRST(&mbox_free);
  80a179:	8b 1d 44 4f b3 00    	mov    0xb34f44,%ebx
    if (!mbe) {
  80a17f:	85 db                	test   %ebx,%ebx
  80a181:	0f 84 a7 00 00 00    	je     80a22e <sys_mbox_new+0xcc>
    LIST_REMOVE(mbe, link);
  80a187:	8b 83 94 00 00 00    	mov    0x94(%ebx),%eax
  80a18d:	85 c0                	test   %eax,%eax
  80a18f:	74 0c                	je     80a19d <sys_mbox_new+0x3b>
  80a191:	8b 93 98 00 00 00    	mov    0x98(%ebx),%edx
  80a197:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
  80a19d:	8b 83 98 00 00 00    	mov    0x98(%ebx),%eax
  80a1a3:	8b 93 94 00 00 00    	mov    0x94(%ebx),%edx
  80a1a9:	89 10                	mov    %edx,(%eax)
    assert(mbe->freed);
  80a1ab:	83 3b 00             	cmpl   $0x0,(%ebx)
  80a1ae:	0f 84 91 00 00 00    	je     80a245 <sys_mbox_new+0xe3>
    mbe->freed = 0;
  80a1b4:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
    int i = mbe - &mboxes[0];
  80a1ba:	89 de                	mov    %ebx,%esi
  80a1bc:	81 ee 60 4f b3 00    	sub    $0xb34f60,%esi
  80a1c2:	c1 fe 02             	sar    $0x2,%esi
  80a1c5:	69 f6 97 6f f9 96    	imul   $0x96f96f97,%esi,%esi
  80a1cb:	89 f7                	mov    %esi,%edi
    mbe->head = -1;
  80a1cd:	c7 43 04 ff ff ff ff 	movl   $0xffffffff,0x4(%ebx)
    mbe->nextq = 0;
  80a1d4:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    mbe->queued_msg = sys_sem_new(0);
  80a1db:	83 ec 0c             	sub    $0xc,%esp
  80a1de:	6a 00                	push   $0x0
  80a1e0:	e8 c8 fd ff ff       	call   809fad <sys_sem_new>
  80a1e5:	89 83 8c 00 00 00    	mov    %eax,0x8c(%ebx)
    mbe->free_msg = sys_sem_new(MBOXSLOTS);
  80a1eb:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
  80a1f2:	e8 b6 fd ff ff       	call   809fad <sys_sem_new>
  80a1f7:	89 83 90 00 00 00    	mov    %eax,0x90(%ebx)
    if (mbe->queued_msg == SYS_SEM_NULL ||
  80a1fd:	83 c4 10             	add    $0x10,%esp
  80a200:	83 bb 8c 00 00 00 ff 	cmpl   $0xffffffff,0x8c(%ebx)
  80a207:	74 52                	je     80a25b <sys_mbox_new+0xf9>
  80a209:	83 f8 ff             	cmp    $0xffffffff,%eax
  80a20c:	74 4d                	je     80a25b <sys_mbox_new+0xf9>
}
  80a20e:	89 f8                	mov    %edi,%eax
  80a210:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80a213:	5b                   	pop    %ebx
  80a214:	5e                   	pop    %esi
  80a215:	5f                   	pop    %edi
  80a216:	5d                   	pop    %ebp
  80a217:	c3                   	ret    
    assert(size < MBOXSLOTS);
  80a218:	68 e2 29 81 00       	push   $0x8129e2
  80a21d:	68 8b 29 81 00       	push   $0x81298b
  80a222:	6a 45                	push   $0x45
  80a224:	68 a0 29 81 00       	push   $0x8129a0
  80a229:	e8 19 46 00 00       	call   80e847 <_panic>
	cprintf("lwip: sys_mbox_new: out of mailboxes\n");
  80a22e:	83 ec 0c             	sub    $0xc,%esp
  80a231:	68 34 28 81 00       	push   $0x812834
  80a236:	e8 f3 46 00 00       	call   80e92e <cprintf>
	return SYS_MBOX_NULL;
  80a23b:	83 c4 10             	add    $0x10,%esp
  80a23e:	bf ff ff ff ff       	mov    $0xffffffff,%edi
  80a243:	eb c9                	jmp    80a20e <sys_mbox_new+0xac>
    assert(mbe->freed);
  80a245:	68 f3 29 81 00       	push   $0x8129f3
  80a24a:	68 8b 29 81 00       	push   $0x81298b
  80a24f:	6a 4c                	push   $0x4c
  80a251:	68 a0 29 81 00       	push   $0x8129a0
  80a256:	e8 ec 45 00 00       	call   80e847 <_panic>
	sys_mbox_free(i);
  80a25b:	83 ec 0c             	sub    $0xc,%esp
  80a25e:	56                   	push   %esi
  80a25f:	e8 5b fe ff ff       	call   80a0bf <sys_mbox_free>
	cprintf("lwip: sys_mbox_new: can't get semaphore\n");
  80a264:	c7 04 24 5c 28 81 00 	movl   $0x81285c,(%esp)
  80a26b:	e8 be 46 00 00       	call   80e92e <cprintf>
	return SYS_MBOX_NULL;
  80a270:	83 c4 10             	add    $0x10,%esp
  80a273:	bf ff ff ff ff       	mov    $0xffffffff,%edi
  80a278:	eb 94                	jmp    80a20e <sys_mbox_new+0xac>

0080a27a <sys_sem_signal>:
{
  80a27a:	f3 0f 1e fb          	endbr32 
  80a27e:	55                   	push   %ebp
  80a27f:	89 e5                	mov    %esp,%ebp
  80a281:	83 ec 08             	sub    $0x8,%esp
  80a284:	8b 45 08             	mov    0x8(%ebp),%eax
    assert(!sems[sem].freed);
  80a287:	8d 14 80             	lea    (%eax,%eax,4),%edx
  80a28a:	83 3c 95 80 9d b3 00 	cmpl   $0x0,0xb39d80(,%edx,4)
  80a291:	00 
  80a292:	75 18                	jne    80a2ac <sys_sem_signal+0x32>
    sems[sem].counter++;
  80a294:	8d 14 80             	lea    (%eax,%eax,4),%edx
  80a297:	8d 14 95 80 9d b3 00 	lea    0xb39d80(,%edx,4),%edx
  80a29e:	66 83 42 08 01       	addw   $0x1,0x8(%edx)
    if (sems[sem].waiters) {
  80a2a3:	66 83 7a 0a 00       	cmpw   $0x0,0xa(%edx)
  80a2a8:	75 1b                	jne    80a2c5 <sys_sem_signal+0x4b>
}
  80a2aa:	c9                   	leave  
  80a2ab:	c3                   	ret    
    assert(!sems[sem].freed);
  80a2ac:	68 bd 29 81 00       	push   $0x8129bd
  80a2b1:	68 8b 29 81 00       	push   $0x81298b
  80a2b6:	68 a1 00 00 00       	push   $0xa1
  80a2bb:	68 a0 29 81 00       	push   $0x8129a0
  80a2c0:	e8 82 45 00 00       	call   80e847 <_panic>
	sems[sem].waiters = 0;
  80a2c5:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  80a2cc:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
  80a2cf:	66 c7 04 8d 8a 9d b3 	movw   $0x0,0xb39d8a(,%ecx,4)
  80a2d6:	00 00 00 
	thread_wakeup(&sems[sem].v);
  80a2d9:	83 ec 0c             	sub    $0xc,%esp
  80a2dc:	8d 04 8d 88 9d b3 00 	lea    0xb39d88(,%ecx,4),%eax
  80a2e3:	50                   	push   %eax
  80a2e4:	e8 cf 04 00 00       	call   80a7b8 <thread_wakeup>
  80a2e9:	83 c4 10             	add    $0x10,%esp
}
  80a2ec:	eb bc                	jmp    80a2aa <sys_sem_signal+0x30>

0080a2ee <sys_arch_sem_wait>:
{
  80a2ee:	f3 0f 1e fb          	endbr32 
  80a2f2:	55                   	push   %ebp
  80a2f3:	89 e5                	mov    %esp,%ebp
  80a2f5:	57                   	push   %edi
  80a2f6:	56                   	push   %esi
  80a2f7:	53                   	push   %ebx
  80a2f8:	83 ec 1c             	sub    $0x1c,%esp
  80a2fb:	8b 75 0c             	mov    0xc(%ebp),%esi
    assert(!sems[sem].freed);
  80a2fe:	8b 45 08             	mov    0x8(%ebp),%eax
  80a301:	8d 04 80             	lea    (%eax,%eax,4),%eax
  80a304:	83 3c 85 80 9d b3 00 	cmpl   $0x0,0xb39d80(,%eax,4)
  80a30b:	00 
  80a30c:	75 2c                	jne    80a33a <sys_arch_sem_wait+0x4c>
    int gen = sems[sem].gen;
  80a30e:	8b 45 08             	mov    0x8(%ebp),%eax
  80a311:	c1 e0 02             	shl    $0x2,%eax
  80a314:	89 c2                	mov    %eax,%edx
  80a316:	03 55 08             	add    0x8(%ebp),%edx
  80a319:	8b 1c 95 84 9d b3 00 	mov    0xb39d84(,%edx,4),%ebx
  80a320:	89 5d d8             	mov    %ebx,-0x28(%ebp)
	    thread_wait(&sems[sem].v, cur_v, sleep_until);
  80a323:	8d 04 95 88 9d b3 00 	lea    0xb39d88(,%edx,4),%eax
  80a32a:	89 45 dc             	mov    %eax,-0x24(%ebp)
    u32_t waited = 0;
  80a32d:	bb 00 00 00 00       	mov    $0x0,%ebx
	if (sems[sem].counter > 0) {
  80a332:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    while (tm_msec == 0 || waited < tm_msec) {
  80a335:	e9 80 00 00 00       	jmp    80a3ba <sys_arch_sem_wait+0xcc>
    assert(!sems[sem].freed);
  80a33a:	68 bd 29 81 00       	push   $0x8129bd
  80a33f:	68 8b 29 81 00       	push   $0x81298b
  80a344:	68 ac 00 00 00       	push   $0xac
  80a349:	68 a0 29 81 00       	push   $0x8129a0
  80a34e:	e8 f4 44 00 00       	call   80e847 <_panic>
	if (sems[sem].counter > 0) {
  80a353:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80a356:	0f b7 04 85 88 9d b3 	movzwl 0xb39d88(,%eax,4),%eax
  80a35d:	00 
  80a35e:	66 85 c0             	test   %ax,%ax
  80a361:	75 6e                	jne    80a3d1 <sys_arch_sem_wait+0xe3>
 	} else if (tm_msec == SYS_ARCH_NOWAIT) {
  80a363:	83 fe fe             	cmp    $0xfffffffe,%esi
  80a366:	0f 84 8f 00 00 00    	je     80a3fb <sys_arch_sem_wait+0x10d>
	    uint32_t a = sys_time_msec();
  80a36c:	e8 1a 52 00 00       	call   80f58b <sys_time_msec>
  80a371:	89 c1                	mov    %eax,%ecx
  80a373:	89 45 e0             	mov    %eax,-0x20(%ebp)
	    uint32_t sleep_until = tm_msec ? a + (tm_msec - waited) : ~0;
  80a376:	89 f0                	mov    %esi,%eax
  80a378:	29 d8                	sub    %ebx,%eax
  80a37a:	01 c8                	add    %ecx,%eax
  80a37c:	85 f6                	test   %esi,%esi
  80a37e:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  80a383:	0f 44 c2             	cmove  %edx,%eax
	    sems[sem].waiters = 1;
  80a386:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80a389:	8d 3c 95 80 9d b3 00 	lea    0xb39d80(,%edx,4),%edi
  80a390:	66 c7 47 0a 01 00    	movw   $0x1,0xa(%edi)
	    thread_wait(&sems[sem].v, cur_v, sleep_until);
  80a396:	83 ec 04             	sub    $0x4,%esp
  80a399:	50                   	push   %eax
  80a39a:	ff 77 08             	pushl  0x8(%edi)
  80a39d:	ff 75 dc             	pushl  -0x24(%ebp)
  80a3a0:	e8 3e 06 00 00       	call   80a9e3 <thread_wait>
	    if (gen != sems[sem].gen) {
  80a3a5:	83 c4 10             	add    $0x10,%esp
  80a3a8:	8b 45 d8             	mov    -0x28(%ebp),%eax
  80a3ab:	39 47 04             	cmp    %eax,0x4(%edi)
  80a3ae:	75 34                	jne    80a3e4 <sys_arch_sem_wait+0xf6>
	    uint32_t b = sys_time_msec();
  80a3b0:	e8 d6 51 00 00       	call   80f58b <sys_time_msec>
	    waited += (b - a);
  80a3b5:	2b 45 e0             	sub    -0x20(%ebp),%eax
  80a3b8:	01 c3                	add    %eax,%ebx
    while (tm_msec == 0 || waited < tm_msec) {
  80a3ba:	85 f6                	test   %esi,%esi
  80a3bc:	74 95                	je     80a353 <sys_arch_sem_wait+0x65>
  80a3be:	39 f3                	cmp    %esi,%ebx
  80a3c0:	72 91                	jb     80a353 <sys_arch_sem_wait+0x65>
    return SYS_ARCH_TIMEOUT;
  80a3c2:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
}
  80a3c7:	89 d8                	mov    %ebx,%eax
  80a3c9:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80a3cc:	5b                   	pop    %ebx
  80a3cd:	5e                   	pop    %esi
  80a3ce:	5f                   	pop    %edi
  80a3cf:	5d                   	pop    %ebp
  80a3d0:	c3                   	ret    
	    sems[sem].counter--;
  80a3d1:	8b 55 08             	mov    0x8(%ebp),%edx
  80a3d4:	8d 14 92             	lea    (%edx,%edx,4),%edx
  80a3d7:	83 e8 01             	sub    $0x1,%eax
  80a3da:	66 89 04 95 88 9d b3 	mov    %ax,0xb39d88(,%edx,4)
  80a3e1:	00 
	    return waited;
  80a3e2:	eb e3                	jmp    80a3c7 <sys_arch_sem_wait+0xd9>
		cprintf("sys_arch_sem_wait: sem freed under waiter!\n");
  80a3e4:	83 ec 0c             	sub    $0xc,%esp
  80a3e7:	68 88 28 81 00       	push   $0x812888
  80a3ec:	e8 3d 45 00 00       	call   80e92e <cprintf>
		return SYS_ARCH_TIMEOUT;
  80a3f1:	83 c4 10             	add    $0x10,%esp
  80a3f4:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
  80a3f9:	eb cc                	jmp    80a3c7 <sys_arch_sem_wait+0xd9>
	    return SYS_ARCH_TIMEOUT;
  80a3fb:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
  80a400:	eb c5                	jmp    80a3c7 <sys_arch_sem_wait+0xd9>

0080a402 <sys_mbox_trypost>:
{
  80a402:	f3 0f 1e fb          	endbr32 
  80a406:	55                   	push   %ebp
  80a407:	89 e5                	mov    %esp,%ebp
  80a409:	57                   	push   %edi
  80a40a:	56                   	push   %esi
  80a40b:	53                   	push   %ebx
  80a40c:	83 ec 0c             	sub    $0xc,%esp
  80a40f:	8b 5d 08             	mov    0x8(%ebp),%ebx
    assert(!mboxes[mbox].freed);
  80a412:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80a418:	83 b8 60 4f b3 00 00 	cmpl   $0x0,0xb34f60(%eax)
  80a41f:	75 7f                	jne    80a4a0 <sys_mbox_trypost+0x9e>
    sys_arch_sem_wait(mboxes[mbox].free_msg, 0);
  80a421:	83 ec 08             	sub    $0x8,%esp
  80a424:	6a 00                	push   $0x0
  80a426:	69 f3 9c 00 00 00    	imul   $0x9c,%ebx,%esi
  80a42c:	ff b6 f0 4f b3 00    	pushl  0xb34ff0(%esi)
  80a432:	e8 b7 fe ff ff       	call   80a2ee <sys_arch_sem_wait>
    if (mboxes[mbox].nextq == mboxes[mbox].head)
  80a437:	8b 96 68 4f b3 00    	mov    0xb34f68(%esi),%edx
  80a43d:	8b 8e 64 4f b3 00    	mov    0xb34f64(%esi),%ecx
  80a443:	83 c4 10             	add    $0x10,%esp
  80a446:	39 ca                	cmp    %ecx,%edx
  80a448:	74 7a                	je     80a4c4 <sys_mbox_trypost+0xc2>
    mboxes[mbox].nextq = (slot + 1) % MBOXSLOTS;
  80a44a:	69 f3 9c 00 00 00    	imul   $0x9c,%ebx,%esi
  80a450:	8d 42 01             	lea    0x1(%edx),%eax
  80a453:	89 c7                	mov    %eax,%edi
  80a455:	c1 ff 1f             	sar    $0x1f,%edi
  80a458:	c1 ef 1b             	shr    $0x1b,%edi
  80a45b:	01 f8                	add    %edi,%eax
  80a45d:	83 e0 1f             	and    $0x1f,%eax
  80a460:	29 f8                	sub    %edi,%eax
  80a462:	89 86 68 4f b3 00    	mov    %eax,0xb34f68(%esi)
    mboxes[mbox].msg[slot] = msg;
  80a468:	6b c3 27             	imul   $0x27,%ebx,%eax
  80a46b:	01 d0                	add    %edx,%eax
  80a46d:	8b 75 0c             	mov    0xc(%ebp),%esi
  80a470:	89 34 85 6c 4f b3 00 	mov    %esi,0xb34f6c(,%eax,4)
    if (mboxes[mbox].head == -1)
  80a477:	83 f9 ff             	cmp    $0xffffffff,%ecx
  80a47a:	74 3a                	je     80a4b6 <sys_mbox_trypost+0xb4>
    sys_sem_signal(mboxes[mbox].queued_msg);
  80a47c:	83 ec 0c             	sub    $0xc,%esp
  80a47f:	69 db 9c 00 00 00    	imul   $0x9c,%ebx,%ebx
  80a485:	ff b3 ec 4f b3 00    	pushl  0xb34fec(%ebx)
  80a48b:	e8 ea fd ff ff       	call   80a27a <sys_sem_signal>
    return ERR_OK;
  80a490:	83 c4 10             	add    $0x10,%esp
  80a493:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80a498:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80a49b:	5b                   	pop    %ebx
  80a49c:	5e                   	pop    %esi
  80a49d:	5f                   	pop    %edi
  80a49e:	5d                   	pop    %ebp
  80a49f:	c3                   	ret    
    assert(!mboxes[mbox].freed);
  80a4a0:	68 ce 29 81 00       	push   $0x8129ce
  80a4a5:	68 8b 29 81 00       	push   $0x81298b
  80a4aa:	6a 72                	push   $0x72
  80a4ac:	68 a0 29 81 00       	push   $0x8129a0
  80a4b1:	e8 91 43 00 00       	call   80e847 <_panic>
	mboxes[mbox].head = slot;
  80a4b6:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80a4bc:	89 90 64 4f b3 00    	mov    %edx,0xb34f64(%eax)
  80a4c2:	eb b8                	jmp    80a47c <sys_mbox_trypost+0x7a>
	return ERR_MEM;
  80a4c4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80a4c9:	eb cd                	jmp    80a498 <sys_mbox_trypost+0x96>

0080a4cb <sys_mbox_post>:
{
  80a4cb:	f3 0f 1e fb          	endbr32 
  80a4cf:	55                   	push   %ebp
  80a4d0:	89 e5                	mov    %esp,%ebp
  80a4d2:	83 ec 10             	sub    $0x10,%esp
    assert(sys_mbox_trypost(mbox, msg) == ERR_OK);
  80a4d5:	ff 75 0c             	pushl  0xc(%ebp)
  80a4d8:	ff 75 08             	pushl  0x8(%ebp)
  80a4db:	e8 22 ff ff ff       	call   80a402 <sys_mbox_trypost>
  80a4e0:	83 c4 10             	add    $0x10,%esp
  80a4e3:	84 c0                	test   %al,%al
  80a4e5:	75 02                	jne    80a4e9 <sys_mbox_post+0x1e>
}
  80a4e7:	c9                   	leave  
  80a4e8:	c3                   	ret    
    assert(sys_mbox_trypost(mbox, msg) == ERR_OK);
  80a4e9:	68 b4 28 81 00       	push   $0x8128b4
  80a4ee:	68 8b 29 81 00       	push   $0x81298b
  80a4f3:	6a 6c                	push   $0x6c
  80a4f5:	68 a0 29 81 00       	push   $0x8129a0
  80a4fa:	e8 48 43 00 00       	call   80e847 <_panic>

0080a4ff <sys_arch_mbox_fetch>:
{
  80a4ff:	f3 0f 1e fb          	endbr32 
  80a503:	55                   	push   %ebp
  80a504:	89 e5                	mov    %esp,%ebp
  80a506:	57                   	push   %edi
  80a507:	56                   	push   %esi
  80a508:	53                   	push   %ebx
  80a509:	83 ec 0c             	sub    $0xc,%esp
  80a50c:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80a50f:	8b 7d 0c             	mov    0xc(%ebp),%edi
    assert(!mboxes[mbox].freed);
  80a512:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80a518:	83 b8 60 4f b3 00 00 	cmpl   $0x0,0xb34f60(%eax)
  80a51f:	0f 85 8a 00 00 00    	jne    80a5af <sys_arch_mbox_fetch+0xb0>
    u32_t waited = sys_arch_sem_wait(mboxes[mbox].queued_msg, tm_msec);
  80a525:	83 ec 08             	sub    $0x8,%esp
  80a528:	ff 75 10             	pushl  0x10(%ebp)
  80a52b:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80a531:	ff b0 ec 4f b3 00    	pushl  0xb34fec(%eax)
  80a537:	e8 b2 fd ff ff       	call   80a2ee <sys_arch_sem_wait>
  80a53c:	89 c6                	mov    %eax,%esi
    if (waited == SYS_ARCH_TIMEOUT)
  80a53e:	83 c4 10             	add    $0x10,%esp
  80a541:	83 f8 ff             	cmp    $0xffffffff,%eax
  80a544:	74 5f                	je     80a5a5 <sys_arch_mbox_fetch+0xa6>
    int slot = mboxes[mbox].head;
  80a546:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80a54c:	8b 80 64 4f b3 00    	mov    0xb34f64(%eax),%eax
    if (slot == -1)
  80a552:	83 f8 ff             	cmp    $0xffffffff,%eax
  80a555:	74 71                	je     80a5c8 <sys_arch_mbox_fetch+0xc9>
    if (msg)
  80a557:	85 ff                	test   %edi,%edi
  80a559:	74 0e                	je     80a569 <sys_arch_mbox_fetch+0x6a>
	*msg = mboxes[mbox].msg[slot];
  80a55b:	6b d3 27             	imul   $0x27,%ebx,%edx
  80a55e:	01 c2                	add    %eax,%edx
  80a560:	8b 14 95 6c 4f b3 00 	mov    0xb34f6c(,%edx,4),%edx
  80a567:	89 17                	mov    %edx,(%edi)
    mboxes[mbox].head = (slot + 1) % MBOXSLOTS;
  80a569:	83 c0 01             	add    $0x1,%eax
  80a56c:	99                   	cltd   
  80a56d:	c1 ea 1b             	shr    $0x1b,%edx
  80a570:	01 d0                	add    %edx,%eax
  80a572:	83 e0 1f             	and    $0x1f,%eax
  80a575:	29 d0                	sub    %edx,%eax
  80a577:	69 d3 9c 00 00 00    	imul   $0x9c,%ebx,%edx
  80a57d:	89 82 64 4f b3 00    	mov    %eax,0xb34f64(%edx)
  80a583:	81 c2 60 4f b3 00    	add    $0xb34f60,%edx
    if (mboxes[mbox].head == mboxes[mbox].nextq)
  80a589:	3b 42 08             	cmp    0x8(%edx),%eax
  80a58c:	74 51                	je     80a5df <sys_arch_mbox_fetch+0xe0>
    sys_sem_signal(mboxes[mbox].free_msg);
  80a58e:	83 ec 0c             	sub    $0xc,%esp
  80a591:	69 db 9c 00 00 00    	imul   $0x9c,%ebx,%ebx
  80a597:	ff b3 f0 4f b3 00    	pushl  0xb34ff0(%ebx)
  80a59d:	e8 d8 fc ff ff       	call   80a27a <sys_sem_signal>
    return waited;
  80a5a2:	83 c4 10             	add    $0x10,%esp
}
  80a5a5:	89 f0                	mov    %esi,%eax
  80a5a7:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80a5aa:	5b                   	pop    %ebx
  80a5ab:	5e                   	pop    %esi
  80a5ac:	5f                   	pop    %edi
  80a5ad:	5d                   	pop    %ebp
  80a5ae:	c3                   	ret    
    assert(!mboxes[mbox].freed);
  80a5af:	68 ce 29 81 00       	push   $0x8129ce
  80a5b4:	68 8b 29 81 00       	push   $0x81298b
  80a5b9:	68 ce 00 00 00       	push   $0xce
  80a5be:	68 a0 29 81 00       	push   $0x8129a0
  80a5c3:	e8 7f 42 00 00       	call   80e847 <_panic>
	panic("lwip: sys_arch_mbox_fetch: no message");
  80a5c8:	83 ec 04             	sub    $0x4,%esp
  80a5cb:	68 dc 28 81 00       	push   $0x8128dc
  80a5d0:	68 d6 00 00 00       	push   $0xd6
  80a5d5:	68 a0 29 81 00       	push   $0x8129a0
  80a5da:	e8 68 42 00 00       	call   80e847 <_panic>
	mboxes[mbox].head = -1;
  80a5df:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80a5e5:	c7 80 64 4f b3 00 ff 	movl   $0xffffffff,0xb34f64(%eax)
  80a5ec:	ff ff ff 
  80a5ef:	eb 9d                	jmp    80a58e <sys_arch_mbox_fetch+0x8f>

0080a5f1 <sys_arch_mbox_tryfetch>:
{
  80a5f1:	f3 0f 1e fb          	endbr32 
  80a5f5:	55                   	push   %ebp
  80a5f6:	89 e5                	mov    %esp,%ebp
  80a5f8:	83 ec 0c             	sub    $0xc,%esp
    return sys_arch_mbox_fetch(mbox, msg, SYS_ARCH_NOWAIT);
  80a5fb:	6a fe                	push   $0xfffffffe
  80a5fd:	ff 75 0c             	pushl  0xc(%ebp)
  80a600:	ff 75 08             	pushl  0x8(%ebp)
  80a603:	e8 f7 fe ff ff       	call   80a4ff <sys_arch_mbox_fetch>
}
  80a608:	c9                   	leave  
  80a609:	c3                   	ret    

0080a60a <sys_thread_new>:
{
  80a60a:	f3 0f 1e fb          	endbr32 
  80a60e:	55                   	push   %ebp
  80a60f:	89 e5                	mov    %esp,%ebp
  80a611:	83 ec 24             	sub    $0x24,%esp
    struct lwip_thread *lt = malloc(sizeof(*lt));
  80a614:	6a 08                	push   $0x8
  80a616:	e8 91 61 00 00       	call   8107ac <malloc>
    if (lt == 0)
  80a61b:	83 c4 10             	add    $0x10,%esp
  80a61e:	85 c0                	test   %eax,%eax
  80a620:	74 32                	je     80a654 <sys_thread_new+0x4a>
    if (stacksize > PGSIZE)
  80a622:	81 7d 14 00 10 00 00 	cmpl   $0x1000,0x14(%ebp)
  80a629:	7f 40                	jg     80a66b <sys_thread_new+0x61>
    lt->func = thread;
  80a62b:	8b 55 0c             	mov    0xc(%ebp),%edx
  80a62e:	89 10                	mov    %edx,(%eax)
    lt->arg = arg;
  80a630:	8b 55 10             	mov    0x10(%ebp),%edx
  80a633:	89 50 04             	mov    %edx,0x4(%eax)
    int r = thread_create(&tid, name, lwip_thread_entry, (uint32_t)lt);
  80a636:	50                   	push   %eax
  80a637:	68 8f 9e 80 00       	push   $0x809e8f
  80a63c:	ff 75 08             	pushl  0x8(%ebp)
  80a63f:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80a642:	50                   	push   %eax
  80a643:	e8 e7 01 00 00       	call   80a82f <thread_create>
    if (r < 0)
  80a648:	83 c4 10             	add    $0x10,%esp
  80a64b:	85 c0                	test   %eax,%eax
  80a64d:	78 33                	js     80a682 <sys_thread_new+0x78>
}
  80a64f:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80a652:	c9                   	leave  
  80a653:	c3                   	ret    
	panic("sys_thread_new: cannot allocate thread struct");
  80a654:	83 ec 04             	sub    $0x4,%esp
  80a657:	68 04 29 81 00       	push   $0x812904
  80a65c:	68 fd 00 00 00       	push   $0xfd
  80a661:	68 a0 29 81 00       	push   $0x8129a0
  80a666:	e8 dc 41 00 00       	call   80e847 <_panic>
	panic("large stack %d", stacksize);
  80a66b:	ff 75 14             	pushl  0x14(%ebp)
  80a66e:	68 fe 29 81 00       	push   $0x8129fe
  80a673:	68 00 01 00 00       	push   $0x100
  80a678:	68 a0 29 81 00       	push   $0x8129a0
  80a67d:	e8 c5 41 00 00       	call   80e847 <_panic>
	panic("lwip: sys_thread_new: cannot create: %s\n", e2s(r));
  80a682:	83 ec 0c             	sub    $0xc,%esp
  80a685:	50                   	push   %eax
  80a686:	e8 f2 04 00 00       	call   80ab7d <e2s>
  80a68b:	50                   	push   %eax
  80a68c:	68 34 29 81 00       	push   $0x812934
  80a691:	68 09 01 00 00       	push   $0x109
  80a696:	68 a0 29 81 00       	push   $0x8129a0
  80a69b:	e8 a7 41 00 00       	call   80e847 <_panic>

0080a6a0 <sys_arch_timeouts>:

struct sys_timeouts *
sys_arch_timeouts(void)
{
  80a6a0:	f3 0f 1e fb          	endbr32 
  80a6a4:	55                   	push   %ebp
  80a6a5:	89 e5                	mov    %esp,%ebp
  80a6a7:	57                   	push   %edi
  80a6a8:	56                   	push   %esi
  80a6a9:	53                   	push   %ebx
  80a6aa:	83 ec 0c             	sub    $0xc,%esp
    thread_id_t tid = thread_id();
  80a6ad:	e8 fa 00 00 00       	call   80a7ac <thread_id>
  80a6b2:	89 c6                	mov    %eax,%esi

    struct sys_thread *t;
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  80a6b4:	ba 01 ff 00 ff       	mov    $0xff00ff01,%edx
  80a6b9:	f7 e2                	mul    %edx
  80a6bb:	89 d7                	mov    %edx,%edi
  80a6bd:	c1 ef 08             	shr    $0x8,%edi
  80a6c0:	b2 00                	mov    $0x0,%dl
  80a6c2:	01 d7                	add    %edx,%edi
  80a6c4:	89 f0                	mov    %esi,%eax
  80a6c6:	29 f8                	sub    %edi,%eax
  80a6c8:	89 c7                	mov    %eax,%edi
  80a6ca:	8b 1c 85 40 4b b3 00 	mov    0xb34b40(,%eax,4),%ebx
  80a6d1:	85 db                	test   %ebx,%ebx
  80a6d3:	74 09                	je     80a6de <sys_arch_timeouts+0x3e>
	if (t->tid == tid)
  80a6d5:	39 33                	cmp    %esi,(%ebx)
  80a6d7:	74 66                	je     80a73f <sys_arch_timeouts+0x9f>
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  80a6d9:	8b 5b 08             	mov    0x8(%ebx),%ebx
  80a6dc:	eb f3                	jmp    80a6d1 <sys_arch_timeouts+0x31>
	    goto out;

    t = malloc(sizeof(*t));
  80a6de:	83 ec 0c             	sub    $0xc,%esp
  80a6e1:	6a 10                	push   $0x10
  80a6e3:	e8 c4 60 00 00       	call   8107ac <malloc>
  80a6e8:	89 c3                	mov    %eax,%ebx
    if (t == 0)
  80a6ea:	83 c4 10             	add    $0x10,%esp
  80a6ed:	85 c0                	test   %eax,%eax
  80a6ef:	74 59                	je     80a74a <sys_arch_timeouts+0xaa>
	panic("sys_arch_timeouts: cannot malloc");

    int r = thread_onhalt(timeout_cleanup);
  80a6f1:	83 ec 0c             	sub    $0xc,%esp
  80a6f4:	68 b2 9e 80 00       	push   $0x809eb2
  80a6f9:	e8 03 01 00 00       	call   80a801 <thread_onhalt>
    if (r < 0)
  80a6fe:	83 c4 10             	add    $0x10,%esp
  80a701:	85 c0                	test   %eax,%eax
  80a703:	78 5c                	js     80a761 <sys_arch_timeouts+0xc1>
	panic("thread_onhalt failed: %s", e2s(r));

    t->tid = tid;
  80a705:	89 33                	mov    %esi,(%ebx)
    memset(&t->tmo, 0, sizeof(t->tmo));
  80a707:	83 ec 04             	sub    $0x4,%esp
  80a70a:	6a 04                	push   $0x4
  80a70c:	6a 00                	push   $0x0
  80a70e:	8d 43 04             	lea    0x4(%ebx),%eax
  80a711:	50                   	push   %eax
  80a712:	e8 8b 49 00 00       	call   80f0a2 <memset>
    LIST_INSERT_HEAD(&threads[tid % thread_hash_size], t, link);
  80a717:	8b 04 bd 40 4b b3 00 	mov    0xb34b40(,%edi,4),%eax
  80a71e:	89 43 08             	mov    %eax,0x8(%ebx)
  80a721:	83 c4 10             	add    $0x10,%esp
  80a724:	85 c0                	test   %eax,%eax
  80a726:	74 06                	je     80a72e <sys_arch_timeouts+0x8e>
  80a728:	8d 53 08             	lea    0x8(%ebx),%edx
  80a72b:	89 50 0c             	mov    %edx,0xc(%eax)
  80a72e:	89 1c bd 40 4b b3 00 	mov    %ebx,0xb34b40(,%edi,4)
  80a735:	8d 04 bd 40 4b b3 00 	lea    0xb34b40(,%edi,4),%eax
  80a73c:	89 43 0c             	mov    %eax,0xc(%ebx)

out:
    return &t->tmo;
  80a73f:	8d 43 04             	lea    0x4(%ebx),%eax
}
  80a742:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80a745:	5b                   	pop    %ebx
  80a746:	5e                   	pop    %esi
  80a747:	5f                   	pop    %edi
  80a748:	5d                   	pop    %ebp
  80a749:	c3                   	ret    
	panic("sys_arch_timeouts: cannot malloc");
  80a74a:	83 ec 04             	sub    $0x4,%esp
  80a74d:	68 60 29 81 00       	push   $0x812960
  80a752:	68 2c 01 00 00       	push   $0x12c
  80a757:	68 a0 29 81 00       	push   $0x8129a0
  80a75c:	e8 e6 40 00 00       	call   80e847 <_panic>
	panic("thread_onhalt failed: %s", e2s(r));
  80a761:	83 ec 0c             	sub    $0xc,%esp
  80a764:	50                   	push   %eax
  80a765:	e8 13 04 00 00       	call   80ab7d <e2s>
  80a76a:	50                   	push   %eax
  80a76b:	68 0d 2a 81 00       	push   $0x812a0d
  80a770:	68 30 01 00 00       	push   $0x130
  80a775:	68 a0 29 81 00       	push   $0x8129a0
  80a77a:	e8 c8 40 00 00       	call   80e847 <_panic>

0080a77f <lwip_core_lock>:

void
lwip_core_lock(void)
{
  80a77f:	f3 0f 1e fb          	endbr32 
}
  80a783:	c3                   	ret    

0080a784 <lwip_core_unlock>:

void
lwip_core_unlock(void)
{
  80a784:	f3 0f 1e fb          	endbr32 
}
  80a788:	c3                   	ret    

0080a789 <thread_init>:

static struct thread_queue thread_queue;
static struct thread_queue kill_queue;

void
thread_init(void) {
  80a789:	f3 0f 1e fb          	endbr32 
};

static inline void 
threadq_init(struct thread_queue *tq)
{
    tq->tq_first = 0;
  80a78d:	c7 05 88 b1 b3 00 00 	movl   $0x0,0xb3b188
  80a794:	00 00 00 
    tq->tq_last = 0;
  80a797:	c7 05 8c b1 b3 00 00 	movl   $0x0,0xb3b18c
  80a79e:	00 00 00 
    threadq_init(&thread_queue);
    max_tid = 0;
  80a7a1:	c7 05 94 b1 b3 00 00 	movl   $0x0,0xb3b194
  80a7a8:	00 00 00 
}
  80a7ab:	c3                   	ret    

0080a7ac <thread_id>:

uint32_t
thread_id(void) {
  80a7ac:	f3 0f 1e fb          	endbr32 
    return cur_tc->tc_tid;
  80a7b0:	a1 90 b1 b3 00       	mov    0xb3b190,%eax
  80a7b5:	8b 00                	mov    (%eax),%eax
}
  80a7b7:	c3                   	ret    

0080a7b8 <thread_wakeup>:

void
thread_wakeup(volatile uint32_t *addr) {
  80a7b8:	f3 0f 1e fb          	endbr32 
  80a7bc:	55                   	push   %ebp
  80a7bd:	89 e5                	mov    %esp,%ebp
  80a7bf:	8b 55 08             	mov    0x8(%ebp),%edx
    struct thread_context *tc = thread_queue.tq_first;
  80a7c2:	a1 88 b1 b3 00       	mov    0xb3b188,%eax
    while (tc) {
  80a7c7:	eb 07                	jmp    80a7d0 <thread_wakeup+0x18>
	if (tc->tc_wait_addr == addr)
	    tc->tc_wakeup = 1;
  80a7c9:	c6 40 4c 01          	movb   $0x1,0x4c(%eax)
	tc = tc->tc_queue_link;
  80a7cd:	8b 40 64             	mov    0x64(%eax),%eax
    while (tc) {
  80a7d0:	85 c0                	test   %eax,%eax
  80a7d2:	74 07                	je     80a7db <thread_wakeup+0x23>
	if (tc->tc_wait_addr == addr)
  80a7d4:	39 50 48             	cmp    %edx,0x48(%eax)
  80a7d7:	75 f4                	jne    80a7cd <thread_wakeup+0x15>
  80a7d9:	eb ee                	jmp    80a7c9 <thread_wakeup+0x11>
    }
}
  80a7db:	5d                   	pop    %ebp
  80a7dc:	c3                   	ret    

0080a7dd <thread_wakeups_pending>:
    cur_tc->tc_wakeup = 0;
}

int
thread_wakeups_pending(void)
{
  80a7dd:	f3 0f 1e fb          	endbr32 
    struct thread_context *tc = thread_queue.tq_first;
  80a7e1:	a1 88 b1 b3 00       	mov    0xb3b188,%eax
    int n = 0;
  80a7e6:	b9 00 00 00 00       	mov    $0x0,%ecx
    while (tc) {
  80a7eb:	85 c0                	test   %eax,%eax
  80a7ed:	74 0f                	je     80a7fe <thread_wakeups_pending+0x21>
	if (tc->tc_wakeup)
  80a7ef:	0f b6 50 4c          	movzbl 0x4c(%eax),%edx
	    ++n;
  80a7f3:	80 fa 01             	cmp    $0x1,%dl
  80a7f6:	83 d9 ff             	sbb    $0xffffffff,%ecx
	tc = tc->tc_queue_link;
  80a7f9:	8b 40 64             	mov    0x64(%eax),%eax
  80a7fc:	eb ed                	jmp    80a7eb <thread_wakeups_pending+0xe>
    }
    return n;
}
  80a7fe:	89 c8                	mov    %ecx,%eax
  80a800:	c3                   	ret    

0080a801 <thread_onhalt>:

int
thread_onhalt(void (*fun)(thread_id_t)) {
  80a801:	f3 0f 1e fb          	endbr32 
    if (cur_tc->tc_nonhalt >= THREAD_NUM_ONHALT)
  80a805:	a1 90 b1 b3 00       	mov    0xb3b190,%eax
  80a80a:	8b 50 60             	mov    0x60(%eax),%edx
  80a80d:	83 fa 03             	cmp    $0x3,%edx
  80a810:	7f 17                	jg     80a829 <thread_onhalt+0x28>
thread_onhalt(void (*fun)(thread_id_t)) {
  80a812:	55                   	push   %ebp
  80a813:	89 e5                	mov    %esp,%ebp
	return -E_NO_MEM;

    cur_tc->tc_onhalt[cur_tc->tc_nonhalt++] = fun;
  80a815:	8d 4a 01             	lea    0x1(%edx),%ecx
  80a818:	89 48 60             	mov    %ecx,0x60(%eax)
  80a81b:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80a81e:	89 4c 90 50          	mov    %ecx,0x50(%eax,%edx,4)
    return 0;
  80a822:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80a827:	5d                   	pop    %ebp
  80a828:	c3                   	ret    
	return -E_NO_MEM;
  80a829:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
}
  80a82e:	c3                   	ret    

0080a82f <thread_create>:
    thread_halt();
}

int
thread_create(thread_id_t *tid, const char *name, 
		void (*entry)(uint32_t), uint32_t arg) {
  80a82f:	f3 0f 1e fb          	endbr32 
  80a833:	55                   	push   %ebp
  80a834:	89 e5                	mov    %esp,%ebp
  80a836:	57                   	push   %edi
  80a837:	56                   	push   %esi
  80a838:	53                   	push   %ebx
  80a839:	83 ec 18             	sub    $0x18,%esp
  80a83c:	8b 75 08             	mov    0x8(%ebp),%esi
    struct thread_context *tc = malloc(sizeof(struct thread_context));
  80a83f:	6a 68                	push   $0x68
  80a841:	e8 66 5f 00 00       	call   8107ac <malloc>
    if (!tc)
  80a846:	83 c4 10             	add    $0x10,%esp
  80a849:	85 c0                	test   %eax,%eax
  80a84b:	0f 84 04 01 00 00    	je     80a955 <thread_create+0x126>
  80a851:	89 c3                	mov    %eax,%ebx
	return -E_NO_MEM;

    memset(tc, 0, sizeof(struct thread_context));
  80a853:	83 ec 04             	sub    $0x4,%esp
  80a856:	6a 68                	push   $0x68
  80a858:	6a 00                	push   $0x0
  80a85a:	50                   	push   %eax
  80a85b:	e8 42 48 00 00       	call   80f0a2 <memset>
    strncpy(tc->tc_name, name, name_size - 1);
  80a860:	83 c4 0c             	add    $0xc,%esp
  80a863:	6a 1f                	push   $0x1f
  80a865:	ff 75 0c             	pushl  0xc(%ebp)
  80a868:	8d 43 08             	lea    0x8(%ebx),%eax
  80a86b:	50                   	push   %eax
  80a86c:	e8 16 47 00 00       	call   80ef87 <strncpy>
    tc->tc_name[name_size - 1] = 0;
  80a871:	c6 43 27 00          	movb   $0x0,0x27(%ebx)
    int tid = max_tid++;
  80a875:	a1 94 b1 b3 00       	mov    0xb3b194,%eax
  80a87a:	8d 50 01             	lea    0x1(%eax),%edx
  80a87d:	89 15 94 b1 b3 00    	mov    %edx,0xb3b194
    if (max_tid == (uint32_t)~0)
  80a883:	83 c4 10             	add    $0x10,%esp
  80a886:	83 fa ff             	cmp    $0xffffffff,%edx
  80a889:	0f 84 91 00 00 00    	je     80a920 <thread_create+0xf1>
    
    thread_set_name(tc, name);
    tc->tc_tid = alloc_tid();
  80a88f:	89 03                	mov    %eax,(%ebx)

    tc->tc_stack_bottom = malloc(stack_size);
  80a891:	83 ec 0c             	sub    $0xc,%esp
  80a894:	68 00 10 00 00       	push   $0x1000
  80a899:	e8 0e 5f 00 00       	call   8107ac <malloc>
  80a89e:	89 43 04             	mov    %eax,0x4(%ebx)
    if (!tc->tc_stack_bottom) {
  80a8a1:	83 c4 10             	add    $0x10,%esp
  80a8a4:	85 c0                	test   %eax,%eax
  80a8a6:	0f 84 88 00 00 00    	je     80a934 <thread_create+0x105>
	return -E_NO_MEM;
    }

    void *stacktop = tc->tc_stack_bottom + stack_size;
    // Terminate stack unwinding
    stacktop = stacktop - 4;
  80a8ac:	8d b8 fc 0f 00 00    	lea    0xffc(%eax),%edi
    memset(stacktop, 0, 4);
  80a8b2:	83 ec 04             	sub    $0x4,%esp
  80a8b5:	6a 04                	push   $0x4
  80a8b7:	6a 00                	push   $0x0
  80a8b9:	57                   	push   %edi
  80a8ba:	e8 e3 47 00 00       	call   80f0a2 <memset>
    
    memset(&tc->tc_jb, 0, sizeof(tc->tc_jb));
  80a8bf:	83 c4 0c             	add    $0xc,%esp
  80a8c2:	6a 18                	push   $0x18
  80a8c4:	6a 00                	push   $0x0
  80a8c6:	8d 43 30             	lea    0x30(%ebx),%eax
  80a8c9:	50                   	push   %eax
  80a8ca:	e8 d3 47 00 00       	call   80f0a2 <memset>
    tc->tc_jb.jb_esp = (uint32_t)stacktop;
  80a8cf:	89 7b 34             	mov    %edi,0x34(%ebx)
    tc->tc_jb.jb_eip = (uint32_t)&thread_entry;
  80a8d2:	c7 43 30 ec aa 80 00 	movl   $0x80aaec,0x30(%ebx)
    tc->tc_entry = entry;
  80a8d9:	8b 45 10             	mov    0x10(%ebp),%eax
  80a8dc:	89 43 28             	mov    %eax,0x28(%ebx)
    tc->tc_arg = arg;
  80a8df:	8b 45 14             	mov    0x14(%ebp),%eax
  80a8e2:	89 43 2c             	mov    %eax,0x2c(%ebx)
}

static inline void
threadq_push(struct thread_queue *tq, struct thread_context *tc)
{
    tc->tc_queue_link = 0;
  80a8e5:	c7 43 64 00 00 00 00 	movl   $0x0,0x64(%ebx)
    if (!tq->tq_first) {
  80a8ec:	83 c4 10             	add    $0x10,%esp
  80a8ef:	83 3d 88 b1 b3 00 00 	cmpl   $0x0,0xb3b188
  80a8f6:	74 4f                	je     80a947 <thread_create+0x118>
	tq->tq_first = tc;
	tq->tq_last = tc;
    } else {
	tq->tq_last->tc_queue_link = tc;
  80a8f8:	a1 8c b1 b3 00       	mov    0xb3b18c,%eax
  80a8fd:	89 58 64             	mov    %ebx,0x64(%eax)
	tq->tq_last = tc;
  80a900:	89 1d 8c b1 b3 00    	mov    %ebx,0xb3b18c

    threadq_push(&thread_queue, tc);

    if (tid)
	*tid = tc->tc_tid;
    return 0;
  80a906:	b8 00 00 00 00       	mov    $0x0,%eax
    if (tid)
  80a90b:	85 f6                	test   %esi,%esi
  80a90d:	74 09                	je     80a918 <thread_create+0xe9>
	*tid = tc->tc_tid;
  80a90f:	8b 03                	mov    (%ebx),%eax
  80a911:	89 06                	mov    %eax,(%esi)
    return 0;
  80a913:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80a918:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80a91b:	5b                   	pop    %ebx
  80a91c:	5e                   	pop    %esi
  80a91d:	5f                   	pop    %edi
  80a91e:	5d                   	pop    %ebp
  80a91f:	c3                   	ret    
	panic("alloc_tid: no more thread ids");
  80a920:	83 ec 04             	sub    $0x4,%esp
  80a923:	68 26 2a 81 00       	push   $0x812a26
  80a928:	6a 54                	push   $0x54
  80a92a:	68 44 2a 81 00       	push   $0x812a44
  80a92f:	e8 13 3f 00 00       	call   80e847 <_panic>
	free(tc);
  80a934:	83 ec 0c             	sub    $0xc,%esp
  80a937:	53                   	push   %ebx
  80a938:	e8 bf 5d 00 00       	call   8106fc <free>
	return -E_NO_MEM;
  80a93d:	83 c4 10             	add    $0x10,%esp
  80a940:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  80a945:	eb d1                	jmp    80a918 <thread_create+0xe9>
	tq->tq_first = tc;
  80a947:	89 1d 88 b1 b3 00    	mov    %ebx,0xb3b188
	tq->tq_last = tc;
  80a94d:	89 1d 8c b1 b3 00    	mov    %ebx,0xb3b18c
  80a953:	eb b1                	jmp    80a906 <thread_create+0xd7>
	return -E_NO_MEM;
  80a955:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  80a95a:	eb bc                	jmp    80a918 <thread_create+0xe9>

0080a95c <thread_yield>:
    // when yield has no thread to run, it will return here!
    exit();
}

void
thread_yield(void) {
  80a95c:	f3 0f 1e fb          	endbr32 
  80a960:	55                   	push   %ebp
  80a961:	89 e5                	mov    %esp,%ebp
  80a963:	53                   	push   %ebx
  80a964:	83 ec 04             	sub    $0x4,%esp
}

static inline struct thread_context *
threadq_pop(struct thread_queue *tq)
{
    if (!tq->tq_first)
  80a967:	8b 1d 88 b1 b3 00    	mov    0xb3b188,%ebx
  80a96d:	85 db                	test   %ebx,%ebx
  80a96f:	74 2b                	je     80a99c <thread_yield+0x40>
	return 0;

    struct thread_context *tc = tq->tq_first;
    tq->tq_first = tc->tc_queue_link;
  80a971:	8b 43 64             	mov    0x64(%ebx),%eax
  80a974:	a3 88 b1 b3 00       	mov    %eax,0xb3b188
    tc->tc_queue_link = 0;
  80a979:	c7 43 64 00 00 00 00 	movl   $0x0,0x64(%ebx)
    struct thread_context *next_tc = threadq_pop(&thread_queue);

    if (!next_tc)
	return;

    if (cur_tc) {
  80a980:	a1 90 b1 b3 00       	mov    0xb3b190,%eax
  80a985:	85 c0                	test   %eax,%eax
  80a987:	74 3b                	je     80a9c4 <thread_yield+0x68>
	if (jos_setjmp(&cur_tc->tc_jb) != 0)
  80a989:	83 ec 0c             	sub    $0xc,%esp
  80a98c:	83 c0 30             	add    $0x30,%eax
  80a98f:	50                   	push   %eax
  80a990:	e8 7b 01 00 00       	call   80ab10 <jos_setjmp>
  80a995:	83 c4 10             	add    $0x10,%esp
  80a998:	85 c0                	test   %eax,%eax
  80a99a:	74 05                	je     80a9a1 <thread_yield+0x45>
	threadq_push(&thread_queue, cur_tc);
    }

    cur_tc = next_tc;
    jos_longjmp(&cur_tc->tc_jb, 1);
}
  80a99c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80a99f:	c9                   	leave  
  80a9a0:	c3                   	ret    
	threadq_push(&thread_queue, cur_tc);
  80a9a1:	a1 90 b1 b3 00       	mov    0xb3b190,%eax
    tc->tc_queue_link = 0;
  80a9a6:	c7 40 64 00 00 00 00 	movl   $0x0,0x64(%eax)
    if (!tq->tq_first) {
  80a9ad:	83 3d 88 b1 b3 00 00 	cmpl   $0x0,0xb3b188
  80a9b4:	74 21                	je     80a9d7 <thread_yield+0x7b>
	tq->tq_last->tc_queue_link = tc;
  80a9b6:	8b 15 8c b1 b3 00    	mov    0xb3b18c,%edx
  80a9bc:	89 42 64             	mov    %eax,0x64(%edx)
	tq->tq_last = tc;
  80a9bf:	a3 8c b1 b3 00       	mov    %eax,0xb3b18c
    cur_tc = next_tc;
  80a9c4:	89 1d 90 b1 b3 00    	mov    %ebx,0xb3b190
    jos_longjmp(&cur_tc->tc_jb, 1);
  80a9ca:	8d 43 30             	lea    0x30(%ebx),%eax
  80a9cd:	ba 01 00 00 00       	mov    $0x1,%edx
  80a9d2:	e8 69 01 00 00       	call   80ab40 <jos_longjmp>
	tq->tq_first = tc;
  80a9d7:	a3 88 b1 b3 00       	mov    %eax,0xb3b188
	tq->tq_last = tc;
  80a9dc:	a3 8c b1 b3 00       	mov    %eax,0xb3b18c
  80a9e1:	eb e1                	jmp    80a9c4 <thread_yield+0x68>

0080a9e3 <thread_wait>:
thread_wait(volatile uint32_t *addr, uint32_t val, uint32_t msec) {
  80a9e3:	f3 0f 1e fb          	endbr32 
  80a9e7:	55                   	push   %ebp
  80a9e8:	89 e5                	mov    %esp,%ebp
  80a9ea:	57                   	push   %edi
  80a9eb:	56                   	push   %esi
  80a9ec:	53                   	push   %ebx
  80a9ed:	83 ec 0c             	sub    $0xc,%esp
  80a9f0:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80a9f3:	8b 7d 10             	mov    0x10(%ebp),%edi
    uint32_t s = sys_time_msec();
  80a9f6:	e8 90 4b 00 00       	call   80f58b <sys_time_msec>
  80a9fb:	89 c6                	mov    %eax,%esi
    cur_tc->tc_wait_addr = addr;
  80a9fd:	a1 90 b1 b3 00       	mov    0xb3b190,%eax
  80aa02:	89 58 48             	mov    %ebx,0x48(%eax)
    cur_tc->tc_wakeup = 0;
  80aa05:	c6 40 4c 00          	movb   $0x0,0x4c(%eax)
    uint32_t p = s;
  80aa09:	89 f0                	mov    %esi,%eax
    while (p < msec) {
  80aa0b:	eb 17                	jmp    80aa24 <thread_wait+0x41>
	if (cur_tc->tc_wakeup)
  80aa0d:	a1 90 b1 b3 00       	mov    0xb3b190,%eax
  80aa12:	0f b6 40 4c          	movzbl 0x4c(%eax),%eax
  80aa16:	84 c0                	test   %al,%al
  80aa18:	75 1d                	jne    80aa37 <thread_wait+0x54>
	thread_yield();
  80aa1a:	e8 3d ff ff ff       	call   80a95c <thread_yield>
	p = sys_time_msec();
  80aa1f:	e8 67 4b 00 00       	call   80f58b <sys_time_msec>
	if (p < s)
  80aa24:	39 f0                	cmp    %esi,%eax
  80aa26:	72 0f                	jb     80aa37 <thread_wait+0x54>
  80aa28:	39 f8                	cmp    %edi,%eax
  80aa2a:	73 0b                	jae    80aa37 <thread_wait+0x54>
	if (addr && *addr != val)
  80aa2c:	85 db                	test   %ebx,%ebx
  80aa2e:	74 dd                	je     80aa0d <thread_wait+0x2a>
  80aa30:	8b 03                	mov    (%ebx),%eax
  80aa32:	3b 45 0c             	cmp    0xc(%ebp),%eax
  80aa35:	74 d6                	je     80aa0d <thread_wait+0x2a>
    cur_tc->tc_wait_addr = 0;
  80aa37:	a1 90 b1 b3 00       	mov    0xb3b190,%eax
  80aa3c:	c7 40 48 00 00 00 00 	movl   $0x0,0x48(%eax)
    cur_tc->tc_wakeup = 0;
  80aa43:	c6 40 4c 00          	movb   $0x0,0x4c(%eax)
}
  80aa47:	83 c4 0c             	add    $0xc,%esp
  80aa4a:	5b                   	pop    %ebx
  80aa4b:	5e                   	pop    %esi
  80aa4c:	5f                   	pop    %edi
  80aa4d:	5d                   	pop    %ebp
  80aa4e:	c3                   	ret    

0080aa4f <thread_halt>:
thread_halt() {
  80aa4f:	f3 0f 1e fb          	endbr32 
  80aa53:	55                   	push   %ebp
  80aa54:	89 e5                	mov    %esp,%ebp
  80aa56:	56                   	push   %esi
  80aa57:	53                   	push   %ebx
    if (!tq->tq_first)
  80aa58:	8b 1d 80 b1 b3 00    	mov    0xb3b180,%ebx
  80aa5e:	85 db                	test   %ebx,%ebx
  80aa60:	74 40                	je     80aaa2 <thread_halt+0x53>
    tq->tq_first = tc->tc_queue_link;
  80aa62:	8b 43 64             	mov    0x64(%ebx),%eax
  80aa65:	a3 80 b1 b3 00       	mov    %eax,0xb3b180
    tc->tc_queue_link = 0;
  80aa6a:	c7 43 64 00 00 00 00 	movl   $0x0,0x64(%ebx)
  80aa71:	be 00 00 00 00       	mov    $0x0,%esi
  80aa76:	eb 0f                	jmp    80aa87 <thread_halt+0x38>
	tc->tc_onhalt[i](tc->tc_tid);
  80aa78:	83 ec 0c             	sub    $0xc,%esp
  80aa7b:	ff 33                	pushl  (%ebx)
  80aa7d:	ff 54 b3 50          	call   *0x50(%ebx,%esi,4)
    for (i = 0; i < tc->tc_nonhalt; i++)
  80aa81:	83 c6 01             	add    $0x1,%esi
  80aa84:	83 c4 10             	add    $0x10,%esp
  80aa87:	3b 73 60             	cmp    0x60(%ebx),%esi
  80aa8a:	7c ec                	jl     80aa78 <thread_halt+0x29>
    free(tc->tc_stack_bottom);
  80aa8c:	83 ec 0c             	sub    $0xc,%esp
  80aa8f:	ff 73 04             	pushl  0x4(%ebx)
  80aa92:	e8 65 5c 00 00       	call   8106fc <free>
    free(tc);
  80aa97:	89 1c 24             	mov    %ebx,(%esp)
  80aa9a:	e8 5d 5c 00 00       	call   8106fc <free>
  80aa9f:	83 c4 10             	add    $0x10,%esp
    threadq_push(&kill_queue, cur_tc);
  80aaa2:	a1 90 b1 b3 00       	mov    0xb3b190,%eax
    tc->tc_queue_link = 0;
  80aaa7:	c7 40 64 00 00 00 00 	movl   $0x0,0x64(%eax)
    if (!tq->tq_first) {
  80aaae:	83 3d 80 b1 b3 00 00 	cmpl   $0x0,0xb3b180
  80aab5:	74 29                	je     80aae0 <thread_halt+0x91>
	tq->tq_last->tc_queue_link = tc;
  80aab7:	8b 15 84 b1 b3 00    	mov    0xb3b184,%edx
  80aabd:	89 42 64             	mov    %eax,0x64(%edx)
	tq->tq_last = tc;
  80aac0:	a3 84 b1 b3 00       	mov    %eax,0xb3b184
    cur_tc = NULL;
  80aac5:	c7 05 90 b1 b3 00 00 	movl   $0x0,0xb3b190
  80aacc:	00 00 00 
    thread_yield();
  80aacf:	e8 88 fe ff ff       	call   80a95c <thread_yield>
    exit();
  80aad4:	e8 50 3d 00 00       	call   80e829 <exit>
}
  80aad9:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80aadc:	5b                   	pop    %ebx
  80aadd:	5e                   	pop    %esi
  80aade:	5d                   	pop    %ebp
  80aadf:	c3                   	ret    
	tq->tq_first = tc;
  80aae0:	a3 80 b1 b3 00       	mov    %eax,0xb3b180
	tq->tq_last = tc;
  80aae5:	a3 84 b1 b3 00       	mov    %eax,0xb3b184
  80aaea:	eb d9                	jmp    80aac5 <thread_halt+0x76>

0080aaec <thread_entry>:
thread_entry(void) {
  80aaec:	f3 0f 1e fb          	endbr32 
  80aaf0:	55                   	push   %ebp
  80aaf1:	89 e5                	mov    %esp,%ebp
  80aaf3:	83 ec 14             	sub    $0x14,%esp
    cur_tc->tc_entry(cur_tc->tc_arg);
  80aaf6:	a1 90 b1 b3 00       	mov    0xb3b190,%eax
  80aafb:	ff 70 2c             	pushl  0x2c(%eax)
  80aafe:	ff 50 28             	call   *0x28(%eax)
    thread_halt();
  80ab01:	e8 49 ff ff ff       	call   80aa4f <thread_halt>
}
  80ab06:	83 c4 10             	add    $0x10,%esp
  80ab09:	c9                   	leave  
  80ab0a:	c3                   	ret    
  80ab0b:	66 90                	xchg   %ax,%ax
  80ab0d:	66 90                	xchg   %ax,%ax
  80ab0f:	90                   	nop

0080ab10 <jos_setjmp>:
#define ENTRY(x) \
        .text; _ALIGN_TEXT; .globl x; .type x,@function; x:


ENTRY(jos_setjmp)
	movl	4(%esp), %ecx	// jos_jmp_buf
  80ab10:	8b 4c 24 04          	mov    0x4(%esp),%ecx

	movl	0(%esp), %edx	// %eip as pushed by call
  80ab14:	8b 14 24             	mov    (%esp),%edx
	movl	%edx,  0(%ecx)
  80ab17:	89 11                	mov    %edx,(%ecx)

	leal	4(%esp), %edx	// where %esp will point when we return
  80ab19:	8d 54 24 04          	lea    0x4(%esp),%edx
	movl	%edx,  4(%ecx)
  80ab1d:	89 51 04             	mov    %edx,0x4(%ecx)

	movl	%ebp,  8(%ecx)
  80ab20:	89 69 08             	mov    %ebp,0x8(%ecx)
	movl	%ebx, 12(%ecx)
  80ab23:	89 59 0c             	mov    %ebx,0xc(%ecx)
	movl	%esi, 16(%ecx)
  80ab26:	89 71 10             	mov    %esi,0x10(%ecx)
	movl	%edi, 20(%ecx)
  80ab29:	89 79 14             	mov    %edi,0x14(%ecx)

	movl	$0, %eax
  80ab2c:	b8 00 00 00 00       	mov    $0x0,%eax
	ret
  80ab31:	c3                   	ret    
  80ab32:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  80ab39:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

0080ab40 <jos_longjmp>:

ENTRY(jos_longjmp)
	// %eax is the jos_jmp_buf*
	// %edx is the return value

	movl	 0(%eax), %ecx	// %eip
  80ab40:	8b 08                	mov    (%eax),%ecx
	movl	 4(%eax), %esp
  80ab42:	8b 60 04             	mov    0x4(%eax),%esp
	movl	 8(%eax), %ebp
  80ab45:	8b 68 08             	mov    0x8(%eax),%ebp
	movl	12(%eax), %ebx
  80ab48:	8b 58 0c             	mov    0xc(%eax),%ebx
	movl	16(%eax), %esi
  80ab4b:	8b 70 10             	mov    0x10(%eax),%esi
	movl	20(%eax), %edi
  80ab4e:	8b 78 14             	mov    0x14(%eax),%edi

	movl	%edx, %eax
  80ab51:	89 d0                	mov    %edx,%eax
	jmp	*%ecx
  80ab53:	ff e1                	jmp    *%ecx

0080ab55 <perror>:
  [ENSRQUERYDOMAINTOOLONG] = "ENSRQUERYDOMAINTOOLONG",  /* Domain name is too long */
  [ENSRCNAMELOOP] = "ENSRCNAMELOOP" /* Domain name is too long */
};

void
perror(const char *s) {
  80ab55:	f3 0f 1e fb          	endbr32 
  80ab59:	55                   	push   %ebp
  80ab5a:	89 e5                	mov    %esp,%ebp
  80ab5c:	83 ec 0c             	sub    $0xc,%esp
	cprintf("%s: %s\n", s, e2s(err));
}

const char *
e2s(int err) {
	return sys_errlist[err];
  80ab5f:	a1 e0 b1 b3 00       	mov    0xb3b1e0,%eax
	cprintf("%s: %s\n", s, e2s(err));
  80ab64:	ff 34 85 20 40 81 00 	pushl  0x814020(,%eax,4)
  80ab6b:	ff 75 08             	pushl  0x8(%ebp)
  80ab6e:	68 5f 2a 81 00       	push   $0x812a5f
  80ab73:	e8 b6 3d 00 00       	call   80e92e <cprintf>
}
  80ab78:	83 c4 10             	add    $0x10,%esp
  80ab7b:	c9                   	leave  
  80ab7c:	c3                   	ret    

0080ab7d <e2s>:
e2s(int err) {
  80ab7d:	f3 0f 1e fb          	endbr32 
  80ab81:	55                   	push   %ebp
  80ab82:	89 e5                	mov    %esp,%ebp
	return sys_errlist[err];
  80ab84:	8b 45 08             	mov    0x8(%ebp),%eax
  80ab87:	8b 04 85 20 40 81 00 	mov    0x814020(,%eax,4),%eax
}
  80ab8e:	5d                   	pop    %ebp
  80ab8f:	c3                   	ret    

0080ab90 <low_level_output>:
 * might be chained.
 *
 */
static err_t
low_level_output(struct netif *netif, struct pbuf *p)
{
  80ab90:	f3 0f 1e fb          	endbr32 
  80ab94:	55                   	push   %ebp
  80ab95:	89 e5                	mov    %esp,%ebp
  80ab97:	57                   	push   %edi
  80ab98:	56                   	push   %esi
  80ab99:	53                   	push   %ebx
  80ab9a:	83 ec 20             	sub    $0x20,%esp
  80ab9d:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    int r = sys_page_alloc(0, (void *)PKTMAP, PTE_U|PTE_W|PTE_P);
  80aba0:	6a 07                	push   $0x7
  80aba2:	68 00 00 00 10       	push   $0x10000000
  80aba7:	6a 00                	push   $0x0
  80aba9:	e8 cc 47 00 00       	call   80f37a <sys_page_alloc>
    if (r < 0)
  80abae:	83 c4 10             	add    $0x10,%esp
  80abb1:	85 c0                	test   %eax,%eax
  80abb3:	78 49                	js     80abfe <low_level_output+0x6e>
	panic("jif: could not allocate page of memory");
    struct jif_pkt *pkt = (struct jif_pkt *)PKTMAP;

    struct jif *jif;
    jif = netif->state;
  80abb5:	8b 45 08             	mov    0x8(%ebp),%eax
  80abb8:	8b 40 1c             	mov    0x1c(%eax),%eax
  80abbb:	89 45 e4             	mov    %eax,-0x1c(%ebp)

    char *txbuf = pkt->jp_data;
  80abbe:	bf 04 00 00 10       	mov    $0x10000004,%edi
    int txsize = 0;
  80abc3:	be 00 00 00 00       	mov    $0x0,%esi
    struct pbuf *q;
    for (q = p; q != NULL; q = q->next) {
  80abc8:	85 db                	test   %ebx,%ebx
  80abca:	74 5c                	je     80ac28 <low_level_output+0x98>
	/* Send the data from the pbuf to the interface, one pbuf at a
	   time. The size of the data in each pbuf is kept in the ->len
	   variable. */

	if (txsize + q->len > 2000)
  80abcc:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  80abd0:	0f b7 d0             	movzwl %ax,%edx
  80abd3:	8d 0c 32             	lea    (%edx,%esi,1),%ecx
  80abd6:	81 f9 d0 07 00 00    	cmp    $0x7d0,%ecx
  80abdc:	7f 34                	jg     80ac12 <low_level_output+0x82>
	    panic("oversized packet, fragment %d txsize %d\n", q->len, txsize);
	memcpy(&txbuf[txsize], q->payload, q->len);
  80abde:	83 ec 04             	sub    $0x4,%esp
  80abe1:	0f b7 c0             	movzwl %ax,%eax
  80abe4:	50                   	push   %eax
  80abe5:	ff 73 04             	pushl  0x4(%ebx)
  80abe8:	8d 04 37             	lea    (%edi,%esi,1),%eax
  80abeb:	50                   	push   %eax
  80abec:	e8 63 45 00 00       	call   80f154 <memcpy>
	txsize += q->len;
  80abf1:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  80abf5:	01 c6                	add    %eax,%esi
    for (q = p; q != NULL; q = q->next) {
  80abf7:	8b 1b                	mov    (%ebx),%ebx
  80abf9:	83 c4 10             	add    $0x10,%esp
  80abfc:	eb ca                	jmp    80abc8 <low_level_output+0x38>
	panic("jif: could not allocate page of memory");
  80abfe:	83 ec 04             	sub    $0x4,%esp
  80ac01:	68 44 2f 81 00       	push   $0x812f44
  80ac06:	6a 55                	push   $0x55
  80ac08:	68 95 2f 81 00       	push   $0x812f95
  80ac0d:	e8 35 3c 00 00       	call   80e847 <_panic>
	    panic("oversized packet, fragment %d txsize %d\n", q->len, txsize);
  80ac12:	83 ec 0c             	sub    $0xc,%esp
  80ac15:	56                   	push   %esi
  80ac16:	52                   	push   %edx
  80ac17:	68 6c 2f 81 00       	push   $0x812f6c
  80ac1c:	6a 64                	push   $0x64
  80ac1e:	68 95 2f 81 00       	push   $0x812f95
  80ac23:	e8 1f 3c 00 00       	call   80e847 <_panic>
    }

    pkt->jp_len = txsize;
  80ac28:	89 35 00 00 00 10    	mov    %esi,0x10000000

    ipc_send(jif->envid, NSREQ_OUTPUT, (void *)pkt, PTE_P|PTE_W|PTE_U);
  80ac2e:	6a 07                	push   $0x7
  80ac30:	68 00 00 00 10       	push   $0x10000000
  80ac35:	6a 0b                	push   $0xb
  80ac37:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80ac3a:	ff 70 04             	pushl  0x4(%eax)
  80ac3d:	e8 1e 4d 00 00       	call   80f960 <ipc_send>
    sys_page_unmap(0, (void *)pkt);
  80ac42:	83 c4 08             	add    $0x8,%esp
  80ac45:	68 00 00 00 10       	push   $0x10000000
  80ac4a:	6a 00                	push   $0x0
  80ac4c:	e8 b6 47 00 00       	call   80f407 <sys_page_unmap>

    return ERR_OK;
}
  80ac51:	b8 00 00 00 00       	mov    $0x0,%eax
  80ac56:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80ac59:	5b                   	pop    %ebx
  80ac5a:	5e                   	pop    %esi
  80ac5b:	5f                   	pop    %edi
  80ac5c:	5d                   	pop    %ebp
  80ac5d:	c3                   	ret    

0080ac5e <jif_output>:
 */

static err_t
jif_output(struct netif *netif, struct pbuf *p,
      struct ip_addr *ipaddr)
{
  80ac5e:	f3 0f 1e fb          	endbr32 
  80ac62:	55                   	push   %ebp
  80ac63:	89 e5                	mov    %esp,%ebp
  80ac65:	83 ec 0c             	sub    $0xc,%esp
    /* resolve hardware address, then send (or queue) packet */
    return etharp_output(netif, p, ipaddr);
  80ac68:	ff 75 10             	pushl  0x10(%ebp)
  80ac6b:	ff 75 0c             	pushl  0xc(%ebp)
  80ac6e:	ff 75 08             	pushl  0x8(%ebp)
  80ac71:	e8 88 f0 ff ff       	call   809cfe <etharp_output>
}
  80ac76:	c9                   	leave  
  80ac77:	c3                   	ret    

0080ac78 <jif_input>:
 *
 */

void
jif_input(struct netif *netif, void *va)
{
  80ac78:	f3 0f 1e fb          	endbr32 
  80ac7c:	55                   	push   %ebp
  80ac7d:	89 e5                	mov    %esp,%ebp
  80ac7f:	57                   	push   %edi
  80ac80:	56                   	push   %esi
  80ac81:	53                   	push   %ebx
  80ac82:	83 ec 20             	sub    $0x20,%esp
  80ac85:	8b 7d 0c             	mov    0xc(%ebp),%edi
    struct jif *jif;
    struct eth_hdr *ethhdr;
    struct pbuf *p;

    jif = netif->state;
  80ac88:	8b 45 08             	mov    0x8(%ebp),%eax
  80ac8b:	8b 40 1c             	mov    0x1c(%eax),%eax
  80ac8e:	89 45 d8             	mov    %eax,-0x28(%ebp)
    s16_t len = pkt->jp_len;
  80ac91:	8b 07                	mov    (%edi),%eax
  80ac93:	89 c6                	mov    %eax,%esi
    struct pbuf *p = pbuf_alloc(PBUF_RAW, len, PBUF_POOL);
  80ac95:	6a 03                	push   $0x3
  80ac97:	0f b7 c0             	movzwl %ax,%eax
  80ac9a:	50                   	push   %eax
  80ac9b:	6a 03                	push   $0x3
  80ac9d:	e8 50 9d ff ff       	call   8049f2 <pbuf_alloc>
    if (p == 0)
  80aca2:	83 c4 10             	add    $0x10,%esp
  80aca5:	85 c0                	test   %eax,%eax
  80aca7:	0f 84 9c 00 00 00    	je     80ad49 <jif_input+0xd1>
  80acad:	89 c3                	mov    %eax,%ebx
    void *rxbuf = (void *) pkt->jp_data;
  80acaf:	8d 47 04             	lea    0x4(%edi),%eax
  80acb2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    for (q = p; q != NULL; q = q->next) {
  80acb5:	89 df                	mov    %ebx,%edi
    int copied = 0;
  80acb7:	ba 00 00 00 00       	mov    $0x0,%edx
	if (bytes > (len - copied))
  80acbc:	0f bf c6             	movswl %si,%eax
  80acbf:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80acc2:	89 5d dc             	mov    %ebx,-0x24(%ebp)
  80acc5:	89 d3                	mov    %edx,%ebx
	int bytes = q->len;
  80acc7:	0f b7 47 0a          	movzwl 0xa(%edi),%eax
	if (bytes > (len - copied))
  80accb:	8b 75 e0             	mov    -0x20(%ebp),%esi
  80acce:	29 de                	sub    %ebx,%esi
  80acd0:	39 c6                	cmp    %eax,%esi
  80acd2:	0f 4f f0             	cmovg  %eax,%esi
	memcpy(q->payload, rxbuf + copied, bytes);
  80acd5:	83 ec 04             	sub    $0x4,%esp
  80acd8:	56                   	push   %esi
  80acd9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80acdc:	01 d8                	add    %ebx,%eax
  80acde:	50                   	push   %eax
  80acdf:	ff 77 04             	pushl  0x4(%edi)
  80ace2:	e8 6d 44 00 00       	call   80f154 <memcpy>
	copied += bytes;
  80ace7:	01 f3                	add    %esi,%ebx
    for (q = p; q != NULL; q = q->next) {
  80ace9:	8b 3f                	mov    (%edi),%edi
  80aceb:	83 c4 10             	add    $0x10,%esp
  80acee:	85 ff                	test   %edi,%edi
  80acf0:	75 d5                	jne    80acc7 <jif_input+0x4f>
  80acf2:	8b 5d dc             	mov    -0x24(%ebp),%ebx
    /* no packet could be read, silently ignore this */
    if (p == NULL) return;
    /* points to packet payload, which starts with an Ethernet header */
    ethhdr = p->payload;

    switch (htons(ethhdr->type)) {
  80acf5:	83 ec 0c             	sub    $0xc,%esp
  80acf8:	8b 43 04             	mov    0x4(%ebx),%eax
  80acfb:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80acff:	50                   	push   %eax
  80ad00:	e8 5b cb ff ff       	call   807860 <htons>
  80ad05:	83 c4 10             	add    $0x10,%esp
  80ad08:	66 3d 00 08          	cmp    $0x800,%ax
  80ad0c:	74 14                	je     80ad22 <jif_input+0xaa>
  80ad0e:	66 3d 06 08          	cmp    $0x806,%ax
  80ad12:	74 3d                	je     80ad51 <jif_input+0xd9>
	/* pass p to ARP module  */
	etharp_arp_input(netif, jif->ethaddr, p);
	break;

    default:
	pbuf_free(p);
  80ad14:	83 ec 0c             	sub    $0xc,%esp
  80ad17:	53                   	push   %ebx
  80ad18:	e8 0b 9c ff ff       	call   804928 <pbuf_free>
  80ad1d:	83 c4 10             	add    $0x10,%esp
  80ad20:	eb 27                	jmp    80ad49 <jif_input+0xd1>
	etharp_ip_input(netif, p);
  80ad22:	83 ec 08             	sub    $0x8,%esp
  80ad25:	53                   	push   %ebx
  80ad26:	ff 75 08             	pushl  0x8(%ebp)
  80ad29:	e8 34 ea ff ff       	call   809762 <etharp_ip_input>
	pbuf_header(p, -(int)sizeof(struct eth_hdr));
  80ad2e:	83 c4 08             	add    $0x8,%esp
  80ad31:	6a f2                	push   $0xfffffff2
  80ad33:	53                   	push   %ebx
  80ad34:	e8 1c 9b ff ff       	call   804855 <pbuf_header>
	netif->input(p, netif);
  80ad39:	83 c4 08             	add    $0x8,%esp
  80ad3c:	ff 75 08             	pushl  0x8(%ebp)
  80ad3f:	53                   	push   %ebx
  80ad40:	8b 45 08             	mov    0x8(%ebp),%eax
  80ad43:	ff 50 10             	call   *0x10(%eax)
	break;
  80ad46:	83 c4 10             	add    $0x10,%esp
    }
}
  80ad49:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80ad4c:	5b                   	pop    %ebx
  80ad4d:	5e                   	pop    %esi
  80ad4e:	5f                   	pop    %edi
  80ad4f:	5d                   	pop    %ebp
  80ad50:	c3                   	ret    
	etharp_arp_input(netif, jif->ethaddr, p);
  80ad51:	83 ec 04             	sub    $0x4,%esp
  80ad54:	53                   	push   %ebx
  80ad55:	8b 45 d8             	mov    -0x28(%ebp),%eax
  80ad58:	ff 30                	pushl  (%eax)
  80ad5a:	ff 75 08             	pushl  0x8(%ebp)
  80ad5d:	e8 50 ea ff ff       	call   8097b2 <etharp_arp_input>
	break;
  80ad62:	83 c4 10             	add    $0x10,%esp
  80ad65:	eb e2                	jmp    80ad49 <jif_input+0xd1>

0080ad67 <jif_init>:
 *
 */

err_t
jif_init(struct netif *netif)
{
  80ad67:	f3 0f 1e fb          	endbr32 
  80ad6b:	55                   	push   %ebp
  80ad6c:	89 e5                	mov    %esp,%ebp
  80ad6e:	57                   	push   %edi
  80ad6f:	56                   	push   %esi
  80ad70:	53                   	push   %ebx
  80ad71:	83 ec 28             	sub    $0x28,%esp
  80ad74:	8b 5d 08             	mov    0x8(%ebp),%ebx
    struct jif *jif;
    envid_t *output_envid; 

    jif = mem_malloc(sizeof(struct jif));
  80ad77:	6a 08                	push   $0x8
  80ad79:	e8 6c 95 ff ff       	call   8042ea <mem_malloc>

    if (jif == NULL) {
  80ad7e:	83 c4 10             	add    $0x10,%esp
  80ad81:	85 c0                	test   %eax,%eax
  80ad83:	0f 84 87 00 00 00    	je     80ae10 <jif_init+0xa9>
  80ad89:	89 c6                	mov    %eax,%esi
	LWIP_DEBUGF(NETIF_DEBUG, ("jif_init: out of memory\n"));
	return ERR_MEM;
    }

    output_envid = (envid_t *)netif->state;
  80ad8b:	8b 7b 1c             	mov    0x1c(%ebx),%edi

    netif->state = jif;
  80ad8e:	89 43 1c             	mov    %eax,0x1c(%ebx)
    netif->output = jif_output;
  80ad91:	c7 43 14 5e ac 80 00 	movl   $0x80ac5e,0x14(%ebx)
    netif->linkoutput = low_level_output;
  80ad98:	c7 43 18 90 ab 80 00 	movl   $0x80ab90,0x18(%ebx)
    memcpy(&netif->name[0], "en", 2);
  80ad9f:	83 ec 04             	sub    $0x4,%esp
  80ada2:	6a 02                	push   $0x2
  80ada4:	68 f4 3c 81 00       	push   $0x813cf4
  80ada9:	8d 43 2f             	lea    0x2f(%ebx),%eax
  80adac:	50                   	push   %eax
  80adad:	e8 a2 43 00 00       	call   80f154 <memcpy>

    jif->ethaddr = (struct eth_addr *)&(netif->hwaddr[0]);
  80adb2:	8d 43 25             	lea    0x25(%ebx),%eax
  80adb5:	89 06                	mov    %eax,(%esi)
    jif->envid = *output_envid; 
  80adb7:	8b 07                	mov    (%edi),%eax
  80adb9:	89 46 04             	mov    %eax,0x4(%esi)
    netif->hwaddr_len = 6;
  80adbc:	c6 43 24 06          	movb   $0x6,0x24(%ebx)
    netif->mtu = 1500;
  80adc0:	66 c7 43 2c dc 05    	movw   $0x5dc,0x2c(%ebx)
    netif->flags = NETIF_FLAG_BROADCAST;
  80adc6:	c6 43 2e 02          	movb   $0x2,0x2e(%ebx)
    netif->hwaddr[0] = 0x52;
  80adca:	c6 43 25 52          	movb   $0x52,0x25(%ebx)
    netif->hwaddr[1] = 0x54;
  80adce:	c6 43 26 54          	movb   $0x54,0x26(%ebx)
    netif->hwaddr[2] = 0x00;
  80add2:	c6 43 27 00          	movb   $0x0,0x27(%ebx)
    netif->hwaddr[3] = 0x12;
  80add6:	c6 43 28 12          	movb   $0x12,0x28(%ebx)
    netif->hwaddr[4] = 0x34;
  80adda:	c6 43 29 34          	movb   $0x34,0x29(%ebx)
    netif->hwaddr[5] = 0x56;
  80adde:	c6 43 2a 56          	movb   $0x56,0x2a(%ebx)
    etharp_init();

    // qemu user-net is dumb; if the host OS does not send and ARP request
    // first, the qemu will send packets destined for the host using the mac
    // addr 00:00:00:00:00; do a arp request for the user-net NAT at 10.0.2.2
    uint32_t ipaddr = inet_addr("10.0.2.2");
  80ade2:	c7 04 24 ab 13 81 00 	movl   $0x8113ab,(%esp)
  80ade9:	e8 9b cc ff ff       	call   807a89 <inet_addr>
  80adee:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    etharp_query(netif, (struct ip_addr *) &ipaddr, 0);
  80adf1:	83 c4 0c             	add    $0xc,%esp
  80adf4:	6a 00                	push   $0x0
  80adf6:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80adf9:	50                   	push   %eax
  80adfa:	53                   	push   %ebx
  80adfb:	e8 c6 ec ff ff       	call   809ac6 <etharp_query>

    return ERR_OK;
  80ae00:	83 c4 10             	add    $0x10,%esp
  80ae03:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80ae08:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80ae0b:	5b                   	pop    %ebx
  80ae0c:	5e                   	pop    %esi
  80ae0d:	5f                   	pop    %edi
  80ae0e:	5d                   	pop    %ebp
  80ae0f:	c3                   	ret    
	return ERR_MEM;
  80ae10:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80ae15:	eb f1                	jmp    80ae08 <jif_init+0xa1>

0080ae17 <netconn_new_with_proto_and_callback>:
 * @return a newly allocated struct netconn or
 *         NULL on memory error
 */
struct netconn*
netconn_new_with_proto_and_callback(enum netconn_type t, u8_t proto, netconn_callback callback)
{
  80ae17:	f3 0f 1e fb          	endbr32 
  80ae1b:	55                   	push   %ebp
  80ae1c:	89 e5                	mov    %esp,%ebp
  80ae1e:	56                   	push   %esi
  80ae1f:	53                   	push   %ebx
  80ae20:	83 ec 28             	sub    $0x28,%esp
  80ae23:	8b 75 0c             	mov    0xc(%ebp),%esi
  struct netconn *conn;
  struct api_msg msg;

  conn = netconn_alloc(t, callback);
  80ae26:	ff 75 10             	pushl  0x10(%ebp)
  80ae29:	ff 75 08             	pushl  0x8(%ebp)
  80ae2c:	e8 9b 0f 00 00       	call   80bdcc <netconn_alloc>
  80ae31:	89 c3                	mov    %eax,%ebx
  
  if (conn != NULL ) {
  80ae33:	83 c4 10             	add    $0x10,%esp
  80ae36:	85 c0                	test   %eax,%eax
  80ae38:	74 63                	je     80ae9d <netconn_new_with_proto_and_callback+0x86>
    msg.function = do_newconn;
  80ae3a:	c7 45 e4 bf bc 80 00 	movl   $0x80bcbf,-0x1c(%ebp)
    msg.msg.msg.n.proto = proto;
  80ae41:	89 f0                	mov    %esi,%eax
  80ae43:	88 45 ec             	mov    %al,-0x14(%ebp)
    msg.msg.conn = conn;
  80ae46:	89 5d e8             	mov    %ebx,-0x18(%ebp)
    TCPIP_APIMSG(&msg);
  80ae49:	83 ec 0c             	sub    $0xc,%esp
  80ae4c:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80ae4f:	50                   	push   %eax
  80ae50:	e8 af 75 ff ff       	call   802404 <tcpip_apimsg>

    if (conn->err != ERR_OK) {
  80ae55:	83 c4 10             	add    $0x10,%esp
  80ae58:	80 7b 0c 00          	cmpb   $0x0,0xc(%ebx)
  80ae5c:	74 3f                	je     80ae9d <netconn_new_with_proto_and_callback+0x86>
      LWIP_ASSERT("freeing conn without freeing pcb", conn->pcb.tcp == NULL);
  80ae5e:	8b 73 08             	mov    0x8(%ebx),%esi
  80ae61:	85 f6                	test   %esi,%esi
  80ae63:	75 41                	jne    80aea6 <netconn_new_with_proto_and_callback+0x8f>
      LWIP_ASSERT("conn has no op_completed", conn->op_completed != SYS_SEM_NULL);
  80ae65:	8b 43 10             	mov    0x10(%ebx),%eax
  80ae68:	83 f8 ff             	cmp    $0xffffffff,%eax
  80ae6b:	74 4d                	je     80aeba <netconn_new_with_proto_and_callback+0xa3>
      LWIP_ASSERT("conn has no recvmbox", conn->recvmbox != SYS_MBOX_NULL);
  80ae6d:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80ae71:	74 5b                	je     80aece <netconn_new_with_proto_and_callback+0xb7>
      LWIP_ASSERT("conn->acceptmbox shouldn't exist", conn->acceptmbox == SYS_MBOX_NULL);
  80ae73:	83 7b 18 ff          	cmpl   $0xffffffff,0x18(%ebx)
  80ae77:	75 69                	jne    80aee2 <netconn_new_with_proto_and_callback+0xcb>
      sys_sem_free(conn->op_completed);
  80ae79:	83 ec 0c             	sub    $0xc,%esp
  80ae7c:	50                   	push   %eax
  80ae7d:	e8 b0 f1 ff ff       	call   80a032 <sys_sem_free>
      sys_mbox_free(conn->recvmbox);
  80ae82:	83 c4 04             	add    $0x4,%esp
  80ae85:	ff 73 14             	pushl  0x14(%ebx)
  80ae88:	e8 32 f2 ff ff       	call   80a0bf <sys_mbox_free>
      memp_free(MEMP_NETCONN, conn);
  80ae8d:	83 c4 08             	add    $0x8,%esp
  80ae90:	53                   	push   %ebx
  80ae91:	6a 07                	push   $0x7
  80ae93:	e8 0d 97 ff ff       	call   8045a5 <memp_free>
      return NULL;
  80ae98:	83 c4 10             	add    $0x10,%esp
  80ae9b:	89 f3                	mov    %esi,%ebx
    }
  }
  return conn;
}
  80ae9d:	89 d8                	mov    %ebx,%eax
  80ae9f:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80aea2:	5b                   	pop    %ebx
  80aea3:	5e                   	pop    %esi
  80aea4:	5d                   	pop    %ebp
  80aea5:	c3                   	ret    
      LWIP_ASSERT("freeing conn without freeing pcb", conn->pcb.tcp == NULL);
  80aea6:	83 ec 04             	sub    $0x4,%esp
  80aea9:	68 ac 2f 81 00       	push   $0x812fac
  80aeae:	6a 52                	push   $0x52
  80aeb0:	68 5e 30 81 00       	push   $0x81305e
  80aeb5:	e8 8d 39 00 00       	call   80e847 <_panic>
      LWIP_ASSERT("conn has no op_completed", conn->op_completed != SYS_SEM_NULL);
  80aeba:	83 ec 04             	sub    $0x4,%esp
  80aebd:	68 75 30 81 00       	push   $0x813075
  80aec2:	6a 53                	push   $0x53
  80aec4:	68 5e 30 81 00       	push   $0x81305e
  80aec9:	e8 79 39 00 00       	call   80e847 <_panic>
      LWIP_ASSERT("conn has no recvmbox", conn->recvmbox != SYS_MBOX_NULL);
  80aece:	83 ec 04             	sub    $0x4,%esp
  80aed1:	68 8e 30 81 00       	push   $0x81308e
  80aed6:	6a 54                	push   $0x54
  80aed8:	68 5e 30 81 00       	push   $0x81305e
  80aedd:	e8 65 39 00 00       	call   80e847 <_panic>
      LWIP_ASSERT("conn->acceptmbox shouldn't exist", conn->acceptmbox == SYS_MBOX_NULL);
  80aee2:	83 ec 04             	sub    $0x4,%esp
  80aee5:	68 d0 2f 81 00       	push   $0x812fd0
  80aeea:	6a 55                	push   $0x55
  80aeec:	68 5e 30 81 00       	push   $0x81305e
  80aef1:	e8 51 39 00 00       	call   80e847 <_panic>

0080aef6 <netconn_delete>:
 * @param conn the netconn to delete
 * @return ERR_OK if the connection was deleted
 */
err_t
netconn_delete(struct netconn *conn)
{
  80aef6:	f3 0f 1e fb          	endbr32 
  80aefa:	55                   	push   %ebp
  80aefb:	89 e5                	mov    %esp,%ebp
  80aefd:	53                   	push   %ebx
  80aefe:	83 ec 24             	sub    $0x24,%esp
  80af01:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  /* No ASSERT here because possible to get a (conn == NULL) if we got an accept error */
  if (conn == NULL) {
  80af04:	85 db                	test   %ebx,%ebx
  80af06:	74 28                	je     80af30 <netconn_delete+0x3a>
    return ERR_OK;
  }

  msg.function = do_delconn;
  80af08:	c7 45 e4 17 c0 80 00 	movl   $0x80c017,-0x1c(%ebp)
  msg.msg.conn = conn;
  80af0f:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  tcpip_apimsg(&msg);
  80af12:	83 ec 0c             	sub    $0xc,%esp
  80af15:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80af18:	50                   	push   %eax
  80af19:	e8 e6 74 ff ff       	call   802404 <tcpip_apimsg>

  conn->pcb.tcp = NULL;
  80af1e:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
  netconn_free(conn);
  80af25:	89 1c 24             	mov    %ebx,(%esp)
  80af28:	e8 51 0f 00 00       	call   80be7e <netconn_free>

  return ERR_OK;
  80af2d:	83 c4 10             	add    $0x10,%esp
}
  80af30:	b8 00 00 00 00       	mov    $0x0,%eax
  80af35:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80af38:	c9                   	leave  
  80af39:	c3                   	ret    

0080af3a <netconn_type>:
 * @param conn the netconn of which to get the type
 * @return the netconn_type of conn
 */
enum netconn_type
netconn_type(struct netconn *conn)
{
  80af3a:	f3 0f 1e fb          	endbr32 
  80af3e:	55                   	push   %ebp
  80af3f:	89 e5                	mov    %esp,%ebp
  80af41:	83 ec 08             	sub    $0x8,%esp
  80af44:	8b 45 08             	mov    0x8(%ebp),%eax
  LWIP_ERROR("netconn_type: invalid conn", (conn != NULL), return NETCONN_INVALID;);
  80af47:	85 c0                	test   %eax,%eax
  80af49:	74 04                	je     80af4f <netconn_type+0x15>
  80af4b:	8b 00                	mov    (%eax),%eax
  return conn->type;
}
  80af4d:	c9                   	leave  
  80af4e:	c3                   	ret    
  LWIP_ERROR("netconn_type: invalid conn", (conn != NULL), return NETCONN_INVALID;);
  80af4f:	83 ec 04             	sub    $0x4,%esp
  80af52:	68 a3 30 81 00       	push   $0x8130a3
  80af57:	68 84 00 00 00       	push   $0x84
  80af5c:	68 5e 30 81 00       	push   $0x81305e
  80af61:	e8 e1 38 00 00       	call   80e847 <_panic>

0080af66 <netconn_getaddr>:
 * @return ERR_CONN for invalid connections
 *         ERR_OK if the information was retrieved
 */
err_t
netconn_getaddr(struct netconn *conn, struct ip_addr *addr, u16_t *port, u8_t local)
{
  80af66:	f3 0f 1e fb          	endbr32 
  80af6a:	55                   	push   %ebp
  80af6b:	89 e5                	mov    %esp,%ebp
  80af6d:	53                   	push   %ebx
  80af6e:	83 ec 24             	sub    $0x24,%esp
  80af71:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80af74:	8b 55 0c             	mov    0xc(%ebp),%edx
  80af77:	8b 45 10             	mov    0x10(%ebp),%eax
  80af7a:	8b 4d 14             	mov    0x14(%ebp),%ecx
  struct api_msg msg;

  LWIP_ERROR("netconn_getaddr: invalid conn", (conn != NULL), return ERR_ARG;);
  80af7d:	85 db                	test   %ebx,%ebx
  80af7f:	74 30                	je     80afb1 <netconn_getaddr+0x4b>
  LWIP_ERROR("netconn_getaddr: invalid addr", (addr != NULL), return ERR_ARG;);
  80af81:	85 d2                	test   %edx,%edx
  80af83:	74 43                	je     80afc8 <netconn_getaddr+0x62>
  LWIP_ERROR("netconn_getaddr: invalid port", (port != NULL), return ERR_ARG;);
  80af85:	85 c0                	test   %eax,%eax
  80af87:	74 56                	je     80afdf <netconn_getaddr+0x79>

  msg.function = do_getaddr;
  80af89:	c7 45 e4 86 c4 80 00 	movl   $0x80c486,-0x1c(%ebp)
  msg.msg.conn = conn;
  80af90:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.ad.ipaddr = addr;
  80af93:	89 55 ec             	mov    %edx,-0x14(%ebp)
  msg.msg.msg.ad.port = port;
  80af96:	89 45 f0             	mov    %eax,-0x10(%ebp)
  msg.msg.msg.ad.local = local;
  80af99:	88 4d f4             	mov    %cl,-0xc(%ebp)
  TCPIP_APIMSG(&msg);
  80af9c:	83 ec 0c             	sub    $0xc,%esp
  80af9f:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80afa2:	50                   	push   %eax
  80afa3:	e8 5c 74 ff ff       	call   802404 <tcpip_apimsg>

  return conn->err;
  80afa8:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80afac:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80afaf:	c9                   	leave  
  80afb0:	c3                   	ret    
  LWIP_ERROR("netconn_getaddr: invalid conn", (conn != NULL), return ERR_ARG;);
  80afb1:	83 ec 04             	sub    $0x4,%esp
  80afb4:	68 be 30 81 00       	push   $0x8130be
  80afb9:	68 98 00 00 00       	push   $0x98
  80afbe:	68 5e 30 81 00       	push   $0x81305e
  80afc3:	e8 7f 38 00 00       	call   80e847 <_panic>
  LWIP_ERROR("netconn_getaddr: invalid addr", (addr != NULL), return ERR_ARG;);
  80afc8:	83 ec 04             	sub    $0x4,%esp
  80afcb:	68 dc 30 81 00       	push   $0x8130dc
  80afd0:	68 99 00 00 00       	push   $0x99
  80afd5:	68 5e 30 81 00       	push   $0x81305e
  80afda:	e8 68 38 00 00       	call   80e847 <_panic>
  LWIP_ERROR("netconn_getaddr: invalid port", (port != NULL), return ERR_ARG;);
  80afdf:	83 ec 04             	sub    $0x4,%esp
  80afe2:	68 fa 30 81 00       	push   $0x8130fa
  80afe7:	68 9a 00 00 00       	push   $0x9a
  80afec:	68 5e 30 81 00       	push   $0x81305e
  80aff1:	e8 51 38 00 00       	call   80e847 <_panic>

0080aff6 <netconn_bind>:
 * @param port the local port to bind the netconn to (not used for RAW)
 * @return ERR_OK if bound, any other err_t on failure
 */
err_t
netconn_bind(struct netconn *conn, struct ip_addr *addr, u16_t port)
{
  80aff6:	f3 0f 1e fb          	endbr32 
  80affa:	55                   	push   %ebp
  80affb:	89 e5                	mov    %esp,%ebp
  80affd:	53                   	push   %ebx
  80affe:	83 ec 24             	sub    $0x24,%esp
  80b001:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80b004:	8b 45 10             	mov    0x10(%ebp),%eax
  struct api_msg msg;

  LWIP_ERROR("netconn_bind: invalid conn", (conn != NULL), return ERR_ARG;);
  80b007:	85 db                	test   %ebx,%ebx
  80b009:	74 29                	je     80b034 <netconn_bind+0x3e>

  msg.function = do_bind;
  80b00b:	c7 45 e4 c4 c0 80 00 	movl   $0x80c0c4,-0x1c(%ebp)
  msg.msg.conn = conn;
  80b012:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.bc.ipaddr = addr;
  80b015:	8b 55 0c             	mov    0xc(%ebp),%edx
  80b018:	89 55 ec             	mov    %edx,-0x14(%ebp)
  msg.msg.msg.bc.port = port;
  80b01b:	66 89 45 f0          	mov    %ax,-0x10(%ebp)
  TCPIP_APIMSG(&msg);
  80b01f:	83 ec 0c             	sub    $0xc,%esp
  80b022:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80b025:	50                   	push   %eax
  80b026:	e8 d9 73 ff ff       	call   802404 <tcpip_apimsg>
  return conn->err;
  80b02b:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80b02f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b032:	c9                   	leave  
  80b033:	c3                   	ret    
  LWIP_ERROR("netconn_bind: invalid conn", (conn != NULL), return ERR_ARG;);
  80b034:	83 ec 04             	sub    $0x4,%esp
  80b037:	68 18 31 81 00       	push   $0x813118
  80b03c:	68 b5 00 00 00       	push   $0xb5
  80b041:	68 5e 30 81 00       	push   $0x81305e
  80b046:	e8 fc 37 00 00       	call   80e847 <_panic>

0080b04b <netconn_connect>:
 * @param port the remote port to connect to (no used for RAW)
 * @return ERR_OK if connected, return value of tcp_/udp_/raw_connect otherwise
 */
err_t
netconn_connect(struct netconn *conn, struct ip_addr *addr, u16_t port)
{
  80b04b:	f3 0f 1e fb          	endbr32 
  80b04f:	55                   	push   %ebp
  80b050:	89 e5                	mov    %esp,%ebp
  80b052:	53                   	push   %ebx
  80b053:	83 ec 24             	sub    $0x24,%esp
  80b056:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80b059:	8b 45 10             	mov    0x10(%ebp),%eax
  struct api_msg msg;

  LWIP_ERROR("netconn_connect: invalid conn", (conn != NULL), return ERR_ARG;);
  80b05c:	85 db                	test   %ebx,%ebx
  80b05e:	74 29                	je     80b089 <netconn_connect+0x3e>

  msg.function = do_connect;
  80b060:	c7 45 e4 58 c1 80 00 	movl   $0x80c158,-0x1c(%ebp)
  msg.msg.conn = conn;
  80b067:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.bc.ipaddr = addr;
  80b06a:	8b 55 0c             	mov    0xc(%ebp),%edx
  80b06d:	89 55 ec             	mov    %edx,-0x14(%ebp)
  msg.msg.msg.bc.port = port;
  80b070:	66 89 45 f0          	mov    %ax,-0x10(%ebp)
  /* This is the only function which need to not block tcpip_thread */
  tcpip_apimsg(&msg);
  80b074:	83 ec 0c             	sub    $0xc,%esp
  80b077:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80b07a:	50                   	push   %eax
  80b07b:	e8 84 73 ff ff       	call   802404 <tcpip_apimsg>
  return conn->err;
  80b080:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80b084:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b087:	c9                   	leave  
  80b088:	c3                   	ret    
  LWIP_ERROR("netconn_connect: invalid conn", (conn != NULL), return ERR_ARG;);
  80b089:	83 ec 04             	sub    $0x4,%esp
  80b08c:	68 33 31 81 00       	push   $0x813133
  80b091:	68 cc 00 00 00       	push   $0xcc
  80b096:	68 5e 30 81 00       	push   $0x81305e
  80b09b:	e8 a7 37 00 00       	call   80e847 <_panic>

0080b0a0 <netconn_disconnect>:
 * @param conn the netconn to disconnect
 * @return TODO: return value is not set here...
 */
err_t
netconn_disconnect(struct netconn *conn)
{
  80b0a0:	f3 0f 1e fb          	endbr32 
  80b0a4:	55                   	push   %ebp
  80b0a5:	89 e5                	mov    %esp,%ebp
  80b0a7:	53                   	push   %ebx
  80b0a8:	83 ec 24             	sub    $0x24,%esp
  80b0ab:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  LWIP_ERROR("netconn_disconnect: invalid conn", (conn != NULL), return ERR_ARG;);
  80b0ae:	85 db                	test   %ebx,%ebx
  80b0b0:	74 1f                	je     80b0d1 <netconn_disconnect+0x31>

  msg.function = do_disconnect;
  80b0b2:	c7 45 e4 11 c2 80 00 	movl   $0x80c211,-0x1c(%ebp)
  msg.msg.conn = conn;
  80b0b9:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  TCPIP_APIMSG(&msg);
  80b0bc:	83 ec 0c             	sub    $0xc,%esp
  80b0bf:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80b0c2:	50                   	push   %eax
  80b0c3:	e8 3c 73 ff ff       	call   802404 <tcpip_apimsg>
  return conn->err;
  80b0c8:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80b0cc:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b0cf:	c9                   	leave  
  80b0d0:	c3                   	ret    
  LWIP_ERROR("netconn_disconnect: invalid conn", (conn != NULL), return ERR_ARG;);
  80b0d1:	83 ec 04             	sub    $0x4,%esp
  80b0d4:	68 f4 2f 81 00       	push   $0x812ff4
  80b0d9:	68 e2 00 00 00       	push   $0xe2
  80b0de:	68 5e 30 81 00       	push   $0x81305e
  80b0e3:	e8 5f 37 00 00       	call   80e847 <_panic>

0080b0e8 <netconn_listen_with_backlog>:
 * @return ERR_OK if the netconn was set to listen (UDP and RAW netconns
 *         don't return any error (yet?))
 */
err_t
netconn_listen_with_backlog(struct netconn *conn, u8_t backlog)
{
  80b0e8:	f3 0f 1e fb          	endbr32 
  80b0ec:	55                   	push   %ebp
  80b0ed:	89 e5                	mov    %esp,%ebp
  80b0ef:	53                   	push   %ebx
  80b0f0:	83 ec 24             	sub    $0x24,%esp
  80b0f3:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  /* This does no harm. If TCP_LISTEN_BACKLOG is off, backlog is unused. */
  LWIP_UNUSED_ARG(backlog);

  LWIP_ERROR("netconn_listen: invalid conn", (conn != NULL), return ERR_ARG;);
  80b0f6:	85 db                	test   %ebx,%ebx
  80b0f8:	74 1f                	je     80b119 <netconn_listen_with_backlog+0x31>

  msg.function = do_listen;
  80b0fa:	c7 45 e4 52 c2 80 00 	movl   $0x80c252,-0x1c(%ebp)
  msg.msg.conn = conn;
  80b101:	89 5d e8             	mov    %ebx,-0x18(%ebp)
#if TCP_LISTEN_BACKLOG
  msg.msg.msg.lb.backlog = backlog;
#endif /* TCP_LISTEN_BACKLOG */
  TCPIP_APIMSG(&msg);
  80b104:	83 ec 0c             	sub    $0xc,%esp
  80b107:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80b10a:	50                   	push   %eax
  80b10b:	e8 f4 72 ff ff       	call   802404 <tcpip_apimsg>
  return conn->err;
  80b110:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80b114:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b117:	c9                   	leave  
  80b118:	c3                   	ret    
  LWIP_ERROR("netconn_listen: invalid conn", (conn != NULL), return ERR_ARG;);
  80b119:	83 ec 04             	sub    $0x4,%esp
  80b11c:	68 51 31 81 00       	push   $0x813151
  80b121:	68 fa 00 00 00       	push   $0xfa
  80b126:	68 5e 30 81 00       	push   $0x81305e
  80b12b:	e8 17 37 00 00       	call   80e847 <_panic>

0080b130 <netconn_accept>:
 * @param conn the TCP listen netconn
 * @return the newly accepted netconn or NULL on timeout
 */
struct netconn *
netconn_accept(struct netconn *conn)
{
  80b130:	f3 0f 1e fb          	endbr32 
  80b134:	55                   	push   %ebp
  80b135:	89 e5                	mov    %esp,%ebp
  80b137:	53                   	push   %ebx
  80b138:	83 ec 14             	sub    $0x14,%esp
  80b13b:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct netconn *newconn;

  LWIP_ERROR("netconn_accept: invalid conn",       (conn != NULL),                      return NULL;);
  80b13e:	85 db                	test   %ebx,%ebx
  80b140:	74 36                	je     80b178 <netconn_accept+0x48>
  LWIP_ERROR("netconn_accept: invalid acceptmbox", (conn->acceptmbox != SYS_MBOX_NULL), return NULL;);
  80b142:	8b 43 18             	mov    0x18(%ebx),%eax
  80b145:	83 f8 ff             	cmp    $0xffffffff,%eax
  80b148:	74 45                	je     80b18f <netconn_accept+0x5f>
#if LWIP_SO_RCVTIMEO
  if (sys_arch_mbox_fetch(conn->acceptmbox, (void *)&newconn, conn->recv_timeout) == SYS_ARCH_TIMEOUT) {
    newconn = NULL;
  } else
#else
  sys_arch_mbox_fetch(conn->acceptmbox, (void *)&newconn, 0);
  80b14a:	83 ec 04             	sub    $0x4,%esp
  80b14d:	6a 00                	push   $0x0
  80b14f:	8d 55 f4             	lea    -0xc(%ebp),%edx
  80b152:	52                   	push   %edx
  80b153:	50                   	push   %eax
  80b154:	e8 a6 f3 ff ff       	call   80a4ff <sys_arch_mbox_fetch>
#endif /* LWIP_SO_RCVTIMEO*/
  {
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVMINUS, 0);
  80b159:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80b15c:	83 c4 10             	add    $0x10,%esp
  80b15f:	85 c0                	test   %eax,%eax
  80b161:	74 0d                	je     80b170 <netconn_accept+0x40>
  80b163:	83 ec 04             	sub    $0x4,%esp
  80b166:	6a 00                	push   $0x0
  80b168:	6a 01                	push   $0x1
  80b16a:	53                   	push   %ebx
  80b16b:	ff d0                	call   *%eax
  80b16d:	83 c4 10             	add    $0x10,%esp
    }
#endif /* TCP_LISTEN_BACKLOG */
  }

  return newconn;
}
  80b170:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80b173:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b176:	c9                   	leave  
  80b177:	c3                   	ret    
  LWIP_ERROR("netconn_accept: invalid conn",       (conn != NULL),                      return NULL;);
  80b178:	83 ec 04             	sub    $0x4,%esp
  80b17b:	68 6e 31 81 00       	push   $0x81316e
  80b180:	68 10 01 00 00       	push   $0x110
  80b185:	68 5e 30 81 00       	push   $0x81305e
  80b18a:	e8 b8 36 00 00       	call   80e847 <_panic>
  LWIP_ERROR("netconn_accept: invalid acceptmbox", (conn->acceptmbox != SYS_MBOX_NULL), return NULL;);
  80b18f:	83 ec 04             	sub    $0x4,%esp
  80b192:	68 18 30 81 00       	push   $0x813018
  80b197:	68 11 01 00 00       	push   $0x111
  80b19c:	68 5e 30 81 00       	push   $0x81305e
  80b1a1:	e8 a1 36 00 00       	call   80e847 <_panic>

0080b1a6 <netconn_recv>:
 * @param conn the netconn from which to receive data
 * @return a new netbuf containing received data or NULL on memory error or timeout
 */
struct netbuf *
netconn_recv(struct netconn *conn)
{
  80b1a6:	f3 0f 1e fb          	endbr32 
  80b1aa:	55                   	push   %ebp
  80b1ab:	89 e5                	mov    %esp,%ebp
  80b1ad:	53                   	push   %ebx
  80b1ae:	83 ec 24             	sub    $0x24,%esp
  80b1b1:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;
  struct netbuf *buf = NULL;
  80b1b4:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  struct pbuf *p;
  u16_t len;

  LWIP_ERROR("netconn_recv: invalid conn",  (conn != NULL), return NULL;);
  80b1bb:	85 db                	test   %ebx,%ebx
  80b1bd:	0f 84 cc 00 00 00    	je     80b28f <netconn_recv+0xe9>

  if (conn->recvmbox == SYS_MBOX_NULL) {
  80b1c3:	8b 43 14             	mov    0x14(%ebx),%eax
  80b1c6:	83 f8 ff             	cmp    $0xffffffff,%eax
  80b1c9:	0f 84 d7 00 00 00    	je     80b2a6 <netconn_recv+0x100>
    /* TCP listen conns don't have a recvmbox! */
    conn->err = ERR_CONN;
    return NULL;
  }

  if (ERR_IS_FATAL(conn->err)) {
  80b1cf:	80 7b 0c fc          	cmpb   $0xfc,0xc(%ebx)
  80b1d3:	0f 8c 27 01 00 00    	jl     80b300 <netconn_recv+0x15a>
    return NULL;
  }

  if (conn->type == NETCONN_TCP) {
  80b1d9:	83 3b 10             	cmpl   $0x10,(%ebx)
  80b1dc:	0f 85 e0 00 00 00    	jne    80b2c2 <netconn_recv+0x11c>
#if LWIP_TCP
    if (conn->state == NETCONN_LISTEN) {
  80b1e2:	83 7b 04 02          	cmpl   $0x2,0x4(%ebx)
  80b1e6:	0f 84 c5 00 00 00    	je     80b2b1 <netconn_recv+0x10b>
      /* @todo: should calling netconn_recv on a TCP listen conn be fatal?? */
      conn->err = ERR_CONN;
      return NULL;
    }

    buf = memp_malloc(MEMP_NETBUF);
  80b1ec:	83 ec 0c             	sub    $0xc,%esp
  80b1ef:	6a 06                	push   $0x6
  80b1f1:	e8 55 93 ff ff       	call   80454b <memp_malloc>
  80b1f6:	89 45 e0             	mov    %eax,-0x20(%ebp)

    if (buf == NULL) {
  80b1f9:	83 c4 10             	add    $0x10,%esp
  80b1fc:	85 c0                	test   %eax,%eax
  80b1fe:	0f 84 b8 00 00 00    	je     80b2bc <netconn_recv+0x116>
    if (sys_arch_mbox_fetch(conn->recvmbox, (void *)&p, conn->recv_timeout)==SYS_ARCH_TIMEOUT) {
      conn->err = ERR_TIMEOUT;
      p = NULL;
    }
#else
    sys_arch_mbox_fetch(conn->recvmbox, (void *)&p, 0);
  80b204:	83 ec 04             	sub    $0x4,%esp
  80b207:	6a 00                	push   $0x0
  80b209:	8d 45 dc             	lea    -0x24(%ebp),%eax
  80b20c:	50                   	push   %eax
  80b20d:	ff 73 14             	pushl  0x14(%ebx)
  80b210:	e8 ea f2 ff ff       	call   80a4ff <sys_arch_mbox_fetch>
#endif /* LWIP_SO_RCVTIMEO*/

    if (p != NULL) {
  80b215:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80b218:	83 c4 10             	add    $0x10,%esp
  80b21b:	85 c0                	test   %eax,%eax
  80b21d:	0f 84 e4 00 00 00    	je     80b307 <netconn_recv+0x161>
      len = p->tot_len;
  80b223:	0f b7 50 08          	movzwl 0x8(%eax),%edx
      SYS_ARCH_DEC(conn->recv_avail, len);
  80b227:	66 29 53 20          	sub    %dx,0x20(%ebx)
    } else {
      len = 0;
    }

    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVMINUS, len);
  80b22b:	8b 4b 2c             	mov    0x2c(%ebx),%ecx
  80b22e:	85 c9                	test   %ecx,%ecx
  80b230:	74 1a                	je     80b24c <netconn_recv+0xa6>
  80b232:	83 ec 04             	sub    $0x4,%esp
  80b235:	0f b7 d2             	movzwl %dx,%edx
  80b238:	52                   	push   %edx
  80b239:	6a 01                	push   $0x1
  80b23b:	53                   	push   %ebx
  80b23c:	ff d1                	call   *%ecx

    /* If we are closed, we indicate that we no longer wish to use the socket */
    if (p == NULL) {
  80b23e:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80b241:	83 c4 10             	add    $0x10,%esp
  80b244:	85 c0                	test   %eax,%eax
  80b246:	0f 84 cb 00 00 00    	je     80b317 <netconn_recv+0x171>
        conn->err = ERR_CLSD;
      }
      return NULL;
    }

    buf->p = p;
  80b24c:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80b24f:	89 02                	mov    %eax,(%edx)
    buf->ptr = p;
  80b251:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80b254:	89 42 04             	mov    %eax,0x4(%edx)
    buf->port = 0;
  80b257:	66 c7 42 0c 00 00    	movw   $0x0,0xc(%edx)
    buf->addr = NULL;
  80b25d:	c7 42 08 00 00 00 00 	movl   $0x0,0x8(%edx)

    /* Let the stack know that we have taken the data. */
    msg.function = do_recv;
  80b264:	c7 45 e4 e8 c3 80 00 	movl   $0x80c3e8,-0x1c(%ebp)
    msg.msg.conn = conn;
  80b26b:	89 5d e8             	mov    %ebx,-0x18(%ebp)
    if (buf != NULL) {
      msg.msg.msg.r.len = buf->p->tot_len;
  80b26e:	8b 02                	mov    (%edx),%eax
  80b270:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  80b274:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
    } else {
      msg.msg.msg.r.len = 1;
    }
    TCPIP_APIMSG(&msg);
  80b278:	83 ec 0c             	sub    $0xc,%esp
  80b27b:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80b27e:	50                   	push   %eax
  80b27f:	e8 80 71 ff ff       	call   802404 <tcpip_apimsg>
  80b284:	83 c4 10             	add    $0x10,%esp
#endif /* (LWIP_UDP || LWIP_RAW) */
  }

  LWIP_DEBUGF(API_LIB_DEBUG, ("netconn_recv: received %p (err %d)\n", (void *)buf, conn->err));

  return buf;
  80b287:	8b 45 e0             	mov    -0x20(%ebp),%eax
}
  80b28a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b28d:	c9                   	leave  
  80b28e:	c3                   	ret    
  LWIP_ERROR("netconn_recv: invalid conn",  (conn != NULL), return NULL;);
  80b28f:	83 ec 04             	sub    $0x4,%esp
  80b292:	68 8b 31 81 00       	push   $0x81318b
  80b297:	68 3a 01 00 00       	push   $0x13a
  80b29c:	68 5e 30 81 00       	push   $0x81305e
  80b2a1:	e8 a1 35 00 00       	call   80e847 <_panic>
    conn->err = ERR_CONN;
  80b2a6:	c6 43 0c f8          	movb   $0xf8,0xc(%ebx)
    return NULL;
  80b2aa:	b8 00 00 00 00       	mov    $0x0,%eax
  80b2af:	eb d9                	jmp    80b28a <netconn_recv+0xe4>
      conn->err = ERR_CONN;
  80b2b1:	c6 43 0c f8          	movb   $0xf8,0xc(%ebx)
      return NULL;
  80b2b5:	b8 00 00 00 00       	mov    $0x0,%eax
  80b2ba:	eb ce                	jmp    80b28a <netconn_recv+0xe4>
      conn->err = ERR_MEM;
  80b2bc:	c6 43 0c ff          	movb   $0xff,0xc(%ebx)
      return NULL;
  80b2c0:	eb c8                	jmp    80b28a <netconn_recv+0xe4>
    sys_arch_mbox_fetch(conn->recvmbox, (void *)&buf, 0);
  80b2c2:	83 ec 04             	sub    $0x4,%esp
  80b2c5:	6a 00                	push   $0x0
  80b2c7:	8d 55 e0             	lea    -0x20(%ebp),%edx
  80b2ca:	52                   	push   %edx
  80b2cb:	50                   	push   %eax
  80b2cc:	e8 2e f2 ff ff       	call   80a4ff <sys_arch_mbox_fetch>
    if (buf!=NULL) {
  80b2d1:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80b2d4:	83 c4 10             	add    $0x10,%esp
  80b2d7:	85 c0                	test   %eax,%eax
  80b2d9:	74 ac                	je     80b287 <netconn_recv+0xe1>
      SYS_ARCH_DEC(conn->recv_avail, buf->p->tot_len);
  80b2db:	8b 10                	mov    (%eax),%edx
  80b2dd:	0f b7 52 08          	movzwl 0x8(%edx),%edx
  80b2e1:	66 29 53 20          	sub    %dx,0x20(%ebx)
      API_EVENT(conn, NETCONN_EVT_RCVMINUS, buf->p->tot_len);
  80b2e5:	8b 53 2c             	mov    0x2c(%ebx),%edx
  80b2e8:	85 d2                	test   %edx,%edx
  80b2ea:	74 9b                	je     80b287 <netconn_recv+0xe1>
  80b2ec:	83 ec 04             	sub    $0x4,%esp
  80b2ef:	8b 00                	mov    (%eax),%eax
  80b2f1:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  80b2f5:	50                   	push   %eax
  80b2f6:	6a 01                	push   $0x1
  80b2f8:	53                   	push   %ebx
  80b2f9:	ff d2                	call   *%edx
  80b2fb:	83 c4 10             	add    $0x10,%esp
  80b2fe:	eb 87                	jmp    80b287 <netconn_recv+0xe1>
    return NULL;
  80b300:	b8 00 00 00 00       	mov    $0x0,%eax
  80b305:	eb 83                	jmp    80b28a <netconn_recv+0xe4>
    API_EVENT(conn, NETCONN_EVT_RCVMINUS, len);
  80b307:	8b 4b 2c             	mov    0x2c(%ebx),%ecx
      len = 0;
  80b30a:	ba 00 00 00 00       	mov    $0x0,%edx
    API_EVENT(conn, NETCONN_EVT_RCVMINUS, len);
  80b30f:	85 c9                	test   %ecx,%ecx
  80b311:	0f 85 1b ff ff ff    	jne    80b232 <netconn_recv+0x8c>
      memp_free(MEMP_NETBUF, buf);
  80b317:	83 ec 08             	sub    $0x8,%esp
  80b31a:	ff 75 e0             	pushl  -0x20(%ebp)
  80b31d:	6a 06                	push   $0x6
  80b31f:	e8 81 92 ff ff       	call   8045a5 <memp_free>
      if (conn->err == ERR_OK) {
  80b324:	83 c4 10             	add    $0x10,%esp
      return NULL;
  80b327:	b8 00 00 00 00       	mov    $0x0,%eax
      if (conn->err == ERR_OK) {
  80b32c:	80 7b 0c 00          	cmpb   $0x0,0xc(%ebx)
  80b330:	0f 85 54 ff ff ff    	jne    80b28a <netconn_recv+0xe4>
        conn->err = ERR_CLSD;
  80b336:	c6 43 0c f9          	movb   $0xf9,0xc(%ebx)
  80b33a:	e9 4b ff ff ff       	jmp    80b28a <netconn_recv+0xe4>

0080b33f <netconn_send>:
 * @param buf a netbuf containing the data to send
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t
netconn_send(struct netconn *conn, struct netbuf *buf)
{
  80b33f:	f3 0f 1e fb          	endbr32 
  80b343:	55                   	push   %ebp
  80b344:	89 e5                	mov    %esp,%ebp
  80b346:	53                   	push   %ebx
  80b347:	83 ec 24             	sub    $0x24,%esp
  80b34a:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  LWIP_ERROR("netconn_send: invalid conn",  (conn != NULL), return ERR_ARG;);
  80b34d:	85 db                	test   %ebx,%ebx
  80b34f:	74 25                	je     80b376 <netconn_send+0x37>

  LWIP_DEBUGF(API_LIB_DEBUG, ("netconn_send: sending %d bytes\n", buf->p->tot_len));
  msg.function = do_send;
  80b351:	c7 45 e4 3e c3 80 00 	movl   $0x80c33e,-0x1c(%ebp)
  msg.msg.conn = conn;
  80b358:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.b = buf;
  80b35b:	8b 45 0c             	mov    0xc(%ebp),%eax
  80b35e:	89 45 ec             	mov    %eax,-0x14(%ebp)
  TCPIP_APIMSG(&msg);
  80b361:	83 ec 0c             	sub    $0xc,%esp
  80b364:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80b367:	50                   	push   %eax
  80b368:	e8 97 70 ff ff       	call   802404 <tcpip_apimsg>
  return conn->err;
  80b36d:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80b371:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b374:	c9                   	leave  
  80b375:	c3                   	ret    
  LWIP_ERROR("netconn_send: invalid conn",  (conn != NULL), return ERR_ARG;);
  80b376:	83 ec 04             	sub    $0x4,%esp
  80b379:	68 a6 31 81 00       	push   $0x8131a6
  80b37e:	68 b9 01 00 00       	push   $0x1b9
  80b383:	68 5e 30 81 00       	push   $0x81305e
  80b388:	e8 ba 34 00 00       	call   80e847 <_panic>

0080b38d <netconn_sendto>:
{
  80b38d:	f3 0f 1e fb          	endbr32 
  80b391:	55                   	push   %ebp
  80b392:	89 e5                	mov    %esp,%ebp
  80b394:	83 ec 08             	sub    $0x8,%esp
  80b397:	8b 45 0c             	mov    0xc(%ebp),%eax
  80b39a:	8b 55 14             	mov    0x14(%ebp),%edx
  if (buf != NULL) {
  80b39d:	85 c0                	test   %eax,%eax
  80b39f:	74 1b                	je     80b3bc <netconn_sendto+0x2f>
    buf->addr = addr;
  80b3a1:	8b 4d 10             	mov    0x10(%ebp),%ecx
  80b3a4:	89 48 08             	mov    %ecx,0x8(%eax)
    buf->port = port;
  80b3a7:	66 89 50 0c          	mov    %dx,0xc(%eax)
    return netconn_send(conn, buf);
  80b3ab:	83 ec 08             	sub    $0x8,%esp
  80b3ae:	50                   	push   %eax
  80b3af:	ff 75 08             	pushl  0x8(%ebp)
  80b3b2:	e8 88 ff ff ff       	call   80b33f <netconn_send>
  80b3b7:	83 c4 10             	add    $0x10,%esp
}
  80b3ba:	c9                   	leave  
  80b3bb:	c3                   	ret    
  return ERR_VAL;
  80b3bc:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  80b3c1:	eb f7                	jmp    80b3ba <netconn_sendto+0x2d>

0080b3c3 <netconn_write>:
 * - NETCONN_MORE (0x02) for TCP connection, PSH flag will be set on last segment sent
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t
netconn_write(struct netconn *conn, const void *dataptr, int size, u8_t apiflags)
{
  80b3c3:	f3 0f 1e fb          	endbr32 
  80b3c7:	55                   	push   %ebp
  80b3c8:	89 e5                	mov    %esp,%ebp
  80b3ca:	53                   	push   %ebx
  80b3cb:	83 ec 24             	sub    $0x24,%esp
  80b3ce:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80b3d1:	8b 45 14             	mov    0x14(%ebp),%eax
  struct api_msg msg;

  LWIP_ERROR("netconn_write: invalid conn",  (conn != NULL), return ERR_ARG;);
  80b3d4:	85 db                	test   %ebx,%ebx
  80b3d6:	74 33                	je     80b40b <netconn_write+0x48>
  LWIP_ERROR("netconn_write: invalid conn->type",  (conn->type == NETCONN_TCP), return ERR_VAL;);
  80b3d8:	83 3b 10             	cmpl   $0x10,(%ebx)
  80b3db:	75 45                	jne    80b422 <netconn_write+0x5f>

  msg.function = do_write;
  80b3dd:	c7 45 e4 32 c4 80 00 	movl   $0x80c432,-0x1c(%ebp)
  msg.msg.conn = conn;
  80b3e4:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.w.dataptr = dataptr;
  80b3e7:	8b 55 0c             	mov    0xc(%ebp),%edx
  80b3ea:	89 55 ec             	mov    %edx,-0x14(%ebp)
  msg.msg.msg.w.apiflags = apiflags;
  80b3ed:	88 45 f4             	mov    %al,-0xc(%ebp)
  msg.msg.msg.w.len = size;
  80b3f0:	8b 45 10             	mov    0x10(%ebp),%eax
  80b3f3:	89 45 f0             	mov    %eax,-0x10(%ebp)
  /* For locking the core: this _can_ be delayed on low memory/low send buffer,
     but if it is, this is done inside api_msg.c:do_write(), so we can use the
     non-blocking version here. */
  TCPIP_APIMSG(&msg);
  80b3f6:	83 ec 0c             	sub    $0xc,%esp
  80b3f9:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80b3fc:	50                   	push   %eax
  80b3fd:	e8 02 70 ff ff       	call   802404 <tcpip_apimsg>
  return conn->err;
  80b402:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80b406:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b409:	c9                   	leave  
  80b40a:	c3                   	ret    
  LWIP_ERROR("netconn_write: invalid conn",  (conn != NULL), return ERR_ARG;);
  80b40b:	83 ec 04             	sub    $0x4,%esp
  80b40e:	68 c1 31 81 00       	push   $0x8131c1
  80b413:	68 d3 01 00 00       	push   $0x1d3
  80b418:	68 5e 30 81 00       	push   $0x81305e
  80b41d:	e8 25 34 00 00       	call   80e847 <_panic>
  LWIP_ERROR("netconn_write: invalid conn->type",  (conn->type == NETCONN_TCP), return ERR_VAL;);
  80b422:	83 ec 04             	sub    $0x4,%esp
  80b425:	68 3c 30 81 00       	push   $0x81303c
  80b42a:	68 d4 01 00 00       	push   $0x1d4
  80b42f:	68 5e 30 81 00       	push   $0x81305e
  80b434:	e8 0e 34 00 00       	call   80e847 <_panic>

0080b439 <netconn_close>:
 * @param conn the TCP netconn to close
 * @return ERR_OK if the netconn was closed, any other err_t on error
 */
err_t
netconn_close(struct netconn *conn)
{
  80b439:	f3 0f 1e fb          	endbr32 
  80b43d:	55                   	push   %ebp
  80b43e:	89 e5                	mov    %esp,%ebp
  80b440:	53                   	push   %ebx
  80b441:	83 ec 24             	sub    $0x24,%esp
  80b444:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  LWIP_ERROR("netconn_close: invalid conn",  (conn != NULL), return ERR_ARG;);
  80b447:	85 db                	test   %ebx,%ebx
  80b449:	74 1f                	je     80b46a <netconn_close+0x31>

  msg.function = do_close;
  80b44b:	c7 45 e4 51 c5 80 00 	movl   $0x80c551,-0x1c(%ebp)
  msg.msg.conn = conn;
  80b452:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  tcpip_apimsg(&msg);
  80b455:	83 ec 0c             	sub    $0xc,%esp
  80b458:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80b45b:	50                   	push   %eax
  80b45c:	e8 a3 6f ff ff       	call   802404 <tcpip_apimsg>
  return conn->err;
  80b461:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80b465:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b468:	c9                   	leave  
  80b469:	c3                   	ret    
  LWIP_ERROR("netconn_close: invalid conn",  (conn != NULL), return ERR_ARG;);
  80b46a:	83 ec 04             	sub    $0x4,%esp
  80b46d:	68 dd 31 81 00       	push   $0x8131dd
  80b472:	68 ed 01 00 00       	push   $0x1ed
  80b477:	68 5e 30 81 00       	push   $0x81305e
  80b47c:	e8 c6 33 00 00       	call   80e847 <_panic>

0080b481 <recv_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.recv) for parameters and return value
 */
static err_t
recv_tcp(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
{
  80b481:	f3 0f 1e fb          	endbr32 
  80b485:	55                   	push   %ebp
  80b486:	89 e5                	mov    %esp,%ebp
  80b488:	56                   	push   %esi
  80b489:	53                   	push   %ebx
  80b48a:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80b48d:	8b 45 0c             	mov    0xc(%ebp),%eax
  80b490:	8b 75 10             	mov    0x10(%ebp),%esi
  80b493:	8b 55 14             	mov    0x14(%ebp),%edx
  struct netconn *conn;
  u16_t len;

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("recv_tcp must have a pcb argument", pcb != NULL);
  80b496:	85 c0                	test   %eax,%eax
  80b498:	74 5a                	je     80b4f4 <recv_tcp+0x73>
  LWIP_ASSERT("recv_tcp must have an argument", arg != NULL);
  80b49a:	85 db                	test   %ebx,%ebx
  80b49c:	74 6d                	je     80b50b <recv_tcp+0x8a>
  conn = arg;
  LWIP_ASSERT("recv_tcp: recv for wrong pcb!", conn->pcb.tcp == pcb);
  80b49e:	39 43 08             	cmp    %eax,0x8(%ebx)
  80b4a1:	75 7f                	jne    80b522 <recv_tcp+0xa1>

  if ((conn == NULL) || (conn->recvmbox == SYS_MBOX_NULL)) {
  80b4a3:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80b4a7:	0f 84 8c 00 00 00    	je     80b539 <recv_tcp+0xb8>
    return ERR_VAL;
  }

  conn->err = err;
  80b4ad:	88 53 0c             	mov    %dl,0xc(%ebx)
  if (p != NULL) {
    len = p->tot_len;
    SYS_ARCH_INC(conn->recv_avail, len);
  } else {
    len = 0;
  80b4b0:	b8 00 00 00 00       	mov    $0x0,%eax
  if (p != NULL) {
  80b4b5:	85 f6                	test   %esi,%esi
  80b4b7:	74 08                	je     80b4c1 <recv_tcp+0x40>
    len = p->tot_len;
  80b4b9:	0f b7 46 08          	movzwl 0x8(%esi),%eax
    SYS_ARCH_INC(conn->recv_avail, len);
  80b4bd:	66 01 43 20          	add    %ax,0x20(%ebx)
  }
  /* Register event with callback */
  API_EVENT(conn, NETCONN_EVT_RCVPLUS, len);
  80b4c1:	8b 53 2c             	mov    0x2c(%ebx),%edx
  80b4c4:	85 d2                	test   %edx,%edx
  80b4c6:	74 0f                	je     80b4d7 <recv_tcp+0x56>
  80b4c8:	83 ec 04             	sub    $0x4,%esp
  80b4cb:	0f b7 c0             	movzwl %ax,%eax
  80b4ce:	50                   	push   %eax
  80b4cf:	6a 00                	push   $0x0
  80b4d1:	53                   	push   %ebx
  80b4d2:	ff d2                	call   *%edx
  80b4d4:	83 c4 10             	add    $0x10,%esp
  if (sys_mbox_trypost(conn->recvmbox, p) != ERR_OK) {
  80b4d7:	83 ec 08             	sub    $0x8,%esp
  80b4da:	56                   	push   %esi
  80b4db:	ff 73 14             	pushl  0x14(%ebx)
  80b4de:	e8 1f ef ff ff       	call   80a402 <sys_mbox_trypost>
  80b4e3:	83 c4 10             	add    $0x10,%esp
  80b4e6:	84 c0                	test   %al,%al
  80b4e8:	0f 95 c0             	setne  %al
  80b4eb:	f7 d8                	neg    %eax
    return ERR_MEM;
  }

  return ERR_OK;
}
  80b4ed:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80b4f0:	5b                   	pop    %ebx
  80b4f1:	5e                   	pop    %esi
  80b4f2:	5d                   	pop    %ebp
  80b4f3:	c3                   	ret    
  LWIP_ASSERT("recv_tcp must have a pcb argument", pcb != NULL);
  80b4f4:	83 ec 04             	sub    $0x4,%esp
  80b4f7:	68 fc 31 81 00       	push   $0x8131fc
  80b4fc:	68 c1 00 00 00       	push   $0xc1
  80b501:	68 46 33 81 00       	push   $0x813346
  80b506:	e8 3c 33 00 00       	call   80e847 <_panic>
  LWIP_ASSERT("recv_tcp must have an argument", arg != NULL);
  80b50b:	83 ec 04             	sub    $0x4,%esp
  80b50e:	68 20 32 81 00       	push   $0x813220
  80b513:	68 c2 00 00 00       	push   $0xc2
  80b518:	68 46 33 81 00       	push   $0x813346
  80b51d:	e8 25 33 00 00       	call   80e847 <_panic>
  LWIP_ASSERT("recv_tcp: recv for wrong pcb!", conn->pcb.tcp == pcb);
  80b522:	83 ec 04             	sub    $0x4,%esp
  80b525:	68 5d 33 81 00       	push   $0x81335d
  80b52a:	68 c4 00 00 00       	push   $0xc4
  80b52f:	68 46 33 81 00       	push   $0x813346
  80b534:	e8 0e 33 00 00       	call   80e847 <_panic>
    return ERR_VAL;
  80b539:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  80b53e:	eb ad                	jmp    80b4ed <recv_tcp+0x6c>

0080b540 <recv_udp>:
{
  80b540:	f3 0f 1e fb          	endbr32 
  80b544:	55                   	push   %ebp
  80b545:	89 e5                	mov    %esp,%ebp
  80b547:	57                   	push   %edi
  80b548:	56                   	push   %esi
  80b549:	53                   	push   %ebx
  80b54a:	83 ec 1c             	sub    $0x1c,%esp
  80b54d:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80b550:	8b 45 0c             	mov    0xc(%ebp),%eax
  80b553:	8b 7d 10             	mov    0x10(%ebp),%edi
  80b556:	8b 4d 18             	mov    0x18(%ebp),%ecx
  80b559:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  LWIP_ASSERT("recv_udp must have a pcb argument", pcb != NULL);
  80b55c:	85 c0                	test   %eax,%eax
  80b55e:	74 7f                	je     80b5df <recv_udp+0x9f>
  LWIP_ASSERT("recv_udp must have an argument", arg != NULL);
  80b560:	85 db                	test   %ebx,%ebx
  80b562:	0f 84 8e 00 00 00    	je     80b5f6 <recv_udp+0xb6>
  LWIP_ASSERT("recv_udp: recv for wrong pcb!", conn->pcb.udp == pcb);
  80b568:	39 43 08             	cmp    %eax,0x8(%ebx)
  80b56b:	0f 85 9c 00 00 00    	jne    80b60d <recv_udp+0xcd>
  if ((conn == NULL) || (conn->recvmbox == SYS_MBOX_NULL)) {
  80b571:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80b575:	0f 84 a9 00 00 00    	je     80b624 <recv_udp+0xe4>
  buf = memp_malloc(MEMP_NETBUF);
  80b57b:	83 ec 0c             	sub    $0xc,%esp
  80b57e:	6a 06                	push   $0x6
  80b580:	e8 c6 8f ff ff       	call   80454b <memp_malloc>
  80b585:	89 c6                	mov    %eax,%esi
  if (buf == NULL) {
  80b587:	83 c4 10             	add    $0x10,%esp
  80b58a:	85 c0                	test   %eax,%eax
  80b58c:	0f 84 a0 00 00 00    	je     80b632 <recv_udp+0xf2>
    buf->p = p;
  80b592:	89 38                	mov    %edi,(%eax)
    buf->ptr = p;
  80b594:	89 78 04             	mov    %edi,0x4(%eax)
    buf->addr = addr;
  80b597:	8b 45 14             	mov    0x14(%ebp),%eax
  80b59a:	89 46 08             	mov    %eax,0x8(%esi)
    buf->port = port;
  80b59d:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  80b5a1:	66 89 46 0c          	mov    %ax,0xc(%esi)
  SYS_ARCH_INC(conn->recv_avail, p->tot_len);
  80b5a5:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  80b5a9:	66 01 43 20          	add    %ax,0x20(%ebx)
  API_EVENT(conn, NETCONN_EVT_RCVPLUS, p->tot_len);
  80b5ad:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80b5b0:	85 c0                	test   %eax,%eax
  80b5b2:	74 10                	je     80b5c4 <recv_udp+0x84>
  80b5b4:	83 ec 04             	sub    $0x4,%esp
  80b5b7:	0f b7 57 08          	movzwl 0x8(%edi),%edx
  80b5bb:	52                   	push   %edx
  80b5bc:	6a 00                	push   $0x0
  80b5be:	53                   	push   %ebx
  80b5bf:	ff d0                	call   *%eax
  80b5c1:	83 c4 10             	add    $0x10,%esp
  if (sys_mbox_trypost(conn->recvmbox, buf) != ERR_OK) {
  80b5c4:	83 ec 08             	sub    $0x8,%esp
  80b5c7:	56                   	push   %esi
  80b5c8:	ff 73 14             	pushl  0x14(%ebx)
  80b5cb:	e8 32 ee ff ff       	call   80a402 <sys_mbox_trypost>
  80b5d0:	83 c4 10             	add    $0x10,%esp
  80b5d3:	84 c0                	test   %al,%al
  80b5d5:	75 69                	jne    80b640 <recv_udp+0x100>
}
  80b5d7:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80b5da:	5b                   	pop    %ebx
  80b5db:	5e                   	pop    %esi
  80b5dc:	5f                   	pop    %edi
  80b5dd:	5d                   	pop    %ebp
  80b5de:	c3                   	ret    
  LWIP_ASSERT("recv_udp must have a pcb argument", pcb != NULL);
  80b5df:	83 ec 04             	sub    $0x4,%esp
  80b5e2:	68 40 32 81 00       	push   $0x813240
  80b5e7:	68 8e 00 00 00       	push   $0x8e
  80b5ec:	68 46 33 81 00       	push   $0x813346
  80b5f1:	e8 51 32 00 00       	call   80e847 <_panic>
  LWIP_ASSERT("recv_udp must have an argument", arg != NULL);
  80b5f6:	83 ec 04             	sub    $0x4,%esp
  80b5f9:	68 64 32 81 00       	push   $0x813264
  80b5fe:	68 8f 00 00 00       	push   $0x8f
  80b603:	68 46 33 81 00       	push   $0x813346
  80b608:	e8 3a 32 00 00       	call   80e847 <_panic>
  LWIP_ASSERT("recv_udp: recv for wrong pcb!", conn->pcb.udp == pcb);
  80b60d:	83 ec 04             	sub    $0x4,%esp
  80b610:	68 7b 33 81 00       	push   $0x81337b
  80b615:	68 91 00 00 00       	push   $0x91
  80b61a:	68 46 33 81 00       	push   $0x813346
  80b61f:	e8 23 32 00 00       	call   80e847 <_panic>
    pbuf_free(p);
  80b624:	83 ec 0c             	sub    $0xc,%esp
  80b627:	57                   	push   %edi
  80b628:	e8 fb 92 ff ff       	call   804928 <pbuf_free>
    return;
  80b62d:	83 c4 10             	add    $0x10,%esp
  80b630:	eb a5                	jmp    80b5d7 <recv_udp+0x97>
    pbuf_free(p);
  80b632:	83 ec 0c             	sub    $0xc,%esp
  80b635:	57                   	push   %edi
  80b636:	e8 ed 92 ff ff       	call   804928 <pbuf_free>
    return;
  80b63b:	83 c4 10             	add    $0x10,%esp
  80b63e:	eb 97                	jmp    80b5d7 <recv_udp+0x97>
    netbuf_delete(buf);
  80b640:	83 ec 0c             	sub    $0xc,%esp
  80b643:	56                   	push   %esi
  80b644:	e8 bf 6e ff ff       	call   802508 <netbuf_delete>
    return;
  80b649:	83 c4 10             	add    $0x10,%esp
  80b64c:	eb 89                	jmp    80b5d7 <recv_udp+0x97>

0080b64e <recv_raw>:
{
  80b64e:	f3 0f 1e fb          	endbr32 
  80b652:	55                   	push   %ebp
  80b653:	89 e5                	mov    %esp,%ebp
  80b655:	57                   	push   %edi
  80b656:	56                   	push   %esi
  80b657:	53                   	push   %ebx
  80b658:	83 ec 0c             	sub    $0xc,%esp
  80b65b:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if ((conn != NULL) && (conn->recvmbox != SYS_MBOX_NULL)) {
  80b65e:	85 db                	test   %ebx,%ebx
  80b660:	74 06                	je     80b668 <recv_raw+0x1a>
  80b662:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80b666:	75 0d                	jne    80b675 <recv_raw+0x27>
}
  80b668:	b8 00 00 00 00       	mov    $0x0,%eax
  80b66d:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80b670:	5b                   	pop    %ebx
  80b671:	5e                   	pop    %esi
  80b672:	5f                   	pop    %edi
  80b673:	5d                   	pop    %ebp
  80b674:	c3                   	ret    
    q = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
  80b675:	83 ec 04             	sub    $0x4,%esp
  80b678:	6a 00                	push   $0x0
  80b67a:	8b 45 10             	mov    0x10(%ebp),%eax
  80b67d:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  80b681:	50                   	push   %eax
  80b682:	6a 03                	push   $0x3
  80b684:	e8 69 93 ff ff       	call   8049f2 <pbuf_alloc>
  80b689:	89 c6                	mov    %eax,%esi
    if(q != NULL) {
  80b68b:	83 c4 10             	add    $0x10,%esp
  80b68e:	85 c0                	test   %eax,%eax
  80b690:	74 d6                	je     80b668 <recv_raw+0x1a>
      if (pbuf_copy(q, p) != ERR_OK) {
  80b692:	83 ec 08             	sub    $0x8,%esp
  80b695:	ff 75 10             	pushl  0x10(%ebp)
  80b698:	50                   	push   %eax
  80b699:	e8 3b 98 ff ff       	call   804ed9 <pbuf_copy>
  80b69e:	83 c4 10             	add    $0x10,%esp
  80b6a1:	84 c0                	test   %al,%al
  80b6a3:	75 73                	jne    80b718 <recv_raw+0xca>
      buf = memp_malloc(MEMP_NETBUF);
  80b6a5:	83 ec 0c             	sub    $0xc,%esp
  80b6a8:	6a 06                	push   $0x6
  80b6aa:	e8 9c 8e ff ff       	call   80454b <memp_malloc>
  80b6af:	89 c7                	mov    %eax,%edi
      if (buf == NULL) {
  80b6b1:	83 c4 10             	add    $0x10,%esp
  80b6b4:	85 c0                	test   %eax,%eax
  80b6b6:	74 71                	je     80b729 <recv_raw+0xdb>
      buf->p = q;
  80b6b8:	89 37                	mov    %esi,(%edi)
      buf->ptr = q;
  80b6ba:	89 77 04             	mov    %esi,0x4(%edi)
      buf->addr = &(((struct ip_hdr*)(q->payload))->src);
  80b6bd:	8b 46 04             	mov    0x4(%esi),%eax
  80b6c0:	83 c0 0c             	add    $0xc,%eax
  80b6c3:	89 47 08             	mov    %eax,0x8(%edi)
      buf->port = pcb->protocol;
  80b6c6:	8b 45 0c             	mov    0xc(%ebp),%eax
  80b6c9:	0f b6 40 10          	movzbl 0x10(%eax),%eax
  80b6cd:	66 89 47 0c          	mov    %ax,0xc(%edi)
      SYS_ARCH_INC(conn->recv_avail, q->tot_len);
  80b6d1:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  80b6d5:	66 01 43 20          	add    %ax,0x20(%ebx)
      API_EVENT(conn, NETCONN_EVT_RCVPLUS, q->tot_len);
  80b6d9:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80b6dc:	85 c0                	test   %eax,%eax
  80b6de:	74 10                	je     80b6f0 <recv_raw+0xa2>
  80b6e0:	83 ec 04             	sub    $0x4,%esp
  80b6e3:	0f b7 56 08          	movzwl 0x8(%esi),%edx
  80b6e7:	52                   	push   %edx
  80b6e8:	6a 00                	push   $0x0
  80b6ea:	53                   	push   %ebx
  80b6eb:	ff d0                	call   *%eax
  80b6ed:	83 c4 10             	add    $0x10,%esp
      if (sys_mbox_trypost(conn->recvmbox, buf) != ERR_OK) {
  80b6f0:	83 ec 08             	sub    $0x8,%esp
  80b6f3:	57                   	push   %edi
  80b6f4:	ff 73 14             	pushl  0x14(%ebx)
  80b6f7:	e8 06 ed ff ff       	call   80a402 <sys_mbox_trypost>
  80b6fc:	83 c4 10             	add    $0x10,%esp
  80b6ff:	84 c0                	test   %al,%al
  80b701:	0f 84 61 ff ff ff    	je     80b668 <recv_raw+0x1a>
        netbuf_delete(buf);
  80b707:	83 ec 0c             	sub    $0xc,%esp
  80b70a:	57                   	push   %edi
  80b70b:	e8 f8 6d ff ff       	call   802508 <netbuf_delete>
  80b710:	83 c4 10             	add    $0x10,%esp
  80b713:	e9 50 ff ff ff       	jmp    80b668 <recv_raw+0x1a>
        pbuf_free(q);
  80b718:	83 ec 0c             	sub    $0xc,%esp
  80b71b:	56                   	push   %esi
  80b71c:	e8 07 92 ff ff       	call   804928 <pbuf_free>
  80b721:	83 c4 10             	add    $0x10,%esp
  80b724:	e9 3f ff ff ff       	jmp    80b668 <recv_raw+0x1a>
        pbuf_free(q);
  80b729:	83 ec 0c             	sub    $0xc,%esp
  80b72c:	56                   	push   %esi
  80b72d:	e8 f6 91 ff ff       	call   804928 <pbuf_free>
        return 0;
  80b732:	83 c4 10             	add    $0x10,%esp
  80b735:	e9 2e ff ff ff       	jmp    80b668 <recv_raw+0x1a>

0080b73a <setup_tcp>:
 *
 * @param conn the TCP netconn to setup
 */
static void
setup_tcp(struct netconn *conn)
{
  80b73a:	55                   	push   %ebp
  80b73b:	89 e5                	mov    %esp,%ebp
  80b73d:	53                   	push   %ebx
  80b73e:	83 ec 0c             	sub    $0xc,%esp
  struct tcp_pcb *pcb;

  pcb = conn->pcb.tcp;
  80b741:	8b 58 08             	mov    0x8(%eax),%ebx
  tcp_arg(pcb, conn);
  80b744:	50                   	push   %eax
  80b745:	53                   	push   %ebx
  80b746:	e8 f6 a1 ff ff       	call   805941 <tcp_arg>
  tcp_recv(pcb, recv_tcp);
  80b74b:	83 c4 08             	add    $0x8,%esp
  80b74e:	68 81 b4 80 00       	push   $0x80b481
  80b753:	53                   	push   %ebx
  80b754:	e8 fa a1 ff ff       	call   805953 <tcp_recv>
  tcp_sent(pcb, sent_tcp);
  80b759:	83 c4 08             	add    $0x8,%esp
  80b75c:	68 28 bc 80 00       	push   $0x80bc28
  80b761:	53                   	push   %ebx
  80b762:	e8 01 a2 ff ff       	call   805968 <tcp_sent>
  tcp_poll(pcb, poll_tcp, 4);
  80b767:	83 c4 0c             	add    $0xc,%esp
  80b76a:	6a 04                	push   $0x4
  80b76c:	68 de bb 80 00       	push   $0x80bbde
  80b771:	53                   	push   %ebx
  80b772:	e8 2d a2 ff ff       	call   8059a4 <tcp_poll>
  tcp_err(pcb, err_tcp);
  80b777:	83 c4 08             	add    $0x8,%esp
  80b77a:	68 dd b7 80 00       	push   $0x80b7dd
  80b77f:	53                   	push   %ebx
  80b780:	e8 f8 a1 ff ff       	call   80597d <tcp_err>
}
  80b785:	83 c4 10             	add    $0x10,%esp
  80b788:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b78b:	c9                   	leave  
  80b78c:	c3                   	ret    

0080b78d <do_connected>:
 *
 * @see tcp.h (struct tcp_pcb.connected) for parameters and return values
 */
static err_t
do_connected(void *arg, struct tcp_pcb *pcb, err_t err)
{
  80b78d:	f3 0f 1e fb          	endbr32 
  80b791:	55                   	push   %ebp
  80b792:	89 e5                	mov    %esp,%ebp
  80b794:	53                   	push   %ebx
  80b795:	83 ec 04             	sub    $0x4,%esp
  80b798:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80b79b:	8b 45 10             	mov    0x10(%ebp),%eax

  LWIP_UNUSED_ARG(pcb);

  conn = arg;

  if (conn == NULL) {
  80b79e:	85 db                	test   %ebx,%ebx
  80b7a0:	74 34                	je     80b7d6 <do_connected+0x49>
    return ERR_VAL;
  }

  conn->err = err;
  80b7a2:	88 43 0c             	mov    %al,0xc(%ebx)
  if ((conn->type == NETCONN_TCP) && (err == ERR_OK)) {
  80b7a5:	83 3b 10             	cmpl   $0x10,(%ebx)
  80b7a8:	75 04                	jne    80b7ae <do_connected+0x21>
  80b7aa:	84 c0                	test   %al,%al
  80b7ac:	74 1f                	je     80b7cd <do_connected+0x40>
    setup_tcp(conn);
  }
  conn->state = NETCONN_NONE;
  80b7ae:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  sys_sem_signal(conn->op_completed);
  80b7b5:	83 ec 0c             	sub    $0xc,%esp
  80b7b8:	ff 73 10             	pushl  0x10(%ebx)
  80b7bb:	e8 ba ea ff ff       	call   80a27a <sys_sem_signal>
  return ERR_OK;
  80b7c0:	83 c4 10             	add    $0x10,%esp
  80b7c3:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80b7c8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b7cb:	c9                   	leave  
  80b7cc:	c3                   	ret    
    setup_tcp(conn);
  80b7cd:	89 d8                	mov    %ebx,%eax
  80b7cf:	e8 66 ff ff ff       	call   80b73a <setup_tcp>
  80b7d4:	eb d8                	jmp    80b7ae <do_connected+0x21>
    return ERR_VAL;
  80b7d6:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  80b7db:	eb eb                	jmp    80b7c8 <do_connected+0x3b>

0080b7dd <err_tcp>:
{
  80b7dd:	f3 0f 1e fb          	endbr32 
  80b7e1:	55                   	push   %ebp
  80b7e2:	89 e5                	mov    %esp,%ebp
  80b7e4:	53                   	push   %ebx
  80b7e5:	83 ec 04             	sub    $0x4,%esp
  80b7e8:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80b7eb:	8b 45 0c             	mov    0xc(%ebp),%eax
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  80b7ee:	85 db                	test   %ebx,%ebx
  80b7f0:	74 7e                	je     80b870 <err_tcp+0x93>
  conn->pcb.tcp = NULL;
  80b7f2:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
  conn->err = err;
  80b7f9:	88 43 0c             	mov    %al,0xc(%ebx)
  if (conn->recvmbox != SYS_MBOX_NULL) {
  80b7fc:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80b800:	74 24                	je     80b826 <err_tcp+0x49>
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  80b802:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80b805:	85 c0                	test   %eax,%eax
  80b807:	74 0d                	je     80b816 <err_tcp+0x39>
  80b809:	83 ec 04             	sub    $0x4,%esp
  80b80c:	6a 00                	push   $0x0
  80b80e:	6a 00                	push   $0x0
  80b810:	53                   	push   %ebx
  80b811:	ff d0                	call   *%eax
  80b813:	83 c4 10             	add    $0x10,%esp
    sys_mbox_post(conn->recvmbox, NULL);
  80b816:	83 ec 08             	sub    $0x8,%esp
  80b819:	6a 00                	push   $0x0
  80b81b:	ff 73 14             	pushl  0x14(%ebx)
  80b81e:	e8 a8 ec ff ff       	call   80a4cb <sys_mbox_post>
  80b823:	83 c4 10             	add    $0x10,%esp
  if (conn->op_completed != SYS_SEM_NULL && conn->state == NETCONN_CONNECT) {
  80b826:	8b 43 10             	mov    0x10(%ebx),%eax
  80b829:	83 f8 ff             	cmp    $0xffffffff,%eax
  80b82c:	74 06                	je     80b834 <err_tcp+0x57>
  80b82e:	83 7b 04 03          	cmpl   $0x3,0x4(%ebx)
  80b832:	74 53                	je     80b887 <err_tcp+0xaa>
  if (conn->acceptmbox != SYS_MBOX_NULL) {
  80b834:	83 7b 18 ff          	cmpl   $0xffffffff,0x18(%ebx)
  80b838:	74 24                	je     80b85e <err_tcp+0x81>
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  80b83a:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80b83d:	85 c0                	test   %eax,%eax
  80b83f:	74 0d                	je     80b84e <err_tcp+0x71>
  80b841:	83 ec 04             	sub    $0x4,%esp
  80b844:	6a 00                	push   $0x0
  80b846:	6a 00                	push   $0x0
  80b848:	53                   	push   %ebx
  80b849:	ff d0                	call   *%eax
  80b84b:	83 c4 10             	add    $0x10,%esp
    sys_mbox_post(conn->acceptmbox, NULL);
  80b84e:	83 ec 08             	sub    $0x8,%esp
  80b851:	6a 00                	push   $0x0
  80b853:	ff 73 18             	pushl  0x18(%ebx)
  80b856:	e8 70 ec ff ff       	call   80a4cb <sys_mbox_post>
  80b85b:	83 c4 10             	add    $0x10,%esp
  if ((conn->state == NETCONN_WRITE) || (conn->state == NETCONN_CLOSE)) {
  80b85e:	8b 43 04             	mov    0x4(%ebx),%eax
  80b861:	83 f8 01             	cmp    $0x1,%eax
  80b864:	74 36                	je     80b89c <err_tcp+0xbf>
  80b866:	83 f8 04             	cmp    $0x4,%eax
  80b869:	74 31                	je     80b89c <err_tcp+0xbf>
}
  80b86b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b86e:	c9                   	leave  
  80b86f:	c3                   	ret    
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  80b870:	83 ec 04             	sub    $0x4,%esp
  80b873:	68 99 33 81 00       	push   $0x813399
  80b878:	68 22 01 00 00       	push   $0x122
  80b87d:	68 46 33 81 00       	push   $0x813346
  80b882:	e8 c0 2f 00 00       	call   80e847 <_panic>
    conn->state = NETCONN_NONE;
  80b887:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    sys_sem_signal(conn->op_completed);
  80b88e:	83 ec 0c             	sub    $0xc,%esp
  80b891:	50                   	push   %eax
  80b892:	e8 e3 e9 ff ff       	call   80a27a <sys_sem_signal>
  80b897:	83 c4 10             	add    $0x10,%esp
  80b89a:	eb 98                	jmp    80b834 <err_tcp+0x57>
    conn->state = NETCONN_NONE;
  80b89c:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    sys_sem_signal(conn->op_completed);
  80b8a3:	83 ec 0c             	sub    $0xc,%esp
  80b8a6:	ff 73 10             	pushl  0x10(%ebx)
  80b8a9:	e8 cc e9 ff ff       	call   80a27a <sys_sem_signal>
  80b8ae:	83 c4 10             	add    $0x10,%esp
}
  80b8b1:	eb b8                	jmp    80b86b <err_tcp+0x8e>

0080b8b3 <do_writemore>:
 * @return ERR_OK
 *         ERR_MEM if LWIP_TCPIP_CORE_LOCKING=1 and sending hasn't yet finished
 */
static err_t
do_writemore(struct netconn *conn)
{
  80b8b3:	55                   	push   %ebp
  80b8b4:	89 e5                	mov    %esp,%ebp
  80b8b6:	57                   	push   %edi
  80b8b7:	56                   	push   %esi
  80b8b8:	53                   	push   %ebx
  80b8b9:	83 ec 0c             	sub    $0xc,%esp
  err_t err;
  void *dataptr;
  u16_t len, available;
  u8_t write_finished = 0;

  LWIP_ASSERT("conn->state == NETCONN_WRITE", (conn->state == NETCONN_WRITE));
  80b8bc:	83 78 04 01          	cmpl   $0x1,0x4(%eax)
  80b8c0:	0f 85 c9 00 00 00    	jne    80b98f <do_writemore+0xdc>
  80b8c6:	89 c3                	mov    %eax,%ebx

  dataptr = (u8_t*)conn->write_msg->msg.w.dataptr + conn->write_offset;
  80b8c8:	8b 40 24             	mov    0x24(%eax),%eax
  80b8cb:	8b 7b 28             	mov    0x28(%ebx),%edi
  80b8ce:	89 fa                	mov    %edi,%edx
  80b8d0:	03 50 04             	add    0x4(%eax),%edx
  if ((conn->write_msg->msg.w.len - conn->write_offset > 0xffff)) { /* max_u16_t */
  80b8d3:	8b 70 08             	mov    0x8(%eax),%esi
  80b8d6:	89 f1                	mov    %esi,%ecx
  80b8d8:	29 f9                	sub    %edi,%ecx
    len = 0xffff;
#if LWIP_TCPIP_CORE_LOCKING
    conn->write_delayed = 1;
#endif
  } else {
    len = conn->write_msg->msg.w.len - conn->write_offset;
  80b8da:	29 fe                	sub    %edi,%esi
  80b8dc:	81 f9 00 00 01 00    	cmp    $0x10000,%ecx
  80b8e2:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
  80b8e7:	0f 4d f1             	cmovge %ecx,%esi
  }
  available = tcp_sndbuf(conn->pcb.tcp);
  80b8ea:	8b 4b 08             	mov    0x8(%ebx),%ecx
#if LWIP_TCPIP_CORE_LOCKING
    conn->write_delayed = 1;
#endif
  }

  err = tcp_write(conn->pcb.tcp, dataptr, len, conn->write_msg->msg.w.apiflags);
  80b8ed:	66 39 71 6e          	cmp    %si,0x6e(%ecx)
  80b8f1:	66 0f 46 71 6e       	cmovbe 0x6e(%ecx),%si
  80b8f6:	0f b7 f6             	movzwl %si,%esi
  80b8f9:	0f b6 40 0c          	movzbl 0xc(%eax),%eax
  80b8fd:	50                   	push   %eax
  80b8fe:	56                   	push   %esi
  80b8ff:	52                   	push   %edx
  80b900:	51                   	push   %ecx
  80b901:	e8 85 c8 ff ff       	call   80818b <tcp_write>
  LWIP_ASSERT("do_writemore: invalid length!", ((conn->write_offset + len) <= conn->write_msg->msg.w.len));
  80b906:	89 f2                	mov    %esi,%edx
  80b908:	03 53 28             	add    0x28(%ebx),%edx
  80b90b:	8b 4b 24             	mov    0x24(%ebx),%ecx
  80b90e:	83 c4 10             	add    $0x10,%esp
  80b911:	3b 51 08             	cmp    0x8(%ecx),%edx
  80b914:	0f 8f 8c 00 00 00    	jg     80b9a6 <do_writemore+0xf3>
  if (err == ERR_OK) {
  80b91a:	84 c0                	test   %al,%al
  80b91c:	0f 85 bf 00 00 00    	jne    80b9e1 <do_writemore+0x12e>
    conn->write_offset += len;
  80b922:	89 53 28             	mov    %edx,0x28(%ebx)
  u8_t write_finished = 0;
  80b925:	bf 00 00 00 00       	mov    $0x0,%edi
    if (conn->write_offset == conn->write_msg->msg.w.len) {
  80b92a:	3b 51 08             	cmp    0x8(%ecx),%edx
  80b92d:	0f 84 8a 00 00 00    	je     80b9bd <do_writemore+0x10a>
      /* everything was written */
      write_finished = 1;
      conn->write_msg = NULL;
      conn->write_offset = 0;
    }
    err = tcp_output_nagle(conn->pcb.tcp);
  80b933:	8b 43 08             	mov    0x8(%ebx),%eax
  80b936:	83 78 78 00          	cmpl   $0x0,0x78(%eax)
  80b93a:	74 1a                	je     80b956 <do_writemore+0xa3>
  80b93c:	f6 40 20 40          	testb  $0x40,0x20(%eax)
  80b940:	75 14                	jne    80b956 <do_writemore+0xa3>
  80b942:	8b 50 74             	mov    0x74(%eax),%edx
  80b945:	85 d2                	test   %edx,%edx
  80b947:	0f 84 88 00 00 00    	je     80b9d5 <do_writemore+0x122>
  80b94d:	83 3a 00             	cmpl   $0x0,(%edx)
  80b950:	0f 84 85 00 00 00    	je     80b9db <do_writemore+0x128>
  80b956:	83 ec 0c             	sub    $0xc,%esp
  80b959:	50                   	push   %eax
  80b95a:	e8 87 c8 ff ff       	call   8081e6 <tcp_output>
    conn->err = err;
  80b95f:	88 43 0c             	mov    %al,0xc(%ebx)
    if ((err == ERR_OK) && (tcp_sndbuf(conn->pcb.tcp) <= TCP_SNDLOWAT)) {
  80b962:	83 c4 10             	add    $0x10,%esp
  80b965:	84 c0                	test   %al,%al
  80b967:	75 1e                	jne    80b987 <do_writemore+0xd4>
  80b969:	8b 43 08             	mov    0x8(%ebx),%eax
  80b96c:	66 81 78 6e a0 2d    	cmpw   $0x2da0,0x6e(%eax)
  80b972:	77 13                	ja     80b987 <do_writemore+0xd4>
      API_EVENT(conn, NETCONN_EVT_SENDMINUS, len);
  80b974:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80b977:	85 c0                	test   %eax,%eax
  80b979:	74 0c                	je     80b987 <do_writemore+0xd4>
  80b97b:	83 ec 04             	sub    $0x4,%esp
  80b97e:	56                   	push   %esi
  80b97f:	6a 03                	push   $0x3
  80b981:	53                   	push   %ebx
  80b982:	ff d0                	call   *%eax
  80b984:	83 c4 10             	add    $0x10,%esp
       the error to the application thread. */
    conn->err = err;
    write_finished = 1;
  }

  if (write_finished) {
  80b987:	89 f8                	mov    %edi,%eax
  80b989:	84 c0                	test   %al,%al
  80b98b:	74 70                	je     80b9fd <do_writemore+0x14a>
  80b98d:	eb 59                	jmp    80b9e8 <do_writemore+0x135>
  LWIP_ASSERT("conn->state == NETCONN_WRITE", (conn->state == NETCONN_WRITE));
  80b98f:	83 ec 04             	sub    $0x4,%esp
  80b992:	68 a6 33 81 00       	push   $0x8133a6
  80b997:	68 b8 03 00 00       	push   $0x3b8
  80b99c:	68 46 33 81 00       	push   $0x813346
  80b9a1:	e8 a1 2e 00 00       	call   80e847 <_panic>
  LWIP_ASSERT("do_writemore: invalid length!", ((conn->write_offset + len) <= conn->write_msg->msg.w.len));
  80b9a6:	83 ec 04             	sub    $0x4,%esp
  80b9a9:	68 c3 33 81 00       	push   $0x8133c3
  80b9ae:	68 cd 03 00 00       	push   $0x3cd
  80b9b3:	68 46 33 81 00       	push   $0x813346
  80b9b8:	e8 8a 2e 00 00       	call   80e847 <_panic>
      conn->write_msg = NULL;
  80b9bd:	c7 43 24 00 00 00 00 	movl   $0x0,0x24(%ebx)
      conn->write_offset = 0;
  80b9c4:	c7 43 28 00 00 00 00 	movl   $0x0,0x28(%ebx)
      write_finished = 1;
  80b9cb:	bf 01 00 00 00       	mov    $0x1,%edi
  80b9d0:	e9 5e ff ff ff       	jmp    80b933 <do_writemore+0x80>
    conn->err = err;
  80b9d5:	c6 43 0c 00          	movb   $0x0,0xc(%ebx)
  80b9d9:	eb 8e                	jmp    80b969 <do_writemore+0xb6>
  80b9db:	c6 43 0c 00          	movb   $0x0,0xc(%ebx)
  80b9df:	eb 88                	jmp    80b969 <do_writemore+0xb6>
  } else if (err == ERR_MEM) {
  80b9e1:	3c ff                	cmp    $0xff,%al
  80b9e3:	74 25                	je     80ba0a <do_writemore+0x157>
    conn->err = err;
  80b9e5:	88 43 0c             	mov    %al,0xc(%ebx)
    /* everything was written: set back connection state
       and back to application task */
    conn->state = NETCONN_NONE;
  80b9e8:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
#if LWIP_TCPIP_CORE_LOCKING
    if (conn->write_delayed != 0)
#endif
    {
      sys_sem_signal(conn->op_completed);
  80b9ef:	83 ec 0c             	sub    $0xc,%esp
  80b9f2:	ff 73 10             	pushl  0x10(%ebx)
  80b9f5:	e8 80 e8 ff ff       	call   80a27a <sys_sem_signal>
  80b9fa:	83 c4 10             	add    $0x10,%esp
#if LWIP_TCPIP_CORE_LOCKING
  else
    return ERR_MEM;
#endif
  return ERR_OK;
}
  80b9fd:	b8 00 00 00 00       	mov    $0x0,%eax
  80ba02:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80ba05:	5b                   	pop    %ebx
  80ba06:	5e                   	pop    %esi
  80ba07:	5f                   	pop    %edi
  80ba08:	5d                   	pop    %ebp
  80ba09:	c3                   	ret    
    err = tcp_output(conn->pcb.tcp);
  80ba0a:	83 ec 0c             	sub    $0xc,%esp
  80ba0d:	ff 73 08             	pushl  0x8(%ebx)
  80ba10:	e8 d1 c7 ff ff       	call   8081e6 <tcp_output>
  80ba15:	83 c4 10             	add    $0x10,%esp
  80ba18:	eb e3                	jmp    80b9fd <do_writemore+0x14a>

0080ba1a <do_close_internal>:
{
  80ba1a:	55                   	push   %ebp
  80ba1b:	89 e5                	mov    %esp,%ebp
  80ba1d:	53                   	push   %ebx
  80ba1e:	83 ec 04             	sub    $0x4,%esp
  LWIP_ASSERT("invalid conn", (conn != NULL));
  80ba21:	85 c0                	test   %eax,%eax
  80ba23:	0f 84 e2 00 00 00    	je     80bb0b <do_close_internal+0xf1>
  80ba29:	89 c3                	mov    %eax,%ebx
  LWIP_ASSERT("this is for tcp netconns only", (conn->type == NETCONN_TCP));
  80ba2b:	83 38 10             	cmpl   $0x10,(%eax)
  80ba2e:	0f 85 ee 00 00 00    	jne    80bb22 <do_close_internal+0x108>
  LWIP_ASSERT("conn must be in state NETCONN_CLOSE", (conn->state == NETCONN_CLOSE));
  80ba34:	83 78 04 04          	cmpl   $0x4,0x4(%eax)
  80ba38:	0f 85 fb 00 00 00    	jne    80bb39 <do_close_internal+0x11f>
  LWIP_ASSERT("pcb already closed", (conn->pcb.tcp != NULL));
  80ba3e:	8b 40 08             	mov    0x8(%eax),%eax
  80ba41:	85 c0                	test   %eax,%eax
  80ba43:	0f 84 07 01 00 00    	je     80bb50 <do_close_internal+0x136>
  tcp_arg(conn->pcb.tcp, NULL);
  80ba49:	83 ec 08             	sub    $0x8,%esp
  80ba4c:	6a 00                	push   $0x0
  80ba4e:	50                   	push   %eax
  80ba4f:	e8 ed 9e ff ff       	call   805941 <tcp_arg>
  if (conn->pcb.tcp->state == LISTEN) {
  80ba54:	8b 43 08             	mov    0x8(%ebx),%eax
  80ba57:	83 c4 10             	add    $0x10,%esp
  80ba5a:	83 78 10 01          	cmpl   $0x1,0x10(%eax)
  80ba5e:	0f 84 03 01 00 00    	je     80bb67 <do_close_internal+0x14d>
    tcp_recv(conn->pcb.tcp, NULL);
  80ba64:	83 ec 08             	sub    $0x8,%esp
  80ba67:	6a 00                	push   $0x0
  80ba69:	50                   	push   %eax
  80ba6a:	e8 e4 9e ff ff       	call   805953 <tcp_recv>
    tcp_accept(conn->pcb.tcp, NULL);
  80ba6f:	83 c4 08             	add    $0x8,%esp
  80ba72:	6a 00                	push   $0x0
  80ba74:	ff 73 08             	pushl  0x8(%ebx)
  80ba77:	e8 16 9f ff ff       	call   805992 <tcp_accept>
    tcp_sent(conn->pcb.tcp, NULL);
  80ba7c:	83 c4 08             	add    $0x8,%esp
  80ba7f:	6a 00                	push   $0x0
  80ba81:	ff 73 08             	pushl  0x8(%ebx)
  80ba84:	e8 df 9e ff ff       	call   805968 <tcp_sent>
    tcp_poll(conn->pcb.tcp, NULL, 4);
  80ba89:	83 c4 0c             	add    $0xc,%esp
  80ba8c:	6a 04                	push   $0x4
  80ba8e:	6a 00                	push   $0x0
  80ba90:	ff 73 08             	pushl  0x8(%ebx)
  80ba93:	e8 0c 9f ff ff       	call   8059a4 <tcp_poll>
    tcp_err(conn->pcb.tcp, NULL);
  80ba98:	83 c4 08             	add    $0x8,%esp
  80ba9b:	6a 00                	push   $0x0
  80ba9d:	ff 73 08             	pushl  0x8(%ebx)
  80baa0:	e8 d8 9e ff ff       	call   80597d <tcp_err>
  80baa5:	83 c4 10             	add    $0x10,%esp
  err = tcp_close(conn->pcb.tcp);
  80baa8:	83 ec 0c             	sub    $0xc,%esp
  80baab:	ff 73 08             	pushl  0x8(%ebx)
  80baae:	e8 a0 a0 ff ff       	call   805b53 <tcp_close>
  if (err == ERR_OK) {
  80bab3:	83 c4 10             	add    $0x10,%esp
  80bab6:	84 c0                	test   %al,%al
  80bab8:	0f 85 bc 00 00 00    	jne    80bb7a <do_close_internal+0x160>
    conn->state = NETCONN_NONE;
  80babe:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    conn->pcb.tcp = NULL;
  80bac5:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    conn->err = ERR_OK;
  80bacc:	c6 43 0c 00          	movb   $0x0,0xc(%ebx)
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  80bad0:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80bad3:	85 c0                	test   %eax,%eax
  80bad5:	74 21                	je     80baf8 <do_close_internal+0xde>
  80bad7:	83 ec 04             	sub    $0x4,%esp
  80bada:	6a 00                	push   $0x0
  80badc:	6a 00                	push   $0x0
  80bade:	53                   	push   %ebx
  80badf:	ff d0                	call   *%eax
    API_EVENT(conn, NETCONN_EVT_SENDPLUS, 0);
  80bae1:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80bae4:	83 c4 10             	add    $0x10,%esp
  80bae7:	85 c0                	test   %eax,%eax
  80bae9:	74 0d                	je     80baf8 <do_close_internal+0xde>
  80baeb:	83 ec 04             	sub    $0x4,%esp
  80baee:	6a 00                	push   $0x0
  80baf0:	6a 02                	push   $0x2
  80baf2:	53                   	push   %ebx
  80baf3:	ff d0                	call   *%eax
  80baf5:	83 c4 10             	add    $0x10,%esp
    sys_sem_signal(conn->op_completed);
  80baf8:	83 ec 0c             	sub    $0xc,%esp
  80bafb:	ff 73 10             	pushl  0x10(%ebx)
  80bafe:	e8 77 e7 ff ff       	call   80a27a <sys_sem_signal>
  80bb03:	83 c4 10             	add    $0x10,%esp
}
  80bb06:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80bb09:	c9                   	leave  
  80bb0a:	c3                   	ret    
  LWIP_ASSERT("invalid conn", (conn != NULL));
  80bb0b:	83 ec 04             	sub    $0x4,%esp
  80bb0e:	68 b4 31 81 00       	push   $0x8131b4
  80bb13:	68 53 02 00 00       	push   $0x253
  80bb18:	68 46 33 81 00       	push   $0x813346
  80bb1d:	e8 25 2d 00 00       	call   80e847 <_panic>
  LWIP_ASSERT("this is for tcp netconns only", (conn->type == NETCONN_TCP));
  80bb22:	83 ec 04             	sub    $0x4,%esp
  80bb25:	68 e1 33 81 00       	push   $0x8133e1
  80bb2a:	68 54 02 00 00       	push   $0x254
  80bb2f:	68 46 33 81 00       	push   $0x813346
  80bb34:	e8 0e 2d 00 00       	call   80e847 <_panic>
  LWIP_ASSERT("conn must be in state NETCONN_CLOSE", (conn->state == NETCONN_CLOSE));
  80bb39:	83 ec 04             	sub    $0x4,%esp
  80bb3c:	68 84 32 81 00       	push   $0x813284
  80bb41:	68 55 02 00 00       	push   $0x255
  80bb46:	68 46 33 81 00       	push   $0x813346
  80bb4b:	e8 f7 2c 00 00       	call   80e847 <_panic>
  LWIP_ASSERT("pcb already closed", (conn->pcb.tcp != NULL));
  80bb50:	83 ec 04             	sub    $0x4,%esp
  80bb53:	68 ff 33 81 00       	push   $0x8133ff
  80bb58:	68 56 02 00 00       	push   $0x256
  80bb5d:	68 46 33 81 00       	push   $0x813346
  80bb62:	e8 e0 2c 00 00       	call   80e847 <_panic>
    tcp_accept(conn->pcb.tcp, NULL);
  80bb67:	83 ec 08             	sub    $0x8,%esp
  80bb6a:	6a 00                	push   $0x0
  80bb6c:	50                   	push   %eax
  80bb6d:	e8 20 9e ff ff       	call   805992 <tcp_accept>
  80bb72:	83 c4 10             	add    $0x10,%esp
  80bb75:	e9 2e ff ff ff       	jmp    80baa8 <do_close_internal+0x8e>
    LWIP_ASSERT("Closing a listen pcb may not fail!", (conn->pcb.tcp->state != LISTEN));
  80bb7a:	8b 43 08             	mov    0x8(%ebx),%eax
  80bb7d:	83 78 10 01          	cmpl   $0x1,0x10(%eax)
  80bb81:	74 44                	je     80bbc7 <do_close_internal+0x1ad>
    tcp_sent(conn->pcb.tcp, sent_tcp);
  80bb83:	83 ec 08             	sub    $0x8,%esp
  80bb86:	68 28 bc 80 00       	push   $0x80bc28
  80bb8b:	50                   	push   %eax
  80bb8c:	e8 d7 9d ff ff       	call   805968 <tcp_sent>
    tcp_poll(conn->pcb.tcp, poll_tcp, 4);
  80bb91:	83 c4 0c             	add    $0xc,%esp
  80bb94:	6a 04                	push   $0x4
  80bb96:	68 de bb 80 00       	push   $0x80bbde
  80bb9b:	ff 73 08             	pushl  0x8(%ebx)
  80bb9e:	e8 01 9e ff ff       	call   8059a4 <tcp_poll>
    tcp_err(conn->pcb.tcp, err_tcp);
  80bba3:	83 c4 08             	add    $0x8,%esp
  80bba6:	68 dd b7 80 00       	push   $0x80b7dd
  80bbab:	ff 73 08             	pushl  0x8(%ebx)
  80bbae:	e8 ca 9d ff ff       	call   80597d <tcp_err>
    tcp_arg(conn->pcb.tcp, conn);
  80bbb3:	83 c4 08             	add    $0x8,%esp
  80bbb6:	53                   	push   %ebx
  80bbb7:	ff 73 08             	pushl  0x8(%ebx)
  80bbba:	e8 82 9d ff ff       	call   805941 <tcp_arg>
  80bbbf:	83 c4 10             	add    $0x10,%esp
}
  80bbc2:	e9 3f ff ff ff       	jmp    80bb06 <do_close_internal+0xec>
    LWIP_ASSERT("Closing a listen pcb may not fail!", (conn->pcb.tcp->state != LISTEN));
  80bbc7:	83 ec 04             	sub    $0x4,%esp
  80bbca:	68 a8 32 81 00       	push   $0x8132a8
  80bbcf:	68 75 02 00 00       	push   $0x275
  80bbd4:	68 46 33 81 00       	push   $0x813346
  80bbd9:	e8 69 2c 00 00       	call   80e847 <_panic>

0080bbde <poll_tcp>:
{
  80bbde:	f3 0f 1e fb          	endbr32 
  80bbe2:	55                   	push   %ebp
  80bbe3:	89 e5                	mov    %esp,%ebp
  80bbe5:	83 ec 08             	sub    $0x8,%esp
  80bbe8:	8b 45 08             	mov    0x8(%ebp),%eax
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  80bbeb:	85 c0                	test   %eax,%eax
  80bbed:	74 14                	je     80bc03 <poll_tcp+0x25>
  if (conn->state == NETCONN_WRITE) {
  80bbef:	8b 50 04             	mov    0x4(%eax),%edx
  80bbf2:	83 fa 01             	cmp    $0x1,%edx
  80bbf5:	74 23                	je     80bc1a <poll_tcp+0x3c>
  } else if (conn->state == NETCONN_CLOSE) {
  80bbf7:	83 fa 04             	cmp    $0x4,%edx
  80bbfa:	74 25                	je     80bc21 <poll_tcp+0x43>
}
  80bbfc:	b8 00 00 00 00       	mov    $0x0,%eax
  80bc01:	c9                   	leave  
  80bc02:	c3                   	ret    
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  80bc03:	83 ec 04             	sub    $0x4,%esp
  80bc06:	68 99 33 81 00       	push   $0x813399
  80bc0b:	68 eb 00 00 00       	push   $0xeb
  80bc10:	68 46 33 81 00       	push   $0x813346
  80bc15:	e8 2d 2c 00 00       	call   80e847 <_panic>
    do_writemore(conn);
  80bc1a:	e8 94 fc ff ff       	call   80b8b3 <do_writemore>
  80bc1f:	eb db                	jmp    80bbfc <poll_tcp+0x1e>
    do_close_internal(conn);
  80bc21:	e8 f4 fd ff ff       	call   80ba1a <do_close_internal>
  80bc26:	eb d4                	jmp    80bbfc <poll_tcp+0x1e>

0080bc28 <sent_tcp>:
{
  80bc28:	f3 0f 1e fb          	endbr32 
  80bc2c:	55                   	push   %ebp
  80bc2d:	89 e5                	mov    %esp,%ebp
  80bc2f:	56                   	push   %esi
  80bc30:	53                   	push   %ebx
  80bc31:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80bc34:	8b 75 10             	mov    0x10(%ebp),%esi
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  80bc37:	85 db                	test   %ebx,%ebx
  80bc39:	74 3e                	je     80bc79 <sent_tcp+0x51>
  if (conn->state == NETCONN_WRITE) {
  80bc3b:	8b 43 04             	mov    0x4(%ebx),%eax
  80bc3e:	83 f8 01             	cmp    $0x1,%eax
  80bc41:	74 4d                	je     80bc90 <sent_tcp+0x68>
  } else if (conn->state == NETCONN_CLOSE) {
  80bc43:	83 f8 04             	cmp    $0x4,%eax
  80bc46:	74 6e                	je     80bcb6 <sent_tcp+0x8e>
    if ((conn->pcb.tcp != NULL) && (tcp_sndbuf(conn->pcb.tcp) > TCP_SNDLOWAT)) {
  80bc48:	8b 43 08             	mov    0x8(%ebx),%eax
  80bc4b:	85 c0                	test   %eax,%eax
  80bc4d:	74 1e                	je     80bc6d <sent_tcp+0x45>
  80bc4f:	66 81 78 6e a0 2d    	cmpw   $0x2da0,0x6e(%eax)
  80bc55:	76 16                	jbe    80bc6d <sent_tcp+0x45>
      API_EVENT(conn, NETCONN_EVT_SENDPLUS, len);
  80bc57:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80bc5a:	85 c0                	test   %eax,%eax
  80bc5c:	74 0f                	je     80bc6d <sent_tcp+0x45>
  80bc5e:	83 ec 04             	sub    $0x4,%esp
  80bc61:	0f b7 f6             	movzwl %si,%esi
  80bc64:	56                   	push   %esi
  80bc65:	6a 02                	push   $0x2
  80bc67:	53                   	push   %ebx
  80bc68:	ff d0                	call   *%eax
  80bc6a:	83 c4 10             	add    $0x10,%esp
}
  80bc6d:	b8 00 00 00 00       	mov    $0x0,%eax
  80bc72:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80bc75:	5b                   	pop    %ebx
  80bc76:	5e                   	pop    %esi
  80bc77:	5d                   	pop    %ebp
  80bc78:	c3                   	ret    
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  80bc79:	83 ec 04             	sub    $0x4,%esp
  80bc7c:	68 99 33 81 00       	push   $0x813399
  80bc81:	68 03 01 00 00       	push   $0x103
  80bc86:	68 46 33 81 00       	push   $0x813346
  80bc8b:	e8 b7 2b 00 00       	call   80e847 <_panic>
    LWIP_ASSERT("conn->pcb.tcp != NULL", conn->pcb.tcp != NULL);
  80bc90:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
  80bc94:	74 09                	je     80bc9f <sent_tcp+0x77>
    do_writemore(conn);
  80bc96:	89 d8                	mov    %ebx,%eax
  80bc98:	e8 16 fc ff ff       	call   80b8b3 <do_writemore>
  80bc9d:	eb a9                	jmp    80bc48 <sent_tcp+0x20>
    LWIP_ASSERT("conn->pcb.tcp != NULL", conn->pcb.tcp != NULL);
  80bc9f:	83 ec 04             	sub    $0x4,%esp
  80bca2:	68 12 34 81 00       	push   $0x813412
  80bca7:	68 06 01 00 00       	push   $0x106
  80bcac:	68 46 33 81 00       	push   $0x813346
  80bcb1:	e8 91 2b 00 00       	call   80e847 <_panic>
    do_close_internal(conn);
  80bcb6:	89 d8                	mov    %ebx,%eax
  80bcb8:	e8 5d fd ff ff       	call   80ba1a <do_close_internal>
  80bcbd:	eb 89                	jmp    80bc48 <sent_tcp+0x20>

0080bcbf <do_newconn>:
{
  80bcbf:	f3 0f 1e fb          	endbr32 
  80bcc3:	55                   	push   %ebp
  80bcc4:	89 e5                	mov    %esp,%ebp
  80bcc6:	56                   	push   %esi
  80bcc7:	53                   	push   %ebx
  80bcc8:	8b 5d 08             	mov    0x8(%ebp),%ebx
   if(msg->conn->pcb.tcp == NULL) {
  80bccb:	8b 03                	mov    (%ebx),%eax
  80bccd:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  80bcd1:	74 17                	je     80bcea <do_newconn+0x2b>
   TCPIP_APIMSG_ACK(msg);
  80bcd3:	83 ec 0c             	sub    $0xc,%esp
  80bcd6:	8b 03                	mov    (%ebx),%eax
  80bcd8:	ff 70 10             	pushl  0x10(%eax)
  80bcdb:	e8 9a e5 ff ff       	call   80a27a <sys_sem_signal>
}
  80bce0:	83 c4 10             	add    $0x10,%esp
  80bce3:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80bce6:	5b                   	pop    %ebx
  80bce7:	5e                   	pop    %esi
  80bce8:	5d                   	pop    %ebp
  80bce9:	c3                   	ret    
   msg->conn->err = ERR_OK;
  80bcea:	c6 40 0c 00          	movb   $0x0,0xc(%eax)
   LWIP_ASSERT("pcb_new: pcb already allocated", msg->conn->pcb.tcp == NULL);
  80bcee:	8b 33                	mov    (%ebx),%esi
  80bcf0:	83 7e 08 00          	cmpl   $0x0,0x8(%esi)
  80bcf4:	75 20                	jne    80bd16 <do_newconn+0x57>
   switch(NETCONNTYPE_GROUP(msg->conn->type)) {
  80bcf6:	8b 06                	mov    (%esi),%eax
  80bcf8:	25 f0 00 00 00       	and    $0xf0,%eax
  80bcfd:	83 f8 20             	cmp    $0x20,%eax
  80bd00:	74 67                	je     80bd69 <do_newconn+0xaa>
  80bd02:	83 f8 40             	cmp    $0x40,%eax
  80bd05:	74 26                	je     80bd2d <do_newconn+0x6e>
  80bd07:	83 f8 10             	cmp    $0x10,%eax
  80bd0a:	0f 84 99 00 00 00    	je     80bda9 <do_newconn+0xea>
     msg->conn->err = ERR_VAL;
  80bd10:	c6 46 0c f7          	movb   $0xf7,0xc(%esi)
     break;
  80bd14:	eb bd                	jmp    80bcd3 <do_newconn+0x14>
   LWIP_ASSERT("pcb_new: pcb already allocated", msg->conn->pcb.tcp == NULL);
  80bd16:	83 ec 04             	sub    $0x4,%esp
  80bd19:	68 cc 32 81 00       	push   $0x8132cc
  80bd1e:	68 8a 01 00 00       	push   $0x18a
  80bd23:	68 46 33 81 00       	push   $0x813346
  80bd28:	e8 1a 2b 00 00       	call   80e847 <_panic>
     msg->conn->pcb.raw = raw_new(msg->msg.n.proto);
  80bd2d:	83 ec 0c             	sub    $0xc,%esp
  80bd30:	0f b6 43 04          	movzbl 0x4(%ebx),%eax
  80bd34:	50                   	push   %eax
  80bd35:	e8 6a 25 00 00       	call   80e2a4 <raw_new>
  80bd3a:	89 46 08             	mov    %eax,0x8(%esi)
     if(msg->conn->pcb.raw == NULL) {
  80bd3d:	8b 03                	mov    (%ebx),%eax
  80bd3f:	8b 50 08             	mov    0x8(%eax),%edx
  80bd42:	83 c4 10             	add    $0x10,%esp
  80bd45:	85 d2                	test   %edx,%edx
  80bd47:	74 17                	je     80bd60 <do_newconn+0xa1>
     raw_recv(msg->conn->pcb.raw, recv_raw, msg->conn);
  80bd49:	83 ec 04             	sub    $0x4,%esp
  80bd4c:	50                   	push   %eax
  80bd4d:	68 4e b6 80 00       	push   $0x80b64e
  80bd52:	52                   	push   %edx
  80bd53:	e8 c0 23 00 00       	call   80e118 <raw_recv>
     break;
  80bd58:	83 c4 10             	add    $0x10,%esp
  80bd5b:	e9 73 ff ff ff       	jmp    80bcd3 <do_newconn+0x14>
       msg->conn->err = ERR_MEM;
  80bd60:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
       break;
  80bd64:	e9 6a ff ff ff       	jmp    80bcd3 <do_newconn+0x14>
     msg->conn->pcb.udp = udp_new();
  80bd69:	e8 4b d4 ff ff       	call   8091b9 <udp_new>
  80bd6e:	89 46 08             	mov    %eax,0x8(%esi)
     if(msg->conn->pcb.udp == NULL) {
  80bd71:	8b 03                	mov    (%ebx),%eax
  80bd73:	8b 50 08             	mov    0x8(%eax),%edx
  80bd76:	85 d2                	test   %edx,%edx
  80bd78:	74 20                	je     80bd9a <do_newconn+0xdb>
     if (msg->conn->type==NETCONN_UDPNOCHKSUM) {
  80bd7a:	83 38 22             	cmpl   $0x22,(%eax)
  80bd7d:	74 24                	je     80bda3 <do_newconn+0xe4>
     udp_recv(msg->conn->pcb.udp, recv_udp, msg->conn);
  80bd7f:	8b 03                	mov    (%ebx),%eax
  80bd81:	83 ec 04             	sub    $0x4,%esp
  80bd84:	50                   	push   %eax
  80bd85:	68 40 b5 80 00       	push   $0x80b540
  80bd8a:	ff 70 08             	pushl  0x8(%eax)
  80bd8d:	e8 c7 d3 ff ff       	call   809159 <udp_recv>
     break;
  80bd92:	83 c4 10             	add    $0x10,%esp
  80bd95:	e9 39 ff ff ff       	jmp    80bcd3 <do_newconn+0x14>
       msg->conn->err = ERR_MEM;
  80bd9a:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
       break;
  80bd9e:	e9 30 ff ff ff       	jmp    80bcd3 <do_newconn+0x14>
       udp_setflags(msg->conn->pcb.udp, UDP_FLAGS_NOCHKSUM);
  80bda3:	c6 42 10 01          	movb   $0x1,0x10(%edx)
  80bda7:	eb d6                	jmp    80bd7f <do_newconn+0xc0>
     msg->conn->pcb.tcp = tcp_new();
  80bda9:	e8 67 a6 ff ff       	call   806415 <tcp_new>
  80bdae:	89 46 08             	mov    %eax,0x8(%esi)
     if(msg->conn->pcb.tcp == NULL) {
  80bdb1:	8b 03                	mov    (%ebx),%eax
  80bdb3:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  80bdb7:	74 0a                	je     80bdc3 <do_newconn+0x104>
     setup_tcp(msg->conn);
  80bdb9:	e8 7c f9 ff ff       	call   80b73a <setup_tcp>
     break;
  80bdbe:	e9 10 ff ff ff       	jmp    80bcd3 <do_newconn+0x14>
       msg->conn->err = ERR_MEM;
  80bdc3:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
       break;
  80bdc7:	e9 07 ff ff ff       	jmp    80bcd3 <do_newconn+0x14>

0080bdcc <netconn_alloc>:
{
  80bdcc:	f3 0f 1e fb          	endbr32 
  80bdd0:	55                   	push   %ebp
  80bdd1:	89 e5                	mov    %esp,%ebp
  80bdd3:	53                   	push   %ebx
  80bdd4:	83 ec 10             	sub    $0x10,%esp
  conn = memp_malloc(MEMP_NETCONN);
  80bdd7:	6a 07                	push   $0x7
  80bdd9:	e8 6d 87 ff ff       	call   80454b <memp_malloc>
  80bdde:	89 c3                	mov    %eax,%ebx
  if (conn == NULL) {
  80bde0:	83 c4 10             	add    $0x10,%esp
  80bde3:	85 c0                	test   %eax,%eax
  80bde5:	74 5b                	je     80be42 <netconn_alloc+0x76>
  conn->err = ERR_OK;
  80bde7:	c6 40 0c 00          	movb   $0x0,0xc(%eax)
  conn->type = t;
  80bdeb:	8b 45 08             	mov    0x8(%ebp),%eax
  80bdee:	89 03                	mov    %eax,(%ebx)
  conn->pcb.tcp = NULL;
  80bdf0:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
  if ((conn->op_completed = sys_sem_new(0)) == SYS_SEM_NULL) {
  80bdf7:	83 ec 0c             	sub    $0xc,%esp
  80bdfa:	6a 00                	push   $0x0
  80bdfc:	e8 ac e1 ff ff       	call   809fad <sys_sem_new>
  80be01:	89 43 10             	mov    %eax,0x10(%ebx)
  80be04:	83 c4 10             	add    $0x10,%esp
  80be07:	83 f8 ff             	cmp    $0xffffffff,%eax
  80be0a:	74 3d                	je     80be49 <netconn_alloc+0x7d>
  if ((conn->recvmbox = sys_mbox_new(size)) == SYS_MBOX_NULL) {
  80be0c:	83 ec 0c             	sub    $0xc,%esp
  80be0f:	6a 00                	push   $0x0
  80be11:	e8 4c e3 ff ff       	call   80a162 <sys_mbox_new>
  80be16:	89 43 14             	mov    %eax,0x14(%ebx)
  80be19:	83 c4 10             	add    $0x10,%esp
  80be1c:	83 f8 ff             	cmp    $0xffffffff,%eax
  80be1f:	74 3d                	je     80be5e <netconn_alloc+0x92>
  conn->acceptmbox   = SYS_MBOX_NULL;
  80be21:	c7 43 18 ff ff ff ff 	movl   $0xffffffff,0x18(%ebx)
  conn->state        = NETCONN_NONE;
  80be28:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  conn->socket       = -1;
  80be2f:	c7 43 1c ff ff ff ff 	movl   $0xffffffff,0x1c(%ebx)
  conn->callback     = callback;
  80be36:	8b 45 0c             	mov    0xc(%ebp),%eax
  80be39:	89 43 2c             	mov    %eax,0x2c(%ebx)
  conn->recv_avail   = 0;
  80be3c:	66 c7 43 20 00 00    	movw   $0x0,0x20(%ebx)
}
  80be42:	89 d8                	mov    %ebx,%eax
  80be44:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80be47:	c9                   	leave  
  80be48:	c3                   	ret    
    memp_free(MEMP_NETCONN, conn);
  80be49:	83 ec 08             	sub    $0x8,%esp
  80be4c:	53                   	push   %ebx
  80be4d:	6a 07                	push   $0x7
  80be4f:	e8 51 87 ff ff       	call   8045a5 <memp_free>
    return NULL;
  80be54:	83 c4 10             	add    $0x10,%esp
  80be57:	bb 00 00 00 00       	mov    $0x0,%ebx
  80be5c:	eb e4                	jmp    80be42 <netconn_alloc+0x76>
    sys_sem_free(conn->op_completed);
  80be5e:	83 ec 0c             	sub    $0xc,%esp
  80be61:	ff 73 10             	pushl  0x10(%ebx)
  80be64:	e8 c9 e1 ff ff       	call   80a032 <sys_sem_free>
    memp_free(MEMP_NETCONN, conn);
  80be69:	83 c4 08             	add    $0x8,%esp
  80be6c:	53                   	push   %ebx
  80be6d:	6a 07                	push   $0x7
  80be6f:	e8 31 87 ff ff       	call   8045a5 <memp_free>
    return NULL;
  80be74:	83 c4 10             	add    $0x10,%esp
  80be77:	bb 00 00 00 00       	mov    $0x0,%ebx
  80be7c:	eb c4                	jmp    80be42 <netconn_alloc+0x76>

0080be7e <netconn_free>:
{
  80be7e:	f3 0f 1e fb          	endbr32 
  80be82:	55                   	push   %ebp
  80be83:	89 e5                	mov    %esp,%ebp
  80be85:	56                   	push   %esi
  80be86:	53                   	push   %ebx
  80be87:	83 ec 10             	sub    $0x10,%esp
  80be8a:	8b 5d 08             	mov    0x8(%ebp),%ebx
  LWIP_ASSERT("PCB must be deallocated outside this function", conn->pcb.tcp == NULL);
  80be8d:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
  80be91:	75 0b                	jne    80be9e <netconn_free+0x20>
    while (sys_mbox_tryfetch(conn->recvmbox, &mem) != SYS_MBOX_EMPTY) {
  80be93:	8d 75 f4             	lea    -0xc(%ebp),%esi
  if (conn->recvmbox != SYS_MBOX_NULL) {
  80be96:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80be9a:	75 27                	jne    80bec3 <netconn_free+0x45>
  80be9c:	eb 68                	jmp    80bf06 <netconn_free+0x88>
  LWIP_ASSERT("PCB must be deallocated outside this function", conn->pcb.tcp == NULL);
  80be9e:	83 ec 04             	sub    $0x4,%esp
  80bea1:	68 ec 32 81 00       	push   $0x8132ec
  80bea6:	68 26 02 00 00       	push   $0x226
  80beab:	68 46 33 81 00       	push   $0x813346
  80beb0:	e8 92 29 00 00       	call   80e847 <_panic>
        netbuf_delete((struct netbuf *)mem);
  80beb5:	83 ec 0c             	sub    $0xc,%esp
  80beb8:	ff 75 f4             	pushl  -0xc(%ebp)
  80bebb:	e8 48 66 ff ff       	call   802508 <netbuf_delete>
  80bec0:	83 c4 10             	add    $0x10,%esp
    while (sys_mbox_tryfetch(conn->recvmbox, &mem) != SYS_MBOX_EMPTY) {
  80bec3:	83 ec 08             	sub    $0x8,%esp
  80bec6:	56                   	push   %esi
  80bec7:	ff 73 14             	pushl  0x14(%ebx)
  80beca:	e8 22 e7 ff ff       	call   80a5f1 <sys_arch_mbox_tryfetch>
  80becf:	83 c4 10             	add    $0x10,%esp
  80bed2:	83 f8 ff             	cmp    $0xffffffff,%eax
  80bed5:	74 1a                	je     80bef1 <netconn_free+0x73>
      if (conn->type == NETCONN_TCP) {
  80bed7:	83 3b 10             	cmpl   $0x10,(%ebx)
  80beda:	75 d9                	jne    80beb5 <netconn_free+0x37>
        if(mem != NULL) {
  80bedc:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80bedf:	85 c0                	test   %eax,%eax
  80bee1:	74 e0                	je     80bec3 <netconn_free+0x45>
          pbuf_free((struct pbuf *)mem);
  80bee3:	83 ec 0c             	sub    $0xc,%esp
  80bee6:	50                   	push   %eax
  80bee7:	e8 3c 8a ff ff       	call   804928 <pbuf_free>
  80beec:	83 c4 10             	add    $0x10,%esp
  80beef:	eb d2                	jmp    80bec3 <netconn_free+0x45>
    sys_mbox_free(conn->recvmbox);
  80bef1:	83 ec 0c             	sub    $0xc,%esp
  80bef4:	ff 73 14             	pushl  0x14(%ebx)
  80bef7:	e8 c3 e1 ff ff       	call   80a0bf <sys_mbox_free>
    conn->recvmbox = SYS_MBOX_NULL;
  80befc:	c7 43 14 ff ff ff ff 	movl   $0xffffffff,0x14(%ebx)
  80bf03:	83 c4 10             	add    $0x10,%esp
    while (sys_mbox_tryfetch(conn->acceptmbox, &mem) != SYS_MBOX_EMPTY) {
  80bf06:	8d 75 f4             	lea    -0xc(%ebp),%esi
  if (conn->acceptmbox != SYS_MBOX_NULL) {
  80bf09:	83 7b 18 ff          	cmpl   $0xffffffff,0x18(%ebx)
  80bf0d:	75 10                	jne    80bf1f <netconn_free+0xa1>
  80bf0f:	eb 37                	jmp    80bf48 <netconn_free+0xca>
      netconn_delete((struct netconn *)mem);
  80bf11:	83 ec 0c             	sub    $0xc,%esp
  80bf14:	ff 75 f4             	pushl  -0xc(%ebp)
  80bf17:	e8 da ef ff ff       	call   80aef6 <netconn_delete>
  80bf1c:	83 c4 10             	add    $0x10,%esp
    while (sys_mbox_tryfetch(conn->acceptmbox, &mem) != SYS_MBOX_EMPTY) {
  80bf1f:	83 ec 08             	sub    $0x8,%esp
  80bf22:	56                   	push   %esi
  80bf23:	ff 73 18             	pushl  0x18(%ebx)
  80bf26:	e8 c6 e6 ff ff       	call   80a5f1 <sys_arch_mbox_tryfetch>
  80bf2b:	83 c4 10             	add    $0x10,%esp
  80bf2e:	83 f8 ff             	cmp    $0xffffffff,%eax
  80bf31:	75 de                	jne    80bf11 <netconn_free+0x93>
    sys_mbox_free(conn->acceptmbox);
  80bf33:	83 ec 0c             	sub    $0xc,%esp
  80bf36:	ff 73 18             	pushl  0x18(%ebx)
  80bf39:	e8 81 e1 ff ff       	call   80a0bf <sys_mbox_free>
    conn->acceptmbox = SYS_MBOX_NULL;
  80bf3e:	c7 43 18 ff ff ff ff 	movl   $0xffffffff,0x18(%ebx)
  80bf45:	83 c4 10             	add    $0x10,%esp
  sys_sem_free(conn->op_completed);
  80bf48:	83 ec 0c             	sub    $0xc,%esp
  80bf4b:	ff 73 10             	pushl  0x10(%ebx)
  80bf4e:	e8 df e0 ff ff       	call   80a032 <sys_sem_free>
  conn->op_completed = SYS_SEM_NULL;
  80bf53:	c7 43 10 ff ff ff ff 	movl   $0xffffffff,0x10(%ebx)
  memp_free(MEMP_NETCONN, conn);
  80bf5a:	83 c4 08             	add    $0x8,%esp
  80bf5d:	53                   	push   %ebx
  80bf5e:	6a 07                	push   $0x7
  80bf60:	e8 40 86 ff ff       	call   8045a5 <memp_free>
}
  80bf65:	83 c4 10             	add    $0x10,%esp
  80bf68:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80bf6b:	5b                   	pop    %ebx
  80bf6c:	5e                   	pop    %esi
  80bf6d:	5d                   	pop    %ebp
  80bf6e:	c3                   	ret    

0080bf6f <accept_function>:
{
  80bf6f:	f3 0f 1e fb          	endbr32 
  80bf73:	55                   	push   %ebp
  80bf74:	89 e5                	mov    %esp,%ebp
  80bf76:	57                   	push   %edi
  80bf77:	56                   	push   %esi
  80bf78:	53                   	push   %ebx
  80bf79:	83 ec 0c             	sub    $0xc,%esp
  80bf7c:	8b 75 08             	mov    0x8(%ebp),%esi
  80bf7f:	8b 7d 10             	mov    0x10(%ebp),%edi
  LWIP_ERROR("accept_function: invalid conn->acceptmbox",
  80bf82:	83 7e 18 ff          	cmpl   $0xffffffff,0x18(%esi)
  80bf86:	74 57                	je     80bfdf <accept_function+0x70>
  newconn = netconn_alloc(conn->type, conn->callback);
  80bf88:	83 ec 08             	sub    $0x8,%esp
  80bf8b:	ff 76 2c             	pushl  0x2c(%esi)
  80bf8e:	ff 36                	pushl  (%esi)
  80bf90:	e8 37 fe ff ff       	call   80bdcc <netconn_alloc>
  80bf95:	89 c3                	mov    %eax,%ebx
  if (newconn == NULL) {
  80bf97:	83 c4 10             	add    $0x10,%esp
  80bf9a:	85 c0                	test   %eax,%eax
  80bf9c:	74 72                	je     80c010 <accept_function+0xa1>
  newconn->pcb.tcp = newpcb;
  80bf9e:	8b 45 0c             	mov    0xc(%ebp),%eax
  80bfa1:	89 43 08             	mov    %eax,0x8(%ebx)
  setup_tcp(newconn);
  80bfa4:	89 d8                	mov    %ebx,%eax
  80bfa6:	e8 8f f7 ff ff       	call   80b73a <setup_tcp>
  newconn->err = err;
  80bfab:	89 f8                	mov    %edi,%eax
  80bfad:	88 43 0c             	mov    %al,0xc(%ebx)
  API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  80bfb0:	8b 46 2c             	mov    0x2c(%esi),%eax
  80bfb3:	85 c0                	test   %eax,%eax
  80bfb5:	74 0d                	je     80bfc4 <accept_function+0x55>
  80bfb7:	83 ec 04             	sub    $0x4,%esp
  80bfba:	6a 00                	push   $0x0
  80bfbc:	6a 00                	push   $0x0
  80bfbe:	56                   	push   %esi
  80bfbf:	ff d0                	call   *%eax
  80bfc1:	83 c4 10             	add    $0x10,%esp
  if (sys_mbox_trypost(conn->acceptmbox, newconn) != ERR_OK) {
  80bfc4:	83 ec 08             	sub    $0x8,%esp
  80bfc7:	53                   	push   %ebx
  80bfc8:	ff 76 18             	pushl  0x18(%esi)
  80bfcb:	e8 32 e4 ff ff       	call   80a402 <sys_mbox_trypost>
  80bfd0:	83 c4 10             	add    $0x10,%esp
  80bfd3:	84 c0                	test   %al,%al
  80bfd5:	75 1f                	jne    80bff6 <accept_function+0x87>
}
  80bfd7:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80bfda:	5b                   	pop    %ebx
  80bfdb:	5e                   	pop    %esi
  80bfdc:	5f                   	pop    %edi
  80bfdd:	5d                   	pop    %ebp
  80bfde:	c3                   	ret    
  LWIP_ERROR("accept_function: invalid conn->acceptmbox",
  80bfdf:	83 ec 04             	sub    $0x4,%esp
  80bfe2:	68 1c 33 81 00       	push   $0x81331c
  80bfe7:	68 64 01 00 00       	push   $0x164
  80bfec:	68 46 33 81 00       	push   $0x813346
  80bff1:	e8 51 28 00 00       	call   80e847 <_panic>
    newconn->pcb.tcp = NULL;
  80bff6:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    netconn_free(newconn);
  80bffd:	83 ec 0c             	sub    $0xc,%esp
  80c000:	53                   	push   %ebx
  80c001:	e8 78 fe ff ff       	call   80be7e <netconn_free>
    return ERR_MEM;
  80c006:	83 c4 10             	add    $0x10,%esp
  80c009:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80c00e:	eb c7                	jmp    80bfd7 <accept_function+0x68>
    return ERR_MEM;
  80c010:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80c015:	eb c0                	jmp    80bfd7 <accept_function+0x68>

0080c017 <do_delconn>:
{
  80c017:	f3 0f 1e fb          	endbr32 
  80c01b:	55                   	push   %ebp
  80c01c:	89 e5                	mov    %esp,%ebp
  80c01e:	53                   	push   %ebx
  80c01f:	83 ec 04             	sub    $0x4,%esp
  80c022:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (msg->conn->pcb.tcp != NULL) {
  80c025:	8b 13                	mov    (%ebx),%edx
  80c027:	8b 4a 08             	mov    0x8(%edx),%ecx
  80c02a:	85 c9                	test   %ecx,%ecx
  80c02c:	74 16                	je     80c044 <do_delconn+0x2d>
    switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80c02e:	8b 02                	mov    (%edx),%eax
  80c030:	25 f0 00 00 00       	and    $0xf0,%eax
  80c035:	83 f8 20             	cmp    $0x20,%eax
  80c038:	74 53                	je     80c08d <do_delconn+0x76>
  80c03a:	83 f8 40             	cmp    $0x40,%eax
  80c03d:	74 40                	je     80c07f <do_delconn+0x68>
  80c03f:	83 f8 10             	cmp    $0x10,%eax
  80c042:	74 62                	je     80c0a6 <do_delconn+0x8f>
  API_EVENT(msg->conn, NETCONN_EVT_RCVPLUS, 0);
  80c044:	8b 13                	mov    (%ebx),%edx
  80c046:	8b 42 2c             	mov    0x2c(%edx),%eax
  80c049:	85 c0                	test   %eax,%eax
  80c04b:	74 23                	je     80c070 <do_delconn+0x59>
  80c04d:	83 ec 04             	sub    $0x4,%esp
  80c050:	6a 00                	push   $0x0
  80c052:	6a 00                	push   $0x0
  80c054:	52                   	push   %edx
  80c055:	ff d0                	call   *%eax
  API_EVENT(msg->conn, NETCONN_EVT_SENDPLUS, 0);
  80c057:	8b 13                	mov    (%ebx),%edx
  80c059:	8b 42 2c             	mov    0x2c(%edx),%eax
  80c05c:	83 c4 10             	add    $0x10,%esp
  80c05f:	85 c0                	test   %eax,%eax
  80c061:	74 0d                	je     80c070 <do_delconn+0x59>
  80c063:	83 ec 04             	sub    $0x4,%esp
  80c066:	6a 00                	push   $0x0
  80c068:	6a 02                	push   $0x2
  80c06a:	52                   	push   %edx
  80c06b:	ff d0                	call   *%eax
  80c06d:	83 c4 10             	add    $0x10,%esp
  if (msg->conn->op_completed != SYS_SEM_NULL) {
  80c070:	8b 03                	mov    (%ebx),%eax
  80c072:	8b 40 10             	mov    0x10(%eax),%eax
  80c075:	83 f8 ff             	cmp    $0xffffffff,%eax
  80c078:	75 3c                	jne    80c0b6 <do_delconn+0x9f>
}
  80c07a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80c07d:	c9                   	leave  
  80c07e:	c3                   	ret    
      raw_remove(msg->conn->pcb.raw);
  80c07f:	83 ec 0c             	sub    $0xc,%esp
  80c082:	51                   	push   %ecx
  80c083:	e8 d4 21 00 00       	call   80e25c <raw_remove>
      break;
  80c088:	83 c4 10             	add    $0x10,%esp
  80c08b:	eb b7                	jmp    80c044 <do_delconn+0x2d>
      msg->conn->pcb.udp->recv_arg = NULL;
  80c08d:	c7 41 1c 00 00 00 00 	movl   $0x0,0x1c(%ecx)
      udp_remove(msg->conn->pcb.udp);
  80c094:	83 ec 0c             	sub    $0xc,%esp
  80c097:	8b 03                	mov    (%ebx),%eax
  80c099:	ff 70 08             	pushl  0x8(%eax)
  80c09c:	e8 d0 d0 ff ff       	call   809171 <udp_remove>
      break;
  80c0a1:	83 c4 10             	add    $0x10,%esp
  80c0a4:	eb 9e                	jmp    80c044 <do_delconn+0x2d>
      msg->conn->state = NETCONN_CLOSE;
  80c0a6:	c7 42 04 04 00 00 00 	movl   $0x4,0x4(%edx)
      do_close_internal(msg->conn);
  80c0ad:	8b 03                	mov    (%ebx),%eax
  80c0af:	e8 66 f9 ff ff       	call   80ba1a <do_close_internal>
      return;
  80c0b4:	eb c4                	jmp    80c07a <do_delconn+0x63>
    sys_sem_signal(msg->conn->op_completed);
  80c0b6:	83 ec 0c             	sub    $0xc,%esp
  80c0b9:	50                   	push   %eax
  80c0ba:	e8 bb e1 ff ff       	call   80a27a <sys_sem_signal>
  80c0bf:	83 c4 10             	add    $0x10,%esp
  80c0c2:	eb b6                	jmp    80c07a <do_delconn+0x63>

0080c0c4 <do_bind>:
{
  80c0c4:	f3 0f 1e fb          	endbr32 
  80c0c8:	55                   	push   %ebp
  80c0c9:	89 e5                	mov    %esp,%ebp
  80c0cb:	56                   	push   %esi
  80c0cc:	53                   	push   %ebx
  80c0cd:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80c0d0:	8b 33                	mov    (%ebx),%esi
  80c0d2:	80 7e 0c fc          	cmpb   $0xfc,0xc(%esi)
  80c0d6:	7c 1d                	jl     80c0f5 <do_bind+0x31>
    if (msg->conn->pcb.tcp != NULL) {
  80c0d8:	8b 56 08             	mov    0x8(%esi),%edx
  80c0db:	85 d2                	test   %edx,%edx
  80c0dd:	74 73                	je     80c152 <do_bind+0x8e>
      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80c0df:	8b 06                	mov    (%esi),%eax
  80c0e1:	25 f0 00 00 00       	and    $0xf0,%eax
  80c0e6:	83 f8 20             	cmp    $0x20,%eax
  80c0e9:	74 35                	je     80c120 <do_bind+0x5c>
  80c0eb:	83 f8 40             	cmp    $0x40,%eax
  80c0ee:	74 1c                	je     80c10c <do_bind+0x48>
  80c0f0:	83 f8 10             	cmp    $0x10,%eax
  80c0f3:	74 44                	je     80c139 <do_bind+0x75>
  TCPIP_APIMSG_ACK(msg);
  80c0f5:	83 ec 0c             	sub    $0xc,%esp
  80c0f8:	8b 03                	mov    (%ebx),%eax
  80c0fa:	ff 70 10             	pushl  0x10(%eax)
  80c0fd:	e8 78 e1 ff ff       	call   80a27a <sys_sem_signal>
}
  80c102:	83 c4 10             	add    $0x10,%esp
  80c105:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80c108:	5b                   	pop    %ebx
  80c109:	5e                   	pop    %esi
  80c10a:	5d                   	pop    %ebp
  80c10b:	c3                   	ret    
        msg->conn->err = raw_bind(msg->conn->pcb.raw, msg->msg.bc.ipaddr);
  80c10c:	83 ec 08             	sub    $0x8,%esp
  80c10f:	ff 73 04             	pushl  0x4(%ebx)
  80c112:	52                   	push   %edx
  80c113:	e8 bd 1f 00 00       	call   80e0d5 <raw_bind>
  80c118:	88 46 0c             	mov    %al,0xc(%esi)
        break;
  80c11b:	83 c4 10             	add    $0x10,%esp
  80c11e:	eb d5                	jmp    80c0f5 <do_bind+0x31>
        msg->conn->err = udp_bind(msg->conn->pcb.udp, msg->msg.bc.ipaddr, msg->msg.bc.port);
  80c120:	83 ec 04             	sub    $0x4,%esp
  80c123:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  80c127:	50                   	push   %eax
  80c128:	ff 73 04             	pushl  0x4(%ebx)
  80c12b:	52                   	push   %edx
  80c12c:	e8 d4 cc ff ff       	call   808e05 <udp_bind>
  80c131:	88 46 0c             	mov    %al,0xc(%esi)
        break;
  80c134:	83 c4 10             	add    $0x10,%esp
  80c137:	eb bc                	jmp    80c0f5 <do_bind+0x31>
        msg->conn->err = tcp_bind(msg->conn->pcb.tcp, msg->msg.bc.ipaddr, msg->msg.bc.port);
  80c139:	83 ec 04             	sub    $0x4,%esp
  80c13c:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  80c140:	50                   	push   %eax
  80c141:	ff 73 04             	pushl  0x4(%ebx)
  80c144:	52                   	push   %edx
  80c145:	e8 ce 93 ff ff       	call   805518 <tcp_bind>
  80c14a:	88 46 0c             	mov    %al,0xc(%esi)
        break;
  80c14d:	83 c4 10             	add    $0x10,%esp
  80c150:	eb a3                	jmp    80c0f5 <do_bind+0x31>
      msg->conn->err = ERR_VAL;
  80c152:	c6 46 0c f7          	movb   $0xf7,0xc(%esi)
  80c156:	eb 9d                	jmp    80c0f5 <do_bind+0x31>

0080c158 <do_connect>:
{
  80c158:	f3 0f 1e fb          	endbr32 
  80c15c:	55                   	push   %ebp
  80c15d:	89 e5                	mov    %esp,%ebp
  80c15f:	56                   	push   %esi
  80c160:	53                   	push   %ebx
  80c161:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (msg->conn->pcb.tcp == NULL) {
  80c164:	8b 33                	mov    (%ebx),%esi
  80c166:	8b 56 08             	mov    0x8(%esi),%edx
  80c169:	85 d2                	test   %edx,%edx
  80c16b:	74 1d                	je     80c18a <do_connect+0x32>
  switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80c16d:	8b 06                	mov    (%esi),%eax
  80c16f:	25 f0 00 00 00       	and    $0xf0,%eax
  80c174:	83 f8 20             	cmp    $0x20,%eax
  80c177:	74 42                	je     80c1bb <do_connect+0x63>
  80c179:	83 f8 40             	cmp    $0x40,%eax
  80c17c:	74 1c                	je     80c19a <do_connect+0x42>
  80c17e:	83 f8 10             	cmp    $0x10,%eax
  80c181:	74 5e                	je     80c1e1 <do_connect+0x89>
}
  80c183:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80c186:	5b                   	pop    %ebx
  80c187:	5e                   	pop    %esi
  80c188:	5d                   	pop    %ebp
  80c189:	c3                   	ret    
    sys_sem_signal(msg->conn->op_completed);
  80c18a:	83 ec 0c             	sub    $0xc,%esp
  80c18d:	ff 76 10             	pushl  0x10(%esi)
  80c190:	e8 e5 e0 ff ff       	call   80a27a <sys_sem_signal>
    return;
  80c195:	83 c4 10             	add    $0x10,%esp
  80c198:	eb e9                	jmp    80c183 <do_connect+0x2b>
    msg->conn->err = raw_connect(msg->conn->pcb.raw, msg->msg.bc.ipaddr);
  80c19a:	83 ec 08             	sub    $0x8,%esp
  80c19d:	ff 73 04             	pushl  0x4(%ebx)
  80c1a0:	52                   	push   %edx
  80c1a1:	e8 50 1f 00 00       	call   80e0f6 <raw_connect>
  80c1a6:	88 46 0c             	mov    %al,0xc(%esi)
    sys_sem_signal(msg->conn->op_completed);
  80c1a9:	83 c4 04             	add    $0x4,%esp
  80c1ac:	8b 03                	mov    (%ebx),%eax
  80c1ae:	ff 70 10             	pushl  0x10(%eax)
  80c1b1:	e8 c4 e0 ff ff       	call   80a27a <sys_sem_signal>
    break;
  80c1b6:	83 c4 10             	add    $0x10,%esp
  80c1b9:	eb c8                	jmp    80c183 <do_connect+0x2b>
    msg->conn->err = udp_connect(msg->conn->pcb.udp, msg->msg.bc.ipaddr, msg->msg.bc.port);
  80c1bb:	83 ec 04             	sub    $0x4,%esp
  80c1be:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  80c1c2:	50                   	push   %eax
  80c1c3:	ff 73 04             	pushl  0x4(%ebx)
  80c1c6:	52                   	push   %edx
  80c1c7:	e8 f9 ce ff ff       	call   8090c5 <udp_connect>
  80c1cc:	88 46 0c             	mov    %al,0xc(%esi)
    sys_sem_signal(msg->conn->op_completed);
  80c1cf:	83 c4 04             	add    $0x4,%esp
  80c1d2:	8b 03                	mov    (%ebx),%eax
  80c1d4:	ff 70 10             	pushl  0x10(%eax)
  80c1d7:	e8 9e e0 ff ff       	call   80a27a <sys_sem_signal>
    break;
  80c1dc:	83 c4 10             	add    $0x10,%esp
  80c1df:	eb a2                	jmp    80c183 <do_connect+0x2b>
    msg->conn->state = NETCONN_CONNECT;
  80c1e1:	c7 46 04 03 00 00 00 	movl   $0x3,0x4(%esi)
    setup_tcp(msg->conn);
  80c1e8:	8b 03                	mov    (%ebx),%eax
  80c1ea:	e8 4b f5 ff ff       	call   80b73a <setup_tcp>
    msg->conn->err = tcp_connect(msg->conn->pcb.tcp, msg->msg.bc.ipaddr, msg->msg.bc.port,
  80c1ef:	8b 33                	mov    (%ebx),%esi
  80c1f1:	68 8d b7 80 00       	push   $0x80b78d
  80c1f6:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  80c1fa:	50                   	push   %eax
  80c1fb:	ff 73 04             	pushl  0x4(%ebx)
  80c1fe:	ff 76 08             	pushl  0x8(%esi)
  80c201:	e8 5d a2 ff ff       	call   806463 <tcp_connect>
  80c206:	88 46 0c             	mov    %al,0xc(%esi)
    break;
  80c209:	83 c4 10             	add    $0x10,%esp
  80c20c:	e9 72 ff ff ff       	jmp    80c183 <do_connect+0x2b>

0080c211 <do_disconnect>:
{
  80c211:	f3 0f 1e fb          	endbr32 
  80c215:	55                   	push   %ebp
  80c216:	89 e5                	mov    %esp,%ebp
  80c218:	53                   	push   %ebx
  80c219:	83 ec 04             	sub    $0x4,%esp
  80c21c:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (NETCONNTYPE_GROUP(msg->conn->type) == NETCONN_UDP) {
  80c21f:	8b 13                	mov    (%ebx),%edx
  80c221:	8b 02                	mov    (%edx),%eax
  80c223:	25 f0 00 00 00       	and    $0xf0,%eax
  80c228:	83 f8 20             	cmp    $0x20,%eax
  80c22b:	74 15                	je     80c242 <do_disconnect+0x31>
  TCPIP_APIMSG_ACK(msg);
  80c22d:	83 ec 0c             	sub    $0xc,%esp
  80c230:	8b 03                	mov    (%ebx),%eax
  80c232:	ff 70 10             	pushl  0x10(%eax)
  80c235:	e8 40 e0 ff ff       	call   80a27a <sys_sem_signal>
}
  80c23a:	83 c4 10             	add    $0x10,%esp
  80c23d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80c240:	c9                   	leave  
  80c241:	c3                   	ret    
    udp_disconnect(msg->conn->pcb.udp);
  80c242:	83 ec 0c             	sub    $0xc,%esp
  80c245:	ff 72 08             	pushl  0x8(%edx)
  80c248:	e8 ed ce ff ff       	call   80913a <udp_disconnect>
  80c24d:	83 c4 10             	add    $0x10,%esp
  80c250:	eb db                	jmp    80c22d <do_disconnect+0x1c>

0080c252 <do_listen>:
{
  80c252:	f3 0f 1e fb          	endbr32 
  80c256:	55                   	push   %ebp
  80c257:	89 e5                	mov    %esp,%ebp
  80c259:	57                   	push   %edi
  80c25a:	56                   	push   %esi
  80c25b:	53                   	push   %ebx
  80c25c:	83 ec 0c             	sub    $0xc,%esp
  80c25f:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80c262:	8b 03                	mov    (%ebx),%eax
  80c264:	80 78 0c fc          	cmpb   $0xfc,0xc(%eax)
  80c268:	7c 0c                	jl     80c276 <do_listen+0x24>
    if (msg->conn->pcb.tcp != NULL) {
  80c26a:	8b 50 08             	mov    0x8(%eax),%edx
  80c26d:	85 d2                	test   %edx,%edx
  80c26f:	74 05                	je     80c276 <do_listen+0x24>
      if (msg->conn->type == NETCONN_TCP) {
  80c271:	83 38 10             	cmpl   $0x10,(%eax)
  80c274:	74 18                	je     80c28e <do_listen+0x3c>
  TCPIP_APIMSG_ACK(msg);
  80c276:	83 ec 0c             	sub    $0xc,%esp
  80c279:	8b 03                	mov    (%ebx),%eax
  80c27b:	ff 70 10             	pushl  0x10(%eax)
  80c27e:	e8 f7 df ff ff       	call   80a27a <sys_sem_signal>
}
  80c283:	83 c4 10             	add    $0x10,%esp
  80c286:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80c289:	5b                   	pop    %ebx
  80c28a:	5e                   	pop    %esi
  80c28b:	5f                   	pop    %edi
  80c28c:	5d                   	pop    %ebp
  80c28d:	c3                   	ret    
        if (msg->conn->pcb.tcp->state == CLOSED) {
  80c28e:	83 7a 10 00          	cmpl   $0x0,0x10(%edx)
  80c292:	74 06                	je     80c29a <do_listen+0x48>
          msg->conn->err = ERR_CONN;
  80c294:	c6 40 0c f8          	movb   $0xf8,0xc(%eax)
  80c298:	eb dc                	jmp    80c276 <do_listen+0x24>
          struct tcp_pcb* lpcb = tcp_listen(msg->conn->pcb.tcp);
  80c29a:	83 ec 08             	sub    $0x8,%esp
  80c29d:	68 ff 00 00 00       	push   $0xff
  80c2a2:	52                   	push   %edx
  80c2a3:	e8 bf 93 ff ff       	call   805667 <tcp_listen_with_backlog>
  80c2a8:	89 c6                	mov    %eax,%esi
          if (lpcb == NULL) {
  80c2aa:	83 c4 10             	add    $0x10,%esp
  80c2ad:	85 c0                	test   %eax,%eax
  80c2af:	74 4e                	je     80c2ff <do_listen+0xad>
            if (msg->conn->recvmbox != SYS_MBOX_NULL) {
  80c2b1:	8b 03                	mov    (%ebx),%eax
  80c2b3:	8b 40 14             	mov    0x14(%eax),%eax
  80c2b6:	83 f8 ff             	cmp    $0xffffffff,%eax
  80c2b9:	75 4f                	jne    80c30a <do_listen+0xb8>
            if (msg->conn->acceptmbox == SYS_MBOX_NULL) {
  80c2bb:	8b 3b                	mov    (%ebx),%edi
  80c2bd:	83 7f 18 ff          	cmpl   $0xffffffff,0x18(%edi)
  80c2c1:	74 5e                	je     80c321 <do_listen+0xcf>
            if (msg->conn->err == ERR_OK) {
  80c2c3:	8b 03                	mov    (%ebx),%eax
  80c2c5:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80c2c9:	75 ab                	jne    80c276 <do_listen+0x24>
              msg->conn->state = NETCONN_LISTEN;
  80c2cb:	c7 40 04 02 00 00 00 	movl   $0x2,0x4(%eax)
              msg->conn->pcb.tcp = lpcb;
  80c2d2:	8b 03                	mov    (%ebx),%eax
  80c2d4:	89 70 08             	mov    %esi,0x8(%eax)
              tcp_arg(msg->conn->pcb.tcp, msg->conn);
  80c2d7:	8b 03                	mov    (%ebx),%eax
  80c2d9:	83 ec 08             	sub    $0x8,%esp
  80c2dc:	50                   	push   %eax
  80c2dd:	ff 70 08             	pushl  0x8(%eax)
  80c2e0:	e8 5c 96 ff ff       	call   805941 <tcp_arg>
              tcp_accept(msg->conn->pcb.tcp, accept_function);
  80c2e5:	83 c4 08             	add    $0x8,%esp
  80c2e8:	68 6f bf 80 00       	push   $0x80bf6f
  80c2ed:	8b 03                	mov    (%ebx),%eax
  80c2ef:	ff 70 08             	pushl  0x8(%eax)
  80c2f2:	e8 9b 96 ff ff       	call   805992 <tcp_accept>
  80c2f7:	83 c4 10             	add    $0x10,%esp
  80c2fa:	e9 77 ff ff ff       	jmp    80c276 <do_listen+0x24>
            msg->conn->err = ERR_MEM;
  80c2ff:	8b 03                	mov    (%ebx),%eax
  80c301:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
  80c305:	e9 6c ff ff ff       	jmp    80c276 <do_listen+0x24>
              sys_mbox_free(msg->conn->recvmbox);
  80c30a:	83 ec 0c             	sub    $0xc,%esp
  80c30d:	50                   	push   %eax
  80c30e:	e8 ac dd ff ff       	call   80a0bf <sys_mbox_free>
              msg->conn->recvmbox = SYS_MBOX_NULL;
  80c313:	8b 03                	mov    (%ebx),%eax
  80c315:	c7 40 14 ff ff ff ff 	movl   $0xffffffff,0x14(%eax)
  80c31c:	83 c4 10             	add    $0x10,%esp
  80c31f:	eb 9a                	jmp    80c2bb <do_listen+0x69>
              if ((msg->conn->acceptmbox = sys_mbox_new(DEFAULT_ACCEPTMBOX_SIZE)) == SYS_MBOX_NULL) {
  80c321:	83 ec 0c             	sub    $0xc,%esp
  80c324:	6a 00                	push   $0x0
  80c326:	e8 37 de ff ff       	call   80a162 <sys_mbox_new>
  80c32b:	89 47 18             	mov    %eax,0x18(%edi)
  80c32e:	83 c4 10             	add    $0x10,%esp
  80c331:	83 f8 ff             	cmp    $0xffffffff,%eax
  80c334:	75 8d                	jne    80c2c3 <do_listen+0x71>
                msg->conn->err = ERR_MEM;
  80c336:	8b 03                	mov    (%ebx),%eax
  80c338:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
  80c33c:	eb 85                	jmp    80c2c3 <do_listen+0x71>

0080c33e <do_send>:
{
  80c33e:	f3 0f 1e fb          	endbr32 
  80c342:	55                   	push   %ebp
  80c343:	89 e5                	mov    %esp,%ebp
  80c345:	57                   	push   %edi
  80c346:	56                   	push   %esi
  80c347:	53                   	push   %ebx
  80c348:	83 ec 0c             	sub    $0xc,%esp
  80c34b:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80c34e:	8b 33                	mov    (%ebx),%esi
  80c350:	80 7e 0c fc          	cmpb   $0xfc,0xc(%esi)
  80c354:	7c 34                	jl     80c38a <do_send+0x4c>
    if (msg->conn->pcb.tcp != NULL) {
  80c356:	8b 56 08             	mov    0x8(%esi),%edx
  80c359:	85 d2                	test   %edx,%edx
  80c35b:	74 2d                	je     80c38a <do_send+0x4c>
      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80c35d:	8b 06                	mov    (%esi),%eax
  80c35f:	25 f0 00 00 00       	and    $0xf0,%eax
  80c364:	83 f8 20             	cmp    $0x20,%eax
  80c367:	74 4c                	je     80c3b5 <do_send+0x77>
  80c369:	83 f8 40             	cmp    $0x40,%eax
  80c36c:	75 1c                	jne    80c38a <do_send+0x4c>
        if (msg->msg.b->addr == NULL) {
  80c36e:	8b 43 04             	mov    0x4(%ebx),%eax
  80c371:	8b 48 08             	mov    0x8(%eax),%ecx
  80c374:	85 c9                	test   %ecx,%ecx
  80c376:	74 2a                	je     80c3a2 <do_send+0x64>
          msg->conn->err = raw_sendto(msg->conn->pcb.raw, msg->msg.b->p, msg->msg.b->addr);
  80c378:	83 ec 04             	sub    $0x4,%esp
  80c37b:	51                   	push   %ecx
  80c37c:	ff 30                	pushl  (%eax)
  80c37e:	52                   	push   %edx
  80c37f:	e8 ac 1d 00 00       	call   80e130 <raw_sendto>
  80c384:	88 46 0c             	mov    %al,0xc(%esi)
  80c387:	83 c4 10             	add    $0x10,%esp
  TCPIP_APIMSG_ACK(msg);
  80c38a:	83 ec 0c             	sub    $0xc,%esp
  80c38d:	8b 03                	mov    (%ebx),%eax
  80c38f:	ff 70 10             	pushl  0x10(%eax)
  80c392:	e8 e3 de ff ff       	call   80a27a <sys_sem_signal>
}
  80c397:	83 c4 10             	add    $0x10,%esp
  80c39a:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80c39d:	5b                   	pop    %ebx
  80c39e:	5e                   	pop    %esi
  80c39f:	5f                   	pop    %edi
  80c3a0:	5d                   	pop    %ebp
  80c3a1:	c3                   	ret    
          msg->conn->err = raw_send(msg->conn->pcb.raw, msg->msg.b->p);
  80c3a2:	83 ec 08             	sub    $0x8,%esp
  80c3a5:	ff 30                	pushl  (%eax)
  80c3a7:	52                   	push   %edx
  80c3a8:	e8 93 1e 00 00       	call   80e240 <raw_send>
  80c3ad:	88 46 0c             	mov    %al,0xc(%esi)
  80c3b0:	83 c4 10             	add    $0x10,%esp
  80c3b3:	eb d5                	jmp    80c38a <do_send+0x4c>
        if (msg->msg.b->addr == NULL) {
  80c3b5:	8b 43 04             	mov    0x4(%ebx),%eax
  80c3b8:	8b 48 08             	mov    0x8(%eax),%ecx
  80c3bb:	85 c9                	test   %ecx,%ecx
  80c3bd:	74 16                	je     80c3d5 <do_send+0x97>
          msg->conn->err = udp_sendto(msg->conn->pcb.udp, msg->msg.b->p, msg->msg.b->addr, msg->msg.b->port);
  80c3bf:	0f b7 78 0c          	movzwl 0xc(%eax),%edi
  80c3c3:	57                   	push   %edi
  80c3c4:	51                   	push   %ecx
  80c3c5:	ff 30                	pushl  (%eax)
  80c3c7:	52                   	push   %edx
  80c3c8:	e8 93 cc ff ff       	call   809060 <udp_sendto>
  80c3cd:	88 46 0c             	mov    %al,0xc(%esi)
  80c3d0:	83 c4 10             	add    $0x10,%esp
  80c3d3:	eb b5                	jmp    80c38a <do_send+0x4c>
          msg->conn->err = udp_send(msg->conn->pcb.udp, msg->msg.b->p);
  80c3d5:	83 ec 08             	sub    $0x8,%esp
  80c3d8:	ff 30                	pushl  (%eax)
  80c3da:	52                   	push   %edx
  80c3db:	e8 c4 cc ff ff       	call   8090a4 <udp_send>
  80c3e0:	88 46 0c             	mov    %al,0xc(%esi)
  80c3e3:	83 c4 10             	add    $0x10,%esp
  80c3e6:	eb a2                	jmp    80c38a <do_send+0x4c>

0080c3e8 <do_recv>:
{
  80c3e8:	f3 0f 1e fb          	endbr32 
  80c3ec:	55                   	push   %ebp
  80c3ed:	89 e5                	mov    %esp,%ebp
  80c3ef:	53                   	push   %ebx
  80c3f0:	83 ec 04             	sub    $0x4,%esp
  80c3f3:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80c3f6:	8b 03                	mov    (%ebx),%eax
  80c3f8:	80 78 0c fc          	cmpb   $0xfc,0xc(%eax)
  80c3fc:	7c 0c                	jl     80c40a <do_recv+0x22>
    if (msg->conn->pcb.tcp != NULL) {
  80c3fe:	8b 50 08             	mov    0x8(%eax),%edx
  80c401:	85 d2                	test   %edx,%edx
  80c403:	74 05                	je     80c40a <do_recv+0x22>
      if (msg->conn->type == NETCONN_TCP) {
  80c405:	83 38 10             	cmpl   $0x10,(%eax)
  80c408:	74 15                	je     80c41f <do_recv+0x37>
  TCPIP_APIMSG_ACK(msg);
  80c40a:	83 ec 0c             	sub    $0xc,%esp
  80c40d:	8b 03                	mov    (%ebx),%eax
  80c40f:	ff 70 10             	pushl  0x10(%eax)
  80c412:	e8 63 de ff ff       	call   80a27a <sys_sem_signal>
}
  80c417:	83 c4 10             	add    $0x10,%esp
  80c41a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80c41d:	c9                   	leave  
  80c41e:	c3                   	ret    
          tcp_recved(msg->conn->pcb.tcp, msg->msg.r.len);
  80c41f:	83 ec 08             	sub    $0x8,%esp
  80c422:	0f b7 43 04          	movzwl 0x4(%ebx),%eax
  80c426:	50                   	push   %eax
  80c427:	52                   	push   %edx
  80c428:	e8 42 93 ff ff       	call   80576f <tcp_recved>
  80c42d:	83 c4 10             	add    $0x10,%esp
  80c430:	eb d8                	jmp    80c40a <do_recv+0x22>

0080c432 <do_write>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_write(struct api_msg_msg *msg)
{
  80c432:	f3 0f 1e fb          	endbr32 
  80c436:	55                   	push   %ebp
  80c437:	89 e5                	mov    %esp,%ebp
  80c439:	83 ec 08             	sub    $0x8,%esp
  80c43c:	8b 55 08             	mov    0x8(%ebp),%edx
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80c43f:	8b 02                	mov    (%edx),%eax
  80c441:	80 78 0c fc          	cmpb   $0xfc,0xc(%eax)
  80c445:	7c 0f                	jl     80c456 <do_write+0x24>
    if ((msg->conn->pcb.tcp != NULL) && (msg->conn->type == NETCONN_TCP)) {
  80c447:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  80c44b:	74 05                	je     80c452 <do_write+0x20>
  80c44d:	83 38 10             	cmpl   $0x10,(%eax)
  80c450:	74 16                	je     80c468 <do_write+0x36>
      /* for both cases: if do_writemore was called, don't ACK the APIMSG! */
      return;
#endif /* LWIP_TCP */
#if (LWIP_UDP || LWIP_RAW)
    } else {
      msg->conn->err = ERR_VAL;
  80c452:	c6 40 0c f7          	movb   $0xf7,0xc(%eax)
#endif /* (LWIP_UDP || LWIP_RAW) */
    }
  }
  TCPIP_APIMSG_ACK(msg);
  80c456:	83 ec 0c             	sub    $0xc,%esp
  80c459:	8b 02                	mov    (%edx),%eax
  80c45b:	ff 70 10             	pushl  0x10(%eax)
  80c45e:	e8 17 de ff ff       	call   80a27a <sys_sem_signal>
  80c463:	83 c4 10             	add    $0x10,%esp
}
  80c466:	c9                   	leave  
  80c467:	c3                   	ret    
      msg->conn->state = NETCONN_WRITE;
  80c468:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
      msg->conn->write_msg = msg;
  80c46f:	8b 02                	mov    (%edx),%eax
  80c471:	89 50 24             	mov    %edx,0x24(%eax)
      msg->conn->write_offset = 0;
  80c474:	8b 02                	mov    (%edx),%eax
  80c476:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%eax)
      do_writemore(msg->conn);
  80c47d:	8b 02                	mov    (%edx),%eax
  80c47f:	e8 2f f4 ff ff       	call   80b8b3 <do_writemore>
      return;
  80c484:	eb e0                	jmp    80c466 <do_write+0x34>

0080c486 <do_getaddr>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_getaddr(struct api_msg_msg *msg)
{
  80c486:	f3 0f 1e fb          	endbr32 
  80c48a:	55                   	push   %ebp
  80c48b:	89 e5                	mov    %esp,%ebp
  80c48d:	83 ec 08             	sub    $0x8,%esp
  80c490:	8b 45 08             	mov    0x8(%ebp),%eax
  if (msg->conn->pcb.ip != NULL) {
  80c493:	8b 08                	mov    (%eax),%ecx
  80c495:	8b 51 08             	mov    0x8(%ecx),%edx
  80c498:	85 d2                	test   %edx,%edx
  80c49a:	0f 84 a8 00 00 00    	je     80c548 <do_getaddr+0xc2>
    *(msg->msg.ad.ipaddr) = (msg->msg.ad.local?msg->conn->pcb.ip->local_ip:msg->conn->pcb.ip->remote_ip);
  80c4a0:	8b 48 04             	mov    0x4(%eax),%ecx
  80c4a3:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80c4a7:	74 2f                	je     80c4d8 <do_getaddr+0x52>
  80c4a9:	8b 12                	mov    (%edx),%edx
  80c4ab:	89 11                	mov    %edx,(%ecx)
    
    switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80c4ad:	8b 08                	mov    (%eax),%ecx
  80c4af:	8b 11                	mov    (%ecx),%edx
  80c4b1:	81 e2 f0 00 00 00    	and    $0xf0,%edx
  80c4b7:	83 fa 20             	cmp    $0x20,%edx
  80c4ba:	74 3e                	je     80c4fa <do_getaddr+0x74>
  80c4bc:	83 fa 40             	cmp    $0x40,%edx
  80c4bf:	74 1e                	je     80c4df <do_getaddr+0x59>
  80c4c1:	83 fa 10             	cmp    $0x10,%edx
  80c4c4:	74 64                	je     80c52a <do_getaddr+0xa4>
#endif /* LWIP_TCP */
    }
  } else {
    msg->conn->err = ERR_CONN;
  }
  TCPIP_APIMSG_ACK(msg);
  80c4c6:	83 ec 0c             	sub    $0xc,%esp
  80c4c9:	8b 00                	mov    (%eax),%eax
  80c4cb:	ff 70 10             	pushl  0x10(%eax)
  80c4ce:	e8 a7 dd ff ff       	call   80a27a <sys_sem_signal>
}
  80c4d3:	83 c4 10             	add    $0x10,%esp
  80c4d6:	c9                   	leave  
  80c4d7:	c3                   	ret    
    *(msg->msg.ad.ipaddr) = (msg->msg.ad.local?msg->conn->pcb.ip->local_ip:msg->conn->pcb.ip->remote_ip);
  80c4d8:	8b 52 04             	mov    0x4(%edx),%edx
  80c4db:	89 11                	mov    %edx,(%ecx)
  80c4dd:	eb ce                	jmp    80c4ad <do_getaddr+0x27>
      if (msg->msg.ad.local) {
  80c4df:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80c4e3:	74 0f                	je     80c4f4 <do_getaddr+0x6e>
        *(msg->msg.ad.port) = msg->conn->pcb.raw->protocol;
  80c4e5:	8b 50 08             	mov    0x8(%eax),%edx
  80c4e8:	8b 49 08             	mov    0x8(%ecx),%ecx
  80c4eb:	0f b6 49 10          	movzbl 0x10(%ecx),%ecx
  80c4ef:	66 89 0a             	mov    %cx,(%edx)
  80c4f2:	eb d2                	jmp    80c4c6 <do_getaddr+0x40>
        msg->conn->err = ERR_CONN;
  80c4f4:	c6 41 0c f8          	movb   $0xf8,0xc(%ecx)
  80c4f8:	eb cc                	jmp    80c4c6 <do_getaddr+0x40>
      if (msg->msg.ad.local) {
  80c4fa:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80c4fe:	74 0f                	je     80c50f <do_getaddr+0x89>
        *(msg->msg.ad.port) = msg->conn->pcb.udp->local_port;
  80c500:	8b 50 08             	mov    0x8(%eax),%edx
  80c503:	8b 49 08             	mov    0x8(%ecx),%ecx
  80c506:	0f b7 49 12          	movzwl 0x12(%ecx),%ecx
  80c50a:	66 89 0a             	mov    %cx,(%edx)
  80c50d:	eb b7                	jmp    80c4c6 <do_getaddr+0x40>
        if ((msg->conn->pcb.udp->flags & UDP_FLAGS_CONNECTED) == 0) {
  80c50f:	8b 51 08             	mov    0x8(%ecx),%edx
  80c512:	f6 42 10 04          	testb  $0x4,0x10(%edx)
  80c516:	75 06                	jne    80c51e <do_getaddr+0x98>
          msg->conn->err = ERR_CONN;
  80c518:	c6 41 0c f8          	movb   $0xf8,0xc(%ecx)
  80c51c:	eb a8                	jmp    80c4c6 <do_getaddr+0x40>
          *(msg->msg.ad.port) = msg->conn->pcb.udp->remote_port;
  80c51e:	8b 48 08             	mov    0x8(%eax),%ecx
  80c521:	0f b7 52 14          	movzwl 0x14(%edx),%edx
  80c525:	66 89 11             	mov    %dx,(%ecx)
  80c528:	eb 9c                	jmp    80c4c6 <do_getaddr+0x40>
      *(msg->msg.ad.port) = (msg->msg.ad.local?msg->conn->pcb.tcp->local_port:msg->conn->pcb.tcp->remote_port);
  80c52a:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80c52e:	74 0f                	je     80c53f <do_getaddr+0xb9>
  80c530:	8b 51 08             	mov    0x8(%ecx),%edx
  80c533:	0f b7 4a 1c          	movzwl 0x1c(%edx),%ecx
  80c537:	8b 50 08             	mov    0x8(%eax),%edx
  80c53a:	66 89 0a             	mov    %cx,(%edx)
      break;
  80c53d:	eb 87                	jmp    80c4c6 <do_getaddr+0x40>
      *(msg->msg.ad.port) = (msg->msg.ad.local?msg->conn->pcb.tcp->local_port:msg->conn->pcb.tcp->remote_port);
  80c53f:	8b 51 08             	mov    0x8(%ecx),%edx
  80c542:	0f b7 4a 1e          	movzwl 0x1e(%edx),%ecx
  80c546:	eb ef                	jmp    80c537 <do_getaddr+0xb1>
    msg->conn->err = ERR_CONN;
  80c548:	c6 41 0c f8          	movb   $0xf8,0xc(%ecx)
  80c54c:	e9 75 ff ff ff       	jmp    80c4c6 <do_getaddr+0x40>

0080c551 <do_close>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_close(struct api_msg_msg *msg)
{
  80c551:	f3 0f 1e fb          	endbr32 
  80c555:	55                   	push   %ebp
  80c556:	89 e5                	mov    %esp,%ebp
  80c558:	83 ec 08             	sub    $0x8,%esp
  80c55b:	8b 55 08             	mov    0x8(%ebp),%edx
#if LWIP_TCP
  if ((msg->conn->pcb.tcp != NULL) && (msg->conn->type == NETCONN_TCP)) {
  80c55e:	8b 02                	mov    (%edx),%eax
  80c560:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  80c564:	74 05                	je     80c56b <do_close+0x1a>
  80c566:	83 38 10             	cmpl   $0x10,(%eax)
  80c569:	74 16                	je     80c581 <do_close+0x30>
      do_close_internal(msg->conn);
      /* for tcp netconns, do_close_internal ACKs the message */
  } else
#endif /* LWIP_TCP */
  {
    msg->conn->err = ERR_VAL;
  80c56b:	c6 40 0c f7          	movb   $0xf7,0xc(%eax)
    TCPIP_APIMSG_ACK(msg);
  80c56f:	83 ec 0c             	sub    $0xc,%esp
  80c572:	8b 02                	mov    (%edx),%eax
  80c574:	ff 70 10             	pushl  0x10(%eax)
  80c577:	e8 fe dc ff ff       	call   80a27a <sys_sem_signal>
  80c57c:	83 c4 10             	add    $0x10,%esp
  }
}
  80c57f:	c9                   	leave  
  80c580:	c3                   	ret    
      msg->conn->state = NETCONN_CLOSE;
  80c581:	c7 40 04 04 00 00 00 	movl   $0x4,0x4(%eax)
      do_close_internal(msg->conn);
  80c588:	8b 02                	mov    (%edx),%eax
  80c58a:	e8 8b f4 ff ff       	call   80ba1a <do_close_internal>
  80c58f:	eb ee                	jmp    80c57f <do_close+0x2e>

0080c591 <tcp_parseopt>:
 *
 * @param pcb the tcp_pcb for which a segment arrived
 */
static void
tcp_parseopt(struct tcp_pcb *pcb)
{
  80c591:	55                   	push   %ebp
  80c592:	89 e5                	mov    %esp,%ebp
  80c594:	57                   	push   %edi
  80c595:	56                   	push   %esi
  80c596:	53                   	push   %ebx
  80c597:	83 ec 18             	sub    $0x18,%esp
  80c59a:	89 c7                	mov    %eax,%edi
  u8_t c;
  u8_t *opts, opt;
  u16_t mss;

  opts = (u8_t *)tcphdr + TCP_HLEN;
  80c59c:	8b 35 b0 b1 b3 00    	mov    0xb3b1b0,%esi

  /* Parse the TCP MSS option, if present. */
  if(TCPH_HDRLEN(tcphdr) > 0x5) {
  80c5a2:	0f b7 46 0c          	movzwl 0xc(%esi),%eax
  80c5a6:	50                   	push   %eax
  80c5a7:	e8 c5 b2 ff ff       	call   807871 <ntohs>
  80c5ac:	83 c4 10             	add    $0x10,%esp
  80c5af:	66 3d ff 5f          	cmp    $0x5fff,%ax
  80c5b3:	0f 86 84 00 00 00    	jbe    80c63d <tcp_parseopt+0xac>
  opts = (u8_t *)tcphdr + TCP_HLEN;
  80c5b9:	83 c6 14             	add    $0x14,%esi
    for(c = 0; c < (TCPH_HDRLEN(tcphdr) - 5) << 2 ;) {
  80c5bc:	bb 00 00 00 00       	mov    $0x0,%ebx
  80c5c1:	eb 10                	jmp    80c5d3 <tcp_parseopt+0x42>
      opt = opts[c];
      if (opt == 0x00) {
        /* End of options. */
        break;
      } else if (opt == 0x01) {
        ++c;
  80c5c3:	83 c3 01             	add    $0x1,%ebx
  80c5c6:	eb 0b                	jmp    80c5d3 <tcp_parseopt+0x42>
        pcb->mss = ((mss > TCP_MSS) || (mss == 0)) ? TCP_MSS : mss;

        /* And we are done processing options. */
        break;
      } else {
        if (opts[c + 1] == 0) {
  80c5c8:	0f b6 44 16 01       	movzbl 0x1(%esi,%edx,1),%eax
  80c5cd:	84 c0                	test   %al,%al
  80c5cf:	74 6c                	je     80c63d <tcp_parseopt+0xac>
             and we don't process them further. */
          break;
        }
        /* All other options have a length field, so that we easily
           can skip past them. */
        c += opts[c + 1];
  80c5d1:	01 c3                	add    %eax,%ebx
    for(c = 0; c < (TCPH_HDRLEN(tcphdr) - 5) << 2 ;) {
  80c5d3:	83 ec 0c             	sub    $0xc,%esp
  80c5d6:	a1 b0 b1 b3 00       	mov    0xb3b1b0,%eax
  80c5db:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80c5df:	50                   	push   %eax
  80c5e0:	e8 8c b2 ff ff       	call   807871 <ntohs>
  80c5e5:	0f b6 d3             	movzbl %bl,%edx
  80c5e8:	66 c1 e8 0c          	shr    $0xc,%ax
  80c5ec:	0f b7 c0             	movzwl %ax,%eax
  80c5ef:	8d 04 85 ec ff ff ff 	lea    -0x14(,%eax,4),%eax
  80c5f6:	83 c4 10             	add    $0x10,%esp
  80c5f9:	39 c2                	cmp    %eax,%edx
  80c5fb:	7d 40                	jge    80c63d <tcp_parseopt+0xac>
      opt = opts[c];
  80c5fd:	0f b6 d3             	movzbl %bl,%edx
  80c600:	0f b6 04 16          	movzbl (%esi,%edx,1),%eax
      if (opt == 0x00) {
  80c604:	84 c0                	test   %al,%al
  80c606:	74 35                	je     80c63d <tcp_parseopt+0xac>
      } else if (opt == 0x01) {
  80c608:	3c 01                	cmp    $0x1,%al
  80c60a:	74 b7                	je     80c5c3 <tcp_parseopt+0x32>
      } else if (opt == 0x02 &&
  80c60c:	3c 02                	cmp    $0x2,%al
  80c60e:	75 b8                	jne    80c5c8 <tcp_parseopt+0x37>
  80c610:	80 7c 16 01 04       	cmpb   $0x4,0x1(%esi,%edx,1)
  80c615:	75 b1                	jne    80c5c8 <tcp_parseopt+0x37>
        mss = (opts[c + 2] << 8) | opts[c + 3];
  80c617:	0f b6 4c 16 02       	movzbl 0x2(%esi,%edx,1),%ecx
  80c61c:	c1 e1 08             	shl    $0x8,%ecx
  80c61f:	0f b6 54 16 03       	movzbl 0x3(%esi,%edx,1),%edx
  80c624:	89 d0                	mov    %edx,%eax
  80c626:	09 c8                	or     %ecx,%eax
        pcb->mss = ((mss > TCP_MSS) || (mss == 0)) ? TCP_MSS : mss;
  80c628:	83 e8 01             	sub    $0x1,%eax
  80c62b:	09 d1                	or     %edx,%ecx
  80c62d:	66 3d b4 05          	cmp    $0x5b4,%ax
  80c631:	b8 b4 05 00 00       	mov    $0x5b4,%eax
  80c636:	0f 42 c1             	cmovb  %ecx,%eax
  80c639:	66 89 47 34          	mov    %ax,0x34(%edi)
      }
    }
  }
}
  80c63d:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80c640:	5b                   	pop    %ebx
  80c641:	5e                   	pop    %esi
  80c642:	5f                   	pop    %edi
  80c643:	5d                   	pop    %ebp
  80c644:	c3                   	ret    

0080c645 <tcp_receive>:
{
  80c645:	55                   	push   %ebp
  80c646:	89 e5                	mov    %esp,%ebp
  80c648:	57                   	push   %edi
  80c649:	56                   	push   %esi
  80c64a:	53                   	push   %ebx
  80c64b:	83 ec 1c             	sub    $0x1c,%esp
  80c64e:	89 c7                	mov    %eax,%edi
  if (flags & TCP_ACK) {
  80c650:	f6 05 a0 b1 b3 00 10 	testb  $0x10,0xb3b1a0
  80c657:	0f 84 24 04 00 00    	je     80ca81 <tcp_receive+0x43c>
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl1;
  80c65d:	0f b7 48 5c          	movzwl 0x5c(%eax),%ecx
  80c661:	8b 50 60             	mov    0x60(%eax),%edx
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
  80c664:	a1 a8 b1 b3 00       	mov    0xb3b1a8,%eax
  80c669:	39 c2                	cmp    %eax,%edx
  80c66b:	78 53                	js     80c6c0 <tcp_receive+0x7b>
  80c66d:	39 c2                	cmp    %eax,%edx
  80c66f:	74 36                	je     80c6a7 <tcp_receive+0x62>
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
  80c671:	8b 35 a4 b1 b3 00    	mov    0xb3b1a4,%esi
  80c677:	39 77 64             	cmp    %esi,0x64(%edi)
  80c67a:	74 38                	je     80c6b4 <tcp_receive+0x6f>
    if (pcb->lastack == ackno) {
  80c67c:	8b 5f 48             	mov    0x48(%edi),%ebx
  80c67f:	a1 a4 b1 b3 00       	mov    0xb3b1a4,%eax
  80c684:	39 c3                	cmp    %eax,%ebx
  80c686:	74 68                	je     80c6f0 <tcp_receive+0xab>
    } else if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_max)){
  80c688:	8d 50 ff             	lea    -0x1(%eax),%edx
  80c68b:	39 da                	cmp    %ebx,%edx
  80c68d:	78 0d                	js     80c69c <tcp_receive+0x57>
  80c68f:	89 c2                	mov    %eax,%edx
  80c691:	2b 57 58             	sub    0x58(%edi),%edx
  80c694:	85 d2                	test   %edx,%edx
  80c696:	0f 8e fa 00 00 00    	jle    80c796 <tcp_receive+0x151>
      pcb->acked = 0;
  80c69c:	66 c7 47 6c 00 00    	movw   $0x0,0x6c(%edi)
  80c6a2:	e9 c3 02 00 00       	jmp    80c96a <tcp_receive+0x325>
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
  80c6a7:	8b 35 a4 b1 b3 00    	mov    0xb3b1a4,%esi
  80c6ad:	39 77 64             	cmp    %esi,0x64(%edi)
  80c6b0:	79 bf                	jns    80c671 <tcp_receive+0x2c>
  80c6b2:	eb 0c                	jmp    80c6c0 <tcp_receive+0x7b>
       (pcb->snd_wl2 == ackno && tcphdr->wnd > pcb->snd_wnd)) {
  80c6b4:	8b 1d b0 b1 b3 00    	mov    0xb3b1b0,%ebx
  80c6ba:	66 3b 4b 0e          	cmp    0xe(%ebx),%cx
  80c6be:	73 bc                	jae    80c67c <tcp_receive+0x37>
      pcb->snd_wnd = tcphdr->wnd;
  80c6c0:	8b 1d b0 b1 b3 00    	mov    0xb3b1b0,%ebx
  80c6c6:	0f b7 5b 0e          	movzwl 0xe(%ebx),%ebx
  80c6ca:	66 89 5f 5c          	mov    %bx,0x5c(%edi)
      pcb->snd_wl1 = seqno;
  80c6ce:	89 47 60             	mov    %eax,0x60(%edi)
      pcb->snd_wl2 = ackno;
  80c6d1:	a1 a4 b1 b3 00       	mov    0xb3b1a4,%eax
  80c6d6:	89 47 64             	mov    %eax,0x64(%edi)
      if (pcb->snd_wnd > 0 && pcb->persist_backoff > 0) {
  80c6d9:	66 85 db             	test   %bx,%bx
  80c6dc:	74 9e                	je     80c67c <tcp_receive+0x37>
  80c6de:	80 bf a4 00 00 00 00 	cmpb   $0x0,0xa4(%edi)
  80c6e5:	74 95                	je     80c67c <tcp_receive+0x37>
          pcb->persist_backoff = 0;
  80c6e7:	c6 87 a4 00 00 00 00 	movb   $0x0,0xa4(%edi)
  80c6ee:	eb 8c                	jmp    80c67c <tcp_receive+0x37>
      pcb->acked = 0;
  80c6f0:	66 c7 47 6c 00 00    	movw   $0x0,0x6c(%edi)
      if (pcb->snd_wl1 + pcb->snd_wnd == right_wnd_edge){
  80c6f6:	0f b7 47 5c          	movzwl 0x5c(%edi),%eax
  80c6fa:	03 47 60             	add    0x60(%edi),%eax
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl1;
  80c6fd:	0f b7 c9             	movzwl %cx,%ecx
  80c700:	01 ca                	add    %ecx,%edx
      if (pcb->snd_wl1 + pcb->snd_wnd == right_wnd_edge){
  80c702:	39 d0                	cmp    %edx,%eax
  80c704:	0f 85 60 02 00 00    	jne    80c96a <tcp_receive+0x325>
        ++pcb->dupacks;
  80c70a:	0f b6 47 4c          	movzbl 0x4c(%edi),%eax
  80c70e:	83 c0 01             	add    $0x1,%eax
  80c711:	88 47 4c             	mov    %al,0x4c(%edi)
        if (pcb->dupacks >= 3 && pcb->unacked != NULL) {
  80c714:	3c 02                	cmp    $0x2,%al
  80c716:	0f 86 4e 02 00 00    	jbe    80c96a <tcp_receive+0x325>
  80c71c:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  80c720:	0f 84 44 02 00 00    	je     80c96a <tcp_receive+0x325>
          if (!(pcb->flags & TF_INFR)) {
  80c726:	f6 47 20 04          	testb  $0x4,0x20(%edi)
  80c72a:	74 1c                	je     80c748 <tcp_receive+0x103>
            if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
  80c72c:	0f b7 57 4e          	movzwl 0x4e(%edi),%edx
  80c730:	89 d0                	mov    %edx,%eax
  80c732:	66 03 47 34          	add    0x34(%edi),%ax
  80c736:	66 39 c2             	cmp    %ax,%dx
  80c739:	0f 83 2b 02 00 00    	jae    80c96a <tcp_receive+0x325>
              pcb->cwnd += pcb->mss;
  80c73f:	66 89 47 4e          	mov    %ax,0x4e(%edi)
  80c743:	e9 22 02 00 00       	jmp    80c96a <tcp_receive+0x325>
            tcp_rexmit(pcb);
  80c748:	83 ec 0c             	sub    $0xc,%esp
  80c74b:	57                   	push   %edi
  80c74c:	e8 c3 c0 ff ff       	call   808814 <tcp_rexmit>
            if (pcb->cwnd > pcb->snd_wnd)
  80c751:	0f b7 5f 4e          	movzwl 0x4e(%edi),%ebx
  80c755:	0f b7 47 5c          	movzwl 0x5c(%edi),%eax
  80c759:	83 c4 10             	add    $0x10,%esp
              pcb->ssthresh = pcb->snd_wnd / 2;
  80c75c:	89 c2                	mov    %eax,%edx
  80c75e:	66 d1 ea             	shr    %dx
  80c761:	89 d9                	mov    %ebx,%ecx
  80c763:	66 d1 e9             	shr    %cx
  80c766:	66 39 c3             	cmp    %ax,%bx
  80c769:	0f 47 ca             	cmova  %edx,%ecx
            if (pcb->ssthresh < 2*pcb->mss) {
  80c76c:	0f b7 47 34          	movzwl 0x34(%edi),%eax
  80c770:	0f b7 f1             	movzwl %cx,%esi
  80c773:	0f b7 d8             	movzwl %ax,%ebx
  80c776:	01 db                	add    %ebx,%ebx
              pcb->ssthresh = 2*pcb->mss;
  80c778:	8d 14 00             	lea    (%eax,%eax,1),%edx
  80c77b:	39 de                	cmp    %ebx,%esi
  80c77d:	0f 4d d1             	cmovge %ecx,%edx
  80c780:	66 89 57 50          	mov    %dx,0x50(%edi)
            pcb->cwnd = pcb->ssthresh + 3 * pcb->mss;
  80c784:	8d 04 40             	lea    (%eax,%eax,2),%eax
  80c787:	01 d0                	add    %edx,%eax
  80c789:	66 89 47 4e          	mov    %ax,0x4e(%edi)
            pcb->flags |= TF_INFR;
  80c78d:	80 4f 20 04          	orb    $0x4,0x20(%edi)
  80c791:	e9 d4 01 00 00       	jmp    80c96a <tcp_receive+0x325>
      if (pcb->flags & TF_INFR) {
  80c796:	0f b6 57 20          	movzbl 0x20(%edi),%edx
  80c79a:	f6 c2 04             	test   $0x4,%dl
  80c79d:	74 0e                	je     80c7ad <tcp_receive+0x168>
        pcb->flags &= ~TF_INFR;
  80c79f:	83 e2 fb             	and    $0xfffffffb,%edx
  80c7a2:	88 57 20             	mov    %dl,0x20(%edi)
        pcb->cwnd = pcb->ssthresh;
  80c7a5:	0f b7 57 50          	movzwl 0x50(%edi),%edx
  80c7a9:	66 89 57 4e          	mov    %dx,0x4e(%edi)
      pcb->nrtx = 0;
  80c7ad:	c6 47 46 00          	movb   $0x0,0x46(%edi)
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
  80c7b1:	0f b7 57 40          	movzwl 0x40(%edi),%edx
  80c7b5:	66 c1 fa 03          	sar    $0x3,%dx
  80c7b9:	66 03 57 42          	add    0x42(%edi),%dx
  80c7bd:	66 89 57 44          	mov    %dx,0x44(%edi)
      pcb->acked = (u16_t)(ackno - pcb->lastack);
  80c7c1:	89 c2                	mov    %eax,%edx
  80c7c3:	29 da                	sub    %ebx,%edx
  80c7c5:	66 89 57 6c          	mov    %dx,0x6c(%edi)
      pcb->snd_buf += pcb->acked;
  80c7c9:	66 01 57 6e          	add    %dx,0x6e(%edi)
      pcb->dupacks = 0;
  80c7cd:	c6 47 4c 00          	movb   $0x0,0x4c(%edi)
      pcb->lastack = ackno;
  80c7d1:	89 47 48             	mov    %eax,0x48(%edi)
      if (pcb->state >= ESTABLISHED) {
  80c7d4:	83 7f 10 03          	cmpl   $0x3,0x10(%edi)
  80c7d8:	76 1d                	jbe    80c7f7 <tcp_receive+0x1b2>
        if (pcb->cwnd < pcb->ssthresh) {
  80c7da:	0f b7 4f 4e          	movzwl 0x4e(%edi),%ecx
  80c7de:	66 3b 4f 50          	cmp    0x50(%edi),%cx
  80c7e2:	0f 83 da 00 00 00    	jae    80c8c2 <tcp_receive+0x27d>
          if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
  80c7e8:	89 c8                	mov    %ecx,%eax
  80c7ea:	66 03 47 34          	add    0x34(%edi),%ax
  80c7ee:	66 39 c1             	cmp    %ax,%cx
  80c7f1:	73 04                	jae    80c7f7 <tcp_receive+0x1b2>
            pcb->cwnd += pcb->mss;
  80c7f3:	66 89 47 4e          	mov    %ax,0x4e(%edi)
      while (pcb->unacked != NULL &&
  80c7f7:	8b 47 78             	mov    0x78(%edi),%eax
  80c7fa:	85 c0                	test   %eax,%eax
  80c7fc:	0f 84 19 01 00 00    	je     80c91b <tcp_receive+0x2d6>
             TCP_SEQ_LEQ(ntohl(pcb->unacked->tcphdr->seqno) +
  80c802:	83 ec 0c             	sub    $0xc,%esp
  80c805:	8b 40 10             	mov    0x10(%eax),%eax
  80c808:	ff 70 04             	pushl  0x4(%eax)
  80c80b:	e8 9f b2 ff ff       	call   807aaf <ntohl>
  80c810:	89 c3                	mov    %eax,%ebx
  80c812:	8b 47 78             	mov    0x78(%edi),%eax
  80c815:	0f b7 70 0c          	movzwl 0xc(%eax),%esi
  80c819:	8b 40 10             	mov    0x10(%eax),%eax
  80c81c:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80c820:	89 04 24             	mov    %eax,(%esp)
  80c823:	e8 49 b0 ff ff       	call   807871 <ntohs>
  80c828:	89 c2                	mov    %eax,%edx
  80c82a:	83 c4 10             	add    $0x10,%esp
  80c82d:	b8 01 00 00 00       	mov    $0x1,%eax
  80c832:	f6 c2 01             	test   $0x1,%dl
  80c835:	0f 84 bf 00 00 00    	je     80c8fa <tcp_receive+0x2b5>
  80c83b:	2b 1d a4 b1 b3 00    	sub    0xb3b1a4,%ebx
  80c841:	01 c6                	add    %eax,%esi
  80c843:	01 f3                	add    %esi,%ebx
      while (pcb->unacked != NULL &&
  80c845:	85 db                	test   %ebx,%ebx
  80c847:	0f 8f ce 00 00 00    	jg     80c91b <tcp_receive+0x2d6>
        next = pcb->unacked;
  80c84d:	8b 5f 78             	mov    0x78(%edi),%ebx
        pcb->unacked = pcb->unacked->next;
  80c850:	8b 03                	mov    (%ebx),%eax
  80c852:	89 47 78             	mov    %eax,0x78(%edi)
        LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
  80c855:	0f b7 77 70          	movzwl 0x70(%edi),%esi
  80c859:	83 ec 0c             	sub    $0xc,%esp
  80c85c:	ff 73 04             	pushl  0x4(%ebx)
  80c85f:	e8 03 85 ff ff       	call   804d67 <pbuf_clen>
  80c864:	0f b6 c0             	movzbl %al,%eax
  80c867:	83 c4 10             	add    $0x10,%esp
  80c86a:	66 39 c6             	cmp    %ax,%si
  80c86d:	72 74                	jb     80c8e3 <tcp_receive+0x29e>
        pcb->snd_queuelen -= pbuf_clen(next->p);
  80c86f:	83 ec 0c             	sub    $0xc,%esp
  80c872:	ff 73 04             	pushl  0x4(%ebx)
  80c875:	e8 ed 84 ff ff       	call   804d67 <pbuf_clen>
  80c87a:	0f b6 c0             	movzbl %al,%eax
  80c87d:	66 29 47 70          	sub    %ax,0x70(%edi)
        tcp_seg_free(next);
  80c881:	89 1c 24             	mov    %ebx,(%esp)
  80c884:	e8 f5 8f ff ff       	call   80587e <tcp_seg_free>
        if (pcb->snd_queuelen != 0) {
  80c889:	83 c4 10             	add    $0x10,%esp
  80c88c:	66 83 7f 70 00       	cmpw   $0x0,0x70(%edi)
  80c891:	0f 84 60 ff ff ff    	je     80c7f7 <tcp_receive+0x1b2>
          LWIP_ASSERT("tcp_receive: valid queue length", pcb->unacked != NULL ||
  80c897:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  80c89b:	0f 85 56 ff ff ff    	jne    80c7f7 <tcp_receive+0x1b2>
  80c8a1:	83 7f 74 00          	cmpl   $0x0,0x74(%edi)
  80c8a5:	0f 85 4c ff ff ff    	jne    80c7f7 <tcp_receive+0x1b2>
  80c8ab:	83 ec 04             	sub    $0x4,%esp
  80c8ae:	68 50 34 81 00       	push   $0x813450
  80c8b3:	68 5b 03 00 00       	push   $0x35b
  80c8b8:	68 94 35 81 00       	push   $0x813594
  80c8bd:	e8 85 1f 00 00       	call   80e847 <_panic>
          u16_t new_cwnd = (pcb->cwnd + pcb->mss * pcb->mss / pcb->cwnd);
  80c8c2:	0f b7 47 34          	movzwl 0x34(%edi),%eax
  80c8c6:	0f af c0             	imul   %eax,%eax
  80c8c9:	0f b7 d9             	movzwl %cx,%ebx
  80c8cc:	99                   	cltd   
  80c8cd:	f7 fb                	idiv   %ebx
  80c8cf:	01 c8                	add    %ecx,%eax
          if (new_cwnd > pcb->cwnd) {
  80c8d1:	66 39 c1             	cmp    %ax,%cx
  80c8d4:	0f 83 1d ff ff ff    	jae    80c7f7 <tcp_receive+0x1b2>
            pcb->cwnd = new_cwnd;
  80c8da:	66 89 47 4e          	mov    %ax,0x4e(%edi)
  80c8de:	e9 14 ff ff ff       	jmp    80c7f7 <tcp_receive+0x1b2>
        LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
  80c8e3:	83 ec 04             	sub    $0x4,%esp
  80c8e6:	68 28 34 81 00       	push   $0x813428
  80c8eb:	68 55 03 00 00       	push   $0x355
  80c8f0:	68 94 35 81 00       	push   $0x813594
  80c8f5:	e8 4d 1f 00 00       	call   80e847 <_panic>
             TCP_SEQ_LEQ(ntohl(pcb->unacked->tcphdr->seqno) +
  80c8fa:	83 ec 0c             	sub    $0xc,%esp
  80c8fd:	8b 47 78             	mov    0x78(%edi),%eax
  80c900:	8b 40 10             	mov    0x10(%eax),%eax
  80c903:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80c907:	50                   	push   %eax
  80c908:	e8 64 af ff ff       	call   807871 <ntohs>
  80c90d:	66 d1 e8             	shr    %ax
  80c910:	83 e0 01             	and    $0x1,%eax
  80c913:	83 c4 10             	add    $0x10,%esp
  80c916:	e9 20 ff ff ff       	jmp    80c83b <tcp_receive+0x1f6>
      if(pcb->unacked == NULL)
  80c91b:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  80c91f:	0f 94 c0             	sete   %al
  80c922:	0f b6 c0             	movzbl %al,%eax
  80c925:	f7 d8                	neg    %eax
  80c927:	66 89 47 32          	mov    %ax,0x32(%edi)
      pcb->polltmr = 0;
  80c92b:	c6 47 30 00          	movb   $0x0,0x30(%edi)
  80c92f:	eb 39                	jmp    80c96a <tcp_receive+0x325>
      LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
  80c931:	83 ec 04             	sub    $0x4,%esp
  80c934:	68 28 34 81 00       	push   $0x813428
  80c939:	68 7f 03 00 00       	push   $0x37f
  80c93e:	68 94 35 81 00       	push   $0x813594
  80c943:	e8 ff 1e 00 00       	call   80e847 <_panic>
        LWIP_ASSERT("tcp_receive: valid queue length",
  80c948:	83 ec 04             	sub    $0x4,%esp
  80c94b:	68 50 34 81 00       	push   $0x813450
  80c950:	68 84 03 00 00       	push   $0x384
  80c955:	68 94 35 81 00       	push   $0x813594
  80c95a:	e8 e8 1e 00 00       	call   80e847 <_panic>
      if (pcb->unsent != NULL) {
  80c95f:	8b 47 74             	mov    0x74(%edi),%eax
  80c962:	85 c0                	test   %eax,%eax
  80c964:	0f 85 cb 00 00 00    	jne    80ca35 <tcp_receive+0x3f0>
    while (pcb->unsent != NULL &&
  80c96a:	8b 47 74             	mov    0x74(%edi),%eax
  80c96d:	85 c0                	test   %eax,%eax
  80c96f:	0f 84 fa 00 00 00    	je     80ca6f <tcp_receive+0x42a>
           TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), pcb->snd_max)
  80c975:	8b 35 a4 b1 b3 00    	mov    0xb3b1a4,%esi
  80c97b:	83 ec 0c             	sub    $0xc,%esp
  80c97e:	8b 40 10             	mov    0x10(%eax),%eax
  80c981:	ff 70 04             	pushl  0x4(%eax)
  80c984:	e8 26 b1 ff ff       	call   807aaf <ntohl>
  80c989:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80c98c:	8b 47 74             	mov    0x74(%edi),%eax
  80c98f:	0f b7 58 0c          	movzwl 0xc(%eax),%ebx
  80c993:	8b 40 10             	mov    0x10(%eax),%eax
  80c996:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80c99a:	89 04 24             	mov    %eax,(%esp)
  80c99d:	e8 cf ae ff ff       	call   807871 <ntohs>
  80c9a2:	89 c2                	mov    %eax,%edx
  80c9a4:	83 c4 10             	add    $0x10,%esp
  80c9a7:	b8 01 00 00 00       	mov    $0x1,%eax
  80c9ac:	f6 c2 01             	test   $0x1,%dl
  80c9af:	0f 84 99 00 00 00    	je     80ca4e <tcp_receive+0x409>
  80c9b5:	2b 75 e4             	sub    -0x1c(%ebp),%esi
  80c9b8:	01 c3                	add    %eax,%ebx
    while (pcb->unsent != NULL &&
  80c9ba:	39 de                	cmp    %ebx,%esi
  80c9bc:	0f 88 ad 00 00 00    	js     80ca6f <tcp_receive+0x42a>
           TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), pcb->snd_max)
  80c9c2:	a1 a4 b1 b3 00       	mov    0xb3b1a4,%eax
  80c9c7:	2b 47 58             	sub    0x58(%edi),%eax
  80c9ca:	85 c0                	test   %eax,%eax
  80c9cc:	0f 8f 9d 00 00 00    	jg     80ca6f <tcp_receive+0x42a>
      next = pcb->unsent;
  80c9d2:	8b 5f 74             	mov    0x74(%edi),%ebx
      pcb->unsent = pcb->unsent->next;
  80c9d5:	8b 03                	mov    (%ebx),%eax
  80c9d7:	89 47 74             	mov    %eax,0x74(%edi)
      LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
  80c9da:	0f b7 77 70          	movzwl 0x70(%edi),%esi
  80c9de:	83 ec 0c             	sub    $0xc,%esp
  80c9e1:	ff 73 04             	pushl  0x4(%ebx)
  80c9e4:	e8 7e 83 ff ff       	call   804d67 <pbuf_clen>
  80c9e9:	0f b6 c0             	movzbl %al,%eax
  80c9ec:	83 c4 10             	add    $0x10,%esp
  80c9ef:	66 39 c6             	cmp    %ax,%si
  80c9f2:	0f 82 39 ff ff ff    	jb     80c931 <tcp_receive+0x2ec>
      pcb->snd_queuelen -= pbuf_clen(next->p);
  80c9f8:	83 ec 0c             	sub    $0xc,%esp
  80c9fb:	ff 73 04             	pushl  0x4(%ebx)
  80c9fe:	e8 64 83 ff ff       	call   804d67 <pbuf_clen>
  80ca03:	0f b6 c0             	movzbl %al,%eax
  80ca06:	66 29 47 70          	sub    %ax,0x70(%edi)
      tcp_seg_free(next);
  80ca0a:	89 1c 24             	mov    %ebx,(%esp)
  80ca0d:	e8 6c 8e ff ff       	call   80587e <tcp_seg_free>
      if (pcb->snd_queuelen != 0) {
  80ca12:	83 c4 10             	add    $0x10,%esp
  80ca15:	66 83 7f 70 00       	cmpw   $0x0,0x70(%edi)
  80ca1a:	0f 84 3f ff ff ff    	je     80c95f <tcp_receive+0x31a>
        LWIP_ASSERT("tcp_receive: valid queue length",
  80ca20:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  80ca24:	0f 85 35 ff ff ff    	jne    80c95f <tcp_receive+0x31a>
  80ca2a:	8b 47 74             	mov    0x74(%edi),%eax
  80ca2d:	85 c0                	test   %eax,%eax
  80ca2f:	0f 84 13 ff ff ff    	je     80c948 <tcp_receive+0x303>
        pcb->snd_nxt = htonl(pcb->unsent->tcphdr->seqno);
  80ca35:	83 ec 0c             	sub    $0xc,%esp
  80ca38:	8b 40 10             	mov    0x10(%eax),%eax
  80ca3b:	ff 70 04             	pushl  0x4(%eax)
  80ca3e:	e8 3f ae ff ff       	call   807882 <htonl>
  80ca43:	89 47 54             	mov    %eax,0x54(%edi)
  80ca46:	83 c4 10             	add    $0x10,%esp
  80ca49:	e9 1c ff ff ff       	jmp    80c96a <tcp_receive+0x325>
           TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), pcb->snd_max)
  80ca4e:	83 ec 0c             	sub    $0xc,%esp
  80ca51:	8b 47 74             	mov    0x74(%edi),%eax
  80ca54:	8b 40 10             	mov    0x10(%eax),%eax
  80ca57:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80ca5b:	50                   	push   %eax
  80ca5c:	e8 10 ae ff ff       	call   807871 <ntohs>
  80ca61:	66 d1 e8             	shr    %ax
  80ca64:	83 e0 01             	and    $0x1,%eax
  80ca67:	83 c4 10             	add    $0x10,%esp
  80ca6a:	e9 46 ff ff ff       	jmp    80c9b5 <tcp_receive+0x370>
    if (pcb->rttest && TCP_SEQ_LT(pcb->rtseq, ackno)) {
  80ca6f:	8b 47 38             	mov    0x38(%edi),%eax
  80ca72:	85 c0                	test   %eax,%eax
  80ca74:	74 0b                	je     80ca81 <tcp_receive+0x43c>
  80ca76:	8b 0d a4 b1 b3 00    	mov    0xb3b1a4,%ecx
  80ca7c:	39 4f 3c             	cmp    %ecx,0x3c(%edi)
  80ca7f:	78 70                	js     80caf1 <tcp_receive+0x4ac>
  if (tcplen > 0) {
  80ca81:	0f b7 05 9e b1 b3 00 	movzwl 0xb3b19e,%eax
  80ca88:	66 85 c0             	test   %ax,%ax
  80ca8b:	0f 84 57 08 00 00    	je     80d2e8 <tcp_receive+0xca3>
    if (TCP_SEQ_BETWEEN(pcb->rcv_nxt, seqno + 1, seqno + tcplen - 1)){
  80ca91:	8b 5f 24             	mov    0x24(%edi),%ebx
  80ca94:	8b 15 a8 b1 b3 00    	mov    0xb3b1a8,%edx
  80ca9a:	89 d9                	mov    %ebx,%ecx
  80ca9c:	29 d1                	sub    %edx,%ecx
  80ca9e:	89 ce                	mov    %ecx,%esi
  80caa0:	83 ee 01             	sub    $0x1,%esi
  80caa3:	78 16                	js     80cabb <tcp_receive+0x476>
  80caa5:	be 01 00 00 00       	mov    $0x1,%esi
  80caaa:	29 d6                	sub    %edx,%esi
  80caac:	0f b7 c0             	movzwl %ax,%eax
  80caaf:	29 c6                	sub    %eax,%esi
  80cab1:	01 de                	add    %ebx,%esi
  80cab3:	85 f6                	test   %esi,%esi
  80cab5:	0f 8e 84 00 00 00    	jle    80cb3f <tcp_receive+0x4fa>
      if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)){
  80cabb:	39 da                	cmp    %ebx,%edx
  80cabd:	0f 88 bd 01 00 00    	js     80cc80 <tcp_receive+0x63b>
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
  80cac3:	0f b7 47 28          	movzwl 0x28(%edi),%eax
  80cac7:	89 d1                	mov    %edx,%ecx
  80cac9:	29 c1                	sub    %eax,%ecx
  80cacb:	8d 41 01             	lea    0x1(%ecx),%eax
  80cace:	29 d8                	sub    %ebx,%eax
  80cad0:	85 c0                	test   %eax,%eax
  80cad2:	0f 8e bd 01 00 00    	jle    80cc95 <tcp_receive+0x650>
      tcp_ack_now(pcb);
  80cad8:	80 4f 20 02          	orb    $0x2,0x20(%edi)
  80cadc:	83 ec 0c             	sub    $0xc,%esp
  80cadf:	57                   	push   %edi
  80cae0:	e8 01 b7 ff ff       	call   8081e6 <tcp_output>
  80cae5:	83 c4 10             	add    $0x10,%esp
  u8_t accepted_inseq = 0;
  80cae8:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
  80caec:	e9 2a 08 00 00       	jmp    80d31b <tcp_receive+0xcd6>
      m = (s16_t)(tcp_ticks - pcb->rttest);
  80caf1:	8b 35 40 b2 b3 00    	mov    0xb3b240,%esi
      m = m - (pcb->sa >> 3);
  80caf7:	0f b7 57 40          	movzwl 0x40(%edi),%edx
  80cafb:	89 d3                	mov    %edx,%ebx
  80cafd:	66 c1 fb 03          	sar    $0x3,%bx
      m = (s16_t)(tcp_ticks - pcb->rttest);
  80cb01:	89 f1                	mov    %esi,%ecx
  80cb03:	29 c1                	sub    %eax,%ecx
      m = m - (pcb->sa >> 3);
  80cb05:	29 d9                	sub    %ebx,%ecx
      pcb->sa += m;
  80cb07:	01 ca                	add    %ecx,%edx
  80cb09:	66 89 57 40          	mov    %dx,0x40(%edi)
        m = -m;
  80cb0d:	29 f0                	sub    %esi,%eax
  80cb0f:	01 d8                	add    %ebx,%eax
  80cb11:	66 85 c9             	test   %cx,%cx
  80cb14:	0f 49 c1             	cmovns %ecx,%eax
      m = m - (pcb->sv >> 2);
  80cb17:	0f b7 4f 42          	movzwl 0x42(%edi),%ecx
  80cb1b:	89 cb                	mov    %ecx,%ebx
  80cb1d:	66 c1 fb 02          	sar    $0x2,%bx
      pcb->sv += m;
  80cb21:	29 d9                	sub    %ebx,%ecx
  80cb23:	01 c8                	add    %ecx,%eax
  80cb25:	66 89 47 42          	mov    %ax,0x42(%edi)
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
  80cb29:	66 c1 fa 03          	sar    $0x3,%dx
  80cb2d:	01 d0                	add    %edx,%eax
  80cb2f:	66 89 47 44          	mov    %ax,0x44(%edi)
      pcb->rttest = 0;
  80cb33:	c7 47 38 00 00 00 00 	movl   $0x0,0x38(%edi)
  80cb3a:	e9 42 ff ff ff       	jmp    80ca81 <tcp_receive+0x43c>
      off = pcb->rcv_nxt - seqno;
  80cb3f:	89 c8                	mov    %ecx,%eax
      p = inseg.p;
  80cb41:	8b 1d b8 b1 b3 00    	mov    0xb3b1b8,%ebx
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
  80cb47:	85 db                	test   %ebx,%ebx
  80cb49:	0f 84 a4 00 00 00    	je     80cbf3 <tcp_receive+0x5ae>
      LWIP_ASSERT("insane offset!", (off < 0x7fff));
  80cb4f:	81 f9 fe 7f 00 00    	cmp    $0x7ffe,%ecx
  80cb55:	0f 8f af 00 00 00    	jg     80cc0a <tcp_receive+0x5c5>
      if (inseg.p->len < off) {
  80cb5b:	0f b7 53 0a          	movzwl 0xa(%ebx),%edx
  80cb5f:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  80cb62:	39 ca                	cmp    %ecx,%edx
  80cb64:	0f 8d e5 00 00 00    	jge    80cc4f <tcp_receive+0x60a>
        LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
  80cb6a:	0f b7 73 08          	movzwl 0x8(%ebx),%esi
  80cb6e:	0f b7 d6             	movzwl %si,%edx
  80cb71:	39 ca                	cmp    %ecx,%edx
  80cb73:	0f 8c a8 00 00 00    	jl     80cc21 <tcp_receive+0x5dc>
        new_tot_len = (u16_t)(inseg.p->tot_len - off);
  80cb79:	29 ce                	sub    %ecx,%esi
  80cb7b:	89 f1                	mov    %esi,%ecx
  80cb7d:	8b 55 e4             	mov    -0x1c(%ebp),%edx
          off -= p->len;
  80cb80:	29 d0                	sub    %edx,%eax
          p->tot_len = new_tot_len;
  80cb82:	66 89 4b 08          	mov    %cx,0x8(%ebx)
          p->len = 0;
  80cb86:	66 c7 43 0a 00 00    	movw   $0x0,0xa(%ebx)
          p = p->next;
  80cb8c:	8b 1b                	mov    (%ebx),%ebx
        while (p->len < off) {
  80cb8e:	0f b7 53 0a          	movzwl 0xa(%ebx),%edx
  80cb92:	39 c2                	cmp    %eax,%edx
  80cb94:	7c ea                	jl     80cb80 <tcp_receive+0x53b>
        if(pbuf_header(p, (s16_t)-off)) {
  80cb96:	83 ec 08             	sub    $0x8,%esp
  80cb99:	f7 d8                	neg    %eax
  80cb9b:	98                   	cwtl   
  80cb9c:	50                   	push   %eax
  80cb9d:	53                   	push   %ebx
  80cb9e:	e8 b2 7c ff ff       	call   804855 <pbuf_header>
  80cba3:	83 c4 10             	add    $0x10,%esp
  80cba6:	84 c0                	test   %al,%al
  80cba8:	0f 85 8a 00 00 00    	jne    80cc38 <tcp_receive+0x5f3>
      inseg.dataptr = p->payload;
  80cbae:	8b 43 04             	mov    0x4(%ebx),%eax
  80cbb1:	a3 bc b1 b3 00       	mov    %eax,0xb3b1bc
      inseg.len -= (u16_t)(pcb->rcv_nxt - seqno);
  80cbb6:	8b 57 24             	mov    0x24(%edi),%edx
  80cbb9:	0f b7 05 c0 b1 b3 00 	movzwl 0xb3b1c0,%eax
  80cbc0:	66 03 05 a8 b1 b3 00 	add    0xb3b1a8,%ax
  80cbc7:	29 d0                	sub    %edx,%eax
  80cbc9:	66 a3 c0 b1 b3 00    	mov    %ax,0xb3b1c0
      inseg.tcphdr->seqno = seqno = pcb->rcv_nxt;
  80cbcf:	89 15 a8 b1 b3 00    	mov    %edx,0xb3b1a8
  80cbd5:	a1 c4 b1 b3 00       	mov    0xb3b1c4,%eax
  80cbda:	89 50 04             	mov    %edx,0x4(%eax)
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
  80cbdd:	8b 15 a8 b1 b3 00    	mov    0xb3b1a8,%edx
  80cbe3:	8b 5f 24             	mov    0x24(%edi),%ebx
  80cbe6:	39 da                	cmp    %ebx,%edx
  80cbe8:	0f 88 ea fe ff ff    	js     80cad8 <tcp_receive+0x493>
  80cbee:	e9 d0 fe ff ff       	jmp    80cac3 <tcp_receive+0x47e>
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
  80cbf3:	83 ec 04             	sub    $0x4,%esp
  80cbf6:	68 ab 35 81 00       	push   $0x8135ab
  80cbfb:	68 e5 03 00 00       	push   $0x3e5
  80cc00:	68 94 35 81 00       	push   $0x813594
  80cc05:	e8 3d 1c 00 00       	call   80e847 <_panic>
      LWIP_ASSERT("insane offset!", (off < 0x7fff));
  80cc0a:	83 ec 04             	sub    $0x4,%esp
  80cc0d:	68 bb 35 81 00       	push   $0x8135bb
  80cc12:	68 e6 03 00 00       	push   $0x3e6
  80cc17:	68 94 35 81 00       	push   $0x813594
  80cc1c:	e8 26 1c 00 00       	call   80e847 <_panic>
        LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
  80cc21:	83 ec 04             	sub    $0x4,%esp
  80cc24:	68 ca 35 81 00       	push   $0x8135ca
  80cc29:	68 e8 03 00 00       	push   $0x3e8
  80cc2e:	68 94 35 81 00       	push   $0x813594
  80cc33:	e8 0f 1c 00 00       	call   80e847 <_panic>
          LWIP_ASSERT("pbuf_header failed", 0);
  80cc38:	83 ec 04             	sub    $0x4,%esp
  80cc3b:	68 da 35 81 00       	push   $0x8135da
  80cc40:	68 f5 03 00 00       	push   $0x3f5
  80cc45:	68 94 35 81 00       	push   $0x813594
  80cc4a:	e8 f8 1b 00 00       	call   80e847 <_panic>
        if(pbuf_header(inseg.p, (s16_t)-off)) {
  80cc4f:	83 ec 08             	sub    $0x8,%esp
  80cc52:	f7 d9                	neg    %ecx
  80cc54:	0f bf c1             	movswl %cx,%eax
  80cc57:	50                   	push   %eax
  80cc58:	53                   	push   %ebx
  80cc59:	e8 f7 7b ff ff       	call   804855 <pbuf_header>
  80cc5e:	83 c4 10             	add    $0x10,%esp
  80cc61:	84 c0                	test   %al,%al
  80cc63:	0f 84 45 ff ff ff    	je     80cbae <tcp_receive+0x569>
          LWIP_ASSERT("pbuf_header failed", 0);
  80cc69:	83 ec 04             	sub    $0x4,%esp
  80cc6c:	68 da 35 81 00       	push   $0x8135da
  80cc71:	68 fa 03 00 00       	push   $0x3fa
  80cc76:	68 94 35 81 00       	push   $0x813594
  80cc7b:	e8 c7 1b 00 00       	call   80e847 <_panic>
        tcp_ack_now(pcb);
  80cc80:	80 4f 20 02          	orb    $0x2,0x20(%edi)
  80cc84:	83 ec 0c             	sub    $0xc,%esp
  80cc87:	57                   	push   %edi
  80cc88:	e8 59 b5 ff ff       	call   8081e6 <tcp_output>
  80cc8d:	83 c4 10             	add    $0x10,%esp
  80cc90:	e9 48 ff ff ff       	jmp    80cbdd <tcp_receive+0x598>
      if (pcb->rcv_nxt == seqno) {
  80cc95:	39 da                	cmp    %ebx,%edx
  80cc97:	0f 85 d7 03 00 00    	jne    80d074 <tcp_receive+0xa2f>
        if (pcb->ooseq != NULL &&
  80cc9d:	8b 47 7c             	mov    0x7c(%edi),%eax
  80cca0:	85 c0                	test   %eax,%eax
  80cca2:	74 1d                	je     80ccc1 <tcp_receive+0x67c>
                TCP_SEQ_LEQ(pcb->ooseq->tcphdr->seqno, seqno + inseg.len)) {
  80cca4:	8b 48 10             	mov    0x10(%eax),%ecx
  80cca7:	8b 59 04             	mov    0x4(%ecx),%ebx
  80ccaa:	0f b7 0d c0 b1 b3 00 	movzwl 0xb3b1c0,%ecx
  80ccb1:	89 de                	mov    %ebx,%esi
  80ccb3:	29 ce                	sub    %ecx,%esi
  80ccb5:	89 f1                	mov    %esi,%ecx
  80ccb7:	29 d1                	sub    %edx,%ecx
        if (pcb->ooseq != NULL &&
  80ccb9:	85 c9                	test   %ecx,%ecx
  80ccbb:	0f 8e b2 00 00 00    	jle    80cd73 <tcp_receive+0x72e>
        tcplen = TCP_TCPLEN(&inseg);
  80ccc1:	0f b7 1d c0 b1 b3 00 	movzwl 0xb3b1c0,%ebx
  80ccc8:	83 ec 0c             	sub    $0xc,%esp
  80cccb:	a1 c4 b1 b3 00       	mov    0xb3b1c4,%eax
  80ccd0:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80ccd4:	50                   	push   %eax
  80ccd5:	e8 97 ab ff ff       	call   807871 <ntohs>
  80ccda:	89 c2                	mov    %eax,%edx
  80ccdc:	83 c4 10             	add    $0x10,%esp
  80ccdf:	b8 01 00 00 00       	mov    $0x1,%eax
  80cce4:	f6 c2 01             	test   $0x1,%dl
  80cce7:	0f 84 ff 00 00 00    	je     80cdec <tcp_receive+0x7a7>
  80cced:	01 d8                	add    %ebx,%eax
  80ccef:	66 a3 9e b1 b3 00    	mov    %ax,0xb3b19e
        if (pcb->state != CLOSE_WAIT) {
  80ccf5:	83 7f 10 07          	cmpl   $0x7,0x10(%edi)
  80ccf9:	74 06                	je     80cd01 <tcp_receive+0x6bc>
          pcb->rcv_nxt += tcplen;
  80ccfb:	0f b7 d0             	movzwl %ax,%edx
  80ccfe:	01 57 24             	add    %edx,0x24(%edi)
        if (pcb->rcv_wnd < tcplen) {
  80cd01:	0f b7 4f 28          	movzwl 0x28(%edi),%ecx
          pcb->rcv_wnd -= tcplen;
  80cd05:	89 ca                	mov    %ecx,%edx
  80cd07:	29 c2                	sub    %eax,%edx
  80cd09:	66 39 c8             	cmp    %cx,%ax
  80cd0c:	b9 00 00 00 00       	mov    $0x0,%ecx
  80cd11:	0f 47 d1             	cmova  %ecx,%edx
  80cd14:	66 89 57 28          	mov    %dx,0x28(%edi)
        if (pcb->rcv_ann_wnd < tcplen) {
  80cd18:	0f b7 4f 2a          	movzwl 0x2a(%edi),%ecx
          pcb->rcv_ann_wnd -= tcplen;
  80cd1c:	89 ca                	mov    %ecx,%edx
  80cd1e:	29 c2                	sub    %eax,%edx
  80cd20:	66 39 c8             	cmp    %cx,%ax
  80cd23:	b8 00 00 00 00       	mov    $0x0,%eax
  80cd28:	0f 46 c2             	cmovbe %edx,%eax
  80cd2b:	66 89 47 2a          	mov    %ax,0x2a(%edi)
        if (inseg.p->tot_len > 0) {
  80cd2f:	a1 b8 b1 b3 00       	mov    0xb3b1b8,%eax
  80cd34:	66 83 78 08 00       	cmpw   $0x0,0x8(%eax)
  80cd39:	74 0f                	je     80cd4a <tcp_receive+0x705>
          recv_data = inseg.p;
  80cd3b:	a3 98 b1 b3 00       	mov    %eax,0xb3b198
          inseg.p = NULL;
  80cd40:	c7 05 b8 b1 b3 00 00 	movl   $0x0,0xb3b1b8
  80cd47:	00 00 00 
        if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
  80cd4a:	83 ec 0c             	sub    $0xc,%esp
  80cd4d:	a1 c4 b1 b3 00       	mov    0xb3b1c4,%eax
  80cd52:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cd56:	50                   	push   %eax
  80cd57:	e8 15 ab ff ff       	call   807871 <ntohs>
  80cd5c:	83 c4 10             	add    $0x10,%esp
  80cd5f:	a8 01                	test   $0x1,%al
  80cd61:	0f 84 d6 01 00 00    	je     80cf3d <tcp_receive+0x8f8>
          recv_flags = TF_GOT_FIN;
  80cd67:	c6 05 9c b1 b3 00 20 	movb   $0x20,0xb3b19c
  80cd6e:	e9 ca 01 00 00       	jmp    80cf3d <tcp_receive+0x8f8>
          if (pcb->ooseq->len > 0) {
  80cd73:	66 83 78 0c 00       	cmpw   $0x0,0xc(%eax)
  80cd78:	74 23                	je     80cd9d <tcp_receive+0x758>
            inseg.len = (u16_t)(pcb->ooseq->tcphdr->seqno - seqno);
  80cd7a:	29 d3                	sub    %edx,%ebx
  80cd7c:	66 89 1d c0 b1 b3 00 	mov    %bx,0xb3b1c0
            pbuf_realloc(inseg.p, inseg.len);
  80cd83:	83 ec 08             	sub    $0x8,%esp
  80cd86:	0f b7 db             	movzwl %bx,%ebx
  80cd89:	53                   	push   %ebx
  80cd8a:	ff 35 b8 b1 b3 00    	pushl  0xb3b1b8
  80cd90:	e8 bc 7e ff ff       	call   804c51 <pbuf_realloc>
  80cd95:	83 c4 10             	add    $0x10,%esp
  80cd98:	e9 24 ff ff ff       	jmp    80ccc1 <tcp_receive+0x67c>
            if ((TCPH_FLAGS(inseg.tcphdr) & (TCP_FIN|TCP_SYN)) ==
  80cd9d:	83 ec 0c             	sub    $0xc,%esp
  80cda0:	a1 c4 b1 b3 00       	mov    0xb3b1c4,%eax
  80cda5:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cda9:	50                   	push   %eax
  80cdaa:	e8 c2 aa ff ff       	call   807871 <ntohs>
  80cdaf:	89 c3                	mov    %eax,%ebx
                (TCPH_FLAGS(pcb->ooseq->tcphdr) & (TCP_FIN|TCP_SYN))) {
  80cdb1:	8b 47 7c             	mov    0x7c(%edi),%eax
  80cdb4:	8b 40 10             	mov    0x10(%eax),%eax
  80cdb7:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cdbb:	89 04 24             	mov    %eax,(%esp)
  80cdbe:	e8 ae aa ff ff       	call   807871 <ntohs>
            if ((TCPH_FLAGS(inseg.tcphdr) & (TCP_FIN|TCP_SYN)) ==
  80cdc3:	31 c3                	xor    %eax,%ebx
  80cdc5:	83 c4 10             	add    $0x10,%esp
  80cdc8:	f6 c3 03             	test   $0x3,%bl
  80cdcb:	0f 85 f0 fe ff ff    	jne    80ccc1 <tcp_receive+0x67c>
              struct tcp_seg *old_ooseq = pcb->ooseq;
  80cdd1:	8b 47 7c             	mov    0x7c(%edi),%eax
              pcb->ooseq = pcb->ooseq->next;
  80cdd4:	8b 10                	mov    (%eax),%edx
  80cdd6:	89 57 7c             	mov    %edx,0x7c(%edi)
              memp_free(MEMP_TCP_SEG, old_ooseq);
  80cdd9:	83 ec 08             	sub    $0x8,%esp
  80cddc:	50                   	push   %eax
  80cddd:	6a 04                	push   $0x4
  80cddf:	e8 c1 77 ff ff       	call   8045a5 <memp_free>
  80cde4:	83 c4 10             	add    $0x10,%esp
  80cde7:	e9 d5 fe ff ff       	jmp    80ccc1 <tcp_receive+0x67c>
        tcplen = TCP_TCPLEN(&inseg);
  80cdec:	83 ec 0c             	sub    $0xc,%esp
  80cdef:	a1 c4 b1 b3 00       	mov    0xb3b1c4,%eax
  80cdf4:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cdf8:	50                   	push   %eax
  80cdf9:	e8 73 aa ff ff       	call   807871 <ntohs>
  80cdfe:	66 d1 e8             	shr    %ax
  80ce01:	83 e0 01             	and    $0x1,%eax
  80ce04:	83 c4 10             	add    $0x10,%esp
  80ce07:	e9 e1 fe ff ff       	jmp    80cced <tcp_receive+0x6a8>
          pcb->rcv_nxt += TCP_TCPLEN(cseg);
  80ce0c:	83 ec 0c             	sub    $0xc,%esp
  80ce0f:	8b 43 10             	mov    0x10(%ebx),%eax
  80ce12:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80ce16:	50                   	push   %eax
  80ce17:	e8 55 aa ff ff       	call   807871 <ntohs>
  80ce1c:	66 d1 e8             	shr    %ax
  80ce1f:	83 e0 01             	and    $0x1,%eax
  80ce22:	83 c4 10             	add    $0x10,%esp
  80ce25:	e9 56 01 00 00       	jmp    80cf80 <tcp_receive+0x93b>
          if (pcb->rcv_wnd < TCP_TCPLEN(cseg)) {
  80ce2a:	83 ec 0c             	sub    $0xc,%esp
  80ce2d:	8b 43 10             	mov    0x10(%ebx),%eax
  80ce30:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80ce34:	50                   	push   %eax
  80ce35:	e8 37 aa ff ff       	call   807871 <ntohs>
  80ce3a:	66 d1 e8             	shr    %ax
  80ce3d:	83 e0 01             	and    $0x1,%eax
  80ce40:	83 c4 10             	add    $0x10,%esp
  80ce43:	e9 6b 01 00 00       	jmp    80cfb3 <tcp_receive+0x96e>
            pcb->rcv_wnd -= TCP_TCPLEN(cseg);
  80ce48:	0f b7 73 0c          	movzwl 0xc(%ebx),%esi
  80ce4c:	83 ec 0c             	sub    $0xc,%esp
  80ce4f:	8b 43 10             	mov    0x10(%ebx),%eax
  80ce52:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80ce56:	50                   	push   %eax
  80ce57:	e8 15 aa ff ff       	call   807871 <ntohs>
  80ce5c:	89 c2                	mov    %eax,%edx
  80ce5e:	83 c4 10             	add    $0x10,%esp
  80ce61:	b8 01 00 00 00       	mov    $0x1,%eax
  80ce66:	f6 c2 01             	test   $0x1,%dl
  80ce69:	74 0b                	je     80ce76 <tcp_receive+0x831>
  80ce6b:	01 c6                	add    %eax,%esi
  80ce6d:	66 29 77 28          	sub    %si,0x28(%edi)
  80ce71:	e9 4e 01 00 00       	jmp    80cfc4 <tcp_receive+0x97f>
  80ce76:	83 ec 0c             	sub    $0xc,%esp
  80ce79:	8b 43 10             	mov    0x10(%ebx),%eax
  80ce7c:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80ce80:	50                   	push   %eax
  80ce81:	e8 eb a9 ff ff       	call   807871 <ntohs>
  80ce86:	66 d1 e8             	shr    %ax
  80ce89:	83 e0 01             	and    $0x1,%eax
  80ce8c:	83 c4 10             	add    $0x10,%esp
  80ce8f:	eb da                	jmp    80ce6b <tcp_receive+0x826>
          if (pcb->rcv_ann_wnd < TCP_TCPLEN(cseg)) {
  80ce91:	83 ec 0c             	sub    $0xc,%esp
  80ce94:	8b 43 10             	mov    0x10(%ebx),%eax
  80ce97:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80ce9b:	50                   	push   %eax
  80ce9c:	e8 d0 a9 ff ff       	call   807871 <ntohs>
  80cea1:	66 d1 e8             	shr    %ax
  80cea4:	83 e0 01             	and    $0x1,%eax
  80cea7:	83 c4 10             	add    $0x10,%esp
  80ceaa:	e9 43 01 00 00       	jmp    80cff2 <tcp_receive+0x9ad>
            pcb->rcv_ann_wnd -= TCP_TCPLEN(cseg);
  80ceaf:	0f b7 73 0c          	movzwl 0xc(%ebx),%esi
  80ceb3:	83 ec 0c             	sub    $0xc,%esp
  80ceb6:	8b 43 10             	mov    0x10(%ebx),%eax
  80ceb9:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cebd:	50                   	push   %eax
  80cebe:	e8 ae a9 ff ff       	call   807871 <ntohs>
  80cec3:	89 c2                	mov    %eax,%edx
  80cec5:	83 c4 10             	add    $0x10,%esp
  80cec8:	b8 01 00 00 00       	mov    $0x1,%eax
  80cecd:	f6 c2 01             	test   $0x1,%dl
  80ced0:	74 0b                	je     80cedd <tcp_receive+0x898>
  80ced2:	01 c6                	add    %eax,%esi
  80ced4:	66 29 77 2a          	sub    %si,0x2a(%edi)
  80ced8:	e9 26 01 00 00       	jmp    80d003 <tcp_receive+0x9be>
  80cedd:	83 ec 0c             	sub    $0xc,%esp
  80cee0:	8b 43 10             	mov    0x10(%ebx),%eax
  80cee3:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cee7:	50                   	push   %eax
  80cee8:	e8 84 a9 ff ff       	call   807871 <ntohs>
  80ceed:	66 d1 e8             	shr    %ax
  80cef0:	83 e0 01             	and    $0x1,%eax
  80cef3:	83 c4 10             	add    $0x10,%esp
  80cef6:	eb da                	jmp    80ced2 <tcp_receive+0x88d>
              recv_data = cseg->p;
  80cef8:	a3 98 b1 b3 00       	mov    %eax,0xb3b198
            cseg->p = NULL;
  80cefd:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
          if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
  80cf04:	83 ec 0c             	sub    $0xc,%esp
  80cf07:	8b 43 10             	mov    0x10(%ebx),%eax
  80cf0a:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cf0e:	50                   	push   %eax
  80cf0f:	e8 5d a9 ff ff       	call   807871 <ntohs>
  80cf14:	83 c4 10             	add    $0x10,%esp
  80cf17:	a8 01                	test   $0x1,%al
  80cf19:	74 11                	je     80cf2c <tcp_receive+0x8e7>
            recv_flags = TF_GOT_FIN;
  80cf1b:	c6 05 9c b1 b3 00 20 	movb   $0x20,0xb3b19c
            if (pcb->state == ESTABLISHED) { /* force passive close or we can move to active close */
  80cf22:	83 7f 10 04          	cmpl   $0x4,0x10(%edi)
  80cf26:	0f 84 05 01 00 00    	je     80d031 <tcp_receive+0x9ec>
          pcb->ooseq = cseg->next;
  80cf2c:	8b 03                	mov    (%ebx),%eax
  80cf2e:	89 47 7c             	mov    %eax,0x7c(%edi)
          tcp_seg_free(cseg);
  80cf31:	83 ec 0c             	sub    $0xc,%esp
  80cf34:	53                   	push   %ebx
  80cf35:	e8 44 89 ff ff       	call   80587e <tcp_seg_free>
  80cf3a:	83 c4 10             	add    $0x10,%esp
        while (pcb->ooseq != NULL &&
  80cf3d:	8b 5f 7c             	mov    0x7c(%edi),%ebx
  80cf40:	85 db                	test   %ebx,%ebx
  80cf42:	0f 84 f5 00 00 00    	je     80d03d <tcp_receive+0x9f8>
               pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {
  80cf48:	8b 53 10             	mov    0x10(%ebx),%edx
  80cf4b:	8b 42 04             	mov    0x4(%edx),%eax
        while (pcb->ooseq != NULL &&
  80cf4e:	3b 47 24             	cmp    0x24(%edi),%eax
  80cf51:	0f 85 e6 00 00 00    	jne    80d03d <tcp_receive+0x9f8>
          seqno = pcb->ooseq->tcphdr->seqno;
  80cf57:	a3 a8 b1 b3 00       	mov    %eax,0xb3b1a8
          pcb->rcv_nxt += TCP_TCPLEN(cseg);
  80cf5c:	0f b7 73 0c          	movzwl 0xc(%ebx),%esi
  80cf60:	83 ec 0c             	sub    $0xc,%esp
  80cf63:	0f b7 42 0c          	movzwl 0xc(%edx),%eax
  80cf67:	50                   	push   %eax
  80cf68:	e8 04 a9 ff ff       	call   807871 <ntohs>
  80cf6d:	89 c2                	mov    %eax,%edx
  80cf6f:	83 c4 10             	add    $0x10,%esp
  80cf72:	b8 01 00 00 00       	mov    $0x1,%eax
  80cf77:	f6 c2 01             	test   $0x1,%dl
  80cf7a:	0f 84 8c fe ff ff    	je     80ce0c <tcp_receive+0x7c7>
  80cf80:	01 c6                	add    %eax,%esi
  80cf82:	01 77 24             	add    %esi,0x24(%edi)
          if (pcb->rcv_wnd < TCP_TCPLEN(cseg)) {
  80cf85:	0f b7 47 28          	movzwl 0x28(%edi),%eax
  80cf89:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80cf8c:	0f b7 73 0c          	movzwl 0xc(%ebx),%esi
  80cf90:	83 ec 0c             	sub    $0xc,%esp
  80cf93:	8b 43 10             	mov    0x10(%ebx),%eax
  80cf96:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cf9a:	50                   	push   %eax
  80cf9b:	e8 d1 a8 ff ff       	call   807871 <ntohs>
  80cfa0:	89 c2                	mov    %eax,%edx
  80cfa2:	83 c4 10             	add    $0x10,%esp
  80cfa5:	b8 01 00 00 00       	mov    $0x1,%eax
  80cfaa:	f6 c2 01             	test   $0x1,%dl
  80cfad:	0f 84 77 fe ff ff    	je     80ce2a <tcp_receive+0x7e5>
  80cfb3:	01 c6                	add    %eax,%esi
  80cfb5:	39 75 e4             	cmp    %esi,-0x1c(%ebp)
  80cfb8:	0f 8d 8a fe ff ff    	jge    80ce48 <tcp_receive+0x803>
            pcb->rcv_wnd = 0;
  80cfbe:	66 c7 47 28 00 00    	movw   $0x0,0x28(%edi)
          if (pcb->rcv_ann_wnd < TCP_TCPLEN(cseg)) {
  80cfc4:	0f b7 47 2a          	movzwl 0x2a(%edi),%eax
  80cfc8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80cfcb:	0f b7 73 0c          	movzwl 0xc(%ebx),%esi
  80cfcf:	83 ec 0c             	sub    $0xc,%esp
  80cfd2:	8b 43 10             	mov    0x10(%ebx),%eax
  80cfd5:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cfd9:	50                   	push   %eax
  80cfda:	e8 92 a8 ff ff       	call   807871 <ntohs>
  80cfdf:	89 c2                	mov    %eax,%edx
  80cfe1:	83 c4 10             	add    $0x10,%esp
  80cfe4:	b8 01 00 00 00       	mov    $0x1,%eax
  80cfe9:	f6 c2 01             	test   $0x1,%dl
  80cfec:	0f 84 9f fe ff ff    	je     80ce91 <tcp_receive+0x84c>
  80cff2:	01 c6                	add    %eax,%esi
  80cff4:	39 75 e4             	cmp    %esi,-0x1c(%ebp)
  80cff7:	0f 8d b2 fe ff ff    	jge    80ceaf <tcp_receive+0x86a>
            pcb->rcv_ann_wnd = 0;
  80cffd:	66 c7 47 2a 00 00    	movw   $0x0,0x2a(%edi)
          if (cseg->p->tot_len > 0) {
  80d003:	8b 43 04             	mov    0x4(%ebx),%eax
  80d006:	66 83 78 08 00       	cmpw   $0x0,0x8(%eax)
  80d00b:	0f 84 f3 fe ff ff    	je     80cf04 <tcp_receive+0x8bf>
            if (recv_data) {
  80d011:	8b 15 98 b1 b3 00    	mov    0xb3b198,%edx
  80d017:	85 d2                	test   %edx,%edx
  80d019:	0f 84 d9 fe ff ff    	je     80cef8 <tcp_receive+0x8b3>
              pbuf_cat(recv_data, cseg->p);
  80d01f:	83 ec 08             	sub    $0x8,%esp
  80d022:	50                   	push   %eax
  80d023:	52                   	push   %edx
  80d024:	e8 71 7d ff ff       	call   804d9a <pbuf_cat>
  80d029:	83 c4 10             	add    $0x10,%esp
  80d02c:	e9 cc fe ff ff       	jmp    80cefd <tcp_receive+0x8b8>
              pcb->state = CLOSE_WAIT;
  80d031:	c7 47 10 07 00 00 00 	movl   $0x7,0x10(%edi)
  80d038:	e9 ef fe ff ff       	jmp    80cf2c <tcp_receive+0x8e7>
        tcp_ack(pcb);
  80d03d:	0f b6 47 20          	movzbl 0x20(%edi),%eax
  80d041:	89 c1                	mov    %eax,%ecx
  80d043:	83 e1 01             	and    $0x1,%ecx
  80d046:	88 4d e4             	mov    %cl,-0x1c(%ebp)
  80d049:	75 0f                	jne    80d05a <tcp_receive+0xa15>
  80d04b:	83 c8 01             	or     $0x1,%eax
  80d04e:	88 47 20             	mov    %al,0x20(%edi)
        accepted_inseq = 1; 
  80d051:	c6 45 e4 01          	movb   $0x1,-0x1c(%ebp)
  80d055:	e9 c1 02 00 00       	jmp    80d31b <tcp_receive+0xcd6>
        tcp_ack(pcb);
  80d05a:	83 e0 fe             	and    $0xfffffffe,%eax
  80d05d:	83 c8 02             	or     $0x2,%eax
  80d060:	88 47 20             	mov    %al,0x20(%edi)
  80d063:	83 ec 0c             	sub    $0xc,%esp
  80d066:	57                   	push   %edi
  80d067:	e8 7a b1 ff ff       	call   8081e6 <tcp_output>
  80d06c:	83 c4 10             	add    $0x10,%esp
  80d06f:	e9 a7 02 00 00       	jmp    80d31b <tcp_receive+0xcd6>
        tcp_ack_now(pcb);
  80d074:	80 4f 20 02          	orb    $0x2,0x20(%edi)
  80d078:	83 ec 0c             	sub    $0xc,%esp
  80d07b:	57                   	push   %edi
  80d07c:	e8 65 b1 ff ff       	call   8081e6 <tcp_output>
        if (pcb->ooseq == NULL) {
  80d081:	8b 5f 7c             	mov    0x7c(%edi),%ebx
  80d084:	83 c4 10             	add    $0x10,%esp
  80d087:	85 db                	test   %ebx,%ebx
  80d089:	74 1e                	je     80d0a9 <tcp_receive+0xa64>
            if (seqno == next->tcphdr->seqno) {
  80d08b:	8b 0d a8 b1 b3 00    	mov    0xb3b1a8,%ecx
  80d091:	8d 41 ff             	lea    -0x1(%ecx),%eax
  80d094:	8d 51 01             	lea    0x1(%ecx),%edx
  80d097:	89 55 e4             	mov    %edx,-0x1c(%ebp)
          prev = NULL;
  80d09a:	be 00 00 00 00       	mov    $0x0,%esi
  80d09f:	89 7d e0             	mov    %edi,-0x20(%ebp)
  80d0a2:	89 c7                	mov    %eax,%edi
  80d0a4:	e9 d7 00 00 00       	jmp    80d180 <tcp_receive+0xb3b>
          pcb->ooseq = tcp_seg_copy(&inseg);
  80d0a9:	83 ec 0c             	sub    $0xc,%esp
  80d0ac:	68 b4 b1 b3 00       	push   $0xb3b1b4
  80d0b1:	e8 4d 88 ff ff       	call   805903 <tcp_seg_copy>
  80d0b6:	89 47 7c             	mov    %eax,0x7c(%edi)
  80d0b9:	83 c4 10             	add    $0x10,%esp
  u8_t accepted_inseq = 0;
  80d0bc:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
  80d0c0:	e9 56 02 00 00       	jmp    80d31b <tcp_receive+0xcd6>
  80d0c5:	8b 7d e0             	mov    -0x20(%ebp),%edi
  80d0c8:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
              if (inseg.len > next->len) {
  80d0cc:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80d0d0:	66 39 05 c0 b1 b3 00 	cmp    %ax,0xb3b1c0
  80d0d7:	0f 86 3e 02 00 00    	jbe    80d31b <tcp_receive+0xcd6>
                cseg = tcp_seg_copy(&inseg);
  80d0dd:	83 ec 0c             	sub    $0xc,%esp
  80d0e0:	68 b4 b1 b3 00       	push   $0xb3b1b4
  80d0e5:	e8 19 88 ff ff       	call   805903 <tcp_seg_copy>
  80d0ea:	89 c1                	mov    %eax,%ecx
  80d0ec:	89 45 e0             	mov    %eax,-0x20(%ebp)
                if (cseg != NULL) {
  80d0ef:	83 c4 10             	add    $0x10,%esp
  u8_t accepted_inseq = 0;
  80d0f2:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
                if (cseg != NULL) {
  80d0f6:	85 c0                	test   %eax,%eax
  80d0f8:	0f 84 1d 02 00 00    	je     80d31b <tcp_receive+0xcd6>
                  cseg->next = next->next;
  80d0fe:	8b 03                	mov    (%ebx),%eax
  80d100:	89 01                	mov    %eax,(%ecx)
                  if (prev != NULL) {
  80d102:	85 f6                	test   %esi,%esi
  80d104:	74 5c                	je     80d162 <tcp_receive+0xb1d>
                    prev->next = cseg;
  80d106:	89 0e                	mov    %ecx,(%esi)
                  tcp_seg_free(next);
  80d108:	83 ec 0c             	sub    $0xc,%esp
  80d10b:	53                   	push   %ebx
  80d10c:	e8 6d 87 ff ff       	call   80587e <tcp_seg_free>
                  if (cseg->next != NULL) {
  80d111:	8b 75 e0             	mov    -0x20(%ebp),%esi
  80d114:	8b 06                	mov    (%esi),%eax
  80d116:	83 c4 10             	add    $0x10,%esp
  u8_t accepted_inseq = 0;
  80d119:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
                  if (cseg->next != NULL) {
  80d11d:	85 c0                	test   %eax,%eax
  80d11f:	0f 84 f6 01 00 00    	je     80d31b <tcp_receive+0xcd6>
                    if (TCP_SEQ_GT(seqno + cseg->len, next->tcphdr->seqno)) {
  80d125:	8b 0d a8 b1 b3 00    	mov    0xb3b1a8,%ecx
  80d12b:	8b 40 10             	mov    0x10(%eax),%eax
  80d12e:	8b 40 04             	mov    0x4(%eax),%eax
  80d131:	0f b7 56 0c          	movzwl 0xc(%esi),%edx
  80d135:	01 ca                	add    %ecx,%edx
  80d137:	29 c2                	sub    %eax,%edx
  80d139:	85 d2                	test   %edx,%edx
  80d13b:	0f 8e da 01 00 00    	jle    80d31b <tcp_receive+0xcd6>
                      cseg->len = (u16_t)(next->tcphdr->seqno - seqno);
  80d141:	29 c8                	sub    %ecx,%eax
  80d143:	66 89 46 0c          	mov    %ax,0xc(%esi)
                      pbuf_realloc(cseg->p, cseg->len);
  80d147:	83 ec 08             	sub    $0x8,%esp
  80d14a:	0f b7 c0             	movzwl %ax,%eax
  80d14d:	50                   	push   %eax
  80d14e:	ff 76 04             	pushl  0x4(%esi)
  80d151:	e8 fb 7a ff ff       	call   804c51 <pbuf_realloc>
  80d156:	83 c4 10             	add    $0x10,%esp
  u8_t accepted_inseq = 0;
  80d159:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
  80d15d:	e9 b9 01 00 00       	jmp    80d31b <tcp_receive+0xcd6>
                    pcb->ooseq = cseg;
  80d162:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80d165:	89 47 7c             	mov    %eax,0x7c(%edi)
  80d168:	eb 9e                	jmp    80d108 <tcp_receive+0xac3>
                if (TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {
  80d16a:	39 c1                	cmp    %eax,%ecx
  80d16c:	0f 88 a0 00 00 00    	js     80d212 <tcp_receive+0xbcd>
              if (next->next == NULL &&
  80d172:	8b 13                	mov    (%ebx),%edx
  80d174:	89 de                	mov    %ebx,%esi
  80d176:	85 d2                	test   %edx,%edx
  80d178:	0f 84 0d 01 00 00    	je     80d28b <tcp_receive+0xc46>
  80d17e:	89 d3                	mov    %edx,%ebx
            if (seqno == next->tcphdr->seqno) {
  80d180:	8b 43 10             	mov    0x10(%ebx),%eax
  80d183:	8b 40 04             	mov    0x4(%eax),%eax
  80d186:	39 c8                	cmp    %ecx,%eax
  80d188:	0f 84 37 ff ff ff    	je     80d0c5 <tcp_receive+0xa80>
              if (prev == NULL) {
  80d18e:	85 f6                	test   %esi,%esi
  80d190:	74 d8                	je     80d16a <tcp_receive+0xb25>
                if(TCP_SEQ_BETWEEN(seqno, prev->tcphdr->seqno+1, next->tcphdr->seqno-1)){
  80d192:	8b 56 10             	mov    0x10(%esi),%edx
  80d195:	3b 7a 04             	cmp    0x4(%edx),%edi
  80d198:	78 d8                	js     80d172 <tcp_receive+0xb2d>
  80d19a:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80d19d:	29 c2                	sub    %eax,%edx
  80d19f:	85 d2                	test   %edx,%edx
  80d1a1:	7f cf                	jg     80d172 <tcp_receive+0xb2d>
                if (TCP_SEQ_GT(seqno + inseg.len, next->tcphdr->seqno)) {
  80d1a3:	0f b7 15 c0 b1 b3 00 	movzwl 0xb3b1c0,%edx
  80d1aa:	01 ca                	add    %ecx,%edx
  80d1ac:	29 c2                	sub    %eax,%edx
  80d1ae:	85 d2                	test   %edx,%edx
  80d1b0:	0f 8f b3 00 00 00    	jg     80d269 <tcp_receive+0xc24>
                cseg = tcp_seg_copy(&inseg);
  80d1b6:	83 ec 0c             	sub    $0xc,%esp
  80d1b9:	68 b4 b1 b3 00       	push   $0xb3b1b4
  80d1be:	e8 40 87 ff ff       	call   805903 <tcp_seg_copy>
                if (cseg != NULL) {
  80d1c3:	83 c4 10             	add    $0x10,%esp
  u8_t accepted_inseq = 0;
  80d1c6:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
                if (cseg != NULL) {
  80d1ca:	85 c0                	test   %eax,%eax
  80d1cc:	0f 84 49 01 00 00    	je     80d31b <tcp_receive+0xcd6>
                  cseg->next = next;
  80d1d2:	89 18                	mov    %ebx,(%eax)
                  prev->next = cseg;
  80d1d4:	89 06                	mov    %eax,(%esi)
                  if (TCP_SEQ_GT(prev->tcphdr->seqno + prev->len, seqno)) {
  80d1d6:	8b 46 10             	mov    0x10(%esi),%eax
  80d1d9:	8b 48 04             	mov    0x4(%eax),%ecx
  80d1dc:	a1 a8 b1 b3 00       	mov    0xb3b1a8,%eax
  80d1e1:	0f b7 56 0c          	movzwl 0xc(%esi),%edx
  80d1e5:	01 ca                	add    %ecx,%edx
  80d1e7:	29 c2                	sub    %eax,%edx
  80d1e9:	85 d2                	test   %edx,%edx
  80d1eb:	0f 8e 2a 01 00 00    	jle    80d31b <tcp_receive+0xcd6>
                    prev->len = (u16_t)(seqno - prev->tcphdr->seqno);
  80d1f1:	29 c8                	sub    %ecx,%eax
  80d1f3:	66 89 46 0c          	mov    %ax,0xc(%esi)
                    pbuf_realloc(prev->p, prev->len);
  80d1f7:	83 ec 08             	sub    $0x8,%esp
  80d1fa:	0f b7 c0             	movzwl %ax,%eax
  80d1fd:	50                   	push   %eax
  80d1fe:	ff 76 04             	pushl  0x4(%esi)
  80d201:	e8 4b 7a ff ff       	call   804c51 <pbuf_realloc>
  80d206:	83 c4 10             	add    $0x10,%esp
  u8_t accepted_inseq = 0;
  80d209:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
  80d20d:	e9 09 01 00 00       	jmp    80d31b <tcp_receive+0xcd6>
  80d212:	8b 7d e0             	mov    -0x20(%ebp),%edi
                  if (TCP_SEQ_GT(seqno + inseg.len, next->tcphdr->seqno)) {
  80d215:	0f b7 15 c0 b1 b3 00 	movzwl 0xb3b1c0,%edx
  80d21c:	01 ca                	add    %ecx,%edx
  80d21e:	29 c2                	sub    %eax,%edx
  80d220:	85 d2                	test   %edx,%edx
  80d222:	7f 26                	jg     80d24a <tcp_receive+0xc05>
                  cseg = tcp_seg_copy(&inseg);
  80d224:	83 ec 0c             	sub    $0xc,%esp
  80d227:	68 b4 b1 b3 00       	push   $0xb3b1b4
  80d22c:	e8 d2 86 ff ff       	call   805903 <tcp_seg_copy>
                  if (cseg != NULL) {
  80d231:	83 c4 10             	add    $0x10,%esp
  u8_t accepted_inseq = 0;
  80d234:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
                  if (cseg != NULL) {
  80d238:	85 c0                	test   %eax,%eax
  80d23a:	0f 84 db 00 00 00    	je     80d31b <tcp_receive+0xcd6>
                    cseg->next = next;
  80d240:	89 18                	mov    %ebx,(%eax)
                    pcb->ooseq = cseg;
  80d242:	89 47 7c             	mov    %eax,0x7c(%edi)
  80d245:	e9 d1 00 00 00       	jmp    80d31b <tcp_receive+0xcd6>
                    inseg.len = (u16_t)(next->tcphdr->seqno - seqno);
  80d24a:	29 c8                	sub    %ecx,%eax
  80d24c:	66 a3 c0 b1 b3 00    	mov    %ax,0xb3b1c0
                    pbuf_realloc(inseg.p, inseg.len);
  80d252:	83 ec 08             	sub    $0x8,%esp
  80d255:	0f b7 c0             	movzwl %ax,%eax
  80d258:	50                   	push   %eax
  80d259:	ff 35 b8 b1 b3 00    	pushl  0xb3b1b8
  80d25f:	e8 ed 79 ff ff       	call   804c51 <pbuf_realloc>
  80d264:	83 c4 10             	add    $0x10,%esp
  80d267:	eb bb                	jmp    80d224 <tcp_receive+0xbdf>
                  inseg.len = (u16_t)(next->tcphdr->seqno - seqno);
  80d269:	29 c8                	sub    %ecx,%eax
  80d26b:	66 a3 c0 b1 b3 00    	mov    %ax,0xb3b1c0
                  pbuf_realloc(inseg.p, inseg.len);
  80d271:	83 ec 08             	sub    $0x8,%esp
  80d274:	0f b7 c0             	movzwl %ax,%eax
  80d277:	50                   	push   %eax
  80d278:	ff 35 b8 b1 b3 00    	pushl  0xb3b1b8
  80d27e:	e8 ce 79 ff ff       	call   804c51 <pbuf_realloc>
  80d283:	83 c4 10             	add    $0x10,%esp
  80d286:	e9 2b ff ff ff       	jmp    80d1b6 <tcp_receive+0xb71>
                  TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
  80d28b:	29 c1                	sub    %eax,%ecx
  u8_t accepted_inseq = 0;
  80d28d:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
              if (next->next == NULL &&
  80d291:	85 c9                	test   %ecx,%ecx
  80d293:	0f 8e 82 00 00 00    	jle    80d31b <tcp_receive+0xcd6>
                next->next = tcp_seg_copy(&inseg);
  80d299:	83 ec 0c             	sub    $0xc,%esp
  80d29c:	68 b4 b1 b3 00       	push   $0xb3b1b4
  80d2a1:	e8 5d 86 ff ff       	call   805903 <tcp_seg_copy>
  80d2a6:	89 03                	mov    %eax,(%ebx)
                if (next->next != NULL) {
  80d2a8:	83 c4 10             	add    $0x10,%esp
  u8_t accepted_inseq = 0;
  80d2ab:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
                if (next->next != NULL) {
  80d2af:	85 c0                	test   %eax,%eax
  80d2b1:	74 68                	je     80d31b <tcp_receive+0xcd6>
                  if (TCP_SEQ_GT(next->tcphdr->seqno + next->len, seqno)) {
  80d2b3:	8b 43 10             	mov    0x10(%ebx),%eax
  80d2b6:	8b 48 04             	mov    0x4(%eax),%ecx
  80d2b9:	a1 a8 b1 b3 00       	mov    0xb3b1a8,%eax
  80d2be:	0f b7 53 0c          	movzwl 0xc(%ebx),%edx
  80d2c2:	01 ca                	add    %ecx,%edx
  80d2c4:	29 c2                	sub    %eax,%edx
  80d2c6:	85 d2                	test   %edx,%edx
  80d2c8:	7e 51                	jle    80d31b <tcp_receive+0xcd6>
                    next->len = (u16_t)(seqno - next->tcphdr->seqno);
  80d2ca:	29 c8                	sub    %ecx,%eax
  80d2cc:	66 89 43 0c          	mov    %ax,0xc(%ebx)
                    pbuf_realloc(next->p, next->len);
  80d2d0:	83 ec 08             	sub    $0x8,%esp
  80d2d3:	0f b7 c0             	movzwl %ax,%eax
  80d2d6:	50                   	push   %eax
  80d2d7:	ff 73 04             	pushl  0x4(%ebx)
  80d2da:	e8 72 79 ff ff       	call   804c51 <pbuf_realloc>
  80d2df:	83 c4 10             	add    $0x10,%esp
  u8_t accepted_inseq = 0;
  80d2e2:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
  80d2e6:	eb 33                	jmp    80d31b <tcp_receive+0xcd6>
    if(!TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd-1)){
  80d2e8:	a1 a8 b1 b3 00       	mov    0xb3b1a8,%eax
  80d2ed:	8b 57 24             	mov    0x24(%edi),%edx
  80d2f0:	39 d0                	cmp    %edx,%eax
  80d2f2:	78 13                	js     80d307 <tcp_receive+0xcc2>
  80d2f4:	83 c0 01             	add    $0x1,%eax
  80d2f7:	29 d0                	sub    %edx,%eax
  80d2f9:	0f b7 57 28          	movzwl 0x28(%edi),%edx
  80d2fd:	29 d0                	sub    %edx,%eax
  u8_t accepted_inseq = 0;
  80d2ff:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
    if(!TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd-1)){
  80d303:	85 c0                	test   %eax,%eax
  80d305:	7e 14                	jle    80d31b <tcp_receive+0xcd6>
      tcp_ack_now(pcb);
  80d307:	80 4f 20 02          	orb    $0x2,0x20(%edi)
  80d30b:	83 ec 0c             	sub    $0xc,%esp
  80d30e:	57                   	push   %edi
  80d30f:	e8 d2 ae ff ff       	call   8081e6 <tcp_output>
  80d314:	83 c4 10             	add    $0x10,%esp
  u8_t accepted_inseq = 0;
  80d317:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
}
  80d31b:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
  80d31f:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80d322:	5b                   	pop    %ebx
  80d323:	5e                   	pop    %esi
  80d324:	5f                   	pop    %edi
  80d325:	5d                   	pop    %ebp
  80d326:	c3                   	ret    

0080d327 <tcp_input>:
{
  80d327:	f3 0f 1e fb          	endbr32 
  80d32b:	55                   	push   %ebp
  80d32c:	89 e5                	mov    %esp,%ebp
  80d32e:	57                   	push   %edi
  80d32f:	56                   	push   %esi
  80d330:	53                   	push   %ebx
  80d331:	83 ec 38             	sub    $0x38,%esp
  80d334:	8b 75 08             	mov    0x8(%ebp),%esi
  iphdr = p->payload;
  80d337:	8b 5e 04             	mov    0x4(%esi),%ebx
  80d33a:	89 1d ac b1 b3 00    	mov    %ebx,0xb3b1ac
  tcphdr = (struct tcp_hdr *)((u8_t *)p->payload + IPH_HL(iphdr) * 4);
  80d340:	0f b7 03             	movzwl (%ebx),%eax
  80d343:	50                   	push   %eax
  80d344:	e8 28 a5 ff ff       	call   807871 <ntohs>
  80d349:	66 c1 e8 08          	shr    $0x8,%ax
  80d34d:	83 e0 0f             	and    $0xf,%eax
  80d350:	8d 04 83             	lea    (%ebx,%eax,4),%eax
  80d353:	a3 b0 b1 b3 00       	mov    %eax,0xb3b1b0
  if (pbuf_header(p, -((s16_t)(IPH_HL(iphdr) * 4))) || (p->tot_len < sizeof(struct tcp_hdr))) {
  80d358:	a1 ac b1 b3 00       	mov    0xb3b1ac,%eax
  80d35d:	0f b7 00             	movzwl (%eax),%eax
  80d360:	89 04 24             	mov    %eax,(%esp)
  80d363:	e8 09 a5 ff ff       	call   807871 <ntohs>
  80d368:	83 c4 08             	add    $0x8,%esp
  80d36b:	66 c1 e8 06          	shr    $0x6,%ax
  80d36f:	83 e0 3c             	and    $0x3c,%eax
  80d372:	f7 d8                	neg    %eax
  80d374:	98                   	cwtl   
  80d375:	50                   	push   %eax
  80d376:	56                   	push   %esi
  80d377:	e8 d9 74 ff ff       	call   804855 <pbuf_header>
  80d37c:	83 c4 10             	add    $0x10,%esp
  80d37f:	84 c0                	test   %al,%al
  80d381:	75 07                	jne    80d38a <tcp_input+0x63>
  80d383:	66 83 7e 08 13       	cmpw   $0x13,0x8(%esi)
  80d388:	77 14                	ja     80d39e <tcp_input+0x77>
    pbuf_free(p);
  80d38a:	83 ec 0c             	sub    $0xc,%esp
  80d38d:	56                   	push   %esi
  80d38e:	e8 95 75 ff ff       	call   804928 <pbuf_free>
    return;
  80d393:	83 c4 10             	add    $0x10,%esp
}
  80d396:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80d399:	5b                   	pop    %ebx
  80d39a:	5e                   	pop    %esi
  80d39b:	5f                   	pop    %edi
  80d39c:	5d                   	pop    %ebp
  80d39d:	c3                   	ret    
  if (ip_addr_isbroadcast(&(iphdr->dest), inp) ||
  80d39e:	83 ec 08             	sub    $0x8,%esp
  80d3a1:	ff 75 0c             	pushl  0xc(%ebp)
  80d3a4:	a1 ac b1 b3 00       	mov    0xb3b1ac,%eax
  80d3a9:	83 c0 10             	add    $0x10,%eax
  80d3ac:	50                   	push   %eax
  80d3ad:	e8 32 92 ff ff       	call   8065e4 <ip_addr_isbroadcast>
  80d3b2:	83 c4 10             	add    $0x10,%esp
  80d3b5:	84 c0                	test   %al,%al
  80d3b7:	0f 85 54 01 00 00    	jne    80d511 <tcp_input+0x1ea>
      ip_addr_ismulticast(&(iphdr->dest))) {
  80d3bd:	a1 ac b1 b3 00       	mov    0xb3b1ac,%eax
  80d3c2:	8b 58 10             	mov    0x10(%eax),%ebx
  80d3c5:	83 ec 0c             	sub    $0xc,%esp
  80d3c8:	68 00 00 00 f0       	push   $0xf0000000
  80d3cd:	e8 dd a6 ff ff       	call   807aaf <ntohl>
  80d3d2:	21 c3                	and    %eax,%ebx
  80d3d4:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  80d3db:	e8 cf a6 ff ff       	call   807aaf <ntohl>
  if (ip_addr_isbroadcast(&(iphdr->dest), inp) ||
  80d3e0:	83 c4 10             	add    $0x10,%esp
  80d3e3:	39 c3                	cmp    %eax,%ebx
  80d3e5:	0f 84 26 01 00 00    	je     80d511 <tcp_input+0x1ea>
      (struct ip_addr *)&(iphdr->dest),
  80d3eb:	a1 ac b1 b3 00       	mov    0xb3b1ac,%eax
  if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
  80d3f0:	83 ec 0c             	sub    $0xc,%esp
  80d3f3:	0f b7 56 08          	movzwl 0x8(%esi),%edx
  80d3f7:	52                   	push   %edx
  80d3f8:	6a 06                	push   $0x6
  80d3fa:	8d 50 10             	lea    0x10(%eax),%edx
  80d3fd:	52                   	push   %edx
  80d3fe:	83 c0 0c             	add    $0xc,%eax
  80d401:	50                   	push   %eax
  80d402:	56                   	push   %esi
  80d403:	e8 20 a1 ff ff       	call   807528 <inet_chksum_pseudo>
  80d408:	83 c4 20             	add    $0x20,%esp
  80d40b:	66 85 c0             	test   %ax,%ax
  80d40e:	0f 85 0e 01 00 00    	jne    80d522 <tcp_input+0x1fb>
  hdrlen = TCPH_HDRLEN(tcphdr);
  80d414:	83 ec 0c             	sub    $0xc,%esp
  80d417:	a1 b0 b1 b3 00       	mov    0xb3b1b0,%eax
  80d41c:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d420:	50                   	push   %eax
  80d421:	e8 4b a4 ff ff       	call   807871 <ntohs>
  if(pbuf_header(p, -(hdrlen * 4))){
  80d426:	83 c4 08             	add    $0x8,%esp
  hdrlen = TCPH_HDRLEN(tcphdr);
  80d429:	66 c1 e8 0c          	shr    $0xc,%ax
  if(pbuf_header(p, -(hdrlen * 4))){
  80d42d:	f7 d8                	neg    %eax
  80d42f:	c1 e0 02             	shl    $0x2,%eax
  80d432:	98                   	cwtl   
  80d433:	50                   	push   %eax
  80d434:	56                   	push   %esi
  80d435:	e8 1b 74 ff ff       	call   804855 <pbuf_header>
  80d43a:	83 c4 10             	add    $0x10,%esp
  80d43d:	84 c0                	test   %al,%al
  80d43f:	0f 85 ee 00 00 00    	jne    80d533 <tcp_input+0x20c>
  tcphdr->src = ntohs(tcphdr->src);
  80d445:	8b 1d b0 b1 b3 00    	mov    0xb3b1b0,%ebx
  80d44b:	83 ec 0c             	sub    $0xc,%esp
  80d44e:	0f b7 03             	movzwl (%ebx),%eax
  80d451:	50                   	push   %eax
  80d452:	e8 1a a4 ff ff       	call   807871 <ntohs>
  80d457:	66 89 03             	mov    %ax,(%ebx)
  tcphdr->dest = ntohs(tcphdr->dest);
  80d45a:	8b 1d b0 b1 b3 00    	mov    0xb3b1b0,%ebx
  80d460:	0f b7 43 02          	movzwl 0x2(%ebx),%eax
  80d464:	89 04 24             	mov    %eax,(%esp)
  80d467:	e8 05 a4 ff ff       	call   807871 <ntohs>
  80d46c:	66 89 43 02          	mov    %ax,0x2(%ebx)
  seqno = tcphdr->seqno = ntohl(tcphdr->seqno);
  80d470:	8b 1d b0 b1 b3 00    	mov    0xb3b1b0,%ebx
  80d476:	83 c4 04             	add    $0x4,%esp
  80d479:	ff 73 04             	pushl  0x4(%ebx)
  80d47c:	e8 2e a6 ff ff       	call   807aaf <ntohl>
  80d481:	89 43 04             	mov    %eax,0x4(%ebx)
  80d484:	a3 a8 b1 b3 00       	mov    %eax,0xb3b1a8
  ackno = tcphdr->ackno = ntohl(tcphdr->ackno);
  80d489:	8b 1d b0 b1 b3 00    	mov    0xb3b1b0,%ebx
  80d48f:	83 c4 04             	add    $0x4,%esp
  80d492:	ff 73 08             	pushl  0x8(%ebx)
  80d495:	e8 15 a6 ff ff       	call   807aaf <ntohl>
  80d49a:	89 43 08             	mov    %eax,0x8(%ebx)
  80d49d:	a3 a4 b1 b3 00       	mov    %eax,0xb3b1a4
  tcphdr->wnd = ntohs(tcphdr->wnd);
  80d4a2:	8b 1d b0 b1 b3 00    	mov    0xb3b1b0,%ebx
  80d4a8:	0f b7 43 0e          	movzwl 0xe(%ebx),%eax
  80d4ac:	89 04 24             	mov    %eax,(%esp)
  80d4af:	e8 bd a3 ff ff       	call   807871 <ntohs>
  80d4b4:	66 89 43 0e          	mov    %ax,0xe(%ebx)
  flags = TCPH_FLAGS(tcphdr) & TCP_FLAGS;
  80d4b8:	a1 b0 b1 b3 00       	mov    0xb3b1b0,%eax
  80d4bd:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d4c1:	89 04 24             	mov    %eax,(%esp)
  80d4c4:	e8 a8 a3 ff ff       	call   807871 <ntohs>
  80d4c9:	89 c1                	mov    %eax,%ecx
  80d4cb:	66 89 45 d6          	mov    %ax,-0x2a(%ebp)
  80d4cf:	83 e0 3f             	and    $0x3f,%eax
  80d4d2:	a2 a0 b1 b3 00       	mov    %al,0xb3b1a0
  tcplen = p->tot_len + ((flags & TCP_FIN || flags & TCP_SYN)? 1: 0);
  80d4d7:	83 c4 10             	add    $0x10,%esp
  80d4da:	f6 c1 03             	test   $0x3,%cl
  80d4dd:	0f 95 c0             	setne  %al
  80d4e0:	0f b6 c0             	movzbl %al,%eax
  80d4e3:	66 03 46 08          	add    0x8(%esi),%ax
  80d4e7:	66 89 45 d4          	mov    %ax,-0x2c(%ebp)
  80d4eb:	66 a3 9e b1 b3 00    	mov    %ax,0xb3b19e
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80d4f1:	a1 3c b2 b3 00       	mov    0xb3b23c,%eax
  80d4f6:	89 45 d0             	mov    %eax,-0x30(%ebp)
    if (pcb->remote_port == tcphdr->src &&
  80d4f9:	8b 15 b0 b1 b3 00    	mov    0xb3b1b0,%edx
       ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
  80d4ff:	8b 0d ac b1 b3 00    	mov    0xb3b1ac,%ecx
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80d505:	89 c3                	mov    %eax,%ebx
  prev = NULL;
  80d507:	bf 00 00 00 00       	mov    $0x0,%edi
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80d50c:	e9 ab 00 00 00       	jmp    80d5bc <tcp_input+0x295>
    pbuf_free(p);
  80d511:	83 ec 0c             	sub    $0xc,%esp
  80d514:	56                   	push   %esi
  80d515:	e8 0e 74 ff ff       	call   804928 <pbuf_free>
    return;
  80d51a:	83 c4 10             	add    $0x10,%esp
  80d51d:	e9 74 fe ff ff       	jmp    80d396 <tcp_input+0x6f>
    pbuf_free(p);
  80d522:	83 ec 0c             	sub    $0xc,%esp
  80d525:	56                   	push   %esi
  80d526:	e8 fd 73 ff ff       	call   804928 <pbuf_free>
    return;
  80d52b:	83 c4 10             	add    $0x10,%esp
  80d52e:	e9 63 fe ff ff       	jmp    80d396 <tcp_input+0x6f>
    pbuf_free(p);
  80d533:	83 ec 0c             	sub    $0xc,%esp
  80d536:	56                   	push   %esi
  80d537:	e8 ec 73 ff ff       	call   804928 <pbuf_free>
    return;
  80d53c:	83 c4 10             	add    $0x10,%esp
  80d53f:	e9 52 fe ff ff       	jmp    80d396 <tcp_input+0x6f>
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
  80d544:	83 ec 04             	sub    $0x4,%esp
  80d547:	68 70 34 81 00       	push   $0x813470
  80d54c:	68 b5 00 00 00       	push   $0xb5
  80d551:	68 94 35 81 00       	push   $0x813594
  80d556:	e8 ec 12 00 00       	call   80e847 <_panic>
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
  80d55b:	83 ec 04             	sub    $0x4,%esp
  80d55e:	68 98 34 81 00       	push   $0x813498
  80d563:	68 b6 00 00 00       	push   $0xb6
  80d568:	68 94 35 81 00       	push   $0x813594
  80d56d:	e8 d5 12 00 00       	call   80e847 <_panic>
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
  80d572:	83 ec 04             	sub    $0x4,%esp
  80d575:	68 c4 34 81 00       	push   $0x8134c4
  80d57a:	68 b7 00 00 00       	push   $0xb7
  80d57f:	68 94 35 81 00       	push   $0x813594
  80d584:	e8 be 12 00 00       	call   80e847 <_panic>
      LWIP_ASSERT("tcp_input: pcb->next != pcb (before cache)", pcb->next != pcb);
  80d589:	83 ec 04             	sub    $0x4,%esp
  80d58c:	68 ec 34 81 00       	push   $0x8134ec
  80d591:	68 c0 00 00 00       	push   $0xc0
  80d596:	68 94 35 81 00       	push   $0x813594
  80d59b:	e8 a7 12 00 00       	call   80e847 <_panic>
      LWIP_ASSERT("tcp_input: pcb->next != pcb (after cache)", pcb->next != pcb);
  80d5a0:	83 ec 04             	sub    $0x4,%esp
  80d5a3:	68 18 35 81 00       	push   $0x813518
  80d5a8:	68 c6 00 00 00       	push   $0xc6
  80d5ad:	68 94 35 81 00       	push   $0x813594
  80d5b2:	e8 90 12 00 00       	call   80e847 <_panic>
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80d5b7:	89 df                	mov    %ebx,%edi
  80d5b9:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  80d5bc:	85 db                	test   %ebx,%ebx
  80d5be:	0f 84 5b 0a 00 00    	je     80e01f <tcp_input+0xcf8>
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
  80d5c4:	8b 43 10             	mov    0x10(%ebx),%eax
  80d5c7:	85 c0                	test   %eax,%eax
  80d5c9:	0f 84 75 ff ff ff    	je     80d544 <tcp_input+0x21d>
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
  80d5cf:	83 f8 0a             	cmp    $0xa,%eax
  80d5d2:	74 87                	je     80d55b <tcp_input+0x234>
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
  80d5d4:	83 f8 01             	cmp    $0x1,%eax
  80d5d7:	74 99                	je     80d572 <tcp_input+0x24b>
    if (pcb->remote_port == tcphdr->src &&
  80d5d9:	0f b7 02             	movzwl (%edx),%eax
  80d5dc:	66 39 43 1e          	cmp    %ax,0x1e(%ebx)
  80d5e0:	75 d5                	jne    80d5b7 <tcp_input+0x290>
  80d5e2:	0f b7 42 02          	movzwl 0x2(%edx),%eax
  80d5e6:	66 39 43 1c          	cmp    %ax,0x1c(%ebx)
  80d5ea:	75 cb                	jne    80d5b7 <tcp_input+0x290>
       pcb->local_port == tcphdr->dest &&
  80d5ec:	8b 41 0c             	mov    0xc(%ecx),%eax
  80d5ef:	39 43 04             	cmp    %eax,0x4(%ebx)
  80d5f2:	75 c3                	jne    80d5b7 <tcp_input+0x290>
       ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
  80d5f4:	8b 41 10             	mov    0x10(%ecx),%eax
  80d5f7:	39 03                	cmp    %eax,(%ebx)
  80d5f9:	75 bc                	jne    80d5b7 <tcp_input+0x290>
      LWIP_ASSERT("tcp_input: pcb->next != pcb (before cache)", pcb->next != pcb);
  80d5fb:	8b 43 0c             	mov    0xc(%ebx),%eax
  80d5fe:	39 c3                	cmp    %eax,%ebx
  80d600:	74 87                	je     80d589 <tcp_input+0x262>
      if (prev != NULL) {
  80d602:	85 ff                	test   %edi,%edi
  80d604:	74 13                	je     80d619 <tcp_input+0x2f2>
        prev->next = pcb->next;
  80d606:	89 47 0c             	mov    %eax,0xc(%edi)
        pcb->next = tcp_active_pcbs;
  80d609:	8b 45 d0             	mov    -0x30(%ebp),%eax
  80d60c:	89 43 0c             	mov    %eax,0xc(%ebx)
        tcp_active_pcbs = pcb;
  80d60f:	89 1d 3c b2 b3 00    	mov    %ebx,0xb3b23c
      LWIP_ASSERT("tcp_input: pcb->next != pcb (after cache)", pcb->next != pcb);
  80d615:	39 c3                	cmp    %eax,%ebx
  80d617:	74 87                	je     80d5a0 <tcp_input+0x279>
    inseg.next = NULL;
  80d619:	c7 05 b4 b1 b3 00 00 	movl   $0x0,0xb3b1b4
  80d620:	00 00 00 
    inseg.len = p->tot_len;
  80d623:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  80d627:	66 a3 c0 b1 b3 00    	mov    %ax,0xb3b1c0
    inseg.dataptr = p->payload;
  80d62d:	8b 46 04             	mov    0x4(%esi),%eax
  80d630:	a3 bc b1 b3 00       	mov    %eax,0xb3b1bc
    inseg.p = p;
  80d635:	89 35 b8 b1 b3 00    	mov    %esi,0xb3b1b8
    inseg.tcphdr = tcphdr;
  80d63b:	89 15 c4 b1 b3 00    	mov    %edx,0xb3b1c4
    recv_data = NULL;
  80d641:	c7 05 98 b1 b3 00 00 	movl   $0x0,0xb3b198
  80d648:	00 00 00 
    recv_flags = 0;
  80d64b:	c6 05 9c b1 b3 00 00 	movb   $0x0,0xb3b19c
    if (pcb->refused_data != NULL) {
  80d652:	8b 83 80 00 00 00    	mov    0x80(%ebx),%eax
  80d658:	85 c0                	test   %eax,%eax
  80d65a:	74 2c                	je     80d688 <tcp_input+0x361>
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
  80d65c:	8b 93 88 00 00 00    	mov    0x88(%ebx),%edx
  80d662:	85 d2                	test   %edx,%edx
  80d664:	0f 84 dd 02 00 00    	je     80d947 <tcp_input+0x620>
  80d66a:	6a 00                	push   $0x0
  80d66c:	50                   	push   %eax
  80d66d:	53                   	push   %ebx
  80d66e:	ff 73 18             	pushl  0x18(%ebx)
  80d671:	ff d2                	call   *%edx
      if (err == ERR_OK) {
  80d673:	83 c4 10             	add    $0x10,%esp
  80d676:	84 c0                	test   %al,%al
  80d678:	0f 85 da 02 00 00    	jne    80d958 <tcp_input+0x631>
        pcb->refused_data = NULL;
  80d67e:	c7 83 80 00 00 00 00 	movl   $0x0,0x80(%ebx)
  80d685:	00 00 00 
    tcp_input_pcb = pcb;
  80d688:	89 1d 58 b2 b3 00    	mov    %ebx,0xb3b258
  if (flags & TCP_RST) {
  80d68e:	0f b6 05 a0 b1 b3 00 	movzbl 0xb3b1a0,%eax
  80d695:	a8 04                	test   $0x4,%al
  80d697:	0f 84 f6 02 00 00    	je     80d993 <tcp_input+0x66c>
    if (pcb->state == SYN_SENT) {
  80d69d:	8b 53 10             	mov    0x10(%ebx),%edx
  80d6a0:	83 fa 02             	cmp    $0x2,%edx
  80d6a3:	0f 84 c0 02 00 00    	je     80d969 <tcp_input+0x642>
      if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
  80d6a9:	a1 a8 b1 b3 00       	mov    0xb3b1a8,%eax
  80d6ae:	2b 43 24             	sub    0x24(%ebx),%eax
  80d6b1:	78 1d                	js     80d6d0 <tcp_input+0x3a9>
  80d6b3:	0f b7 4b 28          	movzwl 0x28(%ebx),%ecx
  80d6b7:	29 c8                	sub    %ecx,%eax
  80d6b9:	85 c0                	test   %eax,%eax
  80d6bb:	7f 13                	jg     80d6d0 <tcp_input+0x3a9>
      LWIP_ASSERT("tcp_input: pcb->state != CLOSED", pcb->state != CLOSED);
  80d6bd:	85 d2                	test   %edx,%edx
  80d6bf:	0f 84 b7 02 00 00    	je     80d97c <tcp_input+0x655>
      recv_flags = TF_RESET;
  80d6c5:	c6 05 9c b1 b3 00 08 	movb   $0x8,0xb3b19c
      pcb->flags &= ~TF_ACK_DELAY;
  80d6cc:	80 63 20 fe          	andb   $0xfe,0x20(%ebx)
    tcp_input_pcb = NULL;
  80d6d0:	c7 05 58 b2 b3 00 00 	movl   $0x0,0xb3b258
  80d6d7:	00 00 00 
      if (recv_flags & TF_RESET) {
  80d6da:	0f b6 05 9c b1 b3 00 	movzbl 0xb3b19c,%eax
  80d6e1:	a8 08                	test   $0x8,%al
  80d6e3:	0f 84 df 07 00 00    	je     80dec8 <tcp_input+0xba1>
        TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_RST);
  80d6e9:	8b 83 98 00 00 00    	mov    0x98(%ebx),%eax
  80d6ef:	85 c0                	test   %eax,%eax
  80d6f1:	74 0d                	je     80d700 <tcp_input+0x3d9>
  80d6f3:	83 ec 08             	sub    $0x8,%esp
  80d6f6:	6a fa                	push   $0xfffffffa
  80d6f8:	ff 73 18             	pushl  0x18(%ebx)
  80d6fb:	ff d0                	call   *%eax
  80d6fd:	83 c4 10             	add    $0x10,%esp
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
  80d700:	83 ec 08             	sub    $0x8,%esp
  80d703:	53                   	push   %ebx
  80d704:	68 3c b2 b3 00       	push   $0xb3b23c
  80d709:	e8 32 83 ff ff       	call   805a40 <tcp_pcb_remove>
        memp_free(MEMP_TCP_PCB, pcb);
  80d70e:	83 c4 08             	add    $0x8,%esp
  80d711:	53                   	push   %ebx
  80d712:	6a 02                	push   $0x2
  80d714:	e8 8c 6e ff ff       	call   8045a5 <memp_free>
  80d719:	83 c4 10             	add    $0x10,%esp
    if (inseg.p != NULL)
  80d71c:	a1 b8 b1 b3 00       	mov    0xb3b1b8,%eax
  80d721:	85 c0                	test   %eax,%eax
  80d723:	0f 84 6d fc ff ff    	je     80d396 <tcp_input+0x6f>
      pbuf_free(inseg.p);
  80d729:	83 ec 0c             	sub    $0xc,%esp
  80d72c:	50                   	push   %eax
  80d72d:	e8 f6 71 ff ff       	call   804928 <pbuf_free>
      inseg.p = NULL;
  80d732:	c7 05 b8 b1 b3 00 00 	movl   $0x0,0xb3b1b8
  80d739:	00 00 00 
  80d73c:	83 c4 10             	add    $0x10,%esp
  80d73f:	e9 52 fc ff ff       	jmp    80d396 <tcp_input+0x6f>
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
  80d744:	83 ec 04             	sub    $0x4,%esp
  80d747:	68 44 35 81 00       	push   $0x813544
  80d74c:	68 d0 00 00 00       	push   $0xd0
  80d751:	68 94 35 81 00       	push   $0x813594
  80d756:	e8 ec 10 00 00       	call   80e847 <_panic>
    tcp_ack_now(pcb);
  80d75b:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80d75f:	83 ec 0c             	sub    $0xc,%esp
  80d762:	53                   	push   %ebx
  80d763:	e8 7e aa ff ff       	call   8081e6 <tcp_output>
  80d768:	83 c4 10             	add    $0x10,%esp
  80d76b:	eb 4c                	jmp    80d7b9 <tcp_input+0x492>
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  80d76d:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  80d770:	85 db                	test   %ebx,%ebx
  80d772:	74 5e                	je     80d7d2 <tcp_input+0x4ab>
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
  80d774:	83 7b 10 0a          	cmpl   $0xa,0x10(%ebx)
  80d778:	75 ca                	jne    80d744 <tcp_input+0x41d>
      if (pcb->remote_port == tcphdr->src &&
  80d77a:	0f b7 02             	movzwl (%edx),%eax
  80d77d:	66 39 43 1e          	cmp    %ax,0x1e(%ebx)
  80d781:	75 ea                	jne    80d76d <tcp_input+0x446>
  80d783:	0f b7 42 02          	movzwl 0x2(%edx),%eax
  80d787:	66 39 43 1c          	cmp    %ax,0x1c(%ebx)
  80d78b:	75 e0                	jne    80d76d <tcp_input+0x446>
         pcb->local_port == tcphdr->dest &&
  80d78d:	8b 41 0c             	mov    0xc(%ecx),%eax
  80d790:	39 43 04             	cmp    %eax,0x4(%ebx)
  80d793:	75 d8                	jne    80d76d <tcp_input+0x446>
         ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
  80d795:	8b 41 10             	mov    0x10(%ecx),%eax
  80d798:	39 03                	cmp    %eax,(%ebx)
  80d79a:	75 d1                	jne    80d76d <tcp_input+0x446>
  if (TCP_SEQ_GT(seqno + tcplen, pcb->rcv_nxt)) {
  80d79c:	0f b7 45 d4          	movzwl -0x2c(%ebp),%eax
  80d7a0:	03 05 a8 b1 b3 00    	add    0xb3b1a8,%eax
  80d7a6:	89 c2                	mov    %eax,%edx
  80d7a8:	2b 53 24             	sub    0x24(%ebx),%edx
  80d7ab:	85 d2                	test   %edx,%edx
  80d7ad:	7e 03                	jle    80d7b2 <tcp_input+0x48b>
    pcb->rcv_nxt = seqno + tcplen;
  80d7af:	89 43 24             	mov    %eax,0x24(%ebx)
  if (tcplen > 0) {
  80d7b2:	66 83 7d d4 00       	cmpw   $0x0,-0x2c(%ebp)
  80d7b7:	75 a2                	jne    80d75b <tcp_input+0x434>
  return tcp_output(pcb);
  80d7b9:	83 ec 0c             	sub    $0xc,%esp
  80d7bc:	53                   	push   %ebx
  80d7bd:	e8 24 aa ff ff       	call   8081e6 <tcp_output>
        pbuf_free(p);
  80d7c2:	89 34 24             	mov    %esi,(%esp)
  80d7c5:	e8 5e 71 ff ff       	call   804928 <pbuf_free>
        return;
  80d7ca:	83 c4 10             	add    $0x10,%esp
  80d7cd:	e9 c4 fb ff ff       	jmp    80d396 <tcp_input+0x6f>
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  80d7d2:	a1 44 b2 b3 00       	mov    0xb3b244,%eax
  80d7d7:	89 45 d0             	mov    %eax,-0x30(%ebp)
  80d7da:	89 c7                	mov    %eax,%edi
  80d7dc:	eb 0f                	jmp    80d7ed <tcp_input+0x4c6>
        ip_addr_cmp(&(lpcb->local_ip), &(iphdr->dest))) &&
  80d7de:	0f b7 42 02          	movzwl 0x2(%edx),%eax
  80d7e2:	66 39 47 1c          	cmp    %ax,0x1c(%edi)
  80d7e6:	74 1a                	je     80d802 <tcp_input+0x4db>
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  80d7e8:	89 fb                	mov    %edi,%ebx
  80d7ea:	8b 7f 0c             	mov    0xc(%edi),%edi
  80d7ed:	85 ff                	test   %edi,%edi
  80d7ef:	0f 84 05 08 00 00    	je     80dffa <tcp_input+0xcd3>
      if ((ip_addr_isany(&(lpcb->local_ip)) ||
  80d7f5:	8b 07                	mov    (%edi),%eax
  80d7f7:	85 c0                	test   %eax,%eax
  80d7f9:	74 e3                	je     80d7de <tcp_input+0x4b7>
  80d7fb:	3b 41 10             	cmp    0x10(%ecx),%eax
  80d7fe:	75 e8                	jne    80d7e8 <tcp_input+0x4c1>
  80d800:	eb dc                	jmp    80d7de <tcp_input+0x4b7>
        if (prev != NULL) {
  80d802:	85 db                	test   %ebx,%ebx
  80d804:	74 12                	je     80d818 <tcp_input+0x4f1>
          ((struct tcp_pcb_listen *)prev)->next = lpcb->next;
  80d806:	8b 47 0c             	mov    0xc(%edi),%eax
  80d809:	89 43 0c             	mov    %eax,0xc(%ebx)
          lpcb->next = tcp_listen_pcbs.listen_pcbs;
  80d80c:	8b 45 d0             	mov    -0x30(%ebp),%eax
  80d80f:	89 47 0c             	mov    %eax,0xc(%edi)
          tcp_listen_pcbs.listen_pcbs = lpcb;
  80d812:	89 3d 44 b2 b3 00    	mov    %edi,0xb3b244
  if (flags & TCP_ACK) {
  80d818:	f6 45 d6 10          	testb  $0x10,-0x2a(%ebp)
  80d81c:	75 17                	jne    80d835 <tcp_input+0x50e>
  } else if (flags & TCP_SYN) {
  80d81e:	f6 45 d6 02          	testb  $0x2,-0x2a(%ebp)
  80d822:	75 43                	jne    80d867 <tcp_input+0x540>
        pbuf_free(p);
  80d824:	83 ec 0c             	sub    $0xc,%esp
  80d827:	56                   	push   %esi
  80d828:	e8 fb 70 ff ff       	call   804928 <pbuf_free>
        return;
  80d82d:	83 c4 10             	add    $0x10,%esp
  80d830:	e9 61 fb ff ff       	jmp    80d396 <tcp_input+0x6f>
    tcp_rst(ackno + 1, seqno + tcplen,
  80d835:	83 ec 08             	sub    $0x8,%esp
  80d838:	0f b7 02             	movzwl (%edx),%eax
  80d83b:	50                   	push   %eax
  80d83c:	0f b7 42 02          	movzwl 0x2(%edx),%eax
  80d840:	50                   	push   %eax
  80d841:	8d 41 0c             	lea    0xc(%ecx),%eax
  80d844:	50                   	push   %eax
  80d845:	83 c1 10             	add    $0x10,%ecx
  80d848:	51                   	push   %ecx
  80d849:	0f b7 45 d4          	movzwl -0x2c(%ebp),%eax
  80d84d:	03 05 a8 b1 b3 00    	add    0xb3b1a8,%eax
  80d853:	50                   	push   %eax
  80d854:	a1 a4 b1 b3 00       	mov    0xb3b1a4,%eax
  80d859:	83 c0 01             	add    $0x1,%eax
  80d85c:	50                   	push   %eax
  80d85d:	e8 2a ae ff ff       	call   80868c <tcp_rst>
  80d862:	83 c4 20             	add    $0x20,%esp
  80d865:	eb bd                	jmp    80d824 <tcp_input+0x4fd>
    npcb = tcp_alloc(pcb->prio);
  80d867:	83 ec 0c             	sub    $0xc,%esp
  80d86a:	0f b6 47 14          	movzbl 0x14(%edi),%eax
  80d86e:	50                   	push   %eax
  80d86f:	e8 0e 8a ff ff       	call   806282 <tcp_alloc>
  80d874:	89 c3                	mov    %eax,%ebx
    if (npcb == NULL) {
  80d876:	83 c4 10             	add    $0x10,%esp
  80d879:	85 c0                	test   %eax,%eax
  80d87b:	74 a7                	je     80d824 <tcp_input+0x4fd>
    ip_addr_set(&(npcb->local_ip), &(iphdr->dest));
  80d87d:	a1 ac b1 b3 00       	mov    0xb3b1ac,%eax
  80d882:	8b 50 10             	mov    0x10(%eax),%edx
  80d885:	89 13                	mov    %edx,(%ebx)
    npcb->local_port = pcb->local_port;
  80d887:	0f b7 57 1c          	movzwl 0x1c(%edi),%edx
  80d88b:	66 89 53 1c          	mov    %dx,0x1c(%ebx)
    ip_addr_set(&(npcb->remote_ip), &(iphdr->src));
  80d88f:	8b 40 0c             	mov    0xc(%eax),%eax
  80d892:	89 43 04             	mov    %eax,0x4(%ebx)
    npcb->remote_port = tcphdr->src;
  80d895:	8b 15 b0 b1 b3 00    	mov    0xb3b1b0,%edx
  80d89b:	0f b7 02             	movzwl (%edx),%eax
  80d89e:	66 89 43 1e          	mov    %ax,0x1e(%ebx)
    npcb->state = SYN_RCVD;
  80d8a2:	c7 43 10 03 00 00 00 	movl   $0x3,0x10(%ebx)
    npcb->rcv_nxt = seqno + 1;
  80d8a9:	a1 a8 b1 b3 00       	mov    0xb3b1a8,%eax
  80d8ae:	8d 48 01             	lea    0x1(%eax),%ecx
  80d8b1:	89 4b 24             	mov    %ecx,0x24(%ebx)
    npcb->snd_wnd = tcphdr->wnd;
  80d8b4:	0f b7 52 0e          	movzwl 0xe(%edx),%edx
  80d8b8:	66 89 53 5c          	mov    %dx,0x5c(%ebx)
    npcb->ssthresh = npcb->snd_wnd;
  80d8bc:	66 89 53 50          	mov    %dx,0x50(%ebx)
    npcb->snd_wl1 = seqno - 1;/* initialise to seqno-1 to force window update */
  80d8c0:	83 e8 01             	sub    $0x1,%eax
  80d8c3:	89 43 60             	mov    %eax,0x60(%ebx)
    npcb->callback_arg = pcb->callback_arg;
  80d8c6:	8b 47 18             	mov    0x18(%edi),%eax
  80d8c9:	89 43 18             	mov    %eax,0x18(%ebx)
    npcb->accept = pcb->accept;
  80d8cc:	8b 47 20             	mov    0x20(%edi),%eax
  80d8cf:	89 83 90 00 00 00    	mov    %eax,0x90(%ebx)
    npcb->so_options = pcb->so_options & (SOF_DEBUG|SOF_DONTROUTE|SOF_KEEPALIVE|SOF_OOBINLINE|SOF_LINGER);
  80d8d5:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  80d8d9:	66 25 99 01          	and    $0x199,%ax
  80d8dd:	66 89 43 08          	mov    %ax,0x8(%ebx)
    TCP_REG(&tcp_active_pcbs, npcb);
  80d8e1:	a1 3c b2 b3 00       	mov    0xb3b23c,%eax
  80d8e6:	89 43 0c             	mov    %eax,0xc(%ebx)
  80d8e9:	89 1d 3c b2 b3 00    	mov    %ebx,0xb3b23c
  80d8ef:	e8 5f 49 ff ff       	call   802253 <tcp_timer_needed>
    tcp_parseopt(npcb);
  80d8f4:	89 d8                	mov    %ebx,%eax
  80d8f6:	e8 96 ec ff ff       	call   80c591 <tcp_parseopt>
    npcb->mss = tcp_eff_send_mss(npcb->mss, &(npcb->remote_ip));
  80d8fb:	83 ec 08             	sub    $0x8,%esp
  80d8fe:	8d 43 04             	lea    0x4(%ebx),%eax
  80d901:	50                   	push   %eax
  80d902:	0f b7 43 34          	movzwl 0x34(%ebx),%eax
  80d906:	50                   	push   %eax
  80d907:	e8 1c 8b ff ff       	call   806428 <tcp_eff_send_mss>
  80d90c:	66 89 43 34          	mov    %ax,0x34(%ebx)
    optdata = TCP_BUILD_MSS_OPTION();
  80d910:	c7 04 24 b4 05 04 02 	movl   $0x20405b4,(%esp)
  80d917:	e8 66 9f ff ff       	call   807882 <htonl>
  80d91c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    tcp_enqueue(npcb, NULL, 0, TCP_SYN | TCP_ACK, 0, (u8_t *)&optdata, 4);
  80d91f:	83 c4 0c             	add    $0xc,%esp
  80d922:	6a 04                	push   $0x4
  80d924:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80d927:	50                   	push   %eax
  80d928:	6a 00                	push   $0x0
  80d92a:	6a 12                	push   $0x12
  80d92c:	6a 00                	push   $0x0
  80d92e:	6a 00                	push   $0x0
  80d930:	53                   	push   %ebx
  80d931:	e8 90 a1 ff ff       	call   807ac6 <tcp_enqueue>
    return tcp_output(npcb);
  80d936:	83 c4 14             	add    $0x14,%esp
  80d939:	53                   	push   %ebx
  80d93a:	e8 a7 a8 ff ff       	call   8081e6 <tcp_output>
  80d93f:	83 c4 10             	add    $0x10,%esp
  80d942:	e9 dd fe ff ff       	jmp    80d824 <tcp_input+0x4fd>
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
  80d947:	83 ec 0c             	sub    $0xc,%esp
  80d94a:	50                   	push   %eax
  80d94b:	e8 d8 6f ff ff       	call   804928 <pbuf_free>
  80d950:	83 c4 10             	add    $0x10,%esp
  80d953:	e9 26 fd ff ff       	jmp    80d67e <tcp_input+0x357>
        pbuf_free(p);
  80d958:	83 ec 0c             	sub    $0xc,%esp
  80d95b:	56                   	push   %esi
  80d95c:	e8 c7 6f ff ff       	call   804928 <pbuf_free>
        return;
  80d961:	83 c4 10             	add    $0x10,%esp
  80d964:	e9 2d fa ff ff       	jmp    80d396 <tcp_input+0x6f>
      if (ackno == pcb->snd_nxt) {
  80d969:	a1 a4 b1 b3 00       	mov    0xb3b1a4,%eax
  80d96e:	39 43 54             	cmp    %eax,0x54(%ebx)
  80d971:	0f 84 4e fd ff ff    	je     80d6c5 <tcp_input+0x39e>
  80d977:	e9 54 fd ff ff       	jmp    80d6d0 <tcp_input+0x3a9>
      LWIP_ASSERT("tcp_input: pcb->state != CLOSED", pcb->state != CLOSED);
  80d97c:	83 ec 04             	sub    $0x4,%esp
  80d97f:	68 74 35 81 00       	push   $0x813574
  80d984:	68 09 02 00 00       	push   $0x209
  80d989:	68 94 35 81 00       	push   $0x813594
  80d98e:	e8 b4 0e 00 00       	call   80e847 <_panic>
  pcb->tmr = tcp_ticks;
  80d993:	8b 15 40 b2 b3 00    	mov    0xb3b240,%edx
  80d999:	89 53 2c             	mov    %edx,0x2c(%ebx)
  pcb->keep_cnt_sent = 0;
  80d99c:	c6 83 a5 00 00 00 00 	movb   $0x0,0xa5(%ebx)
  80d9a3:	83 7b 10 09          	cmpl   $0x9,0x10(%ebx)
  80d9a7:	0f 87 0c 05 00 00    	ja     80deb9 <tcp_input+0xb92>
  80d9ad:	8b 53 10             	mov    0x10(%ebx),%edx
  80d9b0:	3e ff 24 95 18 36 81 	notrack jmp *0x813618(,%edx,4)
  80d9b7:	00 
    if ((flags & TCP_ACK) && (flags & TCP_SYN)
  80d9b8:	83 e0 12             	and    $0x12,%eax
  80d9bb:	3c 12                	cmp    $0x12,%al
  80d9bd:	74 4d                	je     80da0c <tcp_input+0x6e5>
    else if (flags & TCP_ACK) {
  80d9bf:	f6 05 a0 b1 b3 00 10 	testb  $0x10,0xb3b1a0
  80d9c6:	0f 84 04 fd ff ff    	je     80d6d0 <tcp_input+0x3a9>
        tcphdr->dest, tcphdr->src);
  80d9cc:	8b 15 b0 b1 b3 00    	mov    0xb3b1b0,%edx
      tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
  80d9d2:	a1 ac b1 b3 00       	mov    0xb3b1ac,%eax
  80d9d7:	83 ec 08             	sub    $0x8,%esp
  80d9da:	0f b7 0a             	movzwl (%edx),%ecx
  80d9dd:	51                   	push   %ecx
  80d9de:	0f b7 52 02          	movzwl 0x2(%edx),%edx
  80d9e2:	52                   	push   %edx
  80d9e3:	8d 50 0c             	lea    0xc(%eax),%edx
  80d9e6:	52                   	push   %edx
  80d9e7:	83 c0 10             	add    $0x10,%eax
  80d9ea:	50                   	push   %eax
  80d9eb:	0f b7 05 9e b1 b3 00 	movzwl 0xb3b19e,%eax
  80d9f2:	03 05 a8 b1 b3 00    	add    0xb3b1a8,%eax
  80d9f8:	50                   	push   %eax
  80d9f9:	ff 35 a4 b1 b3 00    	pushl  0xb3b1a4
  80d9ff:	e8 88 ac ff ff       	call   80868c <tcp_rst>
  80da04:	83 c4 20             	add    $0x20,%esp
  80da07:	e9 c4 fc ff ff       	jmp    80d6d0 <tcp_input+0x3a9>
        && ackno == ntohl(pcb->unacked->tcphdr->seqno) + 1) {
  80da0c:	83 ec 0c             	sub    $0xc,%esp
  80da0f:	8b 43 78             	mov    0x78(%ebx),%eax
  80da12:	8b 40 10             	mov    0x10(%eax),%eax
  80da15:	ff 70 04             	pushl  0x4(%eax)
  80da18:	e8 92 a0 ff ff       	call   807aaf <ntohl>
  80da1d:	8b 15 a4 b1 b3 00    	mov    0xb3b1a4,%edx
  80da23:	83 c0 01             	add    $0x1,%eax
  80da26:	83 c4 10             	add    $0x10,%esp
  80da29:	39 d0                	cmp    %edx,%eax
  80da2b:	75 92                	jne    80d9bf <tcp_input+0x698>
      pcb->snd_buf++;
  80da2d:	66 83 43 6e 01       	addw   $0x1,0x6e(%ebx)
      pcb->rcv_nxt = seqno + 1;
  80da32:	a1 a8 b1 b3 00       	mov    0xb3b1a8,%eax
  80da37:	8d 48 01             	lea    0x1(%eax),%ecx
  80da3a:	89 4b 24             	mov    %ecx,0x24(%ebx)
      pcb->lastack = ackno;
  80da3d:	89 53 48             	mov    %edx,0x48(%ebx)
      pcb->snd_wnd = tcphdr->wnd;
  80da40:	8b 15 b0 b1 b3 00    	mov    0xb3b1b0,%edx
  80da46:	0f b7 52 0e          	movzwl 0xe(%edx),%edx
  80da4a:	66 89 53 5c          	mov    %dx,0x5c(%ebx)
      pcb->snd_wl1 = seqno - 1; /* initialise to seqno - 1 to force window update */
  80da4e:	83 e8 01             	sub    $0x1,%eax
  80da51:	89 43 60             	mov    %eax,0x60(%ebx)
      pcb->state = ESTABLISHED;
  80da54:	c7 43 10 04 00 00 00 	movl   $0x4,0x10(%ebx)
      tcp_parseopt(pcb);
  80da5b:	89 d8                	mov    %ebx,%eax
  80da5d:	e8 2f eb ff ff       	call   80c591 <tcp_parseopt>
      pcb->mss = tcp_eff_send_mss(pcb->mss, &(pcb->remote_ip));
  80da62:	83 ec 08             	sub    $0x8,%esp
  80da65:	8d 43 04             	lea    0x4(%ebx),%eax
  80da68:	50                   	push   %eax
  80da69:	0f b7 43 34          	movzwl 0x34(%ebx),%eax
  80da6d:	50                   	push   %eax
  80da6e:	e8 b5 89 ff ff       	call   806428 <tcp_eff_send_mss>
  80da73:	66 89 43 34          	mov    %ax,0x34(%ebx)
      pcb->ssthresh = pcb->mss * 10;
  80da77:	6b d0 0a             	imul   $0xa,%eax,%edx
  80da7a:	66 89 53 50          	mov    %dx,0x50(%ebx)
      pcb->cwnd = ((pcb->cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
  80da7e:	83 c4 10             	add    $0x10,%esp
  80da81:	66 83 7b 4e 01       	cmpw   $0x1,0x4e(%ebx)
  80da86:	74 63                	je     80daeb <tcp_input+0x7c4>
  80da88:	66 89 43 4e          	mov    %ax,0x4e(%ebx)
      LWIP_ASSERT("pcb->snd_queuelen > 0", (pcb->snd_queuelen > 0));
  80da8c:	0f b7 43 70          	movzwl 0x70(%ebx),%eax
  80da90:	66 85 c0             	test   %ax,%ax
  80da93:	74 5a                	je     80daef <tcp_input+0x7c8>
      --pcb->snd_queuelen;
  80da95:	83 e8 01             	sub    $0x1,%eax
  80da98:	66 89 43 70          	mov    %ax,0x70(%ebx)
      rseg = pcb->unacked;
  80da9c:	8b 43 78             	mov    0x78(%ebx),%eax
      pcb->unacked = rseg->next;
  80da9f:	8b 10                	mov    (%eax),%edx
  80daa1:	89 53 78             	mov    %edx,0x78(%ebx)
      if(pcb->unacked == NULL)
  80daa4:	85 d2                	test   %edx,%edx
  80daa6:	74 5e                	je     80db06 <tcp_input+0x7df>
        pcb->rtime = 0;
  80daa8:	66 c7 43 32 00 00    	movw   $0x0,0x32(%ebx)
        pcb->nrtx = 0;
  80daae:	c6 43 46 00          	movb   $0x0,0x46(%ebx)
      tcp_seg_free(rseg);
  80dab2:	83 ec 0c             	sub    $0xc,%esp
  80dab5:	50                   	push   %eax
  80dab6:	e8 c3 7d ff ff       	call   80587e <tcp_seg_free>
      TCP_EVENT_CONNECTED(pcb, ERR_OK, err);
  80dabb:	8b 83 8c 00 00 00    	mov    0x8c(%ebx),%eax
  80dac1:	83 c4 10             	add    $0x10,%esp
  80dac4:	85 c0                	test   %eax,%eax
  80dac6:	74 0e                	je     80dad6 <tcp_input+0x7af>
  80dac8:	83 ec 04             	sub    $0x4,%esp
  80dacb:	6a 00                	push   $0x0
  80dacd:	53                   	push   %ebx
  80dace:	ff 73 18             	pushl  0x18(%ebx)
  80dad1:	ff d0                	call   *%eax
  80dad3:	83 c4 10             	add    $0x10,%esp
      tcp_ack_now(pcb);
  80dad6:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80dada:	83 ec 0c             	sub    $0xc,%esp
  80dadd:	53                   	push   %ebx
  80dade:	e8 03 a7 ff ff       	call   8081e6 <tcp_output>
  80dae3:	83 c4 10             	add    $0x10,%esp
  80dae6:	e9 e5 fb ff ff       	jmp    80d6d0 <tcp_input+0x3a9>
      pcb->cwnd = ((pcb->cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
  80daeb:	01 c0                	add    %eax,%eax
  80daed:	eb 99                	jmp    80da88 <tcp_input+0x761>
      LWIP_ASSERT("pcb->snd_queuelen > 0", (pcb->snd_queuelen > 0));
  80daef:	83 ec 04             	sub    $0x4,%esp
  80daf2:	68 ed 35 81 00       	push   $0x8135ed
  80daf7:	68 35 02 00 00       	push   $0x235
  80dafc:	68 94 35 81 00       	push   $0x813594
  80db01:	e8 41 0d 00 00       	call   80e847 <_panic>
        pcb->rtime = -1;
  80db06:	66 c7 43 32 ff ff    	movw   $0xffff,0x32(%ebx)
  80db0c:	eb a4                	jmp    80dab2 <tcp_input+0x78b>
    if (flags & TCP_ACK &&
  80db0e:	83 e0 14             	and    $0x14,%eax
  80db11:	3c 10                	cmp    $0x10,%al
  80db13:	0f 85 b7 fb ff ff    	jne    80d6d0 <tcp_input+0x3a9>
      if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)) {
  80db19:	8b 15 a4 b1 b3 00    	mov    0xb3b1a4,%edx
  80db1f:	8d 42 ff             	lea    -0x1(%edx),%eax
  80db22:	3b 43 48             	cmp    0x48(%ebx),%eax
  80db25:	78 09                	js     80db30 <tcp_input+0x809>
  80db27:	89 d0                	mov    %edx,%eax
  80db29:	2b 43 54             	sub    0x54(%ebx),%eax
  80db2c:	85 c0                	test   %eax,%eax
  80db2e:	7e 3b                	jle    80db6b <tcp_input+0x844>
                tcphdr->dest, tcphdr->src);
  80db30:	8b 0d b0 b1 b3 00    	mov    0xb3b1b0,%ecx
        tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
  80db36:	a1 ac b1 b3 00       	mov    0xb3b1ac,%eax
  80db3b:	83 ec 08             	sub    $0x8,%esp
  80db3e:	0f b7 31             	movzwl (%ecx),%esi
  80db41:	56                   	push   %esi
  80db42:	0f b7 49 02          	movzwl 0x2(%ecx),%ecx
  80db46:	51                   	push   %ecx
  80db47:	8d 48 0c             	lea    0xc(%eax),%ecx
  80db4a:	51                   	push   %ecx
  80db4b:	83 c0 10             	add    $0x10,%eax
  80db4e:	50                   	push   %eax
  80db4f:	0f b7 05 9e b1 b3 00 	movzwl 0xb3b19e,%eax
  80db56:	03 05 a8 b1 b3 00    	add    0xb3b1a8,%eax
  80db5c:	50                   	push   %eax
  80db5d:	52                   	push   %edx
  80db5e:	e8 29 ab ff ff       	call   80868c <tcp_rst>
  80db63:	83 c4 20             	add    $0x20,%esp
  80db66:	e9 65 fb ff ff       	jmp    80d6d0 <tcp_input+0x3a9>
        pcb->state = ESTABLISHED;
  80db6b:	c7 43 10 04 00 00 00 	movl   $0x4,0x10(%ebx)
        LWIP_ASSERT("pcb->accept != NULL", pcb->accept != NULL);
  80db72:	8b 83 90 00 00 00    	mov    0x90(%ebx),%eax
  80db78:	85 c0                	test   %eax,%eax
  80db7a:	74 5e                	je     80dbda <tcp_input+0x8b3>
        TCP_EVENT_ACCEPT(pcb, ERR_OK, err);
  80db7c:	83 ec 04             	sub    $0x4,%esp
  80db7f:	6a 00                	push   $0x0
  80db81:	53                   	push   %ebx
  80db82:	ff 73 18             	pushl  0x18(%ebx)
  80db85:	ff d0                	call   *%eax
        if (err != ERR_OK) {
  80db87:	83 c4 10             	add    $0x10,%esp
  80db8a:	84 c0                	test   %al,%al
  80db8c:	75 63                	jne    80dbf1 <tcp_input+0x8ca>
        old_cwnd = pcb->cwnd;
  80db8e:	0f b7 73 4e          	movzwl 0x4e(%ebx),%esi
        accepted_inseq = tcp_receive(pcb);
  80db92:	89 d8                	mov    %ebx,%eax
  80db94:	e8 ac ea ff ff       	call   80c645 <tcp_receive>
  80db99:	89 c2                	mov    %eax,%edx
        pcb->cwnd = ((old_cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
  80db9b:	66 83 fe 01          	cmp    $0x1,%si
  80db9f:	74 6b                	je     80dc0c <tcp_input+0x8e5>
  80dba1:	0f b7 43 34          	movzwl 0x34(%ebx),%eax
  80dba5:	66 89 43 4e          	mov    %ax,0x4e(%ebx)
        if ((flags & TCP_FIN) && accepted_inseq) {
  80dba9:	f6 05 a0 b1 b3 00 01 	testb  $0x1,0xb3b1a0
  80dbb0:	0f 84 1a fb ff ff    	je     80d6d0 <tcp_input+0x3a9>
  80dbb6:	84 d2                	test   %dl,%dl
  80dbb8:	0f 84 12 fb ff ff    	je     80d6d0 <tcp_input+0x3a9>
          tcp_ack_now(pcb);
  80dbbe:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80dbc2:	83 ec 0c             	sub    $0xc,%esp
  80dbc5:	53                   	push   %ebx
  80dbc6:	e8 1b a6 ff ff       	call   8081e6 <tcp_output>
          pcb->state = CLOSE_WAIT;
  80dbcb:	c7 43 10 07 00 00 00 	movl   $0x7,0x10(%ebx)
  80dbd2:	83 c4 10             	add    $0x10,%esp
  80dbd5:	e9 f6 fa ff ff       	jmp    80d6d0 <tcp_input+0x3a9>
        LWIP_ASSERT("pcb->accept != NULL", pcb->accept != NULL);
  80dbda:	83 ec 04             	sub    $0x4,%esp
  80dbdd:	68 03 36 81 00       	push   $0x813603
  80dbe2:	68 5b 02 00 00       	push   $0x25b
  80dbe7:	68 94 35 81 00       	push   $0x813594
  80dbec:	e8 56 0c 00 00       	call   80e847 <_panic>
          tcp_abort(pcb);
  80dbf1:	83 ec 0c             	sub    $0xc,%esp
  80dbf4:	53                   	push   %ebx
  80dbf5:	e8 e6 80 ff ff       	call   805ce0 <tcp_abort>
    tcp_input_pcb = NULL;
  80dbfa:	c7 05 58 b2 b3 00 00 	movl   $0x0,0xb3b258
  80dc01:	00 00 00 
  80dc04:	83 c4 10             	add    $0x10,%esp
  80dc07:	e9 10 fb ff ff       	jmp    80d71c <tcp_input+0x3f5>
        pcb->cwnd = ((old_cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
  80dc0c:	0f b7 43 34          	movzwl 0x34(%ebx),%eax
  80dc10:	01 c0                	add    %eax,%eax
  80dc12:	eb 91                	jmp    80dba5 <tcp_input+0x87e>
    accepted_inseq = tcp_receive(pcb);
  80dc14:	89 d8                	mov    %ebx,%eax
  80dc16:	e8 2a ea ff ff       	call   80c645 <tcp_receive>
    if ((flags & TCP_FIN) && accepted_inseq) { /* passive close */
  80dc1b:	f6 05 a0 b1 b3 00 01 	testb  $0x1,0xb3b1a0
  80dc22:	0f 84 a8 fa ff ff    	je     80d6d0 <tcp_input+0x3a9>
  80dc28:	84 c0                	test   %al,%al
  80dc2a:	0f 84 a0 fa ff ff    	je     80d6d0 <tcp_input+0x3a9>
      tcp_ack_now(pcb);
  80dc30:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80dc34:	83 ec 0c             	sub    $0xc,%esp
  80dc37:	53                   	push   %ebx
  80dc38:	e8 a9 a5 ff ff       	call   8081e6 <tcp_output>
      pcb->state = CLOSE_WAIT;
  80dc3d:	c7 43 10 07 00 00 00 	movl   $0x7,0x10(%ebx)
  80dc44:	83 c4 10             	add    $0x10,%esp
  80dc47:	e9 84 fa ff ff       	jmp    80d6d0 <tcp_input+0x3a9>
    tcp_receive(pcb);
  80dc4c:	89 d8                	mov    %ebx,%eax
  80dc4e:	e8 f2 e9 ff ff       	call   80c645 <tcp_receive>
    if (flags & TCP_FIN) {
  80dc53:	0f b6 05 a0 b1 b3 00 	movzbl 0xb3b1a0,%eax
  80dc5a:	a8 01                	test   $0x1,%al
  80dc5c:	0f 84 b7 00 00 00    	je     80dd19 <tcp_input+0x9f2>
      if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  80dc62:	a8 10                	test   $0x10,%al
  80dc64:	74 0a                	je     80dc70 <tcp_input+0x949>
  80dc66:	a1 a4 b1 b3 00       	mov    0xb3b1a4,%eax
  80dc6b:	39 43 54             	cmp    %eax,0x54(%ebx)
  80dc6e:	74 1c                	je     80dc8c <tcp_input+0x965>
        tcp_ack_now(pcb);
  80dc70:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80dc74:	83 ec 0c             	sub    $0xc,%esp
  80dc77:	53                   	push   %ebx
  80dc78:	e8 69 a5 ff ff       	call   8081e6 <tcp_output>
        pcb->state = CLOSING;
  80dc7d:	c7 43 10 08 00 00 00 	movl   $0x8,0x10(%ebx)
  80dc84:	83 c4 10             	add    $0x10,%esp
  80dc87:	e9 44 fa ff ff       	jmp    80d6d0 <tcp_input+0x3a9>
        tcp_ack_now(pcb);
  80dc8c:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80dc90:	83 ec 0c             	sub    $0xc,%esp
  80dc93:	53                   	push   %ebx
  80dc94:	e8 4d a5 ff ff       	call   8081e6 <tcp_output>
        tcp_pcb_purge(pcb);
  80dc99:	89 1c 24             	mov    %ebx,(%esp)
  80dc9c:	e8 1e 7d ff ff       	call   8059bf <tcp_pcb_purge>
        TCP_RMV(&tcp_active_pcbs, pcb);
  80dca1:	a1 3c b2 b3 00       	mov    0xb3b23c,%eax
  80dca6:	83 c4 10             	add    $0x10,%esp
  80dca9:	39 c3                	cmp    %eax,%ebx
  80dcab:	74 11                	je     80dcbe <tcp_input+0x997>
  80dcad:	a3 48 b2 b3 00       	mov    %eax,0xb3b248
  80dcb2:	ba 00 00 00 00       	mov    $0x0,%edx
  80dcb7:	be 01 00 00 00       	mov    $0x1,%esi
  80dcbc:	eb 2b                	jmp    80dce9 <tcp_input+0x9c2>
  80dcbe:	8b 40 0c             	mov    0xc(%eax),%eax
  80dcc1:	a3 3c b2 b3 00       	mov    %eax,0xb3b23c
        pcb->state = TIME_WAIT;
  80dcc6:	c7 43 10 0a 00 00 00 	movl   $0xa,0x10(%ebx)
        TCP_REG(&tcp_tw_pcbs, pcb);
  80dccd:	a1 50 b2 b3 00       	mov    0xb3b250,%eax
  80dcd2:	89 43 0c             	mov    %eax,0xc(%ebx)
  80dcd5:	89 1d 50 b2 b3 00    	mov    %ebx,0xb3b250
  80dcdb:	e8 73 45 ff ff       	call   802253 <tcp_timer_needed>
  80dce0:	e9 eb f9 ff ff       	jmp    80d6d0 <tcp_input+0x3a9>
  80dce5:	89 f2                	mov    %esi,%edx
        TCP_RMV(&tcp_active_pcbs, pcb);
  80dce7:	89 c8                	mov    %ecx,%eax
  80dce9:	85 c0                	test   %eax,%eax
  80dceb:	74 1c                	je     80dd09 <tcp_input+0x9e2>
  80dced:	8b 48 0c             	mov    0xc(%eax),%ecx
  80dcf0:	39 cb                	cmp    %ecx,%ebx
  80dcf2:	75 f1                	jne    80dce5 <tcp_input+0x9be>
  80dcf4:	85 c9                	test   %ecx,%ecx
  80dcf6:	74 ed                	je     80dce5 <tcp_input+0x9be>
  80dcf8:	84 d2                	test   %dl,%dl
  80dcfa:	74 05                	je     80dd01 <tcp_input+0x9da>
  80dcfc:	a3 48 b2 b3 00       	mov    %eax,0xb3b248
  80dd01:	8b 53 0c             	mov    0xc(%ebx),%edx
  80dd04:	89 50 0c             	mov    %edx,0xc(%eax)
  80dd07:	eb bd                	jmp    80dcc6 <tcp_input+0x99f>
  80dd09:	84 d2                	test   %dl,%dl
  80dd0b:	74 b9                	je     80dcc6 <tcp_input+0x99f>
  80dd0d:	c7 05 48 b2 b3 00 00 	movl   $0x0,0xb3b248
  80dd14:	00 00 00 
  80dd17:	eb ad                	jmp    80dcc6 <tcp_input+0x99f>
    } else if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  80dd19:	a8 10                	test   $0x10,%al
  80dd1b:	0f 84 af f9 ff ff    	je     80d6d0 <tcp_input+0x3a9>
  80dd21:	a1 a4 b1 b3 00       	mov    0xb3b1a4,%eax
  80dd26:	39 43 54             	cmp    %eax,0x54(%ebx)
  80dd29:	0f 85 a1 f9 ff ff    	jne    80d6d0 <tcp_input+0x3a9>
      pcb->state = FIN_WAIT_2;
  80dd2f:	c7 43 10 06 00 00 00 	movl   $0x6,0x10(%ebx)
  80dd36:	e9 95 f9 ff ff       	jmp    80d6d0 <tcp_input+0x3a9>
    tcp_receive(pcb);
  80dd3b:	89 d8                	mov    %ebx,%eax
  80dd3d:	e8 03 e9 ff ff       	call   80c645 <tcp_receive>
    if (flags & TCP_FIN) {
  80dd42:	f6 05 a0 b1 b3 00 01 	testb  $0x1,0xb3b1a0
  80dd49:	0f 84 81 f9 ff ff    	je     80d6d0 <tcp_input+0x3a9>
      tcp_ack_now(pcb);
  80dd4f:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80dd53:	83 ec 0c             	sub    $0xc,%esp
  80dd56:	53                   	push   %ebx
  80dd57:	e8 8a a4 ff ff       	call   8081e6 <tcp_output>
      tcp_pcb_purge(pcb);
  80dd5c:	89 1c 24             	mov    %ebx,(%esp)
  80dd5f:	e8 5b 7c ff ff       	call   8059bf <tcp_pcb_purge>
      TCP_RMV(&tcp_active_pcbs, pcb);
  80dd64:	a1 3c b2 b3 00       	mov    0xb3b23c,%eax
  80dd69:	83 c4 10             	add    $0x10,%esp
  80dd6c:	39 c3                	cmp    %eax,%ebx
  80dd6e:	74 11                	je     80dd81 <tcp_input+0xa5a>
  80dd70:	a3 48 b2 b3 00       	mov    %eax,0xb3b248
  80dd75:	b9 00 00 00 00       	mov    $0x0,%ecx
  80dd7a:	be 01 00 00 00       	mov    $0x1,%esi
  80dd7f:	eb 2b                	jmp    80ddac <tcp_input+0xa85>
  80dd81:	8b 40 0c             	mov    0xc(%eax),%eax
  80dd84:	a3 3c b2 b3 00       	mov    %eax,0xb3b23c
      pcb->state = TIME_WAIT;
  80dd89:	c7 43 10 0a 00 00 00 	movl   $0xa,0x10(%ebx)
      TCP_REG(&tcp_tw_pcbs, pcb);
  80dd90:	a1 50 b2 b3 00       	mov    0xb3b250,%eax
  80dd95:	89 43 0c             	mov    %eax,0xc(%ebx)
  80dd98:	89 1d 50 b2 b3 00    	mov    %ebx,0xb3b250
  80dd9e:	e8 b0 44 ff ff       	call   802253 <tcp_timer_needed>
  80dda3:	e9 28 f9 ff ff       	jmp    80d6d0 <tcp_input+0x3a9>
  80dda8:	89 f1                	mov    %esi,%ecx
      TCP_RMV(&tcp_active_pcbs, pcb);
  80ddaa:	89 d0                	mov    %edx,%eax
  80ddac:	85 c0                	test   %eax,%eax
  80ddae:	74 1c                	je     80ddcc <tcp_input+0xaa5>
  80ddb0:	8b 50 0c             	mov    0xc(%eax),%edx
  80ddb3:	39 d3                	cmp    %edx,%ebx
  80ddb5:	75 f1                	jne    80dda8 <tcp_input+0xa81>
  80ddb7:	85 d2                	test   %edx,%edx
  80ddb9:	74 ed                	je     80dda8 <tcp_input+0xa81>
  80ddbb:	84 c9                	test   %cl,%cl
  80ddbd:	74 05                	je     80ddc4 <tcp_input+0xa9d>
  80ddbf:	a3 48 b2 b3 00       	mov    %eax,0xb3b248
  80ddc4:	8b 53 0c             	mov    0xc(%ebx),%edx
  80ddc7:	89 50 0c             	mov    %edx,0xc(%eax)
  80ddca:	eb bd                	jmp    80dd89 <tcp_input+0xa62>
  80ddcc:	84 c9                	test   %cl,%cl
  80ddce:	74 b9                	je     80dd89 <tcp_input+0xa62>
  80ddd0:	c7 05 48 b2 b3 00 00 	movl   $0x0,0xb3b248
  80ddd7:	00 00 00 
  80ddda:	eb ad                	jmp    80dd89 <tcp_input+0xa62>
    tcp_receive(pcb);
  80dddc:	89 d8                	mov    %ebx,%eax
  80ddde:	e8 62 e8 ff ff       	call   80c645 <tcp_receive>
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  80dde3:	f6 05 a0 b1 b3 00 10 	testb  $0x10,0xb3b1a0
  80ddea:	0f 84 e0 f8 ff ff    	je     80d6d0 <tcp_input+0x3a9>
  80ddf0:	a1 a4 b1 b3 00       	mov    0xb3b1a4,%eax
  80ddf5:	39 43 54             	cmp    %eax,0x54(%ebx)
  80ddf8:	0f 85 d2 f8 ff ff    	jne    80d6d0 <tcp_input+0x3a9>
      tcp_ack_now(pcb);
  80ddfe:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80de02:	83 ec 0c             	sub    $0xc,%esp
  80de05:	53                   	push   %ebx
  80de06:	e8 db a3 ff ff       	call   8081e6 <tcp_output>
      tcp_pcb_purge(pcb);
  80de0b:	89 1c 24             	mov    %ebx,(%esp)
  80de0e:	e8 ac 7b ff ff       	call   8059bf <tcp_pcb_purge>
      TCP_RMV(&tcp_active_pcbs, pcb);
  80de13:	a1 3c b2 b3 00       	mov    0xb3b23c,%eax
  80de18:	83 c4 10             	add    $0x10,%esp
  80de1b:	39 c3                	cmp    %eax,%ebx
  80de1d:	74 11                	je     80de30 <tcp_input+0xb09>
  80de1f:	a3 48 b2 b3 00       	mov    %eax,0xb3b248
  80de24:	ba 00 00 00 00       	mov    $0x0,%edx
  80de29:	be 01 00 00 00       	mov    $0x1,%esi
  80de2e:	eb 2b                	jmp    80de5b <tcp_input+0xb34>
  80de30:	8b 40 0c             	mov    0xc(%eax),%eax
  80de33:	a3 3c b2 b3 00       	mov    %eax,0xb3b23c
      pcb->state = TIME_WAIT;
  80de38:	c7 43 10 0a 00 00 00 	movl   $0xa,0x10(%ebx)
      TCP_REG(&tcp_tw_pcbs, pcb);
  80de3f:	a1 50 b2 b3 00       	mov    0xb3b250,%eax
  80de44:	89 43 0c             	mov    %eax,0xc(%ebx)
  80de47:	89 1d 50 b2 b3 00    	mov    %ebx,0xb3b250
  80de4d:	e8 01 44 ff ff       	call   802253 <tcp_timer_needed>
  80de52:	e9 79 f8 ff ff       	jmp    80d6d0 <tcp_input+0x3a9>
  80de57:	89 f2                	mov    %esi,%edx
      TCP_RMV(&tcp_active_pcbs, pcb);
  80de59:	89 c8                	mov    %ecx,%eax
  80de5b:	85 c0                	test   %eax,%eax
  80de5d:	74 1c                	je     80de7b <tcp_input+0xb54>
  80de5f:	8b 48 0c             	mov    0xc(%eax),%ecx
  80de62:	39 cb                	cmp    %ecx,%ebx
  80de64:	75 f1                	jne    80de57 <tcp_input+0xb30>
  80de66:	85 c9                	test   %ecx,%ecx
  80de68:	74 ed                	je     80de57 <tcp_input+0xb30>
  80de6a:	84 d2                	test   %dl,%dl
  80de6c:	74 05                	je     80de73 <tcp_input+0xb4c>
  80de6e:	a3 48 b2 b3 00       	mov    %eax,0xb3b248
  80de73:	8b 53 0c             	mov    0xc(%ebx),%edx
  80de76:	89 50 0c             	mov    %edx,0xc(%eax)
  80de79:	eb bd                	jmp    80de38 <tcp_input+0xb11>
  80de7b:	84 d2                	test   %dl,%dl
  80de7d:	74 b9                	je     80de38 <tcp_input+0xb11>
  80de7f:	c7 05 48 b2 b3 00 00 	movl   $0x0,0xb3b248
  80de86:	00 00 00 
  80de89:	eb ad                	jmp    80de38 <tcp_input+0xb11>
    tcp_receive(pcb);
  80de8b:	89 d8                	mov    %ebx,%eax
  80de8d:	e8 b3 e7 ff ff       	call   80c645 <tcp_receive>
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  80de92:	f6 05 a0 b1 b3 00 10 	testb  $0x10,0xb3b1a0
  80de99:	0f 84 31 f8 ff ff    	je     80d6d0 <tcp_input+0x3a9>
  80de9f:	a1 a4 b1 b3 00       	mov    0xb3b1a4,%eax
  80dea4:	39 43 54             	cmp    %eax,0x54(%ebx)
  80dea7:	0f 85 23 f8 ff ff    	jne    80d6d0 <tcp_input+0x3a9>
      recv_flags = TF_CLOSED;
  80dead:	c6 05 9c b1 b3 00 10 	movb   $0x10,0xb3b19c
  80deb4:	e9 17 f8 ff ff       	jmp    80d6d0 <tcp_input+0x3a9>
    tcp_input_pcb = NULL;
  80deb9:	c7 05 58 b2 b3 00 00 	movl   $0x0,0xb3b258
  80dec0:	00 00 00 
  80dec3:	e9 12 f8 ff ff       	jmp    80d6da <tcp_input+0x3b3>
      } else if (recv_flags & TF_CLOSED) {
  80dec8:	a8 10                	test   $0x10,%al
  80deca:	0f 85 96 00 00 00    	jne    80df66 <tcp_input+0xc3f>
        if (pcb->acked > 0) {
  80ded0:	0f b7 53 6c          	movzwl 0x6c(%ebx),%edx
        err = ERR_OK;
  80ded4:	b8 00 00 00 00       	mov    $0x0,%eax
        if (pcb->acked > 0) {
  80ded9:	66 85 d2             	test   %dx,%dx
  80dedc:	74 1a                	je     80def8 <tcp_input+0xbd1>
          TCP_EVENT_SENT(pcb, pcb->acked, err);
  80dede:	8b 8b 84 00 00 00    	mov    0x84(%ebx),%ecx
  80dee4:	85 c9                	test   %ecx,%ecx
  80dee6:	74 10                	je     80def8 <tcp_input+0xbd1>
  80dee8:	83 ec 04             	sub    $0x4,%esp
  80deeb:	0f b7 d2             	movzwl %dx,%edx
  80deee:	52                   	push   %edx
  80deef:	53                   	push   %ebx
  80def0:	ff 73 18             	pushl  0x18(%ebx)
  80def3:	ff d1                	call   *%ecx
  80def5:	83 c4 10             	add    $0x10,%esp
        if (recv_data != NULL) {
  80def8:	8b 15 98 b1 b3 00    	mov    0xb3b198,%edx
  80defe:	85 d2                	test   %edx,%edx
  80df00:	0f 84 a9 00 00 00    	je     80dfaf <tcp_input+0xc88>
          if(flags & TCP_PSH) {
  80df06:	f6 05 a0 b1 b3 00 08 	testb  $0x8,0xb3b1a0
  80df0d:	74 04                	je     80df13 <tcp_input+0xbec>
            recv_data->flags |= PBUF_FLAG_PUSH;
  80df0f:	80 4a 0d 01          	orb    $0x1,0xd(%edx)
          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
  80df13:	8b 83 88 00 00 00    	mov    0x88(%ebx),%eax
  80df19:	85 c0                	test   %eax,%eax
  80df1b:	74 6a                	je     80df87 <tcp_input+0xc60>
  80df1d:	6a 00                	push   $0x0
  80df1f:	52                   	push   %edx
  80df20:	53                   	push   %ebx
  80df21:	ff 73 18             	pushl  0x18(%ebx)
  80df24:	ff d0                	call   *%eax
          if (err != ERR_OK) {
  80df26:	83 c4 10             	add    $0x10,%esp
  80df29:	84 c0                	test   %al,%al
  80df2b:	75 68                	jne    80df95 <tcp_input+0xc6e>
        if (recv_flags & TF_GOT_FIN) {
  80df2d:	f6 05 9c b1 b3 00 20 	testb  $0x20,0xb3b19c
  80df34:	74 1f                	je     80df55 <tcp_input+0xc2e>
          TCP_EVENT_RECV(pcb, NULL, ERR_OK, err);
  80df36:	8b 83 88 00 00 00    	mov    0x88(%ebx),%eax
  80df3c:	85 c0                	test   %eax,%eax
  80df3e:	74 15                	je     80df55 <tcp_input+0xc2e>
  80df40:	6a 00                	push   $0x0
  80df42:	6a 00                	push   $0x0
  80df44:	53                   	push   %ebx
  80df45:	ff 73 18             	pushl  0x18(%ebx)
  80df48:	ff d0                	call   *%eax
  80df4a:	83 c4 10             	add    $0x10,%esp
        if (err == ERR_OK) {
  80df4d:	84 c0                	test   %al,%al
  80df4f:	0f 85 c7 f7 ff ff    	jne    80d71c <tcp_input+0x3f5>
          tcp_output(pcb);
  80df55:	83 ec 0c             	sub    $0xc,%esp
  80df58:	53                   	push   %ebx
  80df59:	e8 88 a2 ff ff       	call   8081e6 <tcp_output>
  80df5e:	83 c4 10             	add    $0x10,%esp
  80df61:	e9 b6 f7 ff ff       	jmp    80d71c <tcp_input+0x3f5>
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
  80df66:	83 ec 08             	sub    $0x8,%esp
  80df69:	53                   	push   %ebx
  80df6a:	68 3c b2 b3 00       	push   $0xb3b23c
  80df6f:	e8 cc 7a ff ff       	call   805a40 <tcp_pcb_remove>
        memp_free(MEMP_TCP_PCB, pcb);
  80df74:	83 c4 08             	add    $0x8,%esp
  80df77:	53                   	push   %ebx
  80df78:	6a 02                	push   $0x2
  80df7a:	e8 26 66 ff ff       	call   8045a5 <memp_free>
  80df7f:	83 c4 10             	add    $0x10,%esp
  80df82:	e9 95 f7 ff ff       	jmp    80d71c <tcp_input+0x3f5>
          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
  80df87:	83 ec 0c             	sub    $0xc,%esp
  80df8a:	52                   	push   %edx
  80df8b:	e8 98 69 ff ff       	call   804928 <pbuf_free>
  80df90:	83 c4 10             	add    $0x10,%esp
  80df93:	eb 98                	jmp    80df2d <tcp_input+0xc06>
            pcb->refused_data = recv_data;
  80df95:	a1 98 b1 b3 00       	mov    0xb3b198,%eax
  80df9a:	89 83 80 00 00 00    	mov    %eax,0x80(%ebx)
        if (recv_flags & TF_GOT_FIN) {
  80dfa0:	f6 05 9c b1 b3 00 20 	testb  $0x20,0xb3b19c
  80dfa7:	0f 84 6f f7 ff ff    	je     80d71c <tcp_input+0x3f5>
  80dfad:	eb 87                	jmp    80df36 <tcp_input+0xc0f>
  80dfaf:	f6 05 9c b1 b3 00 20 	testb  $0x20,0xb3b19c
  80dfb6:	74 95                	je     80df4d <tcp_input+0xc26>
  80dfb8:	e9 79 ff ff ff       	jmp    80df36 <tcp_input+0xc0f>
        tcphdr->dest, tcphdr->src);
  80dfbd:	8b 15 b0 b1 b3 00    	mov    0xb3b1b0,%edx
        &(iphdr->dest), &(iphdr->src),
  80dfc3:	a1 ac b1 b3 00       	mov    0xb3b1ac,%eax
      tcp_rst(ackno, seqno + tcplen,
  80dfc8:	83 ec 08             	sub    $0x8,%esp
  80dfcb:	0f b7 0a             	movzwl (%edx),%ecx
  80dfce:	51                   	push   %ecx
  80dfcf:	0f b7 52 02          	movzwl 0x2(%edx),%edx
  80dfd3:	52                   	push   %edx
  80dfd4:	8d 50 0c             	lea    0xc(%eax),%edx
  80dfd7:	52                   	push   %edx
  80dfd8:	83 c0 10             	add    $0x10,%eax
  80dfdb:	50                   	push   %eax
  80dfdc:	0f b7 05 9e b1 b3 00 	movzwl 0xb3b19e,%eax
  80dfe3:	03 05 a8 b1 b3 00    	add    0xb3b1a8,%eax
  80dfe9:	50                   	push   %eax
  80dfea:	ff 35 a4 b1 b3 00    	pushl  0xb3b1a4
  80dff0:	e8 97 a6 ff ff       	call   80868c <tcp_rst>
  80dff5:	83 c4 20             	add    $0x20,%esp
  80dff8:	eb 14                	jmp    80e00e <tcp_input+0xce7>
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
  80dffa:	83 ec 0c             	sub    $0xc,%esp
  80dffd:	0f b7 42 0c          	movzwl 0xc(%edx),%eax
  80e001:	50                   	push   %eax
  80e002:	e8 6a 98 ff ff       	call   807871 <ntohs>
  80e007:	83 c4 10             	add    $0x10,%esp
  80e00a:	a8 04                	test   $0x4,%al
  80e00c:	74 af                	je     80dfbd <tcp_input+0xc96>
    pbuf_free(p);
  80e00e:	83 ec 0c             	sub    $0xc,%esp
  80e011:	56                   	push   %esi
  80e012:	e8 11 69 ff ff       	call   804928 <pbuf_free>
  80e017:	83 c4 10             	add    $0x10,%esp
  80e01a:	e9 77 f3 ff ff       	jmp    80d396 <tcp_input+0x6f>
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  80e01f:	8b 1d 50 b2 b3 00    	mov    0xb3b250,%ebx
  80e025:	e9 46 f7 ff ff       	jmp    80d770 <tcp_input+0x449>

0080e02a <raw_input>:
 *           caller).
 *
 */
u8_t
raw_input(struct pbuf *p, struct netif *inp)
{
  80e02a:	f3 0f 1e fb          	endbr32 
  80e02e:	55                   	push   %ebp
  80e02f:	89 e5                	mov    %esp,%ebp
  80e031:	57                   	push   %edi
  80e032:	56                   	push   %esi
  80e033:	53                   	push   %ebx
  80e034:	83 ec 28             	sub    $0x28,%esp
  s16_t proto;
  u8_t eaten = 0;

  LWIP_UNUSED_ARG(inp);

  iphdr = p->payload;
  80e037:	8b 45 08             	mov    0x8(%ebp),%eax
  80e03a:	8b 78 04             	mov    0x4(%eax),%edi
  proto = IPH_PROTO(iphdr);
  80e03d:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  80e041:	50                   	push   %eax
  80e042:	e8 2a 98 ff ff       	call   807871 <ntohs>
  80e047:	89 c2                	mov    %eax,%edx

  prev = NULL;
  pcb = raw_pcbs;
  80e049:	8b 1d c8 b1 b3 00    	mov    0xb3b1c8,%ebx
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
  80e04f:	83 c4 10             	add    $0x10,%esp
  u8_t eaten = 0;
  80e052:	b8 00 00 00 00       	mov    $0x0,%eax
  prev = NULL;
  80e057:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    if (pcb->protocol == proto) {
  80e05e:	0f b6 f2             	movzbl %dl,%esi
  while ((eaten == 0) && (pcb != NULL)) {
  80e061:	eb 11                	jmp    80e074 <raw_input+0x4a>
      if (pcb->recv != NULL) {
        /* the receive callback function did not eat the packet? */
        if (pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src)) != 0)
        {
          /* receive function ate the packet */
          p = NULL;
  80e063:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80e066:	89 45 08             	mov    %eax,0x8(%ebp)
          eaten = 1;
  80e069:	b8 01 00 00 00       	mov    $0x1,%eax
        }
      }
      /* no receive callback function was set for this raw PCB */
      /* drop the packet */
    }
    prev = pcb;
  80e06e:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
    pcb = pcb->next;
  80e071:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  while ((eaten == 0) && (pcb != NULL)) {
  80e074:	84 c0                	test   %al,%al
  80e076:	75 55                	jne    80e0cd <raw_input+0xa3>
  80e078:	85 db                	test   %ebx,%ebx
  80e07a:	74 51                	je     80e0cd <raw_input+0xa3>
    if (pcb->protocol == proto) {
  80e07c:	0f b6 53 10          	movzbl 0x10(%ebx),%edx
  80e080:	b8 00 00 00 00       	mov    $0x0,%eax
  80e085:	39 f2                	cmp    %esi,%edx
  80e087:	75 e5                	jne    80e06e <raw_input+0x44>
      if (pcb->recv != NULL) {
  80e089:	8b 53 14             	mov    0x14(%ebx),%edx
  80e08c:	85 d2                	test   %edx,%edx
  80e08e:	74 de                	je     80e06e <raw_input+0x44>
        if (pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src)) != 0)
  80e090:	8d 47 0c             	lea    0xc(%edi),%eax
  80e093:	50                   	push   %eax
  80e094:	ff 75 08             	pushl  0x8(%ebp)
  80e097:	53                   	push   %ebx
  80e098:	ff 73 18             	pushl  0x18(%ebx)
  80e09b:	ff d2                	call   *%edx
  80e09d:	83 c4 10             	add    $0x10,%esp
  80e0a0:	84 c0                	test   %al,%al
  80e0a2:	74 ca                	je     80e06e <raw_input+0x44>
          if (prev != NULL) {
  80e0a4:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  80e0a7:	85 c9                	test   %ecx,%ecx
  80e0a9:	74 b8                	je     80e063 <raw_input+0x39>
            prev->next = pcb->next;
  80e0ab:	8b 43 0c             	mov    0xc(%ebx),%eax
  80e0ae:	89 41 0c             	mov    %eax,0xc(%ecx)
            pcb->next = raw_pcbs;
  80e0b1:	a1 c8 b1 b3 00       	mov    0xb3b1c8,%eax
  80e0b6:	89 43 0c             	mov    %eax,0xc(%ebx)
            raw_pcbs = pcb;
  80e0b9:	89 1d c8 b1 b3 00    	mov    %ebx,0xb3b1c8
          eaten = 1;
  80e0bf:	b8 01 00 00 00       	mov    $0x1,%eax
          p = NULL;
  80e0c4:	c7 45 08 00 00 00 00 	movl   $0x0,0x8(%ebp)
  80e0cb:	eb a1                	jmp    80e06e <raw_input+0x44>
  }
  return eaten;
}
  80e0cd:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80e0d0:	5b                   	pop    %ebx
  80e0d1:	5e                   	pop    %esi
  80e0d2:	5f                   	pop    %edi
  80e0d3:	5d                   	pop    %ebp
  80e0d4:	c3                   	ret    

0080e0d5 <raw_bind>:
 *
 * @see raw_disconnect()
 */
err_t
raw_bind(struct raw_pcb *pcb, struct ip_addr *ipaddr)
{
  80e0d5:	f3 0f 1e fb          	endbr32 
  80e0d9:	55                   	push   %ebp
  80e0da:	89 e5                	mov    %esp,%ebp
  80e0dc:	8b 55 0c             	mov    0xc(%ebp),%edx
  ip_addr_set(&pcb->local_ip, ipaddr);
  80e0df:	b8 00 00 00 00       	mov    $0x0,%eax
  80e0e4:	85 d2                	test   %edx,%edx
  80e0e6:	74 02                	je     80e0ea <raw_bind+0x15>
  80e0e8:	8b 02                	mov    (%edx),%eax
  80e0ea:	8b 55 08             	mov    0x8(%ebp),%edx
  80e0ed:	89 02                	mov    %eax,(%edx)
  return ERR_OK;
}
  80e0ef:	b8 00 00 00 00       	mov    $0x0,%eax
  80e0f4:	5d                   	pop    %ebp
  80e0f5:	c3                   	ret    

0080e0f6 <raw_connect>:
 *
 * @see raw_disconnect() and raw_sendto()
 */
err_t
raw_connect(struct raw_pcb *pcb, struct ip_addr *ipaddr)
{
  80e0f6:	f3 0f 1e fb          	endbr32 
  80e0fa:	55                   	push   %ebp
  80e0fb:	89 e5                	mov    %esp,%ebp
  80e0fd:	8b 55 0c             	mov    0xc(%ebp),%edx
  ip_addr_set(&pcb->remote_ip, ipaddr);
  80e100:	b8 00 00 00 00       	mov    $0x0,%eax
  80e105:	85 d2                	test   %edx,%edx
  80e107:	74 02                	je     80e10b <raw_connect+0x15>
  80e109:	8b 02                	mov    (%edx),%eax
  80e10b:	8b 55 08             	mov    0x8(%ebp),%edx
  80e10e:	89 42 04             	mov    %eax,0x4(%edx)
  return ERR_OK;
}
  80e111:	b8 00 00 00 00       	mov    $0x0,%eax
  80e116:	5d                   	pop    %ebp
  80e117:	c3                   	ret    

0080e118 <raw_recv>:
void
raw_recv(struct raw_pcb *pcb,
         u8_t (* recv)(void *arg, struct raw_pcb *upcb, struct pbuf *p,
                      struct ip_addr *addr),
         void *recv_arg)
{
  80e118:	f3 0f 1e fb          	endbr32 
  80e11c:	55                   	push   %ebp
  80e11d:	89 e5                	mov    %esp,%ebp
  80e11f:	8b 45 08             	mov    0x8(%ebp),%eax
  /* remember recv() callback and user data */
  pcb->recv = recv;
  80e122:	8b 55 0c             	mov    0xc(%ebp),%edx
  80e125:	89 50 14             	mov    %edx,0x14(%eax)
  pcb->recv_arg = recv_arg;
  80e128:	8b 55 10             	mov    0x10(%ebp),%edx
  80e12b:	89 50 18             	mov    %edx,0x18(%eax)
}
  80e12e:	5d                   	pop    %ebp
  80e12f:	c3                   	ret    

0080e130 <raw_sendto>:
 * @param ipaddr the destination address of the IP packet
 *
 */
err_t
raw_sendto(struct raw_pcb *pcb, struct pbuf *p, struct ip_addr *ipaddr)
{
  80e130:	f3 0f 1e fb          	endbr32 
  80e134:	55                   	push   %ebp
  80e135:	89 e5                	mov    %esp,%ebp
  80e137:	57                   	push   %edi
  80e138:	56                   	push   %esi
  80e139:	53                   	push   %ebx
  80e13a:	83 ec 14             	sub    $0x14,%esp
  80e13d:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80e140:	8b 7d 0c             	mov    0xc(%ebp),%edi
  struct pbuf *q; /* q will be sent down the stack */
  
  LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 3, ("raw_sendto\n"));
  
  /* not enough space to add an IP header to first pbuf in given p chain? */
  if (pbuf_header(p, IP_HLEN)) {
  80e143:	6a 14                	push   $0x14
  80e145:	57                   	push   %edi
  80e146:	e8 0a 67 ff ff       	call   804855 <pbuf_header>
  80e14b:	83 c4 10             	add    $0x10,%esp
  80e14e:	84 c0                	test   %al,%al
  80e150:	74 52                	je     80e1a4 <raw_sendto+0x74>
    /* allocate header in new pbuf */
    q = pbuf_alloc(PBUF_IP, 0, PBUF_RAM);
  80e152:	83 ec 04             	sub    $0x4,%esp
  80e155:	6a 00                	push   $0x0
  80e157:	6a 00                	push   $0x0
  80e159:	6a 01                	push   $0x1
  80e15b:	e8 92 68 ff ff       	call   8049f2 <pbuf_alloc>
  80e160:	89 c6                	mov    %eax,%esi
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
  80e162:	83 c4 10             	add    $0x10,%esp
  80e165:	85 c0                	test   %eax,%eax
  80e167:	0f 84 be 00 00 00    	je     80e22b <raw_sendto+0xfb>
      LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 2, ("raw_sendto: could not allocate header\n"));
      return ERR_MEM;
    }
    /* chain header q in front of given pbuf p */
    pbuf_chain(q, p);
  80e16d:	83 ec 08             	sub    $0x8,%esp
  80e170:	57                   	push   %edi
  80e171:	50                   	push   %eax
  80e172:	e8 93 6c ff ff       	call   804e0a <pbuf_chain>
      LWIP_ASSERT("Can't restore header we just removed!", 0);
      return ERR_MEM;
    }
  }
  
  if ((netif = ip_route(ipaddr)) == NULL) {
  80e177:	83 c4 04             	add    $0x4,%esp
  80e17a:	ff 75 10             	pushl  0x10(%ebp)
  80e17d:	e8 a9 84 ff ff       	call   80662b <ip_route>
  80e182:	83 c4 10             	add    $0x10,%esp
  80e185:	85 c0                	test   %eax,%eax
  80e187:	75 41                	jne    80e1ca <raw_sendto+0x9a>
    LWIP_DEBUGF(RAW_DEBUG | 1, ("raw_sendto: No route to 0x%"X32_F"\n", ipaddr->addr));
    /* free any temporary header pbuf allocated by pbuf_header() */
    if (q != p) {
  80e189:	39 f7                	cmp    %esi,%edi
  80e18b:	0f 84 a1 00 00 00    	je     80e232 <raw_sendto+0x102>
      pbuf_free(q);
  80e191:	83 ec 0c             	sub    $0xc,%esp
  80e194:	56                   	push   %esi
  80e195:	e8 8e 67 ff ff       	call   804928 <pbuf_free>
  80e19a:	83 c4 10             	add    $0x10,%esp
    }
    return ERR_RTE;
  80e19d:	bb fc ff ff ff       	mov    $0xfffffffc,%ebx
  80e1a2:	eb 66                	jmp    80e20a <raw_sendto+0xda>
    if(pbuf_header(q, -IP_HLEN)) {
  80e1a4:	83 ec 08             	sub    $0x8,%esp
  80e1a7:	6a ec                	push   $0xffffffec
  80e1a9:	57                   	push   %edi
  80e1aa:	e8 a6 66 ff ff       	call   804855 <pbuf_header>
  80e1af:	83 c4 10             	add    $0x10,%esp
  80e1b2:	84 c0                	test   %al,%al
  80e1b4:	75 5e                	jne    80e214 <raw_sendto+0xe4>
  if ((netif = ip_route(ipaddr)) == NULL) {
  80e1b6:	83 ec 0c             	sub    $0xc,%esp
  80e1b9:	ff 75 10             	pushl  0x10(%ebp)
  80e1bc:	e8 6a 84 ff ff       	call   80662b <ip_route>
  80e1c1:	83 c4 10             	add    $0x10,%esp
  80e1c4:	85 c0                	test   %eax,%eax
  80e1c6:	74 71                	je     80e239 <raw_sendto+0x109>
    q = p;
  80e1c8:	89 fe                	mov    %edi,%esi
  }

  if (ip_addr_isany(&pcb->local_ip)) {
  80e1ca:	89 da                	mov    %ebx,%edx
  80e1cc:	85 db                	test   %ebx,%ebx
  80e1ce:	74 05                	je     80e1d5 <raw_sendto+0xa5>
  80e1d0:	83 3b 00             	cmpl   $0x0,(%ebx)
  80e1d3:	75 03                	jne    80e1d8 <raw_sendto+0xa8>
    /* use outgoing network interface IP address as source address */
    src_ip = &(netif->ip_addr);
  80e1d5:	8d 50 04             	lea    0x4(%eax),%edx
  }

#if LWIP_NETIF_HWADDRHINT
  netif->addr_hint = &(pcb->addr_hint);
#endif /* LWIP_NETIF_HWADDRHINT*/
  err = ip_output_if (q, src_ip, ipaddr, pcb->ttl, pcb->tos, pcb->protocol, netif);
  80e1d8:	83 ec 04             	sub    $0x4,%esp
  80e1db:	50                   	push   %eax
  80e1dc:	0f b6 43 10          	movzbl 0x10(%ebx),%eax
  80e1e0:	50                   	push   %eax
  80e1e1:	0f b6 43 0a          	movzbl 0xa(%ebx),%eax
  80e1e5:	50                   	push   %eax
  80e1e6:	0f b6 43 0b          	movzbl 0xb(%ebx),%eax
  80e1ea:	50                   	push   %eax
  80e1eb:	ff 75 10             	pushl  0x10(%ebp)
  80e1ee:	52                   	push   %edx
  80e1ef:	56                   	push   %esi
  80e1f0:	e8 bd 87 ff ff       	call   8069b2 <ip_output_if>
  80e1f5:	89 c3                	mov    %eax,%ebx
#if LWIP_NETIF_HWADDRHINT
  netif->addr_hint = NULL;
#endif /* LWIP_NETIF_HWADDRHINT*/

  /* did we chain a header earlier? */
  if (q != p) {
  80e1f7:	83 c4 20             	add    $0x20,%esp
  80e1fa:	39 f7                	cmp    %esi,%edi
  80e1fc:	74 0c                	je     80e20a <raw_sendto+0xda>
    /* free the header */
    pbuf_free(q);
  80e1fe:	83 ec 0c             	sub    $0xc,%esp
  80e201:	56                   	push   %esi
  80e202:	e8 21 67 ff ff       	call   804928 <pbuf_free>
  80e207:	83 c4 10             	add    $0x10,%esp
  }
  return err;
}
  80e20a:	89 d8                	mov    %ebx,%eax
  80e20c:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80e20f:	5b                   	pop    %ebx
  80e210:	5e                   	pop    %esi
  80e211:	5f                   	pop    %edi
  80e212:	5d                   	pop    %ebp
  80e213:	c3                   	ret    
      LWIP_ASSERT("Can't restore header we just removed!", 0);
  80e214:	83 ec 04             	sub    $0x4,%esp
  80e217:	68 40 36 81 00       	push   $0x813640
  80e21c:	68 e3 00 00 00       	push   $0xe3
  80e221:	68 66 36 81 00       	push   $0x813666
  80e226:	e8 1c 06 00 00       	call   80e847 <_panic>
      return ERR_MEM;
  80e22b:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
  80e230:	eb d8                	jmp    80e20a <raw_sendto+0xda>
    return ERR_RTE;
  80e232:	bb fc ff ff ff       	mov    $0xfffffffc,%ebx
  80e237:	eb d1                	jmp    80e20a <raw_sendto+0xda>
  80e239:	bb fc ff ff ff       	mov    $0xfffffffc,%ebx
  80e23e:	eb ca                	jmp    80e20a <raw_sendto+0xda>

0080e240 <raw_send>:
 * @param p the IP payload to send
 *
 */
err_t
raw_send(struct raw_pcb *pcb, struct pbuf *p)
{
  80e240:	f3 0f 1e fb          	endbr32 
  80e244:	55                   	push   %ebp
  80e245:	89 e5                	mov    %esp,%ebp
  80e247:	83 ec 0c             	sub    $0xc,%esp
  80e24a:	8b 45 08             	mov    0x8(%ebp),%eax
  return raw_sendto(pcb, p, &pcb->remote_ip);
  80e24d:	8d 50 04             	lea    0x4(%eax),%edx
  80e250:	52                   	push   %edx
  80e251:	ff 75 0c             	pushl  0xc(%ebp)
  80e254:	50                   	push   %eax
  80e255:	e8 d6 fe ff ff       	call   80e130 <raw_sendto>
}
  80e25a:	c9                   	leave  
  80e25b:	c3                   	ret    

0080e25c <raw_remove>:
 *
 * @see raw_new()
 */
void
raw_remove(struct raw_pcb *pcb)
{
  80e25c:	f3 0f 1e fb          	endbr32 
  80e260:	55                   	push   %ebp
  80e261:	89 e5                	mov    %esp,%ebp
  80e263:	83 ec 08             	sub    $0x8,%esp
  80e266:	8b 4d 08             	mov    0x8(%ebp),%ecx
  struct raw_pcb *pcb2;
  /* pcb to be removed is first in list? */
  if (raw_pcbs == pcb) {
  80e269:	a1 c8 b1 b3 00       	mov    0xb3b1c8,%eax
  80e26e:	39 c8                	cmp    %ecx,%eax
  80e270:	75 1b                	jne    80e28d <raw_remove+0x31>
    /* make list start at 2nd pcb */
    raw_pcbs = raw_pcbs->next;
  80e272:	8b 41 0c             	mov    0xc(%ecx),%eax
  80e275:	a3 c8 b1 b3 00       	mov    %eax,0xb3b1c8
        /* remove pcb from list */
        pcb2->next = pcb->next;
      }
    }
  }
  memp_free(MEMP_RAW_PCB, pcb);
  80e27a:	83 ec 08             	sub    $0x8,%esp
  80e27d:	51                   	push   %ecx
  80e27e:	6a 00                	push   $0x0
  80e280:	e8 20 63 ff ff       	call   8045a5 <memp_free>
}
  80e285:	83 c4 10             	add    $0x10,%esp
  80e288:	c9                   	leave  
  80e289:	c3                   	ret    
    for(pcb2 = raw_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
  80e28a:	8b 40 0c             	mov    0xc(%eax),%eax
  80e28d:	85 c0                	test   %eax,%eax
  80e28f:	74 e9                	je     80e27a <raw_remove+0x1e>
      if (pcb2->next != NULL && pcb2->next == pcb) {
  80e291:	8b 50 0c             	mov    0xc(%eax),%edx
  80e294:	39 ca                	cmp    %ecx,%edx
  80e296:	75 f2                	jne    80e28a <raw_remove+0x2e>
  80e298:	85 d2                	test   %edx,%edx
  80e29a:	74 ee                	je     80e28a <raw_remove+0x2e>
        pcb2->next = pcb->next;
  80e29c:	8b 51 0c             	mov    0xc(%ecx),%edx
  80e29f:	89 50 0c             	mov    %edx,0xc(%eax)
  80e2a2:	eb e6                	jmp    80e28a <raw_remove+0x2e>

0080e2a4 <raw_new>:
 * @param proto the protocol number of the IPs payload (e.g. IP_PROTO_ICMP)
 *
 * @see raw_remove()
 */
struct raw_pcb *
raw_new(u8_t proto) {
  80e2a4:	f3 0f 1e fb          	endbr32 
  80e2a8:	55                   	push   %ebp
  80e2a9:	89 e5                	mov    %esp,%ebp
  80e2ab:	56                   	push   %esi
  80e2ac:	53                   	push   %ebx
  80e2ad:	8b 75 08             	mov    0x8(%ebp),%esi
  struct raw_pcb *pcb;

  LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 3, ("raw_new\n"));

  pcb = memp_malloc(MEMP_RAW_PCB);
  80e2b0:	83 ec 0c             	sub    $0xc,%esp
  80e2b3:	6a 00                	push   $0x0
  80e2b5:	e8 91 62 ff ff       	call   80454b <memp_malloc>
  80e2ba:	89 c3                	mov    %eax,%ebx
  /* could allocate RAW PCB? */
  if (pcb != NULL) {
  80e2bc:	83 c4 10             	add    $0x10,%esp
  80e2bf:	85 c0                	test   %eax,%eax
  80e2c1:	74 27                	je     80e2ea <raw_new+0x46>
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct raw_pcb));
  80e2c3:	83 ec 04             	sub    $0x4,%esp
  80e2c6:	6a 1c                	push   $0x1c
  80e2c8:	6a 00                	push   $0x0
  80e2ca:	50                   	push   %eax
  80e2cb:	e8 d2 0d 00 00       	call   80f0a2 <memset>
    pcb->protocol = proto;
  80e2d0:	89 f0                	mov    %esi,%eax
  80e2d2:	88 43 10             	mov    %al,0x10(%ebx)
    pcb->ttl = RAW_TTL;
  80e2d5:	c6 43 0b ff          	movb   $0xff,0xb(%ebx)
    pcb->next = raw_pcbs;
  80e2d9:	a1 c8 b1 b3 00       	mov    0xb3b1c8,%eax
  80e2de:	89 43 0c             	mov    %eax,0xc(%ebx)
    raw_pcbs = pcb;
  80e2e1:	89 1d c8 b1 b3 00    	mov    %ebx,0xb3b1c8
  80e2e7:	83 c4 10             	add    $0x10,%esp
  }
  return pcb;
}
  80e2ea:	89 d8                	mov    %ebx,%eax
  80e2ec:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80e2ef:	5b                   	pop    %ebx
  80e2f0:	5e                   	pop    %esi
  80e2f1:	5d                   	pop    %ebp
  80e2f2:	c3                   	ret    

0080e2f3 <icmp_input>:
 * @param p the icmp echo request packet, p->payload pointing to the ip header
 * @param inp the netif on which this packet was received
 */
void
icmp_input(struct pbuf *p, struct netif *inp)
{
  80e2f3:	f3 0f 1e fb          	endbr32 
  80e2f7:	55                   	push   %ebp
  80e2f8:	89 e5                	mov    %esp,%ebp
  80e2fa:	57                   	push   %edi
  80e2fb:	56                   	push   %esi
  80e2fc:	53                   	push   %ebx
  80e2fd:	83 ec 28             	sub    $0x28,%esp
  80e300:	8b 5d 08             	mov    0x8(%ebp),%ebx

  ICMP_STATS_INC(icmp.recv);
  snmp_inc_icmpinmsgs();


  iphdr = p->payload;
  80e303:	8b 7b 04             	mov    0x4(%ebx),%edi
  hlen = IPH_HL(iphdr) * 4;
  80e306:	0f b7 07             	movzwl (%edi),%eax
  80e309:	50                   	push   %eax
  80e30a:	e8 62 95 ff ff       	call   807871 <ntohs>
  80e30f:	66 c1 e8 06          	shr    $0x6,%ax
  80e313:	83 e0 3c             	and    $0x3c,%eax
  80e316:	66 89 45 e6          	mov    %ax,-0x1a(%ebp)
  if (pbuf_header(p, -hlen) || (p->tot_len < sizeof(u16_t)*2)) {
  80e31a:	89 c6                	mov    %eax,%esi
  80e31c:	f7 de                	neg    %esi
  80e31e:	0f bf f6             	movswl %si,%esi
  80e321:	83 c4 08             	add    $0x8,%esp
  80e324:	56                   	push   %esi
  80e325:	53                   	push   %ebx
  80e326:	e8 2a 65 ff ff       	call   804855 <pbuf_header>
  80e32b:	83 c4 10             	add    $0x10,%esp
  80e32e:	84 c0                	test   %al,%al
  80e330:	75 67                	jne    80e399 <icmp_input+0xa6>
  80e332:	66 83 7b 08 03       	cmpw   $0x3,0x8(%ebx)
  80e337:	76 60                	jbe    80e399 <icmp_input+0xa6>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: short ICMP (%"U16_F" bytes) received\n", p->tot_len));
    goto lenerr;
  }

  type = *((u8_t *)p->payload);
  80e339:	8b 43 04             	mov    0x4(%ebx),%eax
#ifdef LWIP_DEBUG
  code = *(((u8_t *)p->payload)+1);
#endif /* LWIP_DEBUG */
  switch (type) {
  80e33c:	80 38 08             	cmpb   $0x8,(%eax)
  80e33f:	74 0e                	je     80e34f <icmp_input+0x5c>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ICMP type %"S16_F" code %"S16_F" not supported.\n", 
                (s16_t)type, (s16_t)code));
    ICMP_STATS_INC(icmp.proterr);
    ICMP_STATS_INC(icmp.drop);
  }
  pbuf_free(p);
  80e341:	83 ec 0c             	sub    $0xc,%esp
  80e344:	53                   	push   %ebx
  80e345:	e8 de 65 ff ff       	call   804928 <pbuf_free>
  return;
  80e34a:	83 c4 10             	add    $0x10,%esp
  80e34d:	eb 56                	jmp    80e3a5 <icmp_input+0xb2>
    if (ip_addr_isbroadcast(&iphdr->dest, inp) || ip_addr_ismulticast(&iphdr->dest)) {
  80e34f:	83 ec 08             	sub    $0x8,%esp
  80e352:	ff 75 0c             	pushl  0xc(%ebp)
  80e355:	8d 47 10             	lea    0x10(%edi),%eax
  80e358:	50                   	push   %eax
  80e359:	e8 86 82 ff ff       	call   8065e4 <ip_addr_isbroadcast>
  80e35e:	83 c4 10             	add    $0x10,%esp
  80e361:	84 c0                	test   %al,%al
  80e363:	75 48                	jne    80e3ad <icmp_input+0xba>
  80e365:	8b 47 10             	mov    0x10(%edi),%eax
  80e368:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80e36b:	83 ec 0c             	sub    $0xc,%esp
  80e36e:	68 00 00 00 f0       	push   $0xf0000000
  80e373:	e8 37 97 ff ff       	call   807aaf <ntohl>
  80e378:	23 45 e0             	and    -0x20(%ebp),%eax
  80e37b:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80e37e:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  80e385:	e8 25 97 ff ff       	call   807aaf <ntohl>
  80e38a:	83 c4 10             	add    $0x10,%esp
  80e38d:	39 45 e0             	cmp    %eax,-0x20(%ebp)
  80e390:	74 1b                	je     80e3ad <icmp_input+0xba>
    if (p->tot_len < sizeof(struct icmp_echo_hdr)) {
  80e392:	66 83 7b 08 07       	cmpw   $0x7,0x8(%ebx)
  80e397:	77 22                	ja     80e3bb <icmp_input+0xc8>
lenerr:
  pbuf_free(p);
  80e399:	83 ec 0c             	sub    $0xc,%esp
  80e39c:	53                   	push   %ebx
  80e39d:	e8 86 65 ff ff       	call   804928 <pbuf_free>
  ICMP_STATS_INC(icmp.lenerr);
  snmp_inc_icmpinerrors();
  return;
  80e3a2:	83 c4 10             	add    $0x10,%esp
memerr:
  pbuf_free(p);
  ICMP_STATS_INC(icmp.err);
  snmp_inc_icmpinerrors();
  return;
}
  80e3a5:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80e3a8:	5b                   	pop    %ebx
  80e3a9:	5e                   	pop    %esi
  80e3aa:	5f                   	pop    %edi
  80e3ab:	5d                   	pop    %ebp
  80e3ac:	c3                   	ret    
      pbuf_free(p);
  80e3ad:	83 ec 0c             	sub    $0xc,%esp
  80e3b0:	53                   	push   %ebx
  80e3b1:	e8 72 65 ff ff       	call   804928 <pbuf_free>
      return;
  80e3b6:	83 c4 10             	add    $0x10,%esp
  80e3b9:	eb ea                	jmp    80e3a5 <icmp_input+0xb2>
    if (inet_chksum_pbuf(p) != 0) {
  80e3bb:	83 ec 0c             	sub    $0xc,%esp
  80e3be:	53                   	push   %ebx
  80e3bf:	e8 7c 93 ff ff       	call   807740 <inet_chksum_pbuf>
  80e3c4:	83 c4 10             	add    $0x10,%esp
  80e3c7:	66 85 c0             	test   %ax,%ax
  80e3ca:	0f 85 96 00 00 00    	jne    80e466 <icmp_input+0x173>
    if (pbuf_header(p, (PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
  80e3d0:	83 ec 08             	sub    $0x8,%esp
  80e3d3:	6a 22                	push   $0x22
  80e3d5:	53                   	push   %ebx
  80e3d6:	e8 7a 64 ff ff       	call   804855 <pbuf_header>
  80e3db:	83 c4 10             	add    $0x10,%esp
  80e3de:	84 c0                	test   %al,%al
  80e3e0:	0f 84 fb 00 00 00    	je     80e4e1 <icmp_input+0x1ee>
      if (pbuf_header(p, hlen)) {
  80e3e6:	83 ec 08             	sub    $0x8,%esp
  80e3e9:	0f bf 45 e6          	movswl -0x1a(%ebp),%eax
  80e3ed:	50                   	push   %eax
  80e3ee:	53                   	push   %ebx
  80e3ef:	e8 61 64 ff ff       	call   804855 <pbuf_header>
  80e3f4:	83 c4 10             	add    $0x10,%esp
  80e3f7:	84 c0                	test   %al,%al
  80e3f9:	75 7c                	jne    80e477 <icmp_input+0x184>
      r = pbuf_alloc(PBUF_LINK, p->tot_len, PBUF_RAM);
  80e3fb:	83 ec 04             	sub    $0x4,%esp
  80e3fe:	6a 00                	push   $0x0
  80e400:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  80e404:	50                   	push   %eax
  80e405:	6a 02                	push   $0x2
  80e407:	e8 e6 65 ff ff       	call   8049f2 <pbuf_alloc>
  80e40c:	89 45 e0             	mov    %eax,-0x20(%ebp)
      if (r == NULL) {
  80e40f:	83 c4 10             	add    $0x10,%esp
  80e412:	85 c0                	test   %eax,%eax
  80e414:	74 75                	je     80e48b <icmp_input+0x198>
      LWIP_ASSERT("check that first pbuf can hold struct the ICMP header",
  80e416:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80e419:	0f b7 50 0a          	movzwl 0xa(%eax),%edx
  80e41d:	0f bf 45 e6          	movswl -0x1a(%ebp),%eax
  80e421:	83 c0 08             	add    $0x8,%eax
  80e424:	39 c2                	cmp    %eax,%edx
  80e426:	72 74                	jb     80e49c <icmp_input+0x1a9>
      if (pbuf_copy(r, p) != ERR_OK) {
  80e428:	83 ec 08             	sub    $0x8,%esp
  80e42b:	53                   	push   %ebx
  80e42c:	ff 75 e0             	pushl  -0x20(%ebp)
  80e42f:	e8 a5 6a ff ff       	call   804ed9 <pbuf_copy>
  80e434:	83 c4 10             	add    $0x10,%esp
  80e437:	84 c0                	test   %al,%al
  80e439:	75 78                	jne    80e4b3 <icmp_input+0x1c0>
      iphdr = r->payload;
  80e43b:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80e43e:	8b 78 04             	mov    0x4(%eax),%edi
      if (pbuf_header(r, -hlen)) {
  80e441:	83 ec 08             	sub    $0x8,%esp
  80e444:	56                   	push   %esi
  80e445:	50                   	push   %eax
  80e446:	e8 0a 64 ff ff       	call   804855 <pbuf_header>
  80e44b:	83 c4 10             	add    $0x10,%esp
  80e44e:	84 c0                	test   %al,%al
  80e450:	75 78                	jne    80e4ca <icmp_input+0x1d7>
      pbuf_free(p);
  80e452:	83 ec 0c             	sub    $0xc,%esp
  80e455:	53                   	push   %ebx
  80e456:	e8 cd 64 ff ff       	call   804928 <pbuf_free>
  80e45b:	83 c4 10             	add    $0x10,%esp
      p = r;
  80e45e:	8b 5d e0             	mov    -0x20(%ebp),%ebx
  80e461:	e9 91 00 00 00       	jmp    80e4f7 <icmp_input+0x204>
      pbuf_free(p);
  80e466:	83 ec 0c             	sub    $0xc,%esp
  80e469:	53                   	push   %ebx
  80e46a:	e8 b9 64 ff ff       	call   804928 <pbuf_free>
      return;
  80e46f:	83 c4 10             	add    $0x10,%esp
  80e472:	e9 2e ff ff ff       	jmp    80e3a5 <icmp_input+0xb2>
        LWIP_ASSERT("icmp_input: moving p->payload to ip header failed\n", 0);
  80e477:	83 ec 04             	sub    $0x4,%esp
  80e47a:	68 7c 36 81 00       	push   $0x81367c
  80e47f:	6a 7b                	push   $0x7b
  80e481:	68 70 37 81 00       	push   $0x813770
  80e486:	e8 bc 03 00 00       	call   80e847 <_panic>
  pbuf_free(p);
  80e48b:	83 ec 0c             	sub    $0xc,%esp
  80e48e:	53                   	push   %ebx
  80e48f:	e8 94 64 ff ff       	call   804928 <pbuf_free>
  return;
  80e494:	83 c4 10             	add    $0x10,%esp
  80e497:	e9 09 ff ff ff       	jmp    80e3a5 <icmp_input+0xb2>
      LWIP_ASSERT("check that first pbuf can hold struct the ICMP header",
  80e49c:	83 ec 04             	sub    $0x4,%esp
  80e49f:	68 b0 36 81 00       	push   $0x8136b0
  80e4a4:	68 84 00 00 00       	push   $0x84
  80e4a9:	68 70 37 81 00       	push   $0x813770
  80e4ae:	e8 94 03 00 00       	call   80e847 <_panic>
        LWIP_ASSERT("icmp_input: copying to new pbuf failed\n", 0);
  80e4b3:	83 ec 04             	sub    $0x4,%esp
  80e4b6:	68 e8 36 81 00       	push   $0x8136e8
  80e4bb:	68 88 00 00 00       	push   $0x88
  80e4c0:	68 70 37 81 00       	push   $0x813770
  80e4c5:	e8 7d 03 00 00       	call   80e847 <_panic>
        LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
  80e4ca:	83 ec 04             	sub    $0x4,%esp
  80e4cd:	68 10 37 81 00       	push   $0x813710
  80e4d2:	68 8e 00 00 00       	push   $0x8e
  80e4d7:	68 70 37 81 00       	push   $0x813770
  80e4dc:	e8 66 03 00 00       	call   80e847 <_panic>
      if (pbuf_header(p, -(s16_t)(PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
  80e4e1:	83 ec 08             	sub    $0x8,%esp
  80e4e4:	6a de                	push   $0xffffffde
  80e4e6:	53                   	push   %ebx
  80e4e7:	e8 69 63 ff ff       	call   804855 <pbuf_header>
  80e4ec:	83 c4 10             	add    $0x10,%esp
  80e4ef:	84 c0                	test   %al,%al
  80e4f1:	0f 85 d3 00 00 00    	jne    80e5ca <icmp_input+0x2d7>
    iecho = p->payload;
  80e4f7:	8b 73 04             	mov    0x4(%ebx),%esi
    tmpaddr.addr = iphdr->src.addr;
  80e4fa:	8b 47 0c             	mov    0xc(%edi),%eax
    iphdr->src.addr = iphdr->dest.addr;
  80e4fd:	8b 57 10             	mov    0x10(%edi),%edx
  80e500:	89 57 0c             	mov    %edx,0xc(%edi)
    iphdr->dest.addr = tmpaddr.addr;
  80e503:	89 47 10             	mov    %eax,0x10(%edi)
    ICMPH_TYPE_SET(iecho, ICMP_ER);
  80e506:	83 ec 0c             	sub    $0xc,%esp
  80e509:	0f b7 06             	movzwl (%esi),%eax
  80e50c:	50                   	push   %eax
  80e50d:	e8 5f 93 ff ff       	call   807871 <ntohs>
  80e512:	0f b6 c0             	movzbl %al,%eax
  80e515:	89 04 24             	mov    %eax,(%esp)
  80e518:	e8 43 93 ff ff       	call   807860 <htons>
  80e51d:	66 89 06             	mov    %ax,(%esi)
    if (iecho->chksum >= htons(0xffff - (ICMP_ECHO << 8))) {
  80e520:	0f b7 46 02          	movzwl 0x2(%esi),%eax
  80e524:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
  80e528:	c7 04 24 ff f7 00 00 	movl   $0xf7ff,(%esp)
  80e52f:	e8 2c 93 ff ff       	call   807860 <htons>
  80e534:	83 c4 10             	add    $0x10,%esp
  80e537:	66 39 45 e0          	cmp    %ax,-0x20(%ebp)
  80e53b:	0f 82 a0 00 00 00    	jb     80e5e1 <icmp_input+0x2ee>
      iecho->chksum += htons(ICMP_ECHO << 8) + 1;
  80e541:	83 ec 0c             	sub    $0xc,%esp
  80e544:	68 00 08 00 00       	push   $0x800
  80e549:	e8 12 93 ff ff       	call   807860 <htons>
  80e54e:	0f b7 56 02          	movzwl 0x2(%esi),%edx
  80e552:	8d 44 02 01          	lea    0x1(%edx,%eax,1),%eax
  80e556:	66 89 46 02          	mov    %ax,0x2(%esi)
  80e55a:	83 c4 10             	add    $0x10,%esp
    IPH_TTL_SET(iphdr, ICMP_TTL);
  80e55d:	83 ec 0c             	sub    $0xc,%esp
  80e560:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  80e564:	50                   	push   %eax
  80e565:	e8 07 93 ff ff       	call   807871 <ntohs>
  80e56a:	66 0d 00 ff          	or     $0xff00,%ax
  80e56e:	0f b7 c0             	movzwl %ax,%eax
  80e571:	89 04 24             	mov    %eax,(%esp)
  80e574:	e8 e7 92 ff ff       	call   807860 <htons>
  80e579:	66 89 47 08          	mov    %ax,0x8(%edi)
    IPH_CHKSUM_SET(iphdr, 0);
  80e57d:	66 c7 47 0a 00 00    	movw   $0x0,0xa(%edi)
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
  80e583:	83 c4 08             	add    $0x8,%esp
  80e586:	6a 14                	push   $0x14
  80e588:	57                   	push   %edi
  80e589:	e8 98 91 ff ff       	call   807726 <inet_chksum>
  80e58e:	66 89 47 0a          	mov    %ax,0xa(%edi)
    if(pbuf_header(p, hlen)) {
  80e592:	83 c4 08             	add    $0x8,%esp
  80e595:	0f bf 45 e6          	movswl -0x1a(%ebp),%eax
  80e599:	50                   	push   %eax
  80e59a:	53                   	push   %ebx
  80e59b:	e8 b5 62 ff ff       	call   804855 <pbuf_header>
  80e5a0:	83 c4 10             	add    $0x10,%esp
  80e5a3:	84 c0                	test   %al,%al
  80e5a5:	75 53                	jne    80e5fa <icmp_input+0x307>
      ret = ip_output_if(p, &(iphdr->src), IP_HDRINCL,
  80e5a7:	83 ec 04             	sub    $0x4,%esp
  80e5aa:	ff 75 0c             	pushl  0xc(%ebp)
  80e5ad:	6a 01                	push   $0x1
  80e5af:	6a 00                	push   $0x0
  80e5b1:	68 ff 00 00 00       	push   $0xff
  80e5b6:	6a 00                	push   $0x0
  80e5b8:	83 c7 0c             	add    $0xc,%edi
  80e5bb:	57                   	push   %edi
  80e5bc:	53                   	push   %ebx
  80e5bd:	e8 f0 83 ff ff       	call   8069b2 <ip_output_if>
  80e5c2:	83 c4 20             	add    $0x20,%esp
  80e5c5:	e9 77 fd ff ff       	jmp    80e341 <icmp_input+0x4e>
        LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
  80e5ca:	83 ec 04             	sub    $0x4,%esp
  80e5cd:	68 10 37 81 00       	push   $0x813710
  80e5d2:	68 98 00 00 00       	push   $0x98
  80e5d7:	68 70 37 81 00       	push   $0x813770
  80e5dc:	e8 66 02 00 00       	call   80e847 <_panic>
      iecho->chksum += htons(ICMP_ECHO << 8);
  80e5e1:	83 ec 0c             	sub    $0xc,%esp
  80e5e4:	68 00 08 00 00       	push   $0x800
  80e5e9:	e8 72 92 ff ff       	call   807860 <htons>
  80e5ee:	66 01 46 02          	add    %ax,0x2(%esi)
  80e5f2:	83 c4 10             	add    $0x10,%esp
  80e5f5:	e9 63 ff ff ff       	jmp    80e55d <icmp_input+0x26a>
      LWIP_ASSERT("Can't move over header in packet", 0);
  80e5fa:	83 ec 04             	sub    $0x4,%esp
  80e5fd:	68 d8 27 81 00       	push   $0x8127d8
  80e602:	68 b9 00 00 00       	push   $0xb9
  80e607:	68 70 37 81 00       	push   $0x813770
  80e60c:	e8 36 02 00 00       	call   80e847 <_panic>

0080e611 <icmp_dest_unreach>:
 *          p->payload pointing to the IP header
 * @param t type of the 'unreachable' packet
 */
void
icmp_dest_unreach(struct pbuf *p, enum icmp_dur_type t)
{
  80e611:	f3 0f 1e fb          	endbr32 
  80e615:	55                   	push   %ebp
  80e616:	89 e5                	mov    %esp,%ebp
  80e618:	57                   	push   %edi
  80e619:	56                   	push   %esi
  80e61a:	53                   	push   %ebx
  80e61b:	83 ec 10             	sub    $0x10,%esp
  struct pbuf *q;
  struct ip_hdr *iphdr;
  struct icmp_dur_hdr *idur;

  /* ICMP header + IP header + 8 bytes of data */
  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
  80e61e:	6a 00                	push   $0x0
  80e620:	6a 24                	push   $0x24
  80e622:	6a 01                	push   $0x1
  80e624:	e8 c9 63 ff ff       	call   8049f2 <pbuf_alloc>
                 PBUF_RAM);
  if (q == NULL) {
  80e629:	83 c4 10             	add    $0x10,%esp
  80e62c:	85 c0                	test   %eax,%eax
  80e62e:	0f 84 a5 00 00 00    	je     80e6d9 <icmp_dest_unreach+0xc8>
  80e634:	89 c3                	mov    %eax,%ebx
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_dest_unreach: failed to allocate pbuf for ICMP packet.\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold icmp message",
  80e636:	66 83 78 0a 23       	cmpw   $0x23,0xa(%eax)
  80e63b:	0f 86 a0 00 00 00    	jbe    80e6e1 <icmp_dest_unreach+0xd0>
             (q->len >= (sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE)));

  iphdr = p->payload;
  80e641:	8b 45 08             	mov    0x8(%ebp),%eax
  80e644:	8b 78 04             	mov    0x4(%eax),%edi

  idur = q->payload;
  80e647:	8b 73 04             	mov    0x4(%ebx),%esi
  ICMPH_TYPE_SET(idur, ICMP_DUR);
  80e64a:	83 ec 0c             	sub    $0xc,%esp
  80e64d:	0f b7 06             	movzwl (%esi),%eax
  80e650:	50                   	push   %eax
  80e651:	e8 1b 92 ff ff       	call   807871 <ntohs>
  80e656:	0f b6 c0             	movzbl %al,%eax
  80e659:	80 cc 03             	or     $0x3,%ah
  80e65c:	89 04 24             	mov    %eax,(%esp)
  80e65f:	e8 fc 91 ff ff       	call   807860 <htons>
  80e664:	66 89 06             	mov    %ax,(%esi)
  ICMPH_CODE_SET(idur, t);
  80e667:	0f b7 c0             	movzwl %ax,%eax
  80e66a:	89 04 24             	mov    %eax,(%esp)
  80e66d:	e8 ff 91 ff ff       	call   807871 <ntohs>
  80e672:	b0 00                	mov    $0x0,%al
  80e674:	66 0b 45 0c          	or     0xc(%ebp),%ax
  80e678:	0f b7 c0             	movzwl %ax,%eax
  80e67b:	89 04 24             	mov    %eax,(%esp)
  80e67e:	e8 dd 91 ff ff       	call   807860 <htons>
  80e683:	66 89 06             	mov    %ax,(%esi)

  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_dur_hdr), p->payload,
  80e686:	83 c4 0c             	add    $0xc,%esp
  80e689:	6a 1c                	push   $0x1c
  80e68b:	8b 45 08             	mov    0x8(%ebp),%eax
  80e68e:	ff 70 04             	pushl  0x4(%eax)
  80e691:	8b 43 04             	mov    0x4(%ebx),%eax
  80e694:	83 c0 08             	add    $0x8,%eax
  80e697:	50                   	push   %eax
  80e698:	e8 b7 0a 00 00       	call   80f154 <memcpy>
          IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);

  /* calculate checksum */
  idur->chksum = 0;
  80e69d:	66 c7 46 02 00 00    	movw   $0x0,0x2(%esi)
  idur->chksum = inet_chksum(idur, q->len);
  80e6a3:	83 c4 08             	add    $0x8,%esp
  80e6a6:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  80e6aa:	50                   	push   %eax
  80e6ab:	56                   	push   %esi
  80e6ac:	e8 75 90 ff ff       	call   807726 <inet_chksum>
  80e6b1:	66 89 46 02          	mov    %ax,0x2(%esi)
  /* increase number of messages attempted to send */
  snmp_inc_icmpoutmsgs();
  /* increase number of destination unreachable messages attempted to send */
  snmp_inc_icmpoutdestunreachs();

  ip_output(q, NULL, &(iphdr->src), ICMP_TTL, 0, IP_PROTO_ICMP);
  80e6b5:	83 c4 08             	add    $0x8,%esp
  80e6b8:	6a 01                	push   $0x1
  80e6ba:	6a 00                	push   $0x0
  80e6bc:	68 ff 00 00 00       	push   $0xff
  80e6c1:	83 c7 0c             	add    $0xc,%edi
  80e6c4:	57                   	push   %edi
  80e6c5:	6a 00                	push   $0x0
  80e6c7:	53                   	push   %ebx
  80e6c8:	e8 6b 84 ff ff       	call   806b38 <ip_output>
  pbuf_free(q);
  80e6cd:	83 c4 14             	add    $0x14,%esp
  80e6d0:	53                   	push   %ebx
  80e6d1:	e8 52 62 ff ff       	call   804928 <pbuf_free>
  80e6d6:	83 c4 10             	add    $0x10,%esp
}
  80e6d9:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80e6dc:	5b                   	pop    %ebx
  80e6dd:	5e                   	pop    %esi
  80e6de:	5f                   	pop    %edi
  80e6df:	5d                   	pop    %ebp
  80e6e0:	c3                   	ret    
  LWIP_ASSERT("check that first pbuf can hold icmp message",
  80e6e1:	83 ec 04             	sub    $0x4,%esp
  80e6e4:	68 44 37 81 00       	push   $0x813744
  80e6e9:	68 ee 00 00 00       	push   $0xee
  80e6ee:	68 70 37 81 00       	push   $0x813770
  80e6f3:	e8 4f 01 00 00       	call   80e847 <_panic>

0080e6f8 <icmp_time_exceeded>:
 *          p->payload pointing to the IP header
 * @param t type of the 'time exceeded' packet
 */
void
icmp_time_exceeded(struct pbuf *p, enum icmp_te_type t)
{
  80e6f8:	f3 0f 1e fb          	endbr32 
  80e6fc:	55                   	push   %ebp
  80e6fd:	89 e5                	mov    %esp,%ebp
  80e6ff:	57                   	push   %edi
  80e700:	56                   	push   %esi
  80e701:	53                   	push   %ebx
  80e702:	83 ec 10             	sub    $0x10,%esp
  struct pbuf *q;
  struct ip_hdr *iphdr;
  struct icmp_te_hdr *tehdr;

  /* ICMP header + IP header + 8 bytes of data */
  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
  80e705:	6a 00                	push   $0x0
  80e707:	6a 24                	push   $0x24
  80e709:	6a 01                	push   $0x1
  80e70b:	e8 e2 62 ff ff       	call   8049f2 <pbuf_alloc>
                 PBUF_RAM);
  if (q == NULL) {
  80e710:	83 c4 10             	add    $0x10,%esp
  80e713:	85 c0                	test   %eax,%eax
  80e715:	0f 84 a5 00 00 00    	je     80e7c0 <icmp_time_exceeded+0xc8>
  80e71b:	89 c3                	mov    %eax,%ebx
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_time_exceeded: failed to allocate pbuf for ICMP packet.\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold icmp message",
  80e71d:	66 83 78 0a 23       	cmpw   $0x23,0xa(%eax)
  80e722:	0f 86 a0 00 00 00    	jbe    80e7c8 <icmp_time_exceeded+0xd0>
             (q->len >= (sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE)));

  iphdr = p->payload;
  80e728:	8b 45 08             	mov    0x8(%ebp),%eax
  80e72b:	8b 78 04             	mov    0x4(%eax),%edi
  ip_addr_debug_print(ICMP_DEBUG, &(iphdr->src));
  LWIP_DEBUGF(ICMP_DEBUG, (" to "));
  ip_addr_debug_print(ICMP_DEBUG, &(iphdr->dest));
  LWIP_DEBUGF(ICMP_DEBUG, ("\n"));

  tehdr = q->payload;
  80e72e:	8b 73 04             	mov    0x4(%ebx),%esi
  ICMPH_TYPE_SET(tehdr, ICMP_TE);
  80e731:	83 ec 0c             	sub    $0xc,%esp
  80e734:	0f b7 06             	movzwl (%esi),%eax
  80e737:	50                   	push   %eax
  80e738:	e8 34 91 ff ff       	call   807871 <ntohs>
  80e73d:	0f b6 c0             	movzbl %al,%eax
  80e740:	80 cc 0b             	or     $0xb,%ah
  80e743:	89 04 24             	mov    %eax,(%esp)
  80e746:	e8 15 91 ff ff       	call   807860 <htons>
  80e74b:	66 89 06             	mov    %ax,(%esi)
  ICMPH_CODE_SET(tehdr, t);
  80e74e:	0f b7 c0             	movzwl %ax,%eax
  80e751:	89 04 24             	mov    %eax,(%esp)
  80e754:	e8 18 91 ff ff       	call   807871 <ntohs>
  80e759:	b0 00                	mov    $0x0,%al
  80e75b:	66 0b 45 0c          	or     0xc(%ebp),%ax
  80e75f:	0f b7 c0             	movzwl %ax,%eax
  80e762:	89 04 24             	mov    %eax,(%esp)
  80e765:	e8 f6 90 ff ff       	call   807860 <htons>
  80e76a:	66 89 06             	mov    %ax,(%esi)

  /* copy fields from original packet */
  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_dur_hdr), (u8_t *)p->payload,
  80e76d:	83 c4 0c             	add    $0xc,%esp
  80e770:	6a 1c                	push   $0x1c
  80e772:	8b 45 08             	mov    0x8(%ebp),%eax
  80e775:	ff 70 04             	pushl  0x4(%eax)
  80e778:	8b 43 04             	mov    0x4(%ebx),%eax
  80e77b:	83 c0 08             	add    $0x8,%eax
  80e77e:	50                   	push   %eax
  80e77f:	e8 d0 09 00 00       	call   80f154 <memcpy>
          IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);

  /* calculate checksum */
  tehdr->chksum = 0;
  80e784:	66 c7 46 02 00 00    	movw   $0x0,0x2(%esi)
  tehdr->chksum = inet_chksum(tehdr, q->len);
  80e78a:	83 c4 08             	add    $0x8,%esp
  80e78d:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  80e791:	50                   	push   %eax
  80e792:	56                   	push   %esi
  80e793:	e8 8e 8f ff ff       	call   807726 <inet_chksum>
  80e798:	66 89 46 02          	mov    %ax,0x2(%esi)
  ICMP_STATS_INC(icmp.xmit);
  /* increase number of messages attempted to send */
  snmp_inc_icmpoutmsgs();
  /* increase number of destination unreachable messages attempted to send */
  snmp_inc_icmpouttimeexcds();
  ip_output(q, NULL, &(iphdr->src), ICMP_TTL, 0, IP_PROTO_ICMP);
  80e79c:	83 c4 08             	add    $0x8,%esp
  80e79f:	6a 01                	push   $0x1
  80e7a1:	6a 00                	push   $0x0
  80e7a3:	68 ff 00 00 00       	push   $0xff
  80e7a8:	83 c7 0c             	add    $0xc,%edi
  80e7ab:	57                   	push   %edi
  80e7ac:	6a 00                	push   $0x0
  80e7ae:	53                   	push   %ebx
  80e7af:	e8 84 83 ff ff       	call   806b38 <ip_output>
  pbuf_free(q);
  80e7b4:	83 c4 14             	add    $0x14,%esp
  80e7b7:	53                   	push   %ebx
  80e7b8:	e8 6b 61 ff ff       	call   804928 <pbuf_free>
  80e7bd:	83 c4 10             	add    $0x10,%esp
}
  80e7c0:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80e7c3:	5b                   	pop    %ebx
  80e7c4:	5e                   	pop    %esi
  80e7c5:	5f                   	pop    %edi
  80e7c6:	5d                   	pop    %ebp
  80e7c7:	c3                   	ret    
  LWIP_ASSERT("check that first pbuf can hold icmp message",
  80e7c8:	83 ec 04             	sub    $0x4,%esp
  80e7cb:	68 44 37 81 00       	push   $0x813744
  80e7d0:	68 1d 01 00 00       	push   $0x11d
  80e7d5:	68 70 37 81 00       	push   $0x813770
  80e7da:	e8 68 00 00 00       	call   80e847 <_panic>

0080e7df <libmain>:
const volatile struct Env *thisenv;
const char *binaryname = "<unknown>";

void
libmain(int argc, char **argv)
{
  80e7df:	f3 0f 1e fb          	endbr32 
  80e7e3:	55                   	push   %ebp
  80e7e4:	89 e5                	mov    %esp,%ebp
  80e7e6:	56                   	push   %esi
  80e7e7:	53                   	push   %ebx
  80e7e8:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80e7eb:	8b 75 0c             	mov    0xc(%ebp),%esi
	// set thisenv to point at our Env structure in envs[].
	// LAB 3: Your code here.
	thisenv = &envs[ENVX(sys_getenvid())];
  80e7ee:	e8 41 0b 00 00       	call   80f334 <sys_getenvid>
  80e7f3:	25 ff 03 00 00       	and    $0x3ff,%eax
  80e7f8:	6b c0 7c             	imul   $0x7c,%eax,%eax
  80e7fb:	05 00 00 c0 ee       	add    $0xeec00000,%eax
  80e800:	a3 5c b2 b3 00       	mov    %eax,0xb3b25c

	// save the name of the program so that panic() can use it
	if (argc > 0)
  80e805:	85 db                	test   %ebx,%ebx
  80e807:	7e 07                	jle    80e810 <libmain+0x31>
		binaryname = argv[0];
  80e809:	8b 06                	mov    (%esi),%eax
  80e80b:	a3 e8 42 81 00       	mov    %eax,0x8142e8

	// call user main routine
	umain(argc, argv);
  80e810:	83 ec 08             	sub    $0x8,%esp
  80e813:	56                   	push   %esi
  80e814:	53                   	push   %ebx
  80e815:	e8 7c 1d ff ff       	call   800596 <umain>

	// exit gracefully
	exit();
  80e81a:	e8 0a 00 00 00       	call   80e829 <exit>
}
  80e81f:	83 c4 10             	add    $0x10,%esp
  80e822:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80e825:	5b                   	pop    %ebx
  80e826:	5e                   	pop    %esi
  80e827:	5d                   	pop    %ebp
  80e828:	c3                   	ret    

0080e829 <exit>:

#include <inc/lib.h>

void
exit(void)
{
  80e829:	f3 0f 1e fb          	endbr32 
  80e82d:	55                   	push   %ebp
  80e82e:	89 e5                	mov    %esp,%ebp
  80e830:	83 ec 08             	sub    $0x8,%esp
	close_all();
  80e833:	e8 b1 13 00 00       	call   80fbe9 <close_all>
	sys_env_destroy(0);
  80e838:	83 ec 0c             	sub    $0xc,%esp
  80e83b:	6a 00                	push   $0x0
  80e83d:	e8 ad 0a 00 00       	call   80f2ef <sys_env_destroy>
}
  80e842:	83 c4 10             	add    $0x10,%esp
  80e845:	c9                   	leave  
  80e846:	c3                   	ret    

0080e847 <_panic>:
 * It prints "panic: <message>", then causes a breakpoint exception,
 * which causes JOS to enter the JOS kernel monitor.
 */
void
_panic(const char *file, int line, const char *fmt, ...)
{
  80e847:	f3 0f 1e fb          	endbr32 
  80e84b:	55                   	push   %ebp
  80e84c:	89 e5                	mov    %esp,%ebp
  80e84e:	56                   	push   %esi
  80e84f:	53                   	push   %ebx
	va_list ap;

	va_start(ap, fmt);
  80e850:	8d 5d 14             	lea    0x14(%ebp),%ebx

	// Print the panic message
	cprintf("[%08x] user panic in %s at %s:%d: ",
  80e853:	8b 35 e8 42 81 00    	mov    0x8142e8,%esi
  80e859:	e8 d6 0a 00 00       	call   80f334 <sys_getenvid>
  80e85e:	83 ec 0c             	sub    $0xc,%esp
  80e861:	ff 75 0c             	pushl  0xc(%ebp)
  80e864:	ff 75 08             	pushl  0x8(%ebp)
  80e867:	56                   	push   %esi
  80e868:	50                   	push   %eax
  80e869:	68 94 37 81 00       	push   $0x813794
  80e86e:	e8 bb 00 00 00       	call   80e92e <cprintf>
		sys_getenvid(), binaryname, file, line);
	vcprintf(fmt, ap);
  80e873:	83 c4 18             	add    $0x18,%esp
  80e876:	53                   	push   %ebx
  80e877:	ff 75 10             	pushl  0x10(%ebp)
  80e87a:	e8 5a 00 00 00       	call   80e8d9 <vcprintf>
	cprintf("\n");
  80e87f:	c7 04 24 88 13 81 00 	movl   $0x811388,(%esp)
  80e886:	e8 a3 00 00 00       	call   80e92e <cprintf>
  80e88b:	83 c4 10             	add    $0x10,%esp

	// Cause a breakpoint exception
	while (1)
		asm volatile("int3");
  80e88e:	cc                   	int3   
  80e88f:	eb fd                	jmp    80e88e <_panic+0x47>

0080e891 <putch>:
};


static void
putch(int ch, struct printbuf *b)
{
  80e891:	f3 0f 1e fb          	endbr32 
  80e895:	55                   	push   %ebp
  80e896:	89 e5                	mov    %esp,%ebp
  80e898:	53                   	push   %ebx
  80e899:	83 ec 04             	sub    $0x4,%esp
  80e89c:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	b->buf[b->idx++] = ch;
  80e89f:	8b 13                	mov    (%ebx),%edx
  80e8a1:	8d 42 01             	lea    0x1(%edx),%eax
  80e8a4:	89 03                	mov    %eax,(%ebx)
  80e8a6:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80e8a9:	88 4c 13 08          	mov    %cl,0x8(%ebx,%edx,1)
	if (b->idx == 256-1) {
  80e8ad:	3d ff 00 00 00       	cmp    $0xff,%eax
  80e8b2:	74 09                	je     80e8bd <putch+0x2c>
		sys_cputs(b->buf, b->idx);
		b->idx = 0;
	}
	b->cnt++;
  80e8b4:	83 43 04 01          	addl   $0x1,0x4(%ebx)
}
  80e8b8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80e8bb:	c9                   	leave  
  80e8bc:	c3                   	ret    
		sys_cputs(b->buf, b->idx);
  80e8bd:	83 ec 08             	sub    $0x8,%esp
  80e8c0:	68 ff 00 00 00       	push   $0xff
  80e8c5:	8d 43 08             	lea    0x8(%ebx),%eax
  80e8c8:	50                   	push   %eax
  80e8c9:	e8 dc 09 00 00       	call   80f2aa <sys_cputs>
		b->idx = 0;
  80e8ce:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
  80e8d4:	83 c4 10             	add    $0x10,%esp
  80e8d7:	eb db                	jmp    80e8b4 <putch+0x23>

0080e8d9 <vcprintf>:

int
vcprintf(const char *fmt, va_list ap)
{
  80e8d9:	f3 0f 1e fb          	endbr32 
  80e8dd:	55                   	push   %ebp
  80e8de:	89 e5                	mov    %esp,%ebp
  80e8e0:	81 ec 18 01 00 00    	sub    $0x118,%esp
	struct printbuf b;

	b.idx = 0;
  80e8e6:	c7 85 f0 fe ff ff 00 	movl   $0x0,-0x110(%ebp)
  80e8ed:	00 00 00 
	b.cnt = 0;
  80e8f0:	c7 85 f4 fe ff ff 00 	movl   $0x0,-0x10c(%ebp)
  80e8f7:	00 00 00 
	vprintfmt((void*)putch, &b, fmt, ap);
  80e8fa:	ff 75 0c             	pushl  0xc(%ebp)
  80e8fd:	ff 75 08             	pushl  0x8(%ebp)
  80e900:	8d 85 f0 fe ff ff    	lea    -0x110(%ebp),%eax
  80e906:	50                   	push   %eax
  80e907:	68 91 e8 80 00       	push   $0x80e891
  80e90c:	e8 20 01 00 00       	call   80ea31 <vprintfmt>
	sys_cputs(b.buf, b.idx);
  80e911:	83 c4 08             	add    $0x8,%esp
  80e914:	ff b5 f0 fe ff ff    	pushl  -0x110(%ebp)
  80e91a:	8d 85 f8 fe ff ff    	lea    -0x108(%ebp),%eax
  80e920:	50                   	push   %eax
  80e921:	e8 84 09 00 00       	call   80f2aa <sys_cputs>

	return b.cnt;
}
  80e926:	8b 85 f4 fe ff ff    	mov    -0x10c(%ebp),%eax
  80e92c:	c9                   	leave  
  80e92d:	c3                   	ret    

0080e92e <cprintf>:

int
cprintf(const char *fmt, ...)
{
  80e92e:	f3 0f 1e fb          	endbr32 
  80e932:	55                   	push   %ebp
  80e933:	89 e5                	mov    %esp,%ebp
  80e935:	83 ec 10             	sub    $0x10,%esp
	va_list ap;
	int cnt;

	va_start(ap, fmt);
  80e938:	8d 45 0c             	lea    0xc(%ebp),%eax
	cnt = vcprintf(fmt, ap);
  80e93b:	50                   	push   %eax
  80e93c:	ff 75 08             	pushl  0x8(%ebp)
  80e93f:	e8 95 ff ff ff       	call   80e8d9 <vcprintf>
	va_end(ap);

	return cnt;
}
  80e944:	c9                   	leave  
  80e945:	c3                   	ret    

0080e946 <printnum>:
 * using specified putch function and associated pointer putdat.
 */
static void
printnum(void (*putch)(int, void*), void *putdat,
	 unsigned long long num, unsigned base, int width, int padc)
{
  80e946:	55                   	push   %ebp
  80e947:	89 e5                	mov    %esp,%ebp
  80e949:	57                   	push   %edi
  80e94a:	56                   	push   %esi
  80e94b:	53                   	push   %ebx
  80e94c:	83 ec 1c             	sub    $0x1c,%esp
  80e94f:	89 c7                	mov    %eax,%edi
  80e951:	89 d6                	mov    %edx,%esi
  80e953:	8b 45 08             	mov    0x8(%ebp),%eax
  80e956:	8b 55 0c             	mov    0xc(%ebp),%edx
  80e959:	89 d1                	mov    %edx,%ecx
  80e95b:	89 c2                	mov    %eax,%edx
  80e95d:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80e960:	89 4d dc             	mov    %ecx,-0x24(%ebp)
  80e963:	8b 45 10             	mov    0x10(%ebp),%eax
  80e966:	8b 5d 14             	mov    0x14(%ebp),%ebx
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
  80e969:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80e96c:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  80e973:	39 c2                	cmp    %eax,%edx
  80e975:	1b 4d e4             	sbb    -0x1c(%ebp),%ecx
  80e978:	72 3e                	jb     80e9b8 <printnum+0x72>
		printnum(putch, putdat, num / base, base, width - 1, padc);
  80e97a:	83 ec 0c             	sub    $0xc,%esp
  80e97d:	ff 75 18             	pushl  0x18(%ebp)
  80e980:	83 eb 01             	sub    $0x1,%ebx
  80e983:	53                   	push   %ebx
  80e984:	50                   	push   %eax
  80e985:	83 ec 08             	sub    $0x8,%esp
  80e988:	ff 75 e4             	pushl  -0x1c(%ebp)
  80e98b:	ff 75 e0             	pushl  -0x20(%ebp)
  80e98e:	ff 75 dc             	pushl  -0x24(%ebp)
  80e991:	ff 75 d8             	pushl  -0x28(%ebp)
  80e994:	e8 f7 25 00 00       	call   810f90 <__udivdi3>
  80e999:	83 c4 18             	add    $0x18,%esp
  80e99c:	52                   	push   %edx
  80e99d:	50                   	push   %eax
  80e99e:	89 f2                	mov    %esi,%edx
  80e9a0:	89 f8                	mov    %edi,%eax
  80e9a2:	e8 9f ff ff ff       	call   80e946 <printnum>
  80e9a7:	83 c4 20             	add    $0x20,%esp
  80e9aa:	eb 13                	jmp    80e9bf <printnum+0x79>
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
			putch(padc, putdat);
  80e9ac:	83 ec 08             	sub    $0x8,%esp
  80e9af:	56                   	push   %esi
  80e9b0:	ff 75 18             	pushl  0x18(%ebp)
  80e9b3:	ff d7                	call   *%edi
  80e9b5:	83 c4 10             	add    $0x10,%esp
		while (--width > 0)
  80e9b8:	83 eb 01             	sub    $0x1,%ebx
  80e9bb:	85 db                	test   %ebx,%ebx
  80e9bd:	7f ed                	jg     80e9ac <printnum+0x66>
	}

	// then print this (the least significant) digit
	putch("0123456789abcdef"[num % base], putdat);
  80e9bf:	83 ec 08             	sub    $0x8,%esp
  80e9c2:	56                   	push   %esi
  80e9c3:	83 ec 04             	sub    $0x4,%esp
  80e9c6:	ff 75 e4             	pushl  -0x1c(%ebp)
  80e9c9:	ff 75 e0             	pushl  -0x20(%ebp)
  80e9cc:	ff 75 dc             	pushl  -0x24(%ebp)
  80e9cf:	ff 75 d8             	pushl  -0x28(%ebp)
  80e9d2:	e8 c9 26 00 00       	call   8110a0 <__umoddi3>
  80e9d7:	83 c4 14             	add    $0x14,%esp
  80e9da:	0f be 80 b7 37 81 00 	movsbl 0x8137b7(%eax),%eax
  80e9e1:	50                   	push   %eax
  80e9e2:	ff d7                	call   *%edi
}
  80e9e4:	83 c4 10             	add    $0x10,%esp
  80e9e7:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80e9ea:	5b                   	pop    %ebx
  80e9eb:	5e                   	pop    %esi
  80e9ec:	5f                   	pop    %edi
  80e9ed:	5d                   	pop    %ebp
  80e9ee:	c3                   	ret    

0080e9ef <sprintputch>:
	int cnt;
};

static void
sprintputch(int ch, struct sprintbuf *b)
{
  80e9ef:	f3 0f 1e fb          	endbr32 
  80e9f3:	55                   	push   %ebp
  80e9f4:	89 e5                	mov    %esp,%ebp
  80e9f6:	8b 45 0c             	mov    0xc(%ebp),%eax
	b->cnt++;
  80e9f9:	83 40 08 01          	addl   $0x1,0x8(%eax)
	if (b->buf < b->ebuf)
  80e9fd:	8b 10                	mov    (%eax),%edx
  80e9ff:	3b 50 04             	cmp    0x4(%eax),%edx
  80ea02:	73 0a                	jae    80ea0e <sprintputch+0x1f>
		*b->buf++ = ch;
  80ea04:	8d 4a 01             	lea    0x1(%edx),%ecx
  80ea07:	89 08                	mov    %ecx,(%eax)
  80ea09:	8b 45 08             	mov    0x8(%ebp),%eax
  80ea0c:	88 02                	mov    %al,(%edx)
}
  80ea0e:	5d                   	pop    %ebp
  80ea0f:	c3                   	ret    

0080ea10 <printfmt>:
{
  80ea10:	f3 0f 1e fb          	endbr32 
  80ea14:	55                   	push   %ebp
  80ea15:	89 e5                	mov    %esp,%ebp
  80ea17:	83 ec 08             	sub    $0x8,%esp
	va_start(ap, fmt);
  80ea1a:	8d 45 14             	lea    0x14(%ebp),%eax
	vprintfmt(putch, putdat, fmt, ap);
  80ea1d:	50                   	push   %eax
  80ea1e:	ff 75 10             	pushl  0x10(%ebp)
  80ea21:	ff 75 0c             	pushl  0xc(%ebp)
  80ea24:	ff 75 08             	pushl  0x8(%ebp)
  80ea27:	e8 05 00 00 00       	call   80ea31 <vprintfmt>
}
  80ea2c:	83 c4 10             	add    $0x10,%esp
  80ea2f:	c9                   	leave  
  80ea30:	c3                   	ret    

0080ea31 <vprintfmt>:
{
  80ea31:	f3 0f 1e fb          	endbr32 
  80ea35:	55                   	push   %ebp
  80ea36:	89 e5                	mov    %esp,%ebp
  80ea38:	57                   	push   %edi
  80ea39:	56                   	push   %esi
  80ea3a:	53                   	push   %ebx
  80ea3b:	83 ec 3c             	sub    $0x3c,%esp
  80ea3e:	8b 75 08             	mov    0x8(%ebp),%esi
  80ea41:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  80ea44:	8b 7d 10             	mov    0x10(%ebp),%edi
  80ea47:	e9 8e 03 00 00       	jmp    80edda <vprintfmt+0x3a9>
		padc = ' ';
  80ea4c:	c6 45 d3 20          	movb   $0x20,-0x2d(%ebp)
		altflag = 0;
  80ea50:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
		precision = -1;
  80ea57:	c7 45 d8 ff ff ff ff 	movl   $0xffffffff,-0x28(%ebp)
		width = -1;
  80ea5e:	c7 45 e0 ff ff ff ff 	movl   $0xffffffff,-0x20(%ebp)
		lflag = 0;
  80ea65:	b9 00 00 00 00       	mov    $0x0,%ecx
		switch (ch = *(unsigned char *) fmt++) {
  80ea6a:	8d 47 01             	lea    0x1(%edi),%eax
  80ea6d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80ea70:	0f b6 17             	movzbl (%edi),%edx
  80ea73:	8d 42 dd             	lea    -0x23(%edx),%eax
  80ea76:	3c 55                	cmp    $0x55,%al
  80ea78:	0f 87 df 03 00 00    	ja     80ee5d <vprintfmt+0x42c>
  80ea7e:	0f b6 c0             	movzbl %al,%eax
  80ea81:	3e ff 24 85 00 39 81 	notrack jmp *0x813900(,%eax,4)
  80ea88:	00 
  80ea89:	8b 7d e4             	mov    -0x1c(%ebp),%edi
			padc = '-';
  80ea8c:	c6 45 d3 2d          	movb   $0x2d,-0x2d(%ebp)
  80ea90:	eb d8                	jmp    80ea6a <vprintfmt+0x39>
		switch (ch = *(unsigned char *) fmt++) {
  80ea92:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  80ea95:	c6 45 d3 30          	movb   $0x30,-0x2d(%ebp)
  80ea99:	eb cf                	jmp    80ea6a <vprintfmt+0x39>
  80ea9b:	0f b6 d2             	movzbl %dl,%edx
  80ea9e:	8b 7d e4             	mov    -0x1c(%ebp),%edi
			for (precision = 0; ; ++fmt) {
  80eaa1:	b8 00 00 00 00       	mov    $0x0,%eax
  80eaa6:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
				precision = precision * 10 + ch - '0';
  80eaa9:	8d 04 80             	lea    (%eax,%eax,4),%eax
  80eaac:	8d 44 42 d0          	lea    -0x30(%edx,%eax,2),%eax
				ch = *fmt;
  80eab0:	0f be 17             	movsbl (%edi),%edx
				if (ch < '0' || ch > '9')
  80eab3:	8d 4a d0             	lea    -0x30(%edx),%ecx
  80eab6:	83 f9 09             	cmp    $0x9,%ecx
  80eab9:	77 55                	ja     80eb10 <vprintfmt+0xdf>
			for (precision = 0; ; ++fmt) {
  80eabb:	83 c7 01             	add    $0x1,%edi
				precision = precision * 10 + ch - '0';
  80eabe:	eb e9                	jmp    80eaa9 <vprintfmt+0x78>
			precision = va_arg(ap, int);
  80eac0:	8b 45 14             	mov    0x14(%ebp),%eax
  80eac3:	8b 00                	mov    (%eax),%eax
  80eac5:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80eac8:	8b 45 14             	mov    0x14(%ebp),%eax
  80eacb:	8d 40 04             	lea    0x4(%eax),%eax
  80eace:	89 45 14             	mov    %eax,0x14(%ebp)
		switch (ch = *(unsigned char *) fmt++) {
  80ead1:	8b 7d e4             	mov    -0x1c(%ebp),%edi
			if (width < 0)
  80ead4:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
  80ead8:	79 90                	jns    80ea6a <vprintfmt+0x39>
				width = precision, precision = -1;
  80eada:	8b 45 d8             	mov    -0x28(%ebp),%eax
  80eadd:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80eae0:	c7 45 d8 ff ff ff ff 	movl   $0xffffffff,-0x28(%ebp)
  80eae7:	eb 81                	jmp    80ea6a <vprintfmt+0x39>
  80eae9:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80eaec:	85 c0                	test   %eax,%eax
  80eaee:	ba 00 00 00 00       	mov    $0x0,%edx
  80eaf3:	0f 49 d0             	cmovns %eax,%edx
  80eaf6:	89 55 e0             	mov    %edx,-0x20(%ebp)
		switch (ch = *(unsigned char *) fmt++) {
  80eaf9:	8b 7d e4             	mov    -0x1c(%ebp),%edi
			goto reswitch;
  80eafc:	e9 69 ff ff ff       	jmp    80ea6a <vprintfmt+0x39>
		switch (ch = *(unsigned char *) fmt++) {
  80eb01:	8b 7d e4             	mov    -0x1c(%ebp),%edi
			altflag = 1;
  80eb04:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%ebp)
			goto reswitch;
  80eb0b:	e9 5a ff ff ff       	jmp    80ea6a <vprintfmt+0x39>
  80eb10:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  80eb13:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80eb16:	eb bc                	jmp    80ead4 <vprintfmt+0xa3>
			lflag++;
  80eb18:	83 c1 01             	add    $0x1,%ecx
		switch (ch = *(unsigned char *) fmt++) {
  80eb1b:	8b 7d e4             	mov    -0x1c(%ebp),%edi
			goto reswitch;
  80eb1e:	e9 47 ff ff ff       	jmp    80ea6a <vprintfmt+0x39>
			putch(va_arg(ap, int), putdat);
  80eb23:	8b 45 14             	mov    0x14(%ebp),%eax
  80eb26:	8d 78 04             	lea    0x4(%eax),%edi
  80eb29:	83 ec 08             	sub    $0x8,%esp
  80eb2c:	53                   	push   %ebx
  80eb2d:	ff 30                	pushl  (%eax)
  80eb2f:	ff d6                	call   *%esi
			break;
  80eb31:	83 c4 10             	add    $0x10,%esp
			putch(va_arg(ap, int), putdat);
  80eb34:	89 7d 14             	mov    %edi,0x14(%ebp)
			break;
  80eb37:	e9 9b 02 00 00       	jmp    80edd7 <vprintfmt+0x3a6>
			err = va_arg(ap, int);
  80eb3c:	8b 45 14             	mov    0x14(%ebp),%eax
  80eb3f:	8d 78 04             	lea    0x4(%eax),%edi
  80eb42:	8b 00                	mov    (%eax),%eax
  80eb44:	99                   	cltd   
  80eb45:	31 d0                	xor    %edx,%eax
  80eb47:	29 d0                	sub    %edx,%eax
			if (err >= MAXERROR || (p = error_string[err]) == NULL)
  80eb49:	83 f8 0f             	cmp    $0xf,%eax
  80eb4c:	7f 23                	jg     80eb71 <vprintfmt+0x140>
  80eb4e:	8b 14 85 60 3a 81 00 	mov    0x813a60(,%eax,4),%edx
  80eb55:	85 d2                	test   %edx,%edx
  80eb57:	74 18                	je     80eb71 <vprintfmt+0x140>
				printfmt(putch, putdat, "%s", p);
  80eb59:	52                   	push   %edx
  80eb5a:	68 9d 29 81 00       	push   $0x81299d
  80eb5f:	53                   	push   %ebx
  80eb60:	56                   	push   %esi
  80eb61:	e8 aa fe ff ff       	call   80ea10 <printfmt>
  80eb66:	83 c4 10             	add    $0x10,%esp
			err = va_arg(ap, int);
  80eb69:	89 7d 14             	mov    %edi,0x14(%ebp)
  80eb6c:	e9 66 02 00 00       	jmp    80edd7 <vprintfmt+0x3a6>
				printfmt(putch, putdat, "error %d", err);
  80eb71:	50                   	push   %eax
  80eb72:	68 cf 37 81 00       	push   $0x8137cf
  80eb77:	53                   	push   %ebx
  80eb78:	56                   	push   %esi
  80eb79:	e8 92 fe ff ff       	call   80ea10 <printfmt>
  80eb7e:	83 c4 10             	add    $0x10,%esp
			err = va_arg(ap, int);
  80eb81:	89 7d 14             	mov    %edi,0x14(%ebp)
				printfmt(putch, putdat, "error %d", err);
  80eb84:	e9 4e 02 00 00       	jmp    80edd7 <vprintfmt+0x3a6>
			if ((p = va_arg(ap, char *)) == NULL)
  80eb89:	8b 45 14             	mov    0x14(%ebp),%eax
  80eb8c:	83 c0 04             	add    $0x4,%eax
  80eb8f:	89 45 c8             	mov    %eax,-0x38(%ebp)
  80eb92:	8b 45 14             	mov    0x14(%ebp),%eax
  80eb95:	8b 10                	mov    (%eax),%edx
				p = "(null)";
  80eb97:	85 d2                	test   %edx,%edx
  80eb99:	b8 c8 37 81 00       	mov    $0x8137c8,%eax
  80eb9e:	0f 45 c2             	cmovne %edx,%eax
  80eba1:	89 45 cc             	mov    %eax,-0x34(%ebp)
			if (width > 0 && padc != '-')
  80eba4:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
  80eba8:	7e 06                	jle    80ebb0 <vprintfmt+0x17f>
  80ebaa:	80 7d d3 2d          	cmpb   $0x2d,-0x2d(%ebp)
  80ebae:	75 0d                	jne    80ebbd <vprintfmt+0x18c>
				for (width -= strnlen(p, precision); width > 0; width--)
  80ebb0:	8b 45 cc             	mov    -0x34(%ebp),%eax
  80ebb3:	89 c7                	mov    %eax,%edi
  80ebb5:	03 45 e0             	add    -0x20(%ebp),%eax
  80ebb8:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80ebbb:	eb 55                	jmp    80ec12 <vprintfmt+0x1e1>
  80ebbd:	83 ec 08             	sub    $0x8,%esp
  80ebc0:	ff 75 d8             	pushl  -0x28(%ebp)
  80ebc3:	ff 75 cc             	pushl  -0x34(%ebp)
  80ebc6:	e8 46 03 00 00       	call   80ef11 <strnlen>
  80ebcb:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80ebce:	29 c2                	sub    %eax,%edx
  80ebd0:	89 55 c4             	mov    %edx,-0x3c(%ebp)
  80ebd3:	83 c4 10             	add    $0x10,%esp
  80ebd6:	89 d7                	mov    %edx,%edi
					putch(padc, putdat);
  80ebd8:	0f be 45 d3          	movsbl -0x2d(%ebp),%eax
  80ebdc:	89 45 e0             	mov    %eax,-0x20(%ebp)
				for (width -= strnlen(p, precision); width > 0; width--)
  80ebdf:	85 ff                	test   %edi,%edi
  80ebe1:	7e 11                	jle    80ebf4 <vprintfmt+0x1c3>
					putch(padc, putdat);
  80ebe3:	83 ec 08             	sub    $0x8,%esp
  80ebe6:	53                   	push   %ebx
  80ebe7:	ff 75 e0             	pushl  -0x20(%ebp)
  80ebea:	ff d6                	call   *%esi
				for (width -= strnlen(p, precision); width > 0; width--)
  80ebec:	83 ef 01             	sub    $0x1,%edi
  80ebef:	83 c4 10             	add    $0x10,%esp
  80ebf2:	eb eb                	jmp    80ebdf <vprintfmt+0x1ae>
  80ebf4:	8b 55 c4             	mov    -0x3c(%ebp),%edx
  80ebf7:	85 d2                	test   %edx,%edx
  80ebf9:	b8 00 00 00 00       	mov    $0x0,%eax
  80ebfe:	0f 49 c2             	cmovns %edx,%eax
  80ec01:	29 c2                	sub    %eax,%edx
  80ec03:	89 55 e0             	mov    %edx,-0x20(%ebp)
  80ec06:	eb a8                	jmp    80ebb0 <vprintfmt+0x17f>
					putch(ch, putdat);
  80ec08:	83 ec 08             	sub    $0x8,%esp
  80ec0b:	53                   	push   %ebx
  80ec0c:	52                   	push   %edx
  80ec0d:	ff d6                	call   *%esi
  80ec0f:	83 c4 10             	add    $0x10,%esp
  80ec12:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  80ec15:	29 f9                	sub    %edi,%ecx
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
  80ec17:	83 c7 01             	add    $0x1,%edi
  80ec1a:	0f b6 47 ff          	movzbl -0x1(%edi),%eax
  80ec1e:	0f be d0             	movsbl %al,%edx
  80ec21:	85 d2                	test   %edx,%edx
  80ec23:	74 4b                	je     80ec70 <vprintfmt+0x23f>
  80ec25:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
  80ec29:	78 06                	js     80ec31 <vprintfmt+0x200>
  80ec2b:	83 6d d8 01          	subl   $0x1,-0x28(%ebp)
  80ec2f:	78 1e                	js     80ec4f <vprintfmt+0x21e>
				if (altflag && (ch < ' ' || ch > '~'))
  80ec31:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
  80ec35:	74 d1                	je     80ec08 <vprintfmt+0x1d7>
  80ec37:	0f be c0             	movsbl %al,%eax
  80ec3a:	83 e8 20             	sub    $0x20,%eax
  80ec3d:	83 f8 5e             	cmp    $0x5e,%eax
  80ec40:	76 c6                	jbe    80ec08 <vprintfmt+0x1d7>
					putch('?', putdat);
  80ec42:	83 ec 08             	sub    $0x8,%esp
  80ec45:	53                   	push   %ebx
  80ec46:	6a 3f                	push   $0x3f
  80ec48:	ff d6                	call   *%esi
  80ec4a:	83 c4 10             	add    $0x10,%esp
  80ec4d:	eb c3                	jmp    80ec12 <vprintfmt+0x1e1>
  80ec4f:	89 cf                	mov    %ecx,%edi
  80ec51:	eb 0e                	jmp    80ec61 <vprintfmt+0x230>
				putch(' ', putdat);
  80ec53:	83 ec 08             	sub    $0x8,%esp
  80ec56:	53                   	push   %ebx
  80ec57:	6a 20                	push   $0x20
  80ec59:	ff d6                	call   *%esi
			for (; width > 0; width--)
  80ec5b:	83 ef 01             	sub    $0x1,%edi
  80ec5e:	83 c4 10             	add    $0x10,%esp
  80ec61:	85 ff                	test   %edi,%edi
  80ec63:	7f ee                	jg     80ec53 <vprintfmt+0x222>
			if ((p = va_arg(ap, char *)) == NULL)
  80ec65:	8b 45 c8             	mov    -0x38(%ebp),%eax
  80ec68:	89 45 14             	mov    %eax,0x14(%ebp)
  80ec6b:	e9 67 01 00 00       	jmp    80edd7 <vprintfmt+0x3a6>
  80ec70:	89 cf                	mov    %ecx,%edi
  80ec72:	eb ed                	jmp    80ec61 <vprintfmt+0x230>
	if (lflag >= 2)
  80ec74:	83 f9 01             	cmp    $0x1,%ecx
  80ec77:	7f 1b                	jg     80ec94 <vprintfmt+0x263>
	else if (lflag)
  80ec79:	85 c9                	test   %ecx,%ecx
  80ec7b:	74 63                	je     80ece0 <vprintfmt+0x2af>
		return va_arg(*ap, long);
  80ec7d:	8b 45 14             	mov    0x14(%ebp),%eax
  80ec80:	8b 00                	mov    (%eax),%eax
  80ec82:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80ec85:	99                   	cltd   
  80ec86:	89 55 dc             	mov    %edx,-0x24(%ebp)
  80ec89:	8b 45 14             	mov    0x14(%ebp),%eax
  80ec8c:	8d 40 04             	lea    0x4(%eax),%eax
  80ec8f:	89 45 14             	mov    %eax,0x14(%ebp)
  80ec92:	eb 17                	jmp    80ecab <vprintfmt+0x27a>
		return va_arg(*ap, long long);
  80ec94:	8b 45 14             	mov    0x14(%ebp),%eax
  80ec97:	8b 50 04             	mov    0x4(%eax),%edx
  80ec9a:	8b 00                	mov    (%eax),%eax
  80ec9c:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80ec9f:	89 55 dc             	mov    %edx,-0x24(%ebp)
  80eca2:	8b 45 14             	mov    0x14(%ebp),%eax
  80eca5:	8d 40 08             	lea    0x8(%eax),%eax
  80eca8:	89 45 14             	mov    %eax,0x14(%ebp)
			if ((long long) num < 0) {
  80ecab:	8b 55 d8             	mov    -0x28(%ebp),%edx
  80ecae:	8b 4d dc             	mov    -0x24(%ebp),%ecx
			base = 10;
  80ecb1:	b8 0a 00 00 00       	mov    $0xa,%eax
			if ((long long) num < 0) {
  80ecb6:	85 c9                	test   %ecx,%ecx
  80ecb8:	0f 89 ff 00 00 00    	jns    80edbd <vprintfmt+0x38c>
				putch('-', putdat);
  80ecbe:	83 ec 08             	sub    $0x8,%esp
  80ecc1:	53                   	push   %ebx
  80ecc2:	6a 2d                	push   $0x2d
  80ecc4:	ff d6                	call   *%esi
				num = -(long long) num;
  80ecc6:	8b 55 d8             	mov    -0x28(%ebp),%edx
  80ecc9:	8b 4d dc             	mov    -0x24(%ebp),%ecx
  80eccc:	f7 da                	neg    %edx
  80ecce:	83 d1 00             	adc    $0x0,%ecx
  80ecd1:	f7 d9                	neg    %ecx
  80ecd3:	83 c4 10             	add    $0x10,%esp
			base = 10;
  80ecd6:	b8 0a 00 00 00       	mov    $0xa,%eax
  80ecdb:	e9 dd 00 00 00       	jmp    80edbd <vprintfmt+0x38c>
		return va_arg(*ap, int);
  80ece0:	8b 45 14             	mov    0x14(%ebp),%eax
  80ece3:	8b 00                	mov    (%eax),%eax
  80ece5:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80ece8:	99                   	cltd   
  80ece9:	89 55 dc             	mov    %edx,-0x24(%ebp)
  80ecec:	8b 45 14             	mov    0x14(%ebp),%eax
  80ecef:	8d 40 04             	lea    0x4(%eax),%eax
  80ecf2:	89 45 14             	mov    %eax,0x14(%ebp)
  80ecf5:	eb b4                	jmp    80ecab <vprintfmt+0x27a>
	if (lflag >= 2)
  80ecf7:	83 f9 01             	cmp    $0x1,%ecx
  80ecfa:	7f 1e                	jg     80ed1a <vprintfmt+0x2e9>
	else if (lflag)
  80ecfc:	85 c9                	test   %ecx,%ecx
  80ecfe:	74 32                	je     80ed32 <vprintfmt+0x301>
		return va_arg(*ap, unsigned long);
  80ed00:	8b 45 14             	mov    0x14(%ebp),%eax
  80ed03:	8b 10                	mov    (%eax),%edx
  80ed05:	b9 00 00 00 00       	mov    $0x0,%ecx
  80ed0a:	8d 40 04             	lea    0x4(%eax),%eax
  80ed0d:	89 45 14             	mov    %eax,0x14(%ebp)
			base = 10;
  80ed10:	b8 0a 00 00 00       	mov    $0xa,%eax
		return va_arg(*ap, unsigned long);
  80ed15:	e9 a3 00 00 00       	jmp    80edbd <vprintfmt+0x38c>
		return va_arg(*ap, unsigned long long);
  80ed1a:	8b 45 14             	mov    0x14(%ebp),%eax
  80ed1d:	8b 10                	mov    (%eax),%edx
  80ed1f:	8b 48 04             	mov    0x4(%eax),%ecx
  80ed22:	8d 40 08             	lea    0x8(%eax),%eax
  80ed25:	89 45 14             	mov    %eax,0x14(%ebp)
			base = 10;
  80ed28:	b8 0a 00 00 00       	mov    $0xa,%eax
		return va_arg(*ap, unsigned long long);
  80ed2d:	e9 8b 00 00 00       	jmp    80edbd <vprintfmt+0x38c>
		return va_arg(*ap, unsigned int);
  80ed32:	8b 45 14             	mov    0x14(%ebp),%eax
  80ed35:	8b 10                	mov    (%eax),%edx
  80ed37:	b9 00 00 00 00       	mov    $0x0,%ecx
  80ed3c:	8d 40 04             	lea    0x4(%eax),%eax
  80ed3f:	89 45 14             	mov    %eax,0x14(%ebp)
			base = 10;
  80ed42:	b8 0a 00 00 00       	mov    $0xa,%eax
		return va_arg(*ap, unsigned int);
  80ed47:	eb 74                	jmp    80edbd <vprintfmt+0x38c>
	if (lflag >= 2)
  80ed49:	83 f9 01             	cmp    $0x1,%ecx
  80ed4c:	7f 1b                	jg     80ed69 <vprintfmt+0x338>
	else if (lflag)
  80ed4e:	85 c9                	test   %ecx,%ecx
  80ed50:	74 2c                	je     80ed7e <vprintfmt+0x34d>
		return va_arg(*ap, unsigned long);
  80ed52:	8b 45 14             	mov    0x14(%ebp),%eax
  80ed55:	8b 10                	mov    (%eax),%edx
  80ed57:	b9 00 00 00 00       	mov    $0x0,%ecx
  80ed5c:	8d 40 04             	lea    0x4(%eax),%eax
  80ed5f:	89 45 14             	mov    %eax,0x14(%ebp)
			base = 8;
  80ed62:	b8 08 00 00 00       	mov    $0x8,%eax
		return va_arg(*ap, unsigned long);
  80ed67:	eb 54                	jmp    80edbd <vprintfmt+0x38c>
		return va_arg(*ap, unsigned long long);
  80ed69:	8b 45 14             	mov    0x14(%ebp),%eax
  80ed6c:	8b 10                	mov    (%eax),%edx
  80ed6e:	8b 48 04             	mov    0x4(%eax),%ecx
  80ed71:	8d 40 08             	lea    0x8(%eax),%eax
  80ed74:	89 45 14             	mov    %eax,0x14(%ebp)
			base = 8;
  80ed77:	b8 08 00 00 00       	mov    $0x8,%eax
		return va_arg(*ap, unsigned long long);
  80ed7c:	eb 3f                	jmp    80edbd <vprintfmt+0x38c>
		return va_arg(*ap, unsigned int);
  80ed7e:	8b 45 14             	mov    0x14(%ebp),%eax
  80ed81:	8b 10                	mov    (%eax),%edx
  80ed83:	b9 00 00 00 00       	mov    $0x0,%ecx
  80ed88:	8d 40 04             	lea    0x4(%eax),%eax
  80ed8b:	89 45 14             	mov    %eax,0x14(%ebp)
			base = 8;
  80ed8e:	b8 08 00 00 00       	mov    $0x8,%eax
		return va_arg(*ap, unsigned int);
  80ed93:	eb 28                	jmp    80edbd <vprintfmt+0x38c>
			putch('0', putdat);
  80ed95:	83 ec 08             	sub    $0x8,%esp
  80ed98:	53                   	push   %ebx
  80ed99:	6a 30                	push   $0x30
  80ed9b:	ff d6                	call   *%esi
			putch('x', putdat);
  80ed9d:	83 c4 08             	add    $0x8,%esp
  80eda0:	53                   	push   %ebx
  80eda1:	6a 78                	push   $0x78
  80eda3:	ff d6                	call   *%esi
			num = (unsigned long long)
  80eda5:	8b 45 14             	mov    0x14(%ebp),%eax
  80eda8:	8b 10                	mov    (%eax),%edx
  80edaa:	b9 00 00 00 00       	mov    $0x0,%ecx
			goto number;
  80edaf:	83 c4 10             	add    $0x10,%esp
				(uintptr_t) va_arg(ap, void *);
  80edb2:	8d 40 04             	lea    0x4(%eax),%eax
  80edb5:	89 45 14             	mov    %eax,0x14(%ebp)
			base = 16;
  80edb8:	b8 10 00 00 00       	mov    $0x10,%eax
			printnum(putch, putdat, num, base, width, padc);
  80edbd:	83 ec 0c             	sub    $0xc,%esp
  80edc0:	0f be 7d d3          	movsbl -0x2d(%ebp),%edi
  80edc4:	57                   	push   %edi
  80edc5:	ff 75 e0             	pushl  -0x20(%ebp)
  80edc8:	50                   	push   %eax
  80edc9:	51                   	push   %ecx
  80edca:	52                   	push   %edx
  80edcb:	89 da                	mov    %ebx,%edx
  80edcd:	89 f0                	mov    %esi,%eax
  80edcf:	e8 72 fb ff ff       	call   80e946 <printnum>
			break;
  80edd4:	83 c4 20             	add    $0x20,%esp
			if ((p = va_arg(ap, char *)) == NULL)
  80edd7:	8b 7d e4             	mov    -0x1c(%ebp),%edi
		while ((ch = *(unsigned char *) fmt++) != '%') {
  80edda:	83 c7 01             	add    $0x1,%edi
  80eddd:	0f b6 47 ff          	movzbl -0x1(%edi),%eax
  80ede1:	83 f8 25             	cmp    $0x25,%eax
  80ede4:	0f 84 62 fc ff ff    	je     80ea4c <vprintfmt+0x1b>
			if (ch == '\0')
  80edea:	85 c0                	test   %eax,%eax
  80edec:	0f 84 8b 00 00 00    	je     80ee7d <vprintfmt+0x44c>
			putch(ch, putdat);
  80edf2:	83 ec 08             	sub    $0x8,%esp
  80edf5:	53                   	push   %ebx
  80edf6:	50                   	push   %eax
  80edf7:	ff d6                	call   *%esi
  80edf9:	83 c4 10             	add    $0x10,%esp
  80edfc:	eb dc                	jmp    80edda <vprintfmt+0x3a9>
	if (lflag >= 2)
  80edfe:	83 f9 01             	cmp    $0x1,%ecx
  80ee01:	7f 1b                	jg     80ee1e <vprintfmt+0x3ed>
	else if (lflag)
  80ee03:	85 c9                	test   %ecx,%ecx
  80ee05:	74 2c                	je     80ee33 <vprintfmt+0x402>
		return va_arg(*ap, unsigned long);
  80ee07:	8b 45 14             	mov    0x14(%ebp),%eax
  80ee0a:	8b 10                	mov    (%eax),%edx
  80ee0c:	b9 00 00 00 00       	mov    $0x0,%ecx
  80ee11:	8d 40 04             	lea    0x4(%eax),%eax
  80ee14:	89 45 14             	mov    %eax,0x14(%ebp)
			base = 16;
  80ee17:	b8 10 00 00 00       	mov    $0x10,%eax
		return va_arg(*ap, unsigned long);
  80ee1c:	eb 9f                	jmp    80edbd <vprintfmt+0x38c>
		return va_arg(*ap, unsigned long long);
  80ee1e:	8b 45 14             	mov    0x14(%ebp),%eax
  80ee21:	8b 10                	mov    (%eax),%edx
  80ee23:	8b 48 04             	mov    0x4(%eax),%ecx
  80ee26:	8d 40 08             	lea    0x8(%eax),%eax
  80ee29:	89 45 14             	mov    %eax,0x14(%ebp)
			base = 16;
  80ee2c:	b8 10 00 00 00       	mov    $0x10,%eax
		return va_arg(*ap, unsigned long long);
  80ee31:	eb 8a                	jmp    80edbd <vprintfmt+0x38c>
		return va_arg(*ap, unsigned int);
  80ee33:	8b 45 14             	mov    0x14(%ebp),%eax
  80ee36:	8b 10                	mov    (%eax),%edx
  80ee38:	b9 00 00 00 00       	mov    $0x0,%ecx
  80ee3d:	8d 40 04             	lea    0x4(%eax),%eax
  80ee40:	89 45 14             	mov    %eax,0x14(%ebp)
			base = 16;
  80ee43:	b8 10 00 00 00       	mov    $0x10,%eax
		return va_arg(*ap, unsigned int);
  80ee48:	e9 70 ff ff ff       	jmp    80edbd <vprintfmt+0x38c>
			putch(ch, putdat);
  80ee4d:	83 ec 08             	sub    $0x8,%esp
  80ee50:	53                   	push   %ebx
  80ee51:	6a 25                	push   $0x25
  80ee53:	ff d6                	call   *%esi
			break;
  80ee55:	83 c4 10             	add    $0x10,%esp
  80ee58:	e9 7a ff ff ff       	jmp    80edd7 <vprintfmt+0x3a6>
			putch('%', putdat);
  80ee5d:	83 ec 08             	sub    $0x8,%esp
  80ee60:	53                   	push   %ebx
  80ee61:	6a 25                	push   $0x25
  80ee63:	ff d6                	call   *%esi
			for (fmt--; fmt[-1] != '%'; fmt--)
  80ee65:	83 c4 10             	add    $0x10,%esp
  80ee68:	89 f8                	mov    %edi,%eax
  80ee6a:	80 78 ff 25          	cmpb   $0x25,-0x1(%eax)
  80ee6e:	74 05                	je     80ee75 <vprintfmt+0x444>
  80ee70:	83 e8 01             	sub    $0x1,%eax
  80ee73:	eb f5                	jmp    80ee6a <vprintfmt+0x439>
  80ee75:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80ee78:	e9 5a ff ff ff       	jmp    80edd7 <vprintfmt+0x3a6>
}
  80ee7d:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80ee80:	5b                   	pop    %ebx
  80ee81:	5e                   	pop    %esi
  80ee82:	5f                   	pop    %edi
  80ee83:	5d                   	pop    %ebp
  80ee84:	c3                   	ret    

0080ee85 <vsnprintf>:

int
vsnprintf(char *buf, int n, const char *fmt, va_list ap)
{
  80ee85:	f3 0f 1e fb          	endbr32 
  80ee89:	55                   	push   %ebp
  80ee8a:	89 e5                	mov    %esp,%ebp
  80ee8c:	83 ec 18             	sub    $0x18,%esp
  80ee8f:	8b 45 08             	mov    0x8(%ebp),%eax
  80ee92:	8b 55 0c             	mov    0xc(%ebp),%edx
	struct sprintbuf b = {buf, buf+n-1, 0};
  80ee95:	89 45 ec             	mov    %eax,-0x14(%ebp)
  80ee98:	8d 4c 10 ff          	lea    -0x1(%eax,%edx,1),%ecx
  80ee9c:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  80ee9f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	if (buf == NULL || n < 1)
  80eea6:	85 c0                	test   %eax,%eax
  80eea8:	74 26                	je     80eed0 <vsnprintf+0x4b>
  80eeaa:	85 d2                	test   %edx,%edx
  80eeac:	7e 22                	jle    80eed0 <vsnprintf+0x4b>
		return -E_INVAL;

	// print the string to the buffer
	vprintfmt((void*)sprintputch, &b, fmt, ap);
  80eeae:	ff 75 14             	pushl  0x14(%ebp)
  80eeb1:	ff 75 10             	pushl  0x10(%ebp)
  80eeb4:	8d 45 ec             	lea    -0x14(%ebp),%eax
  80eeb7:	50                   	push   %eax
  80eeb8:	68 ef e9 80 00       	push   $0x80e9ef
  80eebd:	e8 6f fb ff ff       	call   80ea31 <vprintfmt>

	// null terminate the buffer
	*b.buf = '\0';
  80eec2:	8b 45 ec             	mov    -0x14(%ebp),%eax
  80eec5:	c6 00 00             	movb   $0x0,(%eax)

	return b.cnt;
  80eec8:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80eecb:	83 c4 10             	add    $0x10,%esp
}
  80eece:	c9                   	leave  
  80eecf:	c3                   	ret    
		return -E_INVAL;
  80eed0:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  80eed5:	eb f7                	jmp    80eece <vsnprintf+0x49>

0080eed7 <snprintf>:

int
snprintf(char *buf, int n, const char *fmt, ...)
{
  80eed7:	f3 0f 1e fb          	endbr32 
  80eedb:	55                   	push   %ebp
  80eedc:	89 e5                	mov    %esp,%ebp
  80eede:	83 ec 08             	sub    $0x8,%esp
	va_list ap;
	int rc;

	va_start(ap, fmt);
  80eee1:	8d 45 14             	lea    0x14(%ebp),%eax
	rc = vsnprintf(buf, n, fmt, ap);
  80eee4:	50                   	push   %eax
  80eee5:	ff 75 10             	pushl  0x10(%ebp)
  80eee8:	ff 75 0c             	pushl  0xc(%ebp)
  80eeeb:	ff 75 08             	pushl  0x8(%ebp)
  80eeee:	e8 92 ff ff ff       	call   80ee85 <vsnprintf>
	va_end(ap);

	return rc;
}
  80eef3:	c9                   	leave  
  80eef4:	c3                   	ret    

0080eef5 <strlen>:
// Primespipe runs 3x faster this way.
#define ASM 1

int
strlen(const char *s)
{
  80eef5:	f3 0f 1e fb          	endbr32 
  80eef9:	55                   	push   %ebp
  80eefa:	89 e5                	mov    %esp,%ebp
  80eefc:	8b 55 08             	mov    0x8(%ebp),%edx
	int n;

	for (n = 0; *s != '\0'; s++)
  80eeff:	b8 00 00 00 00       	mov    $0x0,%eax
  80ef04:	80 3c 02 00          	cmpb   $0x0,(%edx,%eax,1)
  80ef08:	74 05                	je     80ef0f <strlen+0x1a>
		n++;
  80ef0a:	83 c0 01             	add    $0x1,%eax
  80ef0d:	eb f5                	jmp    80ef04 <strlen+0xf>
	return n;
}
  80ef0f:	5d                   	pop    %ebp
  80ef10:	c3                   	ret    

0080ef11 <strnlen>:

int
strnlen(const char *s, size_t size)
{
  80ef11:	f3 0f 1e fb          	endbr32 
  80ef15:	55                   	push   %ebp
  80ef16:	89 e5                	mov    %esp,%ebp
  80ef18:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80ef1b:	8b 55 0c             	mov    0xc(%ebp),%edx
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
  80ef1e:	b8 00 00 00 00       	mov    $0x0,%eax
  80ef23:	39 d0                	cmp    %edx,%eax
  80ef25:	74 0d                	je     80ef34 <strnlen+0x23>
  80ef27:	80 3c 01 00          	cmpb   $0x0,(%ecx,%eax,1)
  80ef2b:	74 05                	je     80ef32 <strnlen+0x21>
		n++;
  80ef2d:	83 c0 01             	add    $0x1,%eax
  80ef30:	eb f1                	jmp    80ef23 <strnlen+0x12>
  80ef32:	89 c2                	mov    %eax,%edx
	return n;
}
  80ef34:	89 d0                	mov    %edx,%eax
  80ef36:	5d                   	pop    %ebp
  80ef37:	c3                   	ret    

0080ef38 <strcpy>:

char *
strcpy(char *dst, const char *src)
{
  80ef38:	f3 0f 1e fb          	endbr32 
  80ef3c:	55                   	push   %ebp
  80ef3d:	89 e5                	mov    %esp,%ebp
  80ef3f:	53                   	push   %ebx
  80ef40:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80ef43:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	char *ret;

	ret = dst;
	while ((*dst++ = *src++) != '\0')
  80ef46:	b8 00 00 00 00       	mov    $0x0,%eax
  80ef4b:	0f b6 14 03          	movzbl (%ebx,%eax,1),%edx
  80ef4f:	88 14 01             	mov    %dl,(%ecx,%eax,1)
  80ef52:	83 c0 01             	add    $0x1,%eax
  80ef55:	84 d2                	test   %dl,%dl
  80ef57:	75 f2                	jne    80ef4b <strcpy+0x13>
		/* do nothing */;
	return ret;
}
  80ef59:	89 c8                	mov    %ecx,%eax
  80ef5b:	5b                   	pop    %ebx
  80ef5c:	5d                   	pop    %ebp
  80ef5d:	c3                   	ret    

0080ef5e <strcat>:

char *
strcat(char *dst, const char *src)
{
  80ef5e:	f3 0f 1e fb          	endbr32 
  80ef62:	55                   	push   %ebp
  80ef63:	89 e5                	mov    %esp,%ebp
  80ef65:	53                   	push   %ebx
  80ef66:	83 ec 10             	sub    $0x10,%esp
  80ef69:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int len = strlen(dst);
  80ef6c:	53                   	push   %ebx
  80ef6d:	e8 83 ff ff ff       	call   80eef5 <strlen>
  80ef72:	83 c4 08             	add    $0x8,%esp
	strcpy(dst + len, src);
  80ef75:	ff 75 0c             	pushl  0xc(%ebp)
  80ef78:	01 d8                	add    %ebx,%eax
  80ef7a:	50                   	push   %eax
  80ef7b:	e8 b8 ff ff ff       	call   80ef38 <strcpy>
	return dst;
}
  80ef80:	89 d8                	mov    %ebx,%eax
  80ef82:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80ef85:	c9                   	leave  
  80ef86:	c3                   	ret    

0080ef87 <strncpy>:

char *
strncpy(char *dst, const char *src, size_t size) {
  80ef87:	f3 0f 1e fb          	endbr32 
  80ef8b:	55                   	push   %ebp
  80ef8c:	89 e5                	mov    %esp,%ebp
  80ef8e:	56                   	push   %esi
  80ef8f:	53                   	push   %ebx
  80ef90:	8b 75 08             	mov    0x8(%ebp),%esi
  80ef93:	8b 55 0c             	mov    0xc(%ebp),%edx
  80ef96:	89 f3                	mov    %esi,%ebx
  80ef98:	03 5d 10             	add    0x10(%ebp),%ebx
	size_t i;
	char *ret;

	ret = dst;
	for (i = 0; i < size; i++) {
  80ef9b:	89 f0                	mov    %esi,%eax
  80ef9d:	39 d8                	cmp    %ebx,%eax
  80ef9f:	74 11                	je     80efb2 <strncpy+0x2b>
		*dst++ = *src;
  80efa1:	83 c0 01             	add    $0x1,%eax
  80efa4:	0f b6 0a             	movzbl (%edx),%ecx
  80efa7:	88 48 ff             	mov    %cl,-0x1(%eax)
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
			src++;
  80efaa:	80 f9 01             	cmp    $0x1,%cl
  80efad:	83 da ff             	sbb    $0xffffffff,%edx
  80efb0:	eb eb                	jmp    80ef9d <strncpy+0x16>
	}
	return ret;
}
  80efb2:	89 f0                	mov    %esi,%eax
  80efb4:	5b                   	pop    %ebx
  80efb5:	5e                   	pop    %esi
  80efb6:	5d                   	pop    %ebp
  80efb7:	c3                   	ret    

0080efb8 <strlcpy>:

size_t
strlcpy(char *dst, const char *src, size_t size)
{
  80efb8:	f3 0f 1e fb          	endbr32 
  80efbc:	55                   	push   %ebp
  80efbd:	89 e5                	mov    %esp,%ebp
  80efbf:	56                   	push   %esi
  80efc0:	53                   	push   %ebx
  80efc1:	8b 75 08             	mov    0x8(%ebp),%esi
  80efc4:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80efc7:	8b 55 10             	mov    0x10(%ebp),%edx
  80efca:	89 f0                	mov    %esi,%eax
	char *dst_in;

	dst_in = dst;
	if (size > 0) {
  80efcc:	85 d2                	test   %edx,%edx
  80efce:	74 21                	je     80eff1 <strlcpy+0x39>
  80efd0:	8d 44 16 ff          	lea    -0x1(%esi,%edx,1),%eax
  80efd4:	89 f2                	mov    %esi,%edx
		while (--size > 0 && *src != '\0')
  80efd6:	39 c2                	cmp    %eax,%edx
  80efd8:	74 14                	je     80efee <strlcpy+0x36>
  80efda:	0f b6 19             	movzbl (%ecx),%ebx
  80efdd:	84 db                	test   %bl,%bl
  80efdf:	74 0b                	je     80efec <strlcpy+0x34>
			*dst++ = *src++;
  80efe1:	83 c1 01             	add    $0x1,%ecx
  80efe4:	83 c2 01             	add    $0x1,%edx
  80efe7:	88 5a ff             	mov    %bl,-0x1(%edx)
  80efea:	eb ea                	jmp    80efd6 <strlcpy+0x1e>
  80efec:	89 d0                	mov    %edx,%eax
		*dst = '\0';
  80efee:	c6 00 00             	movb   $0x0,(%eax)
	}
	return dst - dst_in;
  80eff1:	29 f0                	sub    %esi,%eax
}
  80eff3:	5b                   	pop    %ebx
  80eff4:	5e                   	pop    %esi
  80eff5:	5d                   	pop    %ebp
  80eff6:	c3                   	ret    

0080eff7 <strcmp>:

int
strcmp(const char *p, const char *q)
{
  80eff7:	f3 0f 1e fb          	endbr32 
  80effb:	55                   	push   %ebp
  80effc:	89 e5                	mov    %esp,%ebp
  80effe:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80f001:	8b 55 0c             	mov    0xc(%ebp),%edx
	while (*p && *p == *q)
  80f004:	0f b6 01             	movzbl (%ecx),%eax
  80f007:	84 c0                	test   %al,%al
  80f009:	74 0c                	je     80f017 <strcmp+0x20>
  80f00b:	3a 02                	cmp    (%edx),%al
  80f00d:	75 08                	jne    80f017 <strcmp+0x20>
		p++, q++;
  80f00f:	83 c1 01             	add    $0x1,%ecx
  80f012:	83 c2 01             	add    $0x1,%edx
  80f015:	eb ed                	jmp    80f004 <strcmp+0xd>
	return (int) ((unsigned char) *p - (unsigned char) *q);
  80f017:	0f b6 c0             	movzbl %al,%eax
  80f01a:	0f b6 12             	movzbl (%edx),%edx
  80f01d:	29 d0                	sub    %edx,%eax
}
  80f01f:	5d                   	pop    %ebp
  80f020:	c3                   	ret    

0080f021 <strncmp>:

int
strncmp(const char *p, const char *q, size_t n)
{
  80f021:	f3 0f 1e fb          	endbr32 
  80f025:	55                   	push   %ebp
  80f026:	89 e5                	mov    %esp,%ebp
  80f028:	53                   	push   %ebx
  80f029:	8b 45 08             	mov    0x8(%ebp),%eax
  80f02c:	8b 55 0c             	mov    0xc(%ebp),%edx
  80f02f:	89 c3                	mov    %eax,%ebx
  80f031:	03 5d 10             	add    0x10(%ebp),%ebx
	while (n > 0 && *p && *p == *q)
  80f034:	eb 06                	jmp    80f03c <strncmp+0x1b>
		n--, p++, q++;
  80f036:	83 c0 01             	add    $0x1,%eax
  80f039:	83 c2 01             	add    $0x1,%edx
	while (n > 0 && *p && *p == *q)
  80f03c:	39 d8                	cmp    %ebx,%eax
  80f03e:	74 16                	je     80f056 <strncmp+0x35>
  80f040:	0f b6 08             	movzbl (%eax),%ecx
  80f043:	84 c9                	test   %cl,%cl
  80f045:	74 04                	je     80f04b <strncmp+0x2a>
  80f047:	3a 0a                	cmp    (%edx),%cl
  80f049:	74 eb                	je     80f036 <strncmp+0x15>
	if (n == 0)
		return 0;
	else
		return (int) ((unsigned char) *p - (unsigned char) *q);
  80f04b:	0f b6 00             	movzbl (%eax),%eax
  80f04e:	0f b6 12             	movzbl (%edx),%edx
  80f051:	29 d0                	sub    %edx,%eax
}
  80f053:	5b                   	pop    %ebx
  80f054:	5d                   	pop    %ebp
  80f055:	c3                   	ret    
		return 0;
  80f056:	b8 00 00 00 00       	mov    $0x0,%eax
  80f05b:	eb f6                	jmp    80f053 <strncmp+0x32>

0080f05d <strchr>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
  80f05d:	f3 0f 1e fb          	endbr32 
  80f061:	55                   	push   %ebp
  80f062:	89 e5                	mov    %esp,%ebp
  80f064:	8b 45 08             	mov    0x8(%ebp),%eax
  80f067:	0f b6 4d 0c          	movzbl 0xc(%ebp),%ecx
	for (; *s; s++)
  80f06b:	0f b6 10             	movzbl (%eax),%edx
  80f06e:	84 d2                	test   %dl,%dl
  80f070:	74 09                	je     80f07b <strchr+0x1e>
		if (*s == c)
  80f072:	38 ca                	cmp    %cl,%dl
  80f074:	74 0a                	je     80f080 <strchr+0x23>
	for (; *s; s++)
  80f076:	83 c0 01             	add    $0x1,%eax
  80f079:	eb f0                	jmp    80f06b <strchr+0xe>
			return (char *) s;
	return 0;
  80f07b:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80f080:	5d                   	pop    %ebp
  80f081:	c3                   	ret    

0080f082 <strfind>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
  80f082:	f3 0f 1e fb          	endbr32 
  80f086:	55                   	push   %ebp
  80f087:	89 e5                	mov    %esp,%ebp
  80f089:	8b 45 08             	mov    0x8(%ebp),%eax
  80f08c:	0f b6 4d 0c          	movzbl 0xc(%ebp),%ecx
	for (; *s; s++)
  80f090:	0f b6 10             	movzbl (%eax),%edx
		if (*s == c)
  80f093:	38 ca                	cmp    %cl,%dl
  80f095:	74 09                	je     80f0a0 <strfind+0x1e>
  80f097:	84 d2                	test   %dl,%dl
  80f099:	74 05                	je     80f0a0 <strfind+0x1e>
	for (; *s; s++)
  80f09b:	83 c0 01             	add    $0x1,%eax
  80f09e:	eb f0                	jmp    80f090 <strfind+0xe>
			break;
	return (char *) s;
}
  80f0a0:	5d                   	pop    %ebp
  80f0a1:	c3                   	ret    

0080f0a2 <memset>:

#if ASM
void *
memset(void *v, int c, size_t n)
{
  80f0a2:	f3 0f 1e fb          	endbr32 
  80f0a6:	55                   	push   %ebp
  80f0a7:	89 e5                	mov    %esp,%ebp
  80f0a9:	57                   	push   %edi
  80f0aa:	56                   	push   %esi
  80f0ab:	53                   	push   %ebx
  80f0ac:	8b 7d 08             	mov    0x8(%ebp),%edi
  80f0af:	8b 4d 10             	mov    0x10(%ebp),%ecx
	char *p;

	if (n == 0)
  80f0b2:	85 c9                	test   %ecx,%ecx
  80f0b4:	74 31                	je     80f0e7 <memset+0x45>
		return v;
	if ((int)v%4 == 0 && n%4 == 0) {
  80f0b6:	89 f8                	mov    %edi,%eax
  80f0b8:	09 c8                	or     %ecx,%eax
  80f0ba:	a8 03                	test   $0x3,%al
  80f0bc:	75 23                	jne    80f0e1 <memset+0x3f>
		c &= 0xFF;
  80f0be:	0f b6 55 0c          	movzbl 0xc(%ebp),%edx
		c = (c<<24)|(c<<16)|(c<<8)|c;
  80f0c2:	89 d3                	mov    %edx,%ebx
  80f0c4:	c1 e3 08             	shl    $0x8,%ebx
  80f0c7:	89 d0                	mov    %edx,%eax
  80f0c9:	c1 e0 18             	shl    $0x18,%eax
  80f0cc:	89 d6                	mov    %edx,%esi
  80f0ce:	c1 e6 10             	shl    $0x10,%esi
  80f0d1:	09 f0                	or     %esi,%eax
  80f0d3:	09 c2                	or     %eax,%edx
  80f0d5:	09 da                	or     %ebx,%edx
		asm volatile("cld; rep stosl\n"
			:: "D" (v), "a" (c), "c" (n/4)
  80f0d7:	c1 e9 02             	shr    $0x2,%ecx
		asm volatile("cld; rep stosl\n"
  80f0da:	89 d0                	mov    %edx,%eax
  80f0dc:	fc                   	cld    
  80f0dd:	f3 ab                	rep stos %eax,%es:(%edi)
  80f0df:	eb 06                	jmp    80f0e7 <memset+0x45>
			: "cc", "memory");
	} else
		asm volatile("cld; rep stosb\n"
  80f0e1:	8b 45 0c             	mov    0xc(%ebp),%eax
  80f0e4:	fc                   	cld    
  80f0e5:	f3 aa                	rep stos %al,%es:(%edi)
			:: "D" (v), "a" (c), "c" (n)
			: "cc", "memory");
	return v;
}
  80f0e7:	89 f8                	mov    %edi,%eax
  80f0e9:	5b                   	pop    %ebx
  80f0ea:	5e                   	pop    %esi
  80f0eb:	5f                   	pop    %edi
  80f0ec:	5d                   	pop    %ebp
  80f0ed:	c3                   	ret    

0080f0ee <memmove>:

void *
memmove(void *dst, const void *src, size_t n)
{
  80f0ee:	f3 0f 1e fb          	endbr32 
  80f0f2:	55                   	push   %ebp
  80f0f3:	89 e5                	mov    %esp,%ebp
  80f0f5:	57                   	push   %edi
  80f0f6:	56                   	push   %esi
  80f0f7:	8b 45 08             	mov    0x8(%ebp),%eax
  80f0fa:	8b 75 0c             	mov    0xc(%ebp),%esi
  80f0fd:	8b 4d 10             	mov    0x10(%ebp),%ecx
	const char *s;
	char *d;

	s = src;
	d = dst;
	if (s < d && s + n > d) {
  80f100:	39 c6                	cmp    %eax,%esi
  80f102:	73 32                	jae    80f136 <memmove+0x48>
  80f104:	8d 14 0e             	lea    (%esi,%ecx,1),%edx
  80f107:	39 c2                	cmp    %eax,%edx
  80f109:	76 2b                	jbe    80f136 <memmove+0x48>
		s += n;
		d += n;
  80f10b:	8d 3c 08             	lea    (%eax,%ecx,1),%edi
		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
  80f10e:	89 fe                	mov    %edi,%esi
  80f110:	09 ce                	or     %ecx,%esi
  80f112:	09 d6                	or     %edx,%esi
  80f114:	f7 c6 03 00 00 00    	test   $0x3,%esi
  80f11a:	75 0e                	jne    80f12a <memmove+0x3c>
			asm volatile("std; rep movsl\n"
				:: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
  80f11c:	83 ef 04             	sub    $0x4,%edi
  80f11f:	8d 72 fc             	lea    -0x4(%edx),%esi
  80f122:	c1 e9 02             	shr    $0x2,%ecx
			asm volatile("std; rep movsl\n"
  80f125:	fd                   	std    
  80f126:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
  80f128:	eb 09                	jmp    80f133 <memmove+0x45>
		else
			asm volatile("std; rep movsb\n"
				:: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
  80f12a:	83 ef 01             	sub    $0x1,%edi
  80f12d:	8d 72 ff             	lea    -0x1(%edx),%esi
			asm volatile("std; rep movsb\n"
  80f130:	fd                   	std    
  80f131:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
		// Some versions of GCC rely on DF being clear
		asm volatile("cld" ::: "cc");
  80f133:	fc                   	cld    
  80f134:	eb 1a                	jmp    80f150 <memmove+0x62>
	} else {
		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
  80f136:	89 c2                	mov    %eax,%edx
  80f138:	09 ca                	or     %ecx,%edx
  80f13a:	09 f2                	or     %esi,%edx
  80f13c:	f6 c2 03             	test   $0x3,%dl
  80f13f:	75 0a                	jne    80f14b <memmove+0x5d>
			asm volatile("cld; rep movsl\n"
				:: "D" (d), "S" (s), "c" (n/4) : "cc", "memory");
  80f141:	c1 e9 02             	shr    $0x2,%ecx
			asm volatile("cld; rep movsl\n"
  80f144:	89 c7                	mov    %eax,%edi
  80f146:	fc                   	cld    
  80f147:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
  80f149:	eb 05                	jmp    80f150 <memmove+0x62>
		else
			asm volatile("cld; rep movsb\n"
  80f14b:	89 c7                	mov    %eax,%edi
  80f14d:	fc                   	cld    
  80f14e:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
				:: "D" (d), "S" (s), "c" (n) : "cc", "memory");
	}
	return dst;
}
  80f150:	5e                   	pop    %esi
  80f151:	5f                   	pop    %edi
  80f152:	5d                   	pop    %ebp
  80f153:	c3                   	ret    

0080f154 <memcpy>:
}
#endif

void *
memcpy(void *dst, const void *src, size_t n)
{
  80f154:	f3 0f 1e fb          	endbr32 
  80f158:	55                   	push   %ebp
  80f159:	89 e5                	mov    %esp,%ebp
  80f15b:	83 ec 0c             	sub    $0xc,%esp
	return memmove(dst, src, n);
  80f15e:	ff 75 10             	pushl  0x10(%ebp)
  80f161:	ff 75 0c             	pushl  0xc(%ebp)
  80f164:	ff 75 08             	pushl  0x8(%ebp)
  80f167:	e8 82 ff ff ff       	call   80f0ee <memmove>
}
  80f16c:	c9                   	leave  
  80f16d:	c3                   	ret    

0080f16e <memcmp>:

int
memcmp(const void *v1, const void *v2, size_t n)
{
  80f16e:	f3 0f 1e fb          	endbr32 
  80f172:	55                   	push   %ebp
  80f173:	89 e5                	mov    %esp,%ebp
  80f175:	56                   	push   %esi
  80f176:	53                   	push   %ebx
  80f177:	8b 45 08             	mov    0x8(%ebp),%eax
  80f17a:	8b 55 0c             	mov    0xc(%ebp),%edx
  80f17d:	89 c6                	mov    %eax,%esi
  80f17f:	03 75 10             	add    0x10(%ebp),%esi
	const uint8_t *s1 = (const uint8_t *) v1;
	const uint8_t *s2 = (const uint8_t *) v2;

	while (n-- > 0) {
  80f182:	39 f0                	cmp    %esi,%eax
  80f184:	74 1c                	je     80f1a2 <memcmp+0x34>
		if (*s1 != *s2)
  80f186:	0f b6 08             	movzbl (%eax),%ecx
  80f189:	0f b6 1a             	movzbl (%edx),%ebx
  80f18c:	38 d9                	cmp    %bl,%cl
  80f18e:	75 08                	jne    80f198 <memcmp+0x2a>
			return (int) *s1 - (int) *s2;
		s1++, s2++;
  80f190:	83 c0 01             	add    $0x1,%eax
  80f193:	83 c2 01             	add    $0x1,%edx
  80f196:	eb ea                	jmp    80f182 <memcmp+0x14>
			return (int) *s1 - (int) *s2;
  80f198:	0f b6 c1             	movzbl %cl,%eax
  80f19b:	0f b6 db             	movzbl %bl,%ebx
  80f19e:	29 d8                	sub    %ebx,%eax
  80f1a0:	eb 05                	jmp    80f1a7 <memcmp+0x39>
	}

	return 0;
  80f1a2:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80f1a7:	5b                   	pop    %ebx
  80f1a8:	5e                   	pop    %esi
  80f1a9:	5d                   	pop    %ebp
  80f1aa:	c3                   	ret    

0080f1ab <memfind>:

void *
memfind(const void *s, int c, size_t n)
{
  80f1ab:	f3 0f 1e fb          	endbr32 
  80f1af:	55                   	push   %ebp
  80f1b0:	89 e5                	mov    %esp,%ebp
  80f1b2:	8b 45 08             	mov    0x8(%ebp),%eax
  80f1b5:	8b 4d 0c             	mov    0xc(%ebp),%ecx
	const void *ends = (const char *) s + n;
  80f1b8:	89 c2                	mov    %eax,%edx
  80f1ba:	03 55 10             	add    0x10(%ebp),%edx
	for (; s < ends; s++)
  80f1bd:	39 d0                	cmp    %edx,%eax
  80f1bf:	73 09                	jae    80f1ca <memfind+0x1f>
		if (*(const unsigned char *) s == (unsigned char) c)
  80f1c1:	38 08                	cmp    %cl,(%eax)
  80f1c3:	74 05                	je     80f1ca <memfind+0x1f>
	for (; s < ends; s++)
  80f1c5:	83 c0 01             	add    $0x1,%eax
  80f1c8:	eb f3                	jmp    80f1bd <memfind+0x12>
			break;
	return (void *) s;
}
  80f1ca:	5d                   	pop    %ebp
  80f1cb:	c3                   	ret    

0080f1cc <strtol>:

long
strtol(const char *s, char **endptr, int base)
{
  80f1cc:	f3 0f 1e fb          	endbr32 
  80f1d0:	55                   	push   %ebp
  80f1d1:	89 e5                	mov    %esp,%ebp
  80f1d3:	57                   	push   %edi
  80f1d4:	56                   	push   %esi
  80f1d5:	53                   	push   %ebx
  80f1d6:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80f1d9:	8b 5d 10             	mov    0x10(%ebp),%ebx
	int neg = 0;
	long val = 0;

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
  80f1dc:	eb 03                	jmp    80f1e1 <strtol+0x15>
		s++;
  80f1de:	83 c1 01             	add    $0x1,%ecx
	while (*s == ' ' || *s == '\t')
  80f1e1:	0f b6 01             	movzbl (%ecx),%eax
  80f1e4:	3c 20                	cmp    $0x20,%al
  80f1e6:	74 f6                	je     80f1de <strtol+0x12>
  80f1e8:	3c 09                	cmp    $0x9,%al
  80f1ea:	74 f2                	je     80f1de <strtol+0x12>

	// plus/minus sign
	if (*s == '+')
  80f1ec:	3c 2b                	cmp    $0x2b,%al
  80f1ee:	74 2a                	je     80f21a <strtol+0x4e>
	int neg = 0;
  80f1f0:	bf 00 00 00 00       	mov    $0x0,%edi
		s++;
	else if (*s == '-')
  80f1f5:	3c 2d                	cmp    $0x2d,%al
  80f1f7:	74 2b                	je     80f224 <strtol+0x58>
		s++, neg = 1;

	// hex or octal base prefix
	if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
  80f1f9:	f7 c3 ef ff ff ff    	test   $0xffffffef,%ebx
  80f1ff:	75 0f                	jne    80f210 <strtol+0x44>
  80f201:	80 39 30             	cmpb   $0x30,(%ecx)
  80f204:	74 28                	je     80f22e <strtol+0x62>
		s += 2, base = 16;
	else if (base == 0 && s[0] == '0')
		s++, base = 8;
	else if (base == 0)
		base = 10;
  80f206:	85 db                	test   %ebx,%ebx
  80f208:	b8 0a 00 00 00       	mov    $0xa,%eax
  80f20d:	0f 44 d8             	cmove  %eax,%ebx
  80f210:	b8 00 00 00 00       	mov    $0x0,%eax
  80f215:	89 5d 10             	mov    %ebx,0x10(%ebp)
  80f218:	eb 46                	jmp    80f260 <strtol+0x94>
		s++;
  80f21a:	83 c1 01             	add    $0x1,%ecx
	int neg = 0;
  80f21d:	bf 00 00 00 00       	mov    $0x0,%edi
  80f222:	eb d5                	jmp    80f1f9 <strtol+0x2d>
		s++, neg = 1;
  80f224:	83 c1 01             	add    $0x1,%ecx
  80f227:	bf 01 00 00 00       	mov    $0x1,%edi
  80f22c:	eb cb                	jmp    80f1f9 <strtol+0x2d>
	if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
  80f22e:	80 79 01 78          	cmpb   $0x78,0x1(%ecx)
  80f232:	74 0e                	je     80f242 <strtol+0x76>
	else if (base == 0 && s[0] == '0')
  80f234:	85 db                	test   %ebx,%ebx
  80f236:	75 d8                	jne    80f210 <strtol+0x44>
		s++, base = 8;
  80f238:	83 c1 01             	add    $0x1,%ecx
  80f23b:	bb 08 00 00 00       	mov    $0x8,%ebx
  80f240:	eb ce                	jmp    80f210 <strtol+0x44>
		s += 2, base = 16;
  80f242:	83 c1 02             	add    $0x2,%ecx
  80f245:	bb 10 00 00 00       	mov    $0x10,%ebx
  80f24a:	eb c4                	jmp    80f210 <strtol+0x44>
	// digits
	while (1) {
		int dig;

		if (*s >= '0' && *s <= '9')
			dig = *s - '0';
  80f24c:	0f be d2             	movsbl %dl,%edx
  80f24f:	83 ea 30             	sub    $0x30,%edx
			dig = *s - 'a' + 10;
		else if (*s >= 'A' && *s <= 'Z')
			dig = *s - 'A' + 10;
		else
			break;
		if (dig >= base)
  80f252:	3b 55 10             	cmp    0x10(%ebp),%edx
  80f255:	7d 3a                	jge    80f291 <strtol+0xc5>
			break;
		s++, val = (val * base) + dig;
  80f257:	83 c1 01             	add    $0x1,%ecx
  80f25a:	0f af 45 10          	imul   0x10(%ebp),%eax
  80f25e:	01 d0                	add    %edx,%eax
		if (*s >= '0' && *s <= '9')
  80f260:	0f b6 11             	movzbl (%ecx),%edx
  80f263:	8d 72 d0             	lea    -0x30(%edx),%esi
  80f266:	89 f3                	mov    %esi,%ebx
  80f268:	80 fb 09             	cmp    $0x9,%bl
  80f26b:	76 df                	jbe    80f24c <strtol+0x80>
		else if (*s >= 'a' && *s <= 'z')
  80f26d:	8d 72 9f             	lea    -0x61(%edx),%esi
  80f270:	89 f3                	mov    %esi,%ebx
  80f272:	80 fb 19             	cmp    $0x19,%bl
  80f275:	77 08                	ja     80f27f <strtol+0xb3>
			dig = *s - 'a' + 10;
  80f277:	0f be d2             	movsbl %dl,%edx
  80f27a:	83 ea 57             	sub    $0x57,%edx
  80f27d:	eb d3                	jmp    80f252 <strtol+0x86>
		else if (*s >= 'A' && *s <= 'Z')
  80f27f:	8d 72 bf             	lea    -0x41(%edx),%esi
  80f282:	89 f3                	mov    %esi,%ebx
  80f284:	80 fb 19             	cmp    $0x19,%bl
  80f287:	77 08                	ja     80f291 <strtol+0xc5>
			dig = *s - 'A' + 10;
  80f289:	0f be d2             	movsbl %dl,%edx
  80f28c:	83 ea 37             	sub    $0x37,%edx
  80f28f:	eb c1                	jmp    80f252 <strtol+0x86>
		// we don't properly detect overflow!
	}

	if (endptr)
  80f291:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  80f295:	74 05                	je     80f29c <strtol+0xd0>
		*endptr = (char *) s;
  80f297:	8b 75 0c             	mov    0xc(%ebp),%esi
  80f29a:	89 0e                	mov    %ecx,(%esi)
	return (neg ? -val : val);
  80f29c:	89 c2                	mov    %eax,%edx
  80f29e:	f7 da                	neg    %edx
  80f2a0:	85 ff                	test   %edi,%edi
  80f2a2:	0f 45 c2             	cmovne %edx,%eax
}
  80f2a5:	5b                   	pop    %ebx
  80f2a6:	5e                   	pop    %esi
  80f2a7:	5f                   	pop    %edi
  80f2a8:	5d                   	pop    %ebp
  80f2a9:	c3                   	ret    

0080f2aa <sys_cputs>:
	return ret;
}

void
sys_cputs(const char *s, size_t len)
{
  80f2aa:	f3 0f 1e fb          	endbr32 
  80f2ae:	55                   	push   %ebp
  80f2af:	89 e5                	mov    %esp,%ebp
  80f2b1:	57                   	push   %edi
  80f2b2:	56                   	push   %esi
  80f2b3:	53                   	push   %ebx
	asm volatile("int %1\n"
  80f2b4:	b8 00 00 00 00       	mov    $0x0,%eax
  80f2b9:	8b 55 08             	mov    0x8(%ebp),%edx
  80f2bc:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f2bf:	89 c3                	mov    %eax,%ebx
  80f2c1:	89 c7                	mov    %eax,%edi
  80f2c3:	89 c6                	mov    %eax,%esi
  80f2c5:	cd 30                	int    $0x30
	syscall(SYS_cputs, 0, (uint32_t)s, len, 0, 0, 0);
}
  80f2c7:	5b                   	pop    %ebx
  80f2c8:	5e                   	pop    %esi
  80f2c9:	5f                   	pop    %edi
  80f2ca:	5d                   	pop    %ebp
  80f2cb:	c3                   	ret    

0080f2cc <sys_cgetc>:

int
sys_cgetc(void)
{
  80f2cc:	f3 0f 1e fb          	endbr32 
  80f2d0:	55                   	push   %ebp
  80f2d1:	89 e5                	mov    %esp,%ebp
  80f2d3:	57                   	push   %edi
  80f2d4:	56                   	push   %esi
  80f2d5:	53                   	push   %ebx
	asm volatile("int %1\n"
  80f2d6:	ba 00 00 00 00       	mov    $0x0,%edx
  80f2db:	b8 01 00 00 00       	mov    $0x1,%eax
  80f2e0:	89 d1                	mov    %edx,%ecx
  80f2e2:	89 d3                	mov    %edx,%ebx
  80f2e4:	89 d7                	mov    %edx,%edi
  80f2e6:	89 d6                	mov    %edx,%esi
  80f2e8:	cd 30                	int    $0x30
	return syscall(SYS_cgetc, 0, 0, 0, 0, 0, 0);
}
  80f2ea:	5b                   	pop    %ebx
  80f2eb:	5e                   	pop    %esi
  80f2ec:	5f                   	pop    %edi
  80f2ed:	5d                   	pop    %ebp
  80f2ee:	c3                   	ret    

0080f2ef <sys_env_destroy>:

int
sys_env_destroy(envid_t envid)
{
  80f2ef:	f3 0f 1e fb          	endbr32 
  80f2f3:	55                   	push   %ebp
  80f2f4:	89 e5                	mov    %esp,%ebp
  80f2f6:	57                   	push   %edi
  80f2f7:	56                   	push   %esi
  80f2f8:	53                   	push   %ebx
  80f2f9:	83 ec 0c             	sub    $0xc,%esp
	asm volatile("int %1\n"
  80f2fc:	b9 00 00 00 00       	mov    $0x0,%ecx
  80f301:	8b 55 08             	mov    0x8(%ebp),%edx
  80f304:	b8 03 00 00 00       	mov    $0x3,%eax
  80f309:	89 cb                	mov    %ecx,%ebx
  80f30b:	89 cf                	mov    %ecx,%edi
  80f30d:	89 ce                	mov    %ecx,%esi
  80f30f:	cd 30                	int    $0x30
	if(check && ret > 0)
  80f311:	85 c0                	test   %eax,%eax
  80f313:	7f 08                	jg     80f31d <sys_env_destroy+0x2e>
	return syscall(SYS_env_destroy, 1, envid, 0, 0, 0, 0);
}
  80f315:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80f318:	5b                   	pop    %ebx
  80f319:	5e                   	pop    %esi
  80f31a:	5f                   	pop    %edi
  80f31b:	5d                   	pop    %ebp
  80f31c:	c3                   	ret    
		panic("syscall %d returned %d (> 0)", num, ret);
  80f31d:	83 ec 0c             	sub    $0xc,%esp
  80f320:	50                   	push   %eax
  80f321:	6a 03                	push   $0x3
  80f323:	68 bf 3a 81 00       	push   $0x813abf
  80f328:	6a 23                	push   $0x23
  80f32a:	68 dc 3a 81 00       	push   $0x813adc
  80f32f:	e8 13 f5 ff ff       	call   80e847 <_panic>

0080f334 <sys_getenvid>:

envid_t
sys_getenvid(void)
{
  80f334:	f3 0f 1e fb          	endbr32 
  80f338:	55                   	push   %ebp
  80f339:	89 e5                	mov    %esp,%ebp
  80f33b:	57                   	push   %edi
  80f33c:	56                   	push   %esi
  80f33d:	53                   	push   %ebx
	asm volatile("int %1\n"
  80f33e:	ba 00 00 00 00       	mov    $0x0,%edx
  80f343:	b8 02 00 00 00       	mov    $0x2,%eax
  80f348:	89 d1                	mov    %edx,%ecx
  80f34a:	89 d3                	mov    %edx,%ebx
  80f34c:	89 d7                	mov    %edx,%edi
  80f34e:	89 d6                	mov    %edx,%esi
  80f350:	cd 30                	int    $0x30
	 return syscall(SYS_getenvid, 0, 0, 0, 0, 0, 0);
}
  80f352:	5b                   	pop    %ebx
  80f353:	5e                   	pop    %esi
  80f354:	5f                   	pop    %edi
  80f355:	5d                   	pop    %ebp
  80f356:	c3                   	ret    

0080f357 <sys_yield>:

void
sys_yield(void)
{
  80f357:	f3 0f 1e fb          	endbr32 
  80f35b:	55                   	push   %ebp
  80f35c:	89 e5                	mov    %esp,%ebp
  80f35e:	57                   	push   %edi
  80f35f:	56                   	push   %esi
  80f360:	53                   	push   %ebx
	asm volatile("int %1\n"
  80f361:	ba 00 00 00 00       	mov    $0x0,%edx
  80f366:	b8 0b 00 00 00       	mov    $0xb,%eax
  80f36b:	89 d1                	mov    %edx,%ecx
  80f36d:	89 d3                	mov    %edx,%ebx
  80f36f:	89 d7                	mov    %edx,%edi
  80f371:	89 d6                	mov    %edx,%esi
  80f373:	cd 30                	int    $0x30
	syscall(SYS_yield, 0, 0, 0, 0, 0, 0);
}
  80f375:	5b                   	pop    %ebx
  80f376:	5e                   	pop    %esi
  80f377:	5f                   	pop    %edi
  80f378:	5d                   	pop    %ebp
  80f379:	c3                   	ret    

0080f37a <sys_page_alloc>:

int
sys_page_alloc(envid_t envid, void *va, int perm)
{
  80f37a:	f3 0f 1e fb          	endbr32 
  80f37e:	55                   	push   %ebp
  80f37f:	89 e5                	mov    %esp,%ebp
  80f381:	57                   	push   %edi
  80f382:	56                   	push   %esi
  80f383:	53                   	push   %ebx
  80f384:	83 ec 0c             	sub    $0xc,%esp
	asm volatile("int %1\n"
  80f387:	be 00 00 00 00       	mov    $0x0,%esi
  80f38c:	8b 55 08             	mov    0x8(%ebp),%edx
  80f38f:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f392:	b8 04 00 00 00       	mov    $0x4,%eax
  80f397:	8b 5d 10             	mov    0x10(%ebp),%ebx
  80f39a:	89 f7                	mov    %esi,%edi
  80f39c:	cd 30                	int    $0x30
	if(check && ret > 0)
  80f39e:	85 c0                	test   %eax,%eax
  80f3a0:	7f 08                	jg     80f3aa <sys_page_alloc+0x30>
	return syscall(SYS_page_alloc, 1, envid, (uint32_t) va, perm, 0, 0);
}
  80f3a2:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80f3a5:	5b                   	pop    %ebx
  80f3a6:	5e                   	pop    %esi
  80f3a7:	5f                   	pop    %edi
  80f3a8:	5d                   	pop    %ebp
  80f3a9:	c3                   	ret    
		panic("syscall %d returned %d (> 0)", num, ret);
  80f3aa:	83 ec 0c             	sub    $0xc,%esp
  80f3ad:	50                   	push   %eax
  80f3ae:	6a 04                	push   $0x4
  80f3b0:	68 bf 3a 81 00       	push   $0x813abf
  80f3b5:	6a 23                	push   $0x23
  80f3b7:	68 dc 3a 81 00       	push   $0x813adc
  80f3bc:	e8 86 f4 ff ff       	call   80e847 <_panic>

0080f3c1 <sys_page_map>:

int
sys_page_map(envid_t srcenv, void *srcva, envid_t dstenv, void *dstva, int perm)
{
  80f3c1:	f3 0f 1e fb          	endbr32 
  80f3c5:	55                   	push   %ebp
  80f3c6:	89 e5                	mov    %esp,%ebp
  80f3c8:	57                   	push   %edi
  80f3c9:	56                   	push   %esi
  80f3ca:	53                   	push   %ebx
  80f3cb:	83 ec 0c             	sub    $0xc,%esp
	asm volatile("int %1\n"
  80f3ce:	8b 55 08             	mov    0x8(%ebp),%edx
  80f3d1:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f3d4:	b8 05 00 00 00       	mov    $0x5,%eax
  80f3d9:	8b 5d 10             	mov    0x10(%ebp),%ebx
  80f3dc:	8b 7d 14             	mov    0x14(%ebp),%edi
  80f3df:	8b 75 18             	mov    0x18(%ebp),%esi
  80f3e2:	cd 30                	int    $0x30
	if(check && ret > 0)
  80f3e4:	85 c0                	test   %eax,%eax
  80f3e6:	7f 08                	jg     80f3f0 <sys_page_map+0x2f>
	return syscall(SYS_page_map, 1, srcenv, (uint32_t) srcva, dstenv, (uint32_t) dstva, perm);
}
  80f3e8:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80f3eb:	5b                   	pop    %ebx
  80f3ec:	5e                   	pop    %esi
  80f3ed:	5f                   	pop    %edi
  80f3ee:	5d                   	pop    %ebp
  80f3ef:	c3                   	ret    
		panic("syscall %d returned %d (> 0)", num, ret);
  80f3f0:	83 ec 0c             	sub    $0xc,%esp
  80f3f3:	50                   	push   %eax
  80f3f4:	6a 05                	push   $0x5
  80f3f6:	68 bf 3a 81 00       	push   $0x813abf
  80f3fb:	6a 23                	push   $0x23
  80f3fd:	68 dc 3a 81 00       	push   $0x813adc
  80f402:	e8 40 f4 ff ff       	call   80e847 <_panic>

0080f407 <sys_page_unmap>:

int
sys_page_unmap(envid_t envid, void *va)
{
  80f407:	f3 0f 1e fb          	endbr32 
  80f40b:	55                   	push   %ebp
  80f40c:	89 e5                	mov    %esp,%ebp
  80f40e:	57                   	push   %edi
  80f40f:	56                   	push   %esi
  80f410:	53                   	push   %ebx
  80f411:	83 ec 0c             	sub    $0xc,%esp
	asm volatile("int %1\n"
  80f414:	bb 00 00 00 00       	mov    $0x0,%ebx
  80f419:	8b 55 08             	mov    0x8(%ebp),%edx
  80f41c:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f41f:	b8 06 00 00 00       	mov    $0x6,%eax
  80f424:	89 df                	mov    %ebx,%edi
  80f426:	89 de                	mov    %ebx,%esi
  80f428:	cd 30                	int    $0x30
	if(check && ret > 0)
  80f42a:	85 c0                	test   %eax,%eax
  80f42c:	7f 08                	jg     80f436 <sys_page_unmap+0x2f>
	return syscall(SYS_page_unmap, 1, envid, (uint32_t) va, 0, 0, 0);
}
  80f42e:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80f431:	5b                   	pop    %ebx
  80f432:	5e                   	pop    %esi
  80f433:	5f                   	pop    %edi
  80f434:	5d                   	pop    %ebp
  80f435:	c3                   	ret    
		panic("syscall %d returned %d (> 0)", num, ret);
  80f436:	83 ec 0c             	sub    $0xc,%esp
  80f439:	50                   	push   %eax
  80f43a:	6a 06                	push   $0x6
  80f43c:	68 bf 3a 81 00       	push   $0x813abf
  80f441:	6a 23                	push   $0x23
  80f443:	68 dc 3a 81 00       	push   $0x813adc
  80f448:	e8 fa f3 ff ff       	call   80e847 <_panic>

0080f44d <sys_env_set_status>:

// sys_exofork is inlined in lib.h

int
sys_env_set_status(envid_t envid, int status)
{
  80f44d:	f3 0f 1e fb          	endbr32 
  80f451:	55                   	push   %ebp
  80f452:	89 e5                	mov    %esp,%ebp
  80f454:	57                   	push   %edi
  80f455:	56                   	push   %esi
  80f456:	53                   	push   %ebx
  80f457:	83 ec 0c             	sub    $0xc,%esp
	asm volatile("int %1\n"
  80f45a:	bb 00 00 00 00       	mov    $0x0,%ebx
  80f45f:	8b 55 08             	mov    0x8(%ebp),%edx
  80f462:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f465:	b8 08 00 00 00       	mov    $0x8,%eax
  80f46a:	89 df                	mov    %ebx,%edi
  80f46c:	89 de                	mov    %ebx,%esi
  80f46e:	cd 30                	int    $0x30
	if(check && ret > 0)
  80f470:	85 c0                	test   %eax,%eax
  80f472:	7f 08                	jg     80f47c <sys_env_set_status+0x2f>
	return syscall(SYS_env_set_status, 1, envid, status, 0, 0, 0);
}
  80f474:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80f477:	5b                   	pop    %ebx
  80f478:	5e                   	pop    %esi
  80f479:	5f                   	pop    %edi
  80f47a:	5d                   	pop    %ebp
  80f47b:	c3                   	ret    
		panic("syscall %d returned %d (> 0)", num, ret);
  80f47c:	83 ec 0c             	sub    $0xc,%esp
  80f47f:	50                   	push   %eax
  80f480:	6a 08                	push   $0x8
  80f482:	68 bf 3a 81 00       	push   $0x813abf
  80f487:	6a 23                	push   $0x23
  80f489:	68 dc 3a 81 00       	push   $0x813adc
  80f48e:	e8 b4 f3 ff ff       	call   80e847 <_panic>

0080f493 <sys_env_set_trapframe>:

int
sys_env_set_trapframe(envid_t envid, struct Trapframe *tf)
{
  80f493:	f3 0f 1e fb          	endbr32 
  80f497:	55                   	push   %ebp
  80f498:	89 e5                	mov    %esp,%ebp
  80f49a:	57                   	push   %edi
  80f49b:	56                   	push   %esi
  80f49c:	53                   	push   %ebx
  80f49d:	83 ec 0c             	sub    $0xc,%esp
	asm volatile("int %1\n"
  80f4a0:	bb 00 00 00 00       	mov    $0x0,%ebx
  80f4a5:	8b 55 08             	mov    0x8(%ebp),%edx
  80f4a8:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f4ab:	b8 09 00 00 00       	mov    $0x9,%eax
  80f4b0:	89 df                	mov    %ebx,%edi
  80f4b2:	89 de                	mov    %ebx,%esi
  80f4b4:	cd 30                	int    $0x30
	if(check && ret > 0)
  80f4b6:	85 c0                	test   %eax,%eax
  80f4b8:	7f 08                	jg     80f4c2 <sys_env_set_trapframe+0x2f>
	return syscall(SYS_env_set_trapframe, 1, envid, (uint32_t) tf, 0, 0, 0);
}
  80f4ba:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80f4bd:	5b                   	pop    %ebx
  80f4be:	5e                   	pop    %esi
  80f4bf:	5f                   	pop    %edi
  80f4c0:	5d                   	pop    %ebp
  80f4c1:	c3                   	ret    
		panic("syscall %d returned %d (> 0)", num, ret);
  80f4c2:	83 ec 0c             	sub    $0xc,%esp
  80f4c5:	50                   	push   %eax
  80f4c6:	6a 09                	push   $0x9
  80f4c8:	68 bf 3a 81 00       	push   $0x813abf
  80f4cd:	6a 23                	push   $0x23
  80f4cf:	68 dc 3a 81 00       	push   $0x813adc
  80f4d4:	e8 6e f3 ff ff       	call   80e847 <_panic>

0080f4d9 <sys_env_set_pgfault_upcall>:

int
sys_env_set_pgfault_upcall(envid_t envid, void *upcall)
{
  80f4d9:	f3 0f 1e fb          	endbr32 
  80f4dd:	55                   	push   %ebp
  80f4de:	89 e5                	mov    %esp,%ebp
  80f4e0:	57                   	push   %edi
  80f4e1:	56                   	push   %esi
  80f4e2:	53                   	push   %ebx
  80f4e3:	83 ec 0c             	sub    $0xc,%esp
	asm volatile("int %1\n"
  80f4e6:	bb 00 00 00 00       	mov    $0x0,%ebx
  80f4eb:	8b 55 08             	mov    0x8(%ebp),%edx
  80f4ee:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f4f1:	b8 0a 00 00 00       	mov    $0xa,%eax
  80f4f6:	89 df                	mov    %ebx,%edi
  80f4f8:	89 de                	mov    %ebx,%esi
  80f4fa:	cd 30                	int    $0x30
	if(check && ret > 0)
  80f4fc:	85 c0                	test   %eax,%eax
  80f4fe:	7f 08                	jg     80f508 <sys_env_set_pgfault_upcall+0x2f>
	return syscall(SYS_env_set_pgfault_upcall, 1, envid, (uint32_t) upcall, 0, 0, 0);
}
  80f500:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80f503:	5b                   	pop    %ebx
  80f504:	5e                   	pop    %esi
  80f505:	5f                   	pop    %edi
  80f506:	5d                   	pop    %ebp
  80f507:	c3                   	ret    
		panic("syscall %d returned %d (> 0)", num, ret);
  80f508:	83 ec 0c             	sub    $0xc,%esp
  80f50b:	50                   	push   %eax
  80f50c:	6a 0a                	push   $0xa
  80f50e:	68 bf 3a 81 00       	push   $0x813abf
  80f513:	6a 23                	push   $0x23
  80f515:	68 dc 3a 81 00       	push   $0x813adc
  80f51a:	e8 28 f3 ff ff       	call   80e847 <_panic>

0080f51f <sys_ipc_try_send>:

int
sys_ipc_try_send(envid_t envid, uint32_t value, void *srcva, int perm)
{
  80f51f:	f3 0f 1e fb          	endbr32 
  80f523:	55                   	push   %ebp
  80f524:	89 e5                	mov    %esp,%ebp
  80f526:	57                   	push   %edi
  80f527:	56                   	push   %esi
  80f528:	53                   	push   %ebx
	asm volatile("int %1\n"
  80f529:	8b 55 08             	mov    0x8(%ebp),%edx
  80f52c:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f52f:	b8 0c 00 00 00       	mov    $0xc,%eax
  80f534:	be 00 00 00 00       	mov    $0x0,%esi
  80f539:	8b 5d 10             	mov    0x10(%ebp),%ebx
  80f53c:	8b 7d 14             	mov    0x14(%ebp),%edi
  80f53f:	cd 30                	int    $0x30
	return syscall(SYS_ipc_try_send, 0, envid, value, (uint32_t) srcva, perm, 0);
}
  80f541:	5b                   	pop    %ebx
  80f542:	5e                   	pop    %esi
  80f543:	5f                   	pop    %edi
  80f544:	5d                   	pop    %ebp
  80f545:	c3                   	ret    

0080f546 <sys_ipc_recv>:

int
sys_ipc_recv(void *dstva)
{
  80f546:	f3 0f 1e fb          	endbr32 
  80f54a:	55                   	push   %ebp
  80f54b:	89 e5                	mov    %esp,%ebp
  80f54d:	57                   	push   %edi
  80f54e:	56                   	push   %esi
  80f54f:	53                   	push   %ebx
  80f550:	83 ec 0c             	sub    $0xc,%esp
	asm volatile("int %1\n"
  80f553:	b9 00 00 00 00       	mov    $0x0,%ecx
  80f558:	8b 55 08             	mov    0x8(%ebp),%edx
  80f55b:	b8 0d 00 00 00       	mov    $0xd,%eax
  80f560:	89 cb                	mov    %ecx,%ebx
  80f562:	89 cf                	mov    %ecx,%edi
  80f564:	89 ce                	mov    %ecx,%esi
  80f566:	cd 30                	int    $0x30
	if(check && ret > 0)
  80f568:	85 c0                	test   %eax,%eax
  80f56a:	7f 08                	jg     80f574 <sys_ipc_recv+0x2e>
	return syscall(SYS_ipc_recv, 1, (uint32_t)dstva, 0, 0, 0, 0);
}
  80f56c:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80f56f:	5b                   	pop    %ebx
  80f570:	5e                   	pop    %esi
  80f571:	5f                   	pop    %edi
  80f572:	5d                   	pop    %ebp
  80f573:	c3                   	ret    
		panic("syscall %d returned %d (> 0)", num, ret);
  80f574:	83 ec 0c             	sub    $0xc,%esp
  80f577:	50                   	push   %eax
  80f578:	6a 0d                	push   $0xd
  80f57a:	68 bf 3a 81 00       	push   $0x813abf
  80f57f:	6a 23                	push   $0x23
  80f581:	68 dc 3a 81 00       	push   $0x813adc
  80f586:	e8 bc f2 ff ff       	call   80e847 <_panic>

0080f58b <sys_time_msec>:

unsigned int
sys_time_msec(void)
{
  80f58b:	f3 0f 1e fb          	endbr32 
  80f58f:	55                   	push   %ebp
  80f590:	89 e5                	mov    %esp,%ebp
  80f592:	57                   	push   %edi
  80f593:	56                   	push   %esi
  80f594:	53                   	push   %ebx
	asm volatile("int %1\n"
  80f595:	ba 00 00 00 00       	mov    $0x0,%edx
  80f59a:	b8 0e 00 00 00       	mov    $0xe,%eax
  80f59f:	89 d1                	mov    %edx,%ecx
  80f5a1:	89 d3                	mov    %edx,%ebx
  80f5a3:	89 d7                	mov    %edx,%edi
  80f5a5:	89 d6                	mov    %edx,%esi
  80f5a7:	cd 30                	int    $0x30
	return (unsigned int) syscall(SYS_time_msec, 0, 0, 0, 0, 0, 0);
}
  80f5a9:	5b                   	pop    %ebx
  80f5aa:	5e                   	pop    %esi
  80f5ab:	5f                   	pop    %edi
  80f5ac:	5d                   	pop    %ebp
  80f5ad:	c3                   	ret    

0080f5ae <pgfault>:
// Custom page fault handler - if faulting page is copy-on-write,
// map in our own private writable copy.
//
static void
pgfault(struct UTrapframe *utf)
{
  80f5ae:	f3 0f 1e fb          	endbr32 
  80f5b2:	55                   	push   %ebp
  80f5b3:	89 e5                	mov    %esp,%ebp
  80f5b5:	56                   	push   %esi
  80f5b6:	53                   	push   %ebx
  80f5b7:	8b 45 08             	mov    0x8(%ebp),%eax
    int r;
    void *addr = (void *) utf->utf_fault_va;
  80f5ba:	8b 30                	mov    (%eax),%esi
    uint32_t err = utf->utf_err;
    //cprintf("envid is %d, running pgfault\n", sys_getenvid());
    if ((err & FEC_WR) == 0 && (uvpt[PGNUM(addr)] & PTE_COW) == 0)
  80f5bc:	f6 40 04 02          	testb  $0x2,0x4(%eax)
  80f5c0:	75 11                	jne    80f5d3 <pgfault+0x25>
  80f5c2:	89 f0                	mov    %esi,%eax
  80f5c4:	c1 e8 0c             	shr    $0xc,%eax
  80f5c7:	8b 04 85 00 00 40 ef 	mov    -0x10c00000(,%eax,4),%eax
  80f5ce:	f6 c4 08             	test   $0x8,%ah
  80f5d1:	74 7d                	je     80f650 <pgfault+0xa2>
    //cprintf("%x have %x\n", sys_getenvid(), addr);
    // Allocate a new page, map it at a temporary location (PFTEMP),
    // copy the data from the old page to the new page, then move the new
    // page to the old page's address.

    envid_t envid = sys_getenvid();
  80f5d3:	e8 5c fd ff ff       	call   80f334 <sys_getenvid>
  80f5d8:	89 c3                	mov    %eax,%ebx
    if ((r = sys_page_alloc(envid, (void *)PFTEMP, PTE_P | PTE_W | PTE_U)) < 0)
  80f5da:	83 ec 04             	sub    $0x4,%esp
  80f5dd:	6a 07                	push   $0x7
  80f5df:	68 00 f0 7f 00       	push   $0x7ff000
  80f5e4:	50                   	push   %eax
  80f5e5:	e8 90 fd ff ff       	call   80f37a <sys_page_alloc>
  80f5ea:	83 c4 10             	add    $0x10,%esp
  80f5ed:	85 c0                	test   %eax,%eax
  80f5ef:	78 7a                	js     80f66b <pgfault+0xbd>
        panic("pgfault: page allocation failed %e", r);

    addr = ROUNDDOWN(addr, PGSIZE);
  80f5f1:	81 e6 00 f0 ff ff    	and    $0xfffff000,%esi
    memmove(PFTEMP, addr, PGSIZE);
  80f5f7:	83 ec 04             	sub    $0x4,%esp
  80f5fa:	68 00 10 00 00       	push   $0x1000
  80f5ff:	56                   	push   %esi
  80f600:	68 00 f0 7f 00       	push   $0x7ff000
  80f605:	e8 e4 fa ff ff       	call   80f0ee <memmove>
    if ((r = sys_page_unmap(envid, addr)) < 0)
  80f60a:	83 c4 08             	add    $0x8,%esp
  80f60d:	56                   	push   %esi
  80f60e:	53                   	push   %ebx
  80f60f:	e8 f3 fd ff ff       	call   80f407 <sys_page_unmap>
  80f614:	83 c4 10             	add    $0x10,%esp
  80f617:	85 c0                	test   %eax,%eax
  80f619:	78 62                	js     80f67d <pgfault+0xcf>
        panic("pgfault: page unmap failed %e", r);
    if ((r = sys_page_map(envid, PFTEMP, envid, addr, PTE_P | PTE_W |PTE_U)) < 0)
  80f61b:	83 ec 0c             	sub    $0xc,%esp
  80f61e:	6a 07                	push   $0x7
  80f620:	56                   	push   %esi
  80f621:	53                   	push   %ebx
  80f622:	68 00 f0 7f 00       	push   $0x7ff000
  80f627:	53                   	push   %ebx
  80f628:	e8 94 fd ff ff       	call   80f3c1 <sys_page_map>
  80f62d:	83 c4 20             	add    $0x20,%esp
  80f630:	85 c0                	test   %eax,%eax
  80f632:	78 5b                	js     80f68f <pgfault+0xe1>
        panic("pgfault: page map failed %e", r);
    if ((r = sys_page_unmap(envid, PFTEMP)) < 0)
  80f634:	83 ec 08             	sub    $0x8,%esp
  80f637:	68 00 f0 7f 00       	push   $0x7ff000
  80f63c:	53                   	push   %ebx
  80f63d:	e8 c5 fd ff ff       	call   80f407 <sys_page_unmap>
  80f642:	83 c4 10             	add    $0x10,%esp
  80f645:	85 c0                	test   %eax,%eax
  80f647:	78 58                	js     80f6a1 <pgfault+0xf3>
        panic("pgfault: page unmap failed %e", r);
}
  80f649:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80f64c:	5b                   	pop    %ebx
  80f64d:	5e                   	pop    %esi
  80f64e:	5d                   	pop    %ebp
  80f64f:	c3                   	ret    
        panic("%x, pgfault: it's not writable or attempt to access a non-cow page!, %x", sys_getenvid(), addr);
  80f650:	e8 df fc ff ff       	call   80f334 <sys_getenvid>
  80f655:	83 ec 0c             	sub    $0xc,%esp
  80f658:	56                   	push   %esi
  80f659:	50                   	push   %eax
  80f65a:	68 ec 3a 81 00       	push   $0x813aec
  80f65f:	6a 16                	push   $0x16
  80f661:	68 7a 3b 81 00       	push   $0x813b7a
  80f666:	e8 dc f1 ff ff       	call   80e847 <_panic>
        panic("pgfault: page allocation failed %e", r);
  80f66b:	50                   	push   %eax
  80f66c:	68 34 3b 81 00       	push   $0x813b34
  80f671:	6a 1f                	push   $0x1f
  80f673:	68 7a 3b 81 00       	push   $0x813b7a
  80f678:	e8 ca f1 ff ff       	call   80e847 <_panic>
        panic("pgfault: page unmap failed %e", r);
  80f67d:	50                   	push   %eax
  80f67e:	68 85 3b 81 00       	push   $0x813b85
  80f683:	6a 24                	push   $0x24
  80f685:	68 7a 3b 81 00       	push   $0x813b7a
  80f68a:	e8 b8 f1 ff ff       	call   80e847 <_panic>
        panic("pgfault: page map failed %e", r);
  80f68f:	50                   	push   %eax
  80f690:	68 a3 3b 81 00       	push   $0x813ba3
  80f695:	6a 26                	push   $0x26
  80f697:	68 7a 3b 81 00       	push   $0x813b7a
  80f69c:	e8 a6 f1 ff ff       	call   80e847 <_panic>
        panic("pgfault: page unmap failed %e", r);
  80f6a1:	50                   	push   %eax
  80f6a2:	68 85 3b 81 00       	push   $0x813b85
  80f6a7:	6a 28                	push   $0x28
  80f6a9:	68 7a 3b 81 00       	push   $0x813b7a
  80f6ae:	e8 94 f1 ff ff       	call   80e847 <_panic>

0080f6b3 <duppage>:
// Returns: 0 on success, < 0 on error.
// It is also OK to panic on error.
//
static int
duppage(envid_t envid, unsigned pn)
{
  80f6b3:	55                   	push   %ebp
  80f6b4:	89 e5                	mov    %esp,%ebp
  80f6b6:	53                   	push   %ebx
  80f6b7:	83 ec 04             	sub    $0x4,%esp

    void *addr;
    pte_t pte;
    int perm;

    addr = (void *)((uint32_t)pn * PGSIZE);
  80f6ba:	89 d3                	mov    %edx,%ebx
  80f6bc:	c1 e3 0c             	shl    $0xc,%ebx
    pte = uvpt[pn];
  80f6bf:	8b 14 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%edx
    perm = PTE_P | PTE_U;
    if (pte & PTE_SHARE) {
  80f6c6:	f6 c6 04             	test   $0x4,%dh
  80f6c9:	75 62                	jne    80f72d <duppage+0x7a>
        if ((r = sys_page_map(thisenv->env_id, addr, envid, addr, pte & PTE_SYSCALL)) < 0) 
            panic("duppage: page remapping failed %e", r);
    } else if (pte & (PTE_W | PTE_COW)) {
  80f6cb:	f7 c2 02 08 00 00    	test   $0x802,%edx
  80f6d1:	0f 84 9d 00 00 00    	je     80f774 <duppage+0xc1>
        perm |= PTE_COW;
        if ((r = sys_page_map(thisenv->env_id, addr, envid, addr, perm)) < 0) 
  80f6d7:	8b 15 5c b2 b3 00    	mov    0xb3b25c,%edx
  80f6dd:	8b 52 48             	mov    0x48(%edx),%edx
  80f6e0:	83 ec 0c             	sub    $0xc,%esp
  80f6e3:	68 05 08 00 00       	push   $0x805
  80f6e8:	53                   	push   %ebx
  80f6e9:	50                   	push   %eax
  80f6ea:	53                   	push   %ebx
  80f6eb:	52                   	push   %edx
  80f6ec:	e8 d0 fc ff ff       	call   80f3c1 <sys_page_map>
  80f6f1:	83 c4 20             	add    $0x20,%esp
  80f6f4:	85 c0                	test   %eax,%eax
  80f6f6:	78 6a                	js     80f762 <duppage+0xaf>
            panic("duppage: page remapping failed %e", r);
        if ((r = sys_page_map(thisenv->env_id, addr, thisenv->env_id, addr, perm)) < 0) 
  80f6f8:	a1 5c b2 b3 00       	mov    0xb3b25c,%eax
  80f6fd:	8b 50 48             	mov    0x48(%eax),%edx
  80f700:	8b 40 48             	mov    0x48(%eax),%eax
  80f703:	83 ec 0c             	sub    $0xc,%esp
  80f706:	68 05 08 00 00       	push   $0x805
  80f70b:	53                   	push   %ebx
  80f70c:	52                   	push   %edx
  80f70d:	53                   	push   %ebx
  80f70e:	50                   	push   %eax
  80f70f:	e8 ad fc ff ff       	call   80f3c1 <sys_page_map>
  80f714:	83 c4 20             	add    $0x20,%esp
  80f717:	85 c0                	test   %eax,%eax
  80f719:	79 77                	jns    80f792 <duppage+0xdf>
            panic("duppage: page remapping failed %e", r);
  80f71b:	50                   	push   %eax
  80f71c:	68 58 3b 81 00       	push   $0x813b58
  80f721:	6a 49                	push   $0x49
  80f723:	68 7a 3b 81 00       	push   $0x813b7a
  80f728:	e8 1a f1 ff ff       	call   80e847 <_panic>
        if ((r = sys_page_map(thisenv->env_id, addr, envid, addr, pte & PTE_SYSCALL)) < 0) 
  80f72d:	8b 0d 5c b2 b3 00    	mov    0xb3b25c,%ecx
  80f733:	8b 49 48             	mov    0x48(%ecx),%ecx
  80f736:	83 ec 0c             	sub    $0xc,%esp
  80f739:	81 e2 07 0e 00 00    	and    $0xe07,%edx
  80f73f:	52                   	push   %edx
  80f740:	53                   	push   %ebx
  80f741:	50                   	push   %eax
  80f742:	53                   	push   %ebx
  80f743:	51                   	push   %ecx
  80f744:	e8 78 fc ff ff       	call   80f3c1 <sys_page_map>
  80f749:	83 c4 20             	add    $0x20,%esp
  80f74c:	85 c0                	test   %eax,%eax
  80f74e:	79 42                	jns    80f792 <duppage+0xdf>
            panic("duppage: page remapping failed %e", r);
  80f750:	50                   	push   %eax
  80f751:	68 58 3b 81 00       	push   $0x813b58
  80f756:	6a 43                	push   $0x43
  80f758:	68 7a 3b 81 00       	push   $0x813b7a
  80f75d:	e8 e5 f0 ff ff       	call   80e847 <_panic>
            panic("duppage: page remapping failed %e", r);
  80f762:	50                   	push   %eax
  80f763:	68 58 3b 81 00       	push   $0x813b58
  80f768:	6a 47                	push   $0x47
  80f76a:	68 7a 3b 81 00       	push   $0x813b7a
  80f76f:	e8 d3 f0 ff ff       	call   80e847 <_panic>
    } else {
		if ((r = sys_page_map(thisenv->env_id, addr, envid, addr, PTE_U|PTE_P)) < 0)
  80f774:	8b 15 5c b2 b3 00    	mov    0xb3b25c,%edx
  80f77a:	8b 52 48             	mov    0x48(%edx),%edx
  80f77d:	83 ec 0c             	sub    $0xc,%esp
  80f780:	6a 05                	push   $0x5
  80f782:	53                   	push   %ebx
  80f783:	50                   	push   %eax
  80f784:	53                   	push   %ebx
  80f785:	52                   	push   %edx
  80f786:	e8 36 fc ff ff       	call   80f3c1 <sys_page_map>
  80f78b:	83 c4 20             	add    $0x20,%esp
  80f78e:	85 c0                	test   %eax,%eax
  80f790:	78 0a                	js     80f79c <duppage+0xe9>
			panic("duppage: page remapping failed %e", r);
	}
    return 0;
}
  80f792:	b8 00 00 00 00       	mov    $0x0,%eax
  80f797:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80f79a:	c9                   	leave  
  80f79b:	c3                   	ret    
			panic("duppage: page remapping failed %e", r);
  80f79c:	50                   	push   %eax
  80f79d:	68 58 3b 81 00       	push   $0x813b58
  80f7a2:	6a 4c                	push   $0x4c
  80f7a4:	68 7a 3b 81 00       	push   $0x813b7a
  80f7a9:	e8 99 f0 ff ff       	call   80e847 <_panic>

0080f7ae <fork>:
//   Neither user exception stack should ever be marked copy-on-write,
//   so you must allocate a new page for the child's user exception stack.
//
envid_t
fork(void)
{
  80f7ae:	f3 0f 1e fb          	endbr32 
  80f7b2:	55                   	push   %ebp
  80f7b3:	89 e5                	mov    %esp,%ebp
  80f7b5:	56                   	push   %esi
  80f7b6:	53                   	push   %ebx
  80f7b7:	83 ec 1c             	sub    $0x1c,%esp
	// LAB 4: Your code here.
	set_pgfault_handler(pgfault);
  80f7ba:	68 ae f5 80 00       	push   $0x80f5ae
  80f7bf:	e8 d8 16 00 00       	call   810e9c <set_pgfault_handler>
// This must be inlined.  Exercise for reader: why?
static inline envid_t __attribute__((always_inline))
sys_exofork(void)
{
	envid_t ret;
	asm volatile("int %2"
  80f7c4:	b8 07 00 00 00       	mov    $0x7,%eax
  80f7c9:	cd 30                	int    $0x30
  80f7cb:	89 c3                	mov    %eax,%ebx

	envid_t envid = sys_exofork();
	uint8_t *addr;
	if (envid < 0)
  80f7cd:	83 c4 10             	add    $0x10,%esp
  80f7d0:	85 c0                	test   %eax,%eax
  80f7d2:	78 12                	js     80f7e6 <fork+0x38>
  80f7d4:	89 c6                	mov    %eax,%esi
		panic("sys_exofork:%e", envid);
	if (envid == 0) {
  80f7d6:	74 20                	je     80f7f8 <fork+0x4a>
		thisenv = &envs[ENVX(sys_getenvid())];
		return 0;
	}

	for (addr = (uint8_t *)UTEXT; addr < (uint8_t *)USTACKTOP; addr += PGSIZE) {
  80f7d8:	c7 45 f4 00 00 80 00 	movl   $0x800000,-0xc(%ebp)
  80f7df:	ba 00 00 80 00       	mov    $0x800000,%edx
  80f7e4:	eb 42                	jmp    80f828 <fork+0x7a>
		panic("sys_exofork:%e", envid);
  80f7e6:	50                   	push   %eax
  80f7e7:	68 bf 3b 81 00       	push   $0x813bbf
  80f7ec:	6a 6a                	push   $0x6a
  80f7ee:	68 7a 3b 81 00       	push   $0x813b7a
  80f7f3:	e8 4f f0 ff ff       	call   80e847 <_panic>
		thisenv = &envs[ENVX(sys_getenvid())];
  80f7f8:	e8 37 fb ff ff       	call   80f334 <sys_getenvid>
  80f7fd:	25 ff 03 00 00       	and    $0x3ff,%eax
  80f802:	6b c0 7c             	imul   $0x7c,%eax,%eax
  80f805:	05 00 00 c0 ee       	add    $0xeec00000,%eax
  80f80a:	a3 5c b2 b3 00       	mov    %eax,0xb3b25c
		return 0;
  80f80f:	e9 8a 00 00 00       	jmp    80f89e <fork+0xf0>
	for (addr = (uint8_t *)UTEXT; addr < (uint8_t *)USTACKTOP; addr += PGSIZE) {
  80f814:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80f817:	8d 90 00 10 00 00    	lea    0x1000(%eax),%edx
  80f81d:	89 55 f4             	mov    %edx,-0xc(%ebp)
  80f820:	81 fa ff df bf ee    	cmp    $0xeebfdfff,%edx
  80f826:	77 32                	ja     80f85a <fork+0xac>
		if ((uvpd[PDX(addr)] & PTE_P) && (uvpt[PGNUM(addr)] & PTE_P)
  80f828:	89 d0                	mov    %edx,%eax
  80f82a:	c1 e8 16             	shr    $0x16,%eax
  80f82d:	8b 04 85 00 d0 7b ef 	mov    -0x10843000(,%eax,4),%eax
  80f834:	a8 01                	test   $0x1,%al
  80f836:	74 dc                	je     80f814 <fork+0x66>
  80f838:	c1 ea 0c             	shr    $0xc,%edx
  80f83b:	8b 04 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%eax
  80f842:	a8 01                	test   $0x1,%al
  80f844:	74 ce                	je     80f814 <fork+0x66>
				&& (uvpt[PGNUM(addr)] & PTE_U)) {
  80f846:	8b 04 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%eax
  80f84d:	a8 04                	test   $0x4,%al
  80f84f:	74 c3                	je     80f814 <fork+0x66>
			duppage(envid, PGNUM(addr));
  80f851:	89 f0                	mov    %esi,%eax
  80f853:	e8 5b fe ff ff       	call   80f6b3 <duppage>
  80f858:	eb ba                	jmp    80f814 <fork+0x66>
		}
	}

	duppage(envid, PGNUM(ROUNDDOWN(&addr, PGSIZE)));
  80f85a:	8d 55 f4             	lea    -0xc(%ebp),%edx
  80f85d:	c1 ea 0c             	shr    $0xc,%edx
  80f860:	89 d8                	mov    %ebx,%eax
  80f862:	e8 4c fe ff ff       	call   80f6b3 <duppage>

	int r;
	if ((r = sys_page_alloc(envid, (void *)(UXSTACKTOP - PGSIZE), PTE_P|PTE_U|PTE_W)))
  80f867:	83 ec 04             	sub    $0x4,%esp
  80f86a:	6a 07                	push   $0x7
  80f86c:	68 00 f0 bf ee       	push   $0xeebff000
  80f871:	53                   	push   %ebx
  80f872:	e8 03 fb ff ff       	call   80f37a <sys_page_alloc>
  80f877:	83 c4 10             	add    $0x10,%esp
  80f87a:	85 c0                	test   %eax,%eax
  80f87c:	75 29                	jne    80f8a7 <fork+0xf9>
		panic("sys_page_alloc:%e", r);

	extern void _pgfault_upcall();
	sys_env_set_pgfault_upcall(envid, _pgfault_upcall);
  80f87e:	83 ec 08             	sub    $0x8,%esp
  80f881:	68 1d 0f 81 00       	push   $0x810f1d
  80f886:	53                   	push   %ebx
  80f887:	e8 4d fc ff ff       	call   80f4d9 <sys_env_set_pgfault_upcall>

	if ((r = sys_env_set_status(envid, ENV_RUNNABLE)))
  80f88c:	83 c4 08             	add    $0x8,%esp
  80f88f:	6a 02                	push   $0x2
  80f891:	53                   	push   %ebx
  80f892:	e8 b6 fb ff ff       	call   80f44d <sys_env_set_status>
  80f897:	83 c4 10             	add    $0x10,%esp
  80f89a:	85 c0                	test   %eax,%eax
  80f89c:	75 1b                	jne    80f8b9 <fork+0x10b>
		panic("sys_env_set_status:%e", r);

	return envid;
	//panic("fork not implemented");
}
  80f89e:	89 d8                	mov    %ebx,%eax
  80f8a0:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80f8a3:	5b                   	pop    %ebx
  80f8a4:	5e                   	pop    %esi
  80f8a5:	5d                   	pop    %ebp
  80f8a6:	c3                   	ret    
		panic("sys_page_alloc:%e", r);
  80f8a7:	50                   	push   %eax
  80f8a8:	68 ce 3b 81 00       	push   $0x813bce
  80f8ad:	6a 7b                	push   $0x7b
  80f8af:	68 7a 3b 81 00       	push   $0x813b7a
  80f8b4:	e8 8e ef ff ff       	call   80e847 <_panic>
		panic("sys_env_set_status:%e", r);
  80f8b9:	50                   	push   %eax
  80f8ba:	68 e0 3b 81 00       	push   $0x813be0
  80f8bf:	68 81 00 00 00       	push   $0x81
  80f8c4:	68 7a 3b 81 00       	push   $0x813b7a
  80f8c9:	e8 79 ef ff ff       	call   80e847 <_panic>

0080f8ce <sfork>:

// Challenge!
int
sfork(void)
{
  80f8ce:	f3 0f 1e fb          	endbr32 
  80f8d2:	55                   	push   %ebp
  80f8d3:	89 e5                	mov    %esp,%ebp
  80f8d5:	83 ec 0c             	sub    $0xc,%esp
	panic("sfork not implemented");
  80f8d8:	68 f6 3b 81 00       	push   $0x813bf6
  80f8dd:	68 8b 00 00 00       	push   $0x8b
  80f8e2:	68 7a 3b 81 00       	push   $0x813b7a
  80f8e7:	e8 5b ef ff ff       	call   80e847 <_panic>

0080f8ec <ipc_recv>:
//   If 'pg' is null, pass sys_ipc_recv a value that it will understand
//   as meaning "no page".  (Zero is not the right value, since that's
//   a perfectly valid place to map a page.)
int32_t
ipc_recv(envid_t *from_env_store, void *pg, int *perm_store)
{
  80f8ec:	f3 0f 1e fb          	endbr32 
  80f8f0:	55                   	push   %ebp
  80f8f1:	89 e5                	mov    %esp,%ebp
  80f8f3:	56                   	push   %esi
  80f8f4:	53                   	push   %ebx
  80f8f5:	8b 75 08             	mov    0x8(%ebp),%esi
  80f8f8:	8b 45 0c             	mov    0xc(%ebp),%eax
  80f8fb:	8b 5d 10             	mov    0x10(%ebp),%ebx
	// LAB 4: Your code here.
	if (!pg || pg > (void *)UTOP) pg = (void *)UTOP;
  80f8fe:	83 e8 01             	sub    $0x1,%eax
  80f901:	3d ff ff bf ee       	cmp    $0xeebfffff,%eax
  80f906:	b8 00 00 c0 ee       	mov    $0xeec00000,%eax
  80f90b:	0f 46 45 0c          	cmovbe 0xc(%ebp),%eax
	int t = sys_ipc_recv(pg);
  80f90f:	83 ec 0c             	sub    $0xc,%esp
  80f912:	50                   	push   %eax
  80f913:	e8 2e fc ff ff       	call   80f546 <sys_ipc_recv>
	if (!t) {
  80f918:	83 c4 10             	add    $0x10,%esp
  80f91b:	85 c0                	test   %eax,%eax
  80f91d:	75 2b                	jne    80f94a <ipc_recv+0x5e>
		if (from_env_store) *from_env_store = thisenv->env_ipc_from;
  80f91f:	85 f6                	test   %esi,%esi
  80f921:	74 0a                	je     80f92d <ipc_recv+0x41>
  80f923:	a1 5c b2 b3 00       	mov    0xb3b25c,%eax
  80f928:	8b 40 74             	mov    0x74(%eax),%eax
  80f92b:	89 06                	mov    %eax,(%esi)
		if (perm_store) *perm_store = thisenv->env_ipc_perm; 
  80f92d:	85 db                	test   %ebx,%ebx
  80f92f:	74 0a                	je     80f93b <ipc_recv+0x4f>
  80f931:	a1 5c b2 b3 00       	mov    0xb3b25c,%eax
  80f936:	8b 40 78             	mov    0x78(%eax),%eax
  80f939:	89 03                	mov    %eax,(%ebx)
		if (from_env_store) *from_env_store = 0;
		if (perm_store) *perm_store = 0; 
		return t;
	}
	
	return thisenv->env_ipc_value;
  80f93b:	a1 5c b2 b3 00       	mov    0xb3b25c,%eax
  80f940:	8b 40 70             	mov    0x70(%eax),%eax
	//panic("ipc_recv not implemented");
	
}
  80f943:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80f946:	5b                   	pop    %ebx
  80f947:	5e                   	pop    %esi
  80f948:	5d                   	pop    %ebp
  80f949:	c3                   	ret    
		if (from_env_store) *from_env_store = 0;
  80f94a:	85 f6                	test   %esi,%esi
  80f94c:	74 06                	je     80f954 <ipc_recv+0x68>
  80f94e:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
		if (perm_store) *perm_store = 0; 
  80f954:	85 db                	test   %ebx,%ebx
  80f956:	74 eb                	je     80f943 <ipc_recv+0x57>
  80f958:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
  80f95e:	eb e3                	jmp    80f943 <ipc_recv+0x57>

0080f960 <ipc_send>:
//   Use sys_yield() to be CPU-friendly.
//   If 'pg' is null, pass sys_ipc_try_send a value that it will understand
//   as meaning "no page".  (Zero is not the right value.)
void
ipc_send(envid_t to_env, uint32_t val, void *pg, int perm)
{
  80f960:	f3 0f 1e fb          	endbr32 
  80f964:	55                   	push   %ebp
  80f965:	89 e5                	mov    %esp,%ebp
  80f967:	57                   	push   %edi
  80f968:	56                   	push   %esi
  80f969:	53                   	push   %ebx
  80f96a:	83 ec 0c             	sub    $0xc,%esp
  80f96d:	8b 7d 08             	mov    0x8(%ebp),%edi
  80f970:	8b 75 0c             	mov    0xc(%ebp),%esi
  80f973:	8b 5d 10             	mov    0x10(%ebp),%ebx
	// LAB 4: Your code here.
	if (!pg) pg = (void *)UTOP;
  80f976:	85 db                	test   %ebx,%ebx
  80f978:	b8 00 00 c0 ee       	mov    $0xeec00000,%eax
  80f97d:	0f 44 d8             	cmove  %eax,%ebx
	int r;
	while ((r = sys_ipc_try_send(to_env, val, pg, perm))) {
  80f980:	ff 75 14             	pushl  0x14(%ebp)
  80f983:	53                   	push   %ebx
  80f984:	56                   	push   %esi
  80f985:	57                   	push   %edi
  80f986:	e8 94 fb ff ff       	call   80f51f <sys_ipc_try_send>
  80f98b:	83 c4 10             	add    $0x10,%esp
  80f98e:	85 c0                	test   %eax,%eax
  80f990:	74 1e                	je     80f9b0 <ipc_send+0x50>
		if (r != -E_IPC_NOT_RECV) panic("ipc_send error %e", r);
  80f992:	83 f8 f9             	cmp    $0xfffffff9,%eax
  80f995:	75 07                	jne    80f99e <ipc_send+0x3e>
		sys_yield();
  80f997:	e8 bb f9 ff ff       	call   80f357 <sys_yield>
  80f99c:	eb e2                	jmp    80f980 <ipc_send+0x20>
		if (r != -E_IPC_NOT_RECV) panic("ipc_send error %e", r);
  80f99e:	50                   	push   %eax
  80f99f:	68 0c 3c 81 00       	push   $0x813c0c
  80f9a4:	6a 39                	push   $0x39
  80f9a6:	68 1e 3c 81 00       	push   $0x813c1e
  80f9ab:	e8 97 ee ff ff       	call   80e847 <_panic>
	}
	//panic("ipc_send not implemented");
}
  80f9b0:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80f9b3:	5b                   	pop    %ebx
  80f9b4:	5e                   	pop    %esi
  80f9b5:	5f                   	pop    %edi
  80f9b6:	5d                   	pop    %ebp
  80f9b7:	c3                   	ret    

0080f9b8 <ipc_find_env>:
// Find the first environment of the given type.  We'll use this to
// find special environments.
// Returns 0 if no such environment exists.
envid_t
ipc_find_env(enum EnvType type)
{
  80f9b8:	f3 0f 1e fb          	endbr32 
  80f9bc:	55                   	push   %ebp
  80f9bd:	89 e5                	mov    %esp,%ebp
  80f9bf:	8b 4d 08             	mov    0x8(%ebp),%ecx
	int i;
	for (i = 0; i < NENV; i++)
  80f9c2:	b8 00 00 00 00       	mov    $0x0,%eax
		if (envs[i].env_type == type)
  80f9c7:	6b d0 7c             	imul   $0x7c,%eax,%edx
  80f9ca:	81 c2 00 00 c0 ee    	add    $0xeec00000,%edx
  80f9d0:	8b 52 50             	mov    0x50(%edx),%edx
  80f9d3:	39 ca                	cmp    %ecx,%edx
  80f9d5:	74 11                	je     80f9e8 <ipc_find_env+0x30>
	for (i = 0; i < NENV; i++)
  80f9d7:	83 c0 01             	add    $0x1,%eax
  80f9da:	3d 00 04 00 00       	cmp    $0x400,%eax
  80f9df:	75 e6                	jne    80f9c7 <ipc_find_env+0xf>
			return envs[i].env_id;
	return 0;
  80f9e1:	b8 00 00 00 00       	mov    $0x0,%eax
  80f9e6:	eb 0b                	jmp    80f9f3 <ipc_find_env+0x3b>
			return envs[i].env_id;
  80f9e8:	6b c0 7c             	imul   $0x7c,%eax,%eax
  80f9eb:	05 00 00 c0 ee       	add    $0xeec00000,%eax
  80f9f0:	8b 40 48             	mov    0x48(%eax),%eax
}
  80f9f3:	5d                   	pop    %ebp
  80f9f4:	c3                   	ret    

0080f9f5 <fd2num>:
// File descriptor manipulators
// --------------------------------------------------------------

int
fd2num(struct Fd *fd)
{
  80f9f5:	f3 0f 1e fb          	endbr32 
  80f9f9:	55                   	push   %ebp
  80f9fa:	89 e5                	mov    %esp,%ebp
	return ((uintptr_t) fd - FDTABLE) / PGSIZE;
  80f9fc:	8b 45 08             	mov    0x8(%ebp),%eax
  80f9ff:	05 00 00 00 30       	add    $0x30000000,%eax
  80fa04:	c1 e8 0c             	shr    $0xc,%eax
}
  80fa07:	5d                   	pop    %ebp
  80fa08:	c3                   	ret    

0080fa09 <fd2data>:

char*
fd2data(struct Fd *fd)
{
  80fa09:	f3 0f 1e fb          	endbr32 
  80fa0d:	55                   	push   %ebp
  80fa0e:	89 e5                	mov    %esp,%ebp
	return ((uintptr_t) fd - FDTABLE) / PGSIZE;
  80fa10:	8b 45 08             	mov    0x8(%ebp),%eax
  80fa13:	05 00 00 00 30       	add    $0x30000000,%eax
	return INDEX2DATA(fd2num(fd));
  80fa18:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  80fa1d:	2d 00 00 fe 2f       	sub    $0x2ffe0000,%eax
}
  80fa22:	5d                   	pop    %ebp
  80fa23:	c3                   	ret    

0080fa24 <fd_alloc>:
// Returns 0 on success, < 0 on error.  Errors are:
//	-E_MAX_FD: no more file descriptors
// On error, *fd_store is set to 0.
int
fd_alloc(struct Fd **fd_store)
{
  80fa24:	f3 0f 1e fb          	endbr32 
  80fa28:	55                   	push   %ebp
  80fa29:	89 e5                	mov    %esp,%ebp
  80fa2b:	b8 00 00 00 d0       	mov    $0xd0000000,%eax
	int i;
	struct Fd *fd;

	for (i = 0; i < MAXFD; i++) {
		fd = INDEX2FD(i);
		if ((uvpd[PDX(fd)] & PTE_P) == 0 || (uvpt[PGNUM(fd)] & PTE_P) == 0) {
  80fa30:	89 c2                	mov    %eax,%edx
  80fa32:	c1 ea 16             	shr    $0x16,%edx
  80fa35:	8b 14 95 00 d0 7b ef 	mov    -0x10843000(,%edx,4),%edx
  80fa3c:	f6 c2 01             	test   $0x1,%dl
  80fa3f:	74 2d                	je     80fa6e <fd_alloc+0x4a>
  80fa41:	89 c2                	mov    %eax,%edx
  80fa43:	c1 ea 0c             	shr    $0xc,%edx
  80fa46:	8b 14 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%edx
  80fa4d:	f6 c2 01             	test   $0x1,%dl
  80fa50:	74 1c                	je     80fa6e <fd_alloc+0x4a>
  80fa52:	05 00 10 00 00       	add    $0x1000,%eax
	for (i = 0; i < MAXFD; i++) {
  80fa57:	3d 00 00 02 d0       	cmp    $0xd0020000,%eax
  80fa5c:	75 d2                	jne    80fa30 <fd_alloc+0xc>
			*fd_store = fd;
			return 0;
		}
	}
	*fd_store = 0;
  80fa5e:	8b 45 08             	mov    0x8(%ebp),%eax
  80fa61:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	return -E_MAX_OPEN;
  80fa67:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  80fa6c:	eb 0a                	jmp    80fa78 <fd_alloc+0x54>
			*fd_store = fd;
  80fa6e:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80fa71:	89 01                	mov    %eax,(%ecx)
			return 0;
  80fa73:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80fa78:	5d                   	pop    %ebp
  80fa79:	c3                   	ret    

0080fa7a <fd_lookup>:
// Returns 0 on success (the page is in range and mapped), < 0 on error.
// Errors are:
//	-E_INVAL: fdnum was either not in range or not mapped.
int
fd_lookup(int fdnum, struct Fd **fd_store)
{
  80fa7a:	f3 0f 1e fb          	endbr32 
  80fa7e:	55                   	push   %ebp
  80fa7f:	89 e5                	mov    %esp,%ebp
  80fa81:	8b 45 08             	mov    0x8(%ebp),%eax
	struct Fd *fd;

	if (fdnum < 0 || fdnum >= MAXFD) {
  80fa84:	83 f8 1f             	cmp    $0x1f,%eax
  80fa87:	77 30                	ja     80fab9 <fd_lookup+0x3f>
		if (debug)
			cprintf("[%08x] bad fd %d\n", thisenv->env_id, fdnum);
		return -E_INVAL;
	}
	fd = INDEX2FD(fdnum);
  80fa89:	c1 e0 0c             	shl    $0xc,%eax
  80fa8c:	2d 00 00 00 30       	sub    $0x30000000,%eax
	if (!(uvpd[PDX(fd)] & PTE_P) || !(uvpt[PGNUM(fd)] & PTE_P)) {
  80fa91:	8b 15 00 dd 7b ef    	mov    0xef7bdd00,%edx
  80fa97:	f6 c2 01             	test   $0x1,%dl
  80fa9a:	74 24                	je     80fac0 <fd_lookup+0x46>
  80fa9c:	89 c2                	mov    %eax,%edx
  80fa9e:	c1 ea 0c             	shr    $0xc,%edx
  80faa1:	8b 14 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%edx
  80faa8:	f6 c2 01             	test   $0x1,%dl
  80faab:	74 1a                	je     80fac7 <fd_lookup+0x4d>
		if (debug)
			cprintf("[%08x] closed fd %d\n", thisenv->env_id, fdnum);
		return -E_INVAL;
	}
	*fd_store = fd;
  80faad:	8b 55 0c             	mov    0xc(%ebp),%edx
  80fab0:	89 02                	mov    %eax,(%edx)
	return 0;
  80fab2:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80fab7:	5d                   	pop    %ebp
  80fab8:	c3                   	ret    
		return -E_INVAL;
  80fab9:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  80fabe:	eb f7                	jmp    80fab7 <fd_lookup+0x3d>
		return -E_INVAL;
  80fac0:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  80fac5:	eb f0                	jmp    80fab7 <fd_lookup+0x3d>
  80fac7:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  80facc:	eb e9                	jmp    80fab7 <fd_lookup+0x3d>

0080face <dev_lookup>:
	0
};

int
dev_lookup(int dev_id, struct Dev **dev)
{
  80face:	f3 0f 1e fb          	endbr32 
  80fad2:	55                   	push   %ebp
  80fad3:	89 e5                	mov    %esp,%ebp
  80fad5:	83 ec 08             	sub    $0x8,%esp
  80fad8:	8b 4d 08             	mov    0x8(%ebp),%ecx
	int i;
	for (i = 0; devtab[i]; i++)
  80fadb:	ba 00 00 00 00       	mov    $0x0,%edx
  80fae0:	b8 ec 42 81 00       	mov    $0x8142ec,%eax
		if (devtab[i]->dev_id == dev_id) {
  80fae5:	39 08                	cmp    %ecx,(%eax)
  80fae7:	74 38                	je     80fb21 <dev_lookup+0x53>
	for (i = 0; devtab[i]; i++)
  80fae9:	83 c2 01             	add    $0x1,%edx
  80faec:	8b 04 95 a4 3c 81 00 	mov    0x813ca4(,%edx,4),%eax
  80faf3:	85 c0                	test   %eax,%eax
  80faf5:	75 ee                	jne    80fae5 <dev_lookup+0x17>
			*dev = devtab[i];
			return 0;
		}
	cprintf("[%08x] unknown device type %d\n", thisenv->env_id, dev_id);
  80faf7:	a1 5c b2 b3 00       	mov    0xb3b25c,%eax
  80fafc:	8b 40 48             	mov    0x48(%eax),%eax
  80faff:	83 ec 04             	sub    $0x4,%esp
  80fb02:	51                   	push   %ecx
  80fb03:	50                   	push   %eax
  80fb04:	68 28 3c 81 00       	push   $0x813c28
  80fb09:	e8 20 ee ff ff       	call   80e92e <cprintf>
	*dev = 0;
  80fb0e:	8b 45 0c             	mov    0xc(%ebp),%eax
  80fb11:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	return -E_INVAL;
  80fb17:	83 c4 10             	add    $0x10,%esp
  80fb1a:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
}
  80fb1f:	c9                   	leave  
  80fb20:	c3                   	ret    
			*dev = devtab[i];
  80fb21:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80fb24:	89 01                	mov    %eax,(%ecx)
			return 0;
  80fb26:	b8 00 00 00 00       	mov    $0x0,%eax
  80fb2b:	eb f2                	jmp    80fb1f <dev_lookup+0x51>

0080fb2d <fd_close>:
{
  80fb2d:	f3 0f 1e fb          	endbr32 
  80fb31:	55                   	push   %ebp
  80fb32:	89 e5                	mov    %esp,%ebp
  80fb34:	57                   	push   %edi
  80fb35:	56                   	push   %esi
  80fb36:	53                   	push   %ebx
  80fb37:	83 ec 24             	sub    $0x24,%esp
  80fb3a:	8b 75 08             	mov    0x8(%ebp),%esi
  80fb3d:	8b 7d 0c             	mov    0xc(%ebp),%edi
	if ((r = fd_lookup(fd2num(fd), &fd2)) < 0
  80fb40:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80fb43:	50                   	push   %eax
	return ((uintptr_t) fd - FDTABLE) / PGSIZE;
  80fb44:	8d 86 00 00 00 30    	lea    0x30000000(%esi),%eax
  80fb4a:	c1 e8 0c             	shr    $0xc,%eax
	if ((r = fd_lookup(fd2num(fd), &fd2)) < 0
  80fb4d:	50                   	push   %eax
  80fb4e:	e8 27 ff ff ff       	call   80fa7a <fd_lookup>
  80fb53:	89 c3                	mov    %eax,%ebx
  80fb55:	83 c4 10             	add    $0x10,%esp
  80fb58:	85 c0                	test   %eax,%eax
  80fb5a:	78 05                	js     80fb61 <fd_close+0x34>
	    || fd != fd2)
  80fb5c:	39 75 e4             	cmp    %esi,-0x1c(%ebp)
  80fb5f:	74 16                	je     80fb77 <fd_close+0x4a>
		return (must_exist ? r : 0);
  80fb61:	89 f8                	mov    %edi,%eax
  80fb63:	84 c0                	test   %al,%al
  80fb65:	b8 00 00 00 00       	mov    $0x0,%eax
  80fb6a:	0f 44 d8             	cmove  %eax,%ebx
}
  80fb6d:	89 d8                	mov    %ebx,%eax
  80fb6f:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80fb72:	5b                   	pop    %ebx
  80fb73:	5e                   	pop    %esi
  80fb74:	5f                   	pop    %edi
  80fb75:	5d                   	pop    %ebp
  80fb76:	c3                   	ret    
	if ((r = dev_lookup(fd->fd_dev_id, &dev)) >= 0) {
  80fb77:	83 ec 08             	sub    $0x8,%esp
  80fb7a:	8d 45 e0             	lea    -0x20(%ebp),%eax
  80fb7d:	50                   	push   %eax
  80fb7e:	ff 36                	pushl  (%esi)
  80fb80:	e8 49 ff ff ff       	call   80face <dev_lookup>
  80fb85:	89 c3                	mov    %eax,%ebx
  80fb87:	83 c4 10             	add    $0x10,%esp
  80fb8a:	85 c0                	test   %eax,%eax
  80fb8c:	78 1a                	js     80fba8 <fd_close+0x7b>
		if (dev->dev_close)
  80fb8e:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80fb91:	8b 40 10             	mov    0x10(%eax),%eax
			r = 0;
  80fb94:	bb 00 00 00 00       	mov    $0x0,%ebx
		if (dev->dev_close)
  80fb99:	85 c0                	test   %eax,%eax
  80fb9b:	74 0b                	je     80fba8 <fd_close+0x7b>
			r = (*dev->dev_close)(fd);
  80fb9d:	83 ec 0c             	sub    $0xc,%esp
  80fba0:	56                   	push   %esi
  80fba1:	ff d0                	call   *%eax
  80fba3:	89 c3                	mov    %eax,%ebx
  80fba5:	83 c4 10             	add    $0x10,%esp
	(void) sys_page_unmap(0, fd);
  80fba8:	83 ec 08             	sub    $0x8,%esp
  80fbab:	56                   	push   %esi
  80fbac:	6a 00                	push   $0x0
  80fbae:	e8 54 f8 ff ff       	call   80f407 <sys_page_unmap>
	return r;
  80fbb3:	83 c4 10             	add    $0x10,%esp
  80fbb6:	eb b5                	jmp    80fb6d <fd_close+0x40>

0080fbb8 <close>:

int
close(int fdnum)
{
  80fbb8:	f3 0f 1e fb          	endbr32 
  80fbbc:	55                   	push   %ebp
  80fbbd:	89 e5                	mov    %esp,%ebp
  80fbbf:	83 ec 20             	sub    $0x20,%esp
	struct Fd *fd;
	int r;

	if ((r = fd_lookup(fdnum, &fd)) < 0)
  80fbc2:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80fbc5:	50                   	push   %eax
  80fbc6:	ff 75 08             	pushl  0x8(%ebp)
  80fbc9:	e8 ac fe ff ff       	call   80fa7a <fd_lookup>
  80fbce:	83 c4 10             	add    $0x10,%esp
  80fbd1:	85 c0                	test   %eax,%eax
  80fbd3:	79 02                	jns    80fbd7 <close+0x1f>
		return r;
	else
		return fd_close(fd, 1);
}
  80fbd5:	c9                   	leave  
  80fbd6:	c3                   	ret    
		return fd_close(fd, 1);
  80fbd7:	83 ec 08             	sub    $0x8,%esp
  80fbda:	6a 01                	push   $0x1
  80fbdc:	ff 75 f4             	pushl  -0xc(%ebp)
  80fbdf:	e8 49 ff ff ff       	call   80fb2d <fd_close>
  80fbe4:	83 c4 10             	add    $0x10,%esp
  80fbe7:	eb ec                	jmp    80fbd5 <close+0x1d>

0080fbe9 <close_all>:

void
close_all(void)
{
  80fbe9:	f3 0f 1e fb          	endbr32 
  80fbed:	55                   	push   %ebp
  80fbee:	89 e5                	mov    %esp,%ebp
  80fbf0:	53                   	push   %ebx
  80fbf1:	83 ec 04             	sub    $0x4,%esp
	int i;
	for (i = 0; i < MAXFD; i++)
  80fbf4:	bb 00 00 00 00       	mov    $0x0,%ebx
		close(i);
  80fbf9:	83 ec 0c             	sub    $0xc,%esp
  80fbfc:	53                   	push   %ebx
  80fbfd:	e8 b6 ff ff ff       	call   80fbb8 <close>
	for (i = 0; i < MAXFD; i++)
  80fc02:	83 c3 01             	add    $0x1,%ebx
  80fc05:	83 c4 10             	add    $0x10,%esp
  80fc08:	83 fb 20             	cmp    $0x20,%ebx
  80fc0b:	75 ec                	jne    80fbf9 <close_all+0x10>
}
  80fc0d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80fc10:	c9                   	leave  
  80fc11:	c3                   	ret    

0080fc12 <dup>:
// file and the file offset of the other.
// Closes any previously open file descriptor at 'newfdnum'.
// This is implemented using virtual memory tricks (of course!).
int
dup(int oldfdnum, int newfdnum)
{
  80fc12:	f3 0f 1e fb          	endbr32 
  80fc16:	55                   	push   %ebp
  80fc17:	89 e5                	mov    %esp,%ebp
  80fc19:	57                   	push   %edi
  80fc1a:	56                   	push   %esi
  80fc1b:	53                   	push   %ebx
  80fc1c:	83 ec 24             	sub    $0x24,%esp
	int r;
	char *ova, *nva;
	pte_t pte;
	struct Fd *oldfd, *newfd;

	if ((r = fd_lookup(oldfdnum, &oldfd)) < 0)
  80fc1f:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80fc22:	50                   	push   %eax
  80fc23:	ff 75 08             	pushl  0x8(%ebp)
  80fc26:	e8 4f fe ff ff       	call   80fa7a <fd_lookup>
  80fc2b:	89 c3                	mov    %eax,%ebx
  80fc2d:	83 c4 10             	add    $0x10,%esp
  80fc30:	85 c0                	test   %eax,%eax
  80fc32:	0f 88 81 00 00 00    	js     80fcb9 <dup+0xa7>
		return r;
	close(newfdnum);
  80fc38:	83 ec 0c             	sub    $0xc,%esp
  80fc3b:	ff 75 0c             	pushl  0xc(%ebp)
  80fc3e:	e8 75 ff ff ff       	call   80fbb8 <close>

	newfd = INDEX2FD(newfdnum);
  80fc43:	8b 75 0c             	mov    0xc(%ebp),%esi
  80fc46:	c1 e6 0c             	shl    $0xc,%esi
  80fc49:	81 ee 00 00 00 30    	sub    $0x30000000,%esi
	ova = fd2data(oldfd);
  80fc4f:	83 c4 04             	add    $0x4,%esp
  80fc52:	ff 75 e4             	pushl  -0x1c(%ebp)
  80fc55:	e8 af fd ff ff       	call   80fa09 <fd2data>
  80fc5a:	89 c3                	mov    %eax,%ebx
	nva = fd2data(newfd);
  80fc5c:	89 34 24             	mov    %esi,(%esp)
  80fc5f:	e8 a5 fd ff ff       	call   80fa09 <fd2data>
  80fc64:	83 c4 10             	add    $0x10,%esp
  80fc67:	89 c7                	mov    %eax,%edi

	if ((uvpd[PDX(ova)] & PTE_P) && (uvpt[PGNUM(ova)] & PTE_P))
  80fc69:	89 d8                	mov    %ebx,%eax
  80fc6b:	c1 e8 16             	shr    $0x16,%eax
  80fc6e:	8b 04 85 00 d0 7b ef 	mov    -0x10843000(,%eax,4),%eax
  80fc75:	a8 01                	test   $0x1,%al
  80fc77:	74 11                	je     80fc8a <dup+0x78>
  80fc79:	89 d8                	mov    %ebx,%eax
  80fc7b:	c1 e8 0c             	shr    $0xc,%eax
  80fc7e:	8b 14 85 00 00 40 ef 	mov    -0x10c00000(,%eax,4),%edx
  80fc85:	f6 c2 01             	test   $0x1,%dl
  80fc88:	75 39                	jne    80fcc3 <dup+0xb1>
		if ((r = sys_page_map(0, ova, 0, nva, uvpt[PGNUM(ova)] & PTE_SYSCALL)) < 0)
			goto err;
	if ((r = sys_page_map(0, oldfd, 0, newfd, uvpt[PGNUM(oldfd)] & PTE_SYSCALL)) < 0)
  80fc8a:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80fc8d:	89 d0                	mov    %edx,%eax
  80fc8f:	c1 e8 0c             	shr    $0xc,%eax
  80fc92:	8b 04 85 00 00 40 ef 	mov    -0x10c00000(,%eax,4),%eax
  80fc99:	83 ec 0c             	sub    $0xc,%esp
  80fc9c:	25 07 0e 00 00       	and    $0xe07,%eax
  80fca1:	50                   	push   %eax
  80fca2:	56                   	push   %esi
  80fca3:	6a 00                	push   $0x0
  80fca5:	52                   	push   %edx
  80fca6:	6a 00                	push   $0x0
  80fca8:	e8 14 f7 ff ff       	call   80f3c1 <sys_page_map>
  80fcad:	89 c3                	mov    %eax,%ebx
  80fcaf:	83 c4 20             	add    $0x20,%esp
  80fcb2:	85 c0                	test   %eax,%eax
  80fcb4:	78 31                	js     80fce7 <dup+0xd5>
		goto err;

	return newfdnum;
  80fcb6:	8b 5d 0c             	mov    0xc(%ebp),%ebx

err:
	sys_page_unmap(0, newfd);
	sys_page_unmap(0, nva);
	return r;
}
  80fcb9:	89 d8                	mov    %ebx,%eax
  80fcbb:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80fcbe:	5b                   	pop    %ebx
  80fcbf:	5e                   	pop    %esi
  80fcc0:	5f                   	pop    %edi
  80fcc1:	5d                   	pop    %ebp
  80fcc2:	c3                   	ret    
		if ((r = sys_page_map(0, ova, 0, nva, uvpt[PGNUM(ova)] & PTE_SYSCALL)) < 0)
  80fcc3:	8b 04 85 00 00 40 ef 	mov    -0x10c00000(,%eax,4),%eax
  80fcca:	83 ec 0c             	sub    $0xc,%esp
  80fccd:	25 07 0e 00 00       	and    $0xe07,%eax
  80fcd2:	50                   	push   %eax
  80fcd3:	57                   	push   %edi
  80fcd4:	6a 00                	push   $0x0
  80fcd6:	53                   	push   %ebx
  80fcd7:	6a 00                	push   $0x0
  80fcd9:	e8 e3 f6 ff ff       	call   80f3c1 <sys_page_map>
  80fcde:	89 c3                	mov    %eax,%ebx
  80fce0:	83 c4 20             	add    $0x20,%esp
  80fce3:	85 c0                	test   %eax,%eax
  80fce5:	79 a3                	jns    80fc8a <dup+0x78>
	sys_page_unmap(0, newfd);
  80fce7:	83 ec 08             	sub    $0x8,%esp
  80fcea:	56                   	push   %esi
  80fceb:	6a 00                	push   $0x0
  80fced:	e8 15 f7 ff ff       	call   80f407 <sys_page_unmap>
	sys_page_unmap(0, nva);
  80fcf2:	83 c4 08             	add    $0x8,%esp
  80fcf5:	57                   	push   %edi
  80fcf6:	6a 00                	push   $0x0
  80fcf8:	e8 0a f7 ff ff       	call   80f407 <sys_page_unmap>
	return r;
  80fcfd:	83 c4 10             	add    $0x10,%esp
  80fd00:	eb b7                	jmp    80fcb9 <dup+0xa7>

0080fd02 <read>:

ssize_t
read(int fdnum, void *buf, size_t n)
{
  80fd02:	f3 0f 1e fb          	endbr32 
  80fd06:	55                   	push   %ebp
  80fd07:	89 e5                	mov    %esp,%ebp
  80fd09:	53                   	push   %ebx
  80fd0a:	83 ec 1c             	sub    $0x1c,%esp
  80fd0d:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0
  80fd10:	8d 45 f0             	lea    -0x10(%ebp),%eax
  80fd13:	50                   	push   %eax
  80fd14:	53                   	push   %ebx
  80fd15:	e8 60 fd ff ff       	call   80fa7a <fd_lookup>
  80fd1a:	83 c4 10             	add    $0x10,%esp
  80fd1d:	85 c0                	test   %eax,%eax
  80fd1f:	78 3f                	js     80fd60 <read+0x5e>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  80fd21:	83 ec 08             	sub    $0x8,%esp
  80fd24:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80fd27:	50                   	push   %eax
  80fd28:	8b 45 f0             	mov    -0x10(%ebp),%eax
  80fd2b:	ff 30                	pushl  (%eax)
  80fd2d:	e8 9c fd ff ff       	call   80face <dev_lookup>
  80fd32:	83 c4 10             	add    $0x10,%esp
  80fd35:	85 c0                	test   %eax,%eax
  80fd37:	78 27                	js     80fd60 <read+0x5e>
		return r;
	if ((fd->fd_omode & O_ACCMODE) == O_WRONLY) {
  80fd39:	8b 55 f0             	mov    -0x10(%ebp),%edx
  80fd3c:	8b 42 08             	mov    0x8(%edx),%eax
  80fd3f:	83 e0 03             	and    $0x3,%eax
  80fd42:	83 f8 01             	cmp    $0x1,%eax
  80fd45:	74 1e                	je     80fd65 <read+0x63>
		cprintf("[%08x] read %d -- bad mode\n", thisenv->env_id, fdnum);
		return -E_INVAL;
	}
	if (!dev->dev_read)
  80fd47:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80fd4a:	8b 40 08             	mov    0x8(%eax),%eax
  80fd4d:	85 c0                	test   %eax,%eax
  80fd4f:	74 35                	je     80fd86 <read+0x84>
		return -E_NOT_SUPP;
	return (*dev->dev_read)(fd, buf, n);
  80fd51:	83 ec 04             	sub    $0x4,%esp
  80fd54:	ff 75 10             	pushl  0x10(%ebp)
  80fd57:	ff 75 0c             	pushl  0xc(%ebp)
  80fd5a:	52                   	push   %edx
  80fd5b:	ff d0                	call   *%eax
  80fd5d:	83 c4 10             	add    $0x10,%esp
}
  80fd60:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80fd63:	c9                   	leave  
  80fd64:	c3                   	ret    
		cprintf("[%08x] read %d -- bad mode\n", thisenv->env_id, fdnum);
  80fd65:	a1 5c b2 b3 00       	mov    0xb3b25c,%eax
  80fd6a:	8b 40 48             	mov    0x48(%eax),%eax
  80fd6d:	83 ec 04             	sub    $0x4,%esp
  80fd70:	53                   	push   %ebx
  80fd71:	50                   	push   %eax
  80fd72:	68 69 3c 81 00       	push   $0x813c69
  80fd77:	e8 b2 eb ff ff       	call   80e92e <cprintf>
		return -E_INVAL;
  80fd7c:	83 c4 10             	add    $0x10,%esp
  80fd7f:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  80fd84:	eb da                	jmp    80fd60 <read+0x5e>
		return -E_NOT_SUPP;
  80fd86:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
  80fd8b:	eb d3                	jmp    80fd60 <read+0x5e>

0080fd8d <readn>:

ssize_t
readn(int fdnum, void *buf, size_t n)
{
  80fd8d:	f3 0f 1e fb          	endbr32 
  80fd91:	55                   	push   %ebp
  80fd92:	89 e5                	mov    %esp,%ebp
  80fd94:	57                   	push   %edi
  80fd95:	56                   	push   %esi
  80fd96:	53                   	push   %ebx
  80fd97:	83 ec 0c             	sub    $0xc,%esp
  80fd9a:	8b 7d 08             	mov    0x8(%ebp),%edi
  80fd9d:	8b 75 10             	mov    0x10(%ebp),%esi
	int m, tot;

	for (tot = 0; tot < n; tot += m) {
  80fda0:	bb 00 00 00 00       	mov    $0x0,%ebx
  80fda5:	eb 02                	jmp    80fda9 <readn+0x1c>
  80fda7:	01 c3                	add    %eax,%ebx
  80fda9:	39 f3                	cmp    %esi,%ebx
  80fdab:	73 21                	jae    80fdce <readn+0x41>
		m = read(fdnum, (char*)buf + tot, n - tot);
  80fdad:	83 ec 04             	sub    $0x4,%esp
  80fdb0:	89 f0                	mov    %esi,%eax
  80fdb2:	29 d8                	sub    %ebx,%eax
  80fdb4:	50                   	push   %eax
  80fdb5:	89 d8                	mov    %ebx,%eax
  80fdb7:	03 45 0c             	add    0xc(%ebp),%eax
  80fdba:	50                   	push   %eax
  80fdbb:	57                   	push   %edi
  80fdbc:	e8 41 ff ff ff       	call   80fd02 <read>
		if (m < 0)
  80fdc1:	83 c4 10             	add    $0x10,%esp
  80fdc4:	85 c0                	test   %eax,%eax
  80fdc6:	78 04                	js     80fdcc <readn+0x3f>
			return m;
		if (m == 0)
  80fdc8:	75 dd                	jne    80fda7 <readn+0x1a>
  80fdca:	eb 02                	jmp    80fdce <readn+0x41>
		m = read(fdnum, (char*)buf + tot, n - tot);
  80fdcc:	89 c3                	mov    %eax,%ebx
			break;
	}
	return tot;
}
  80fdce:	89 d8                	mov    %ebx,%eax
  80fdd0:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80fdd3:	5b                   	pop    %ebx
  80fdd4:	5e                   	pop    %esi
  80fdd5:	5f                   	pop    %edi
  80fdd6:	5d                   	pop    %ebp
  80fdd7:	c3                   	ret    

0080fdd8 <write>:

ssize_t
write(int fdnum, const void *buf, size_t n)
{
  80fdd8:	f3 0f 1e fb          	endbr32 
  80fddc:	55                   	push   %ebp
  80fddd:	89 e5                	mov    %esp,%ebp
  80fddf:	53                   	push   %ebx
  80fde0:	83 ec 1c             	sub    $0x1c,%esp
  80fde3:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0
  80fde6:	8d 45 f0             	lea    -0x10(%ebp),%eax
  80fde9:	50                   	push   %eax
  80fdea:	53                   	push   %ebx
  80fdeb:	e8 8a fc ff ff       	call   80fa7a <fd_lookup>
  80fdf0:	83 c4 10             	add    $0x10,%esp
  80fdf3:	85 c0                	test   %eax,%eax
  80fdf5:	78 3a                	js     80fe31 <write+0x59>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  80fdf7:	83 ec 08             	sub    $0x8,%esp
  80fdfa:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80fdfd:	50                   	push   %eax
  80fdfe:	8b 45 f0             	mov    -0x10(%ebp),%eax
  80fe01:	ff 30                	pushl  (%eax)
  80fe03:	e8 c6 fc ff ff       	call   80face <dev_lookup>
  80fe08:	83 c4 10             	add    $0x10,%esp
  80fe0b:	85 c0                	test   %eax,%eax
  80fe0d:	78 22                	js     80fe31 <write+0x59>
		return r;
	if ((fd->fd_omode & O_ACCMODE) == O_RDONLY) {
  80fe0f:	8b 45 f0             	mov    -0x10(%ebp),%eax
  80fe12:	f6 40 08 03          	testb  $0x3,0x8(%eax)
  80fe16:	74 1e                	je     80fe36 <write+0x5e>
		return -E_INVAL;
	}
	if (debug)
		cprintf("write %d %p %d via dev %s\n",
			fdnum, buf, n, dev->dev_name);
	if (!dev->dev_write)
  80fe18:	8b 55 f4             	mov    -0xc(%ebp),%edx
  80fe1b:	8b 52 0c             	mov    0xc(%edx),%edx
  80fe1e:	85 d2                	test   %edx,%edx
  80fe20:	74 35                	je     80fe57 <write+0x7f>
		return -E_NOT_SUPP;
	return (*dev->dev_write)(fd, buf, n);
  80fe22:	83 ec 04             	sub    $0x4,%esp
  80fe25:	ff 75 10             	pushl  0x10(%ebp)
  80fe28:	ff 75 0c             	pushl  0xc(%ebp)
  80fe2b:	50                   	push   %eax
  80fe2c:	ff d2                	call   *%edx
  80fe2e:	83 c4 10             	add    $0x10,%esp
}
  80fe31:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80fe34:	c9                   	leave  
  80fe35:	c3                   	ret    
		cprintf("[%08x] write %d -- bad mode\n", thisenv->env_id, fdnum);
  80fe36:	a1 5c b2 b3 00       	mov    0xb3b25c,%eax
  80fe3b:	8b 40 48             	mov    0x48(%eax),%eax
  80fe3e:	83 ec 04             	sub    $0x4,%esp
  80fe41:	53                   	push   %ebx
  80fe42:	50                   	push   %eax
  80fe43:	68 85 3c 81 00       	push   $0x813c85
  80fe48:	e8 e1 ea ff ff       	call   80e92e <cprintf>
		return -E_INVAL;
  80fe4d:	83 c4 10             	add    $0x10,%esp
  80fe50:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  80fe55:	eb da                	jmp    80fe31 <write+0x59>
		return -E_NOT_SUPP;
  80fe57:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
  80fe5c:	eb d3                	jmp    80fe31 <write+0x59>

0080fe5e <seek>:

int
seek(int fdnum, off_t offset)
{
  80fe5e:	f3 0f 1e fb          	endbr32 
  80fe62:	55                   	push   %ebp
  80fe63:	89 e5                	mov    %esp,%ebp
  80fe65:	83 ec 20             	sub    $0x20,%esp
	int r;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0)
  80fe68:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80fe6b:	50                   	push   %eax
  80fe6c:	ff 75 08             	pushl  0x8(%ebp)
  80fe6f:	e8 06 fc ff ff       	call   80fa7a <fd_lookup>
  80fe74:	83 c4 10             	add    $0x10,%esp
  80fe77:	85 c0                	test   %eax,%eax
  80fe79:	78 0e                	js     80fe89 <seek+0x2b>
		return r;
	fd->fd_offset = offset;
  80fe7b:	8b 55 0c             	mov    0xc(%ebp),%edx
  80fe7e:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80fe81:	89 50 04             	mov    %edx,0x4(%eax)
	return 0;
  80fe84:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80fe89:	c9                   	leave  
  80fe8a:	c3                   	ret    

0080fe8b <ftruncate>:

int
ftruncate(int fdnum, off_t newsize)
{
  80fe8b:	f3 0f 1e fb          	endbr32 
  80fe8f:	55                   	push   %ebp
  80fe90:	89 e5                	mov    %esp,%ebp
  80fe92:	53                   	push   %ebx
  80fe93:	83 ec 1c             	sub    $0x1c,%esp
  80fe96:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int r;
	struct Dev *dev;
	struct Fd *fd;
	if ((r = fd_lookup(fdnum, &fd)) < 0
  80fe99:	8d 45 f0             	lea    -0x10(%ebp),%eax
  80fe9c:	50                   	push   %eax
  80fe9d:	53                   	push   %ebx
  80fe9e:	e8 d7 fb ff ff       	call   80fa7a <fd_lookup>
  80fea3:	83 c4 10             	add    $0x10,%esp
  80fea6:	85 c0                	test   %eax,%eax
  80fea8:	78 37                	js     80fee1 <ftruncate+0x56>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  80feaa:	83 ec 08             	sub    $0x8,%esp
  80fead:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80feb0:	50                   	push   %eax
  80feb1:	8b 45 f0             	mov    -0x10(%ebp),%eax
  80feb4:	ff 30                	pushl  (%eax)
  80feb6:	e8 13 fc ff ff       	call   80face <dev_lookup>
  80febb:	83 c4 10             	add    $0x10,%esp
  80febe:	85 c0                	test   %eax,%eax
  80fec0:	78 1f                	js     80fee1 <ftruncate+0x56>
		return r;
	if ((fd->fd_omode & O_ACCMODE) == O_RDONLY) {
  80fec2:	8b 45 f0             	mov    -0x10(%ebp),%eax
  80fec5:	f6 40 08 03          	testb  $0x3,0x8(%eax)
  80fec9:	74 1b                	je     80fee6 <ftruncate+0x5b>
		cprintf("[%08x] ftruncate %d -- bad mode\n",
			thisenv->env_id, fdnum);
		return -E_INVAL;
	}
	if (!dev->dev_trunc)
  80fecb:	8b 55 f4             	mov    -0xc(%ebp),%edx
  80fece:	8b 52 18             	mov    0x18(%edx),%edx
  80fed1:	85 d2                	test   %edx,%edx
  80fed3:	74 32                	je     80ff07 <ftruncate+0x7c>
		return -E_NOT_SUPP;
	return (*dev->dev_trunc)(fd, newsize);
  80fed5:	83 ec 08             	sub    $0x8,%esp
  80fed8:	ff 75 0c             	pushl  0xc(%ebp)
  80fedb:	50                   	push   %eax
  80fedc:	ff d2                	call   *%edx
  80fede:	83 c4 10             	add    $0x10,%esp
}
  80fee1:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80fee4:	c9                   	leave  
  80fee5:	c3                   	ret    
			thisenv->env_id, fdnum);
  80fee6:	a1 5c b2 b3 00       	mov    0xb3b25c,%eax
		cprintf("[%08x] ftruncate %d -- bad mode\n",
  80feeb:	8b 40 48             	mov    0x48(%eax),%eax
  80feee:	83 ec 04             	sub    $0x4,%esp
  80fef1:	53                   	push   %ebx
  80fef2:	50                   	push   %eax
  80fef3:	68 48 3c 81 00       	push   $0x813c48
  80fef8:	e8 31 ea ff ff       	call   80e92e <cprintf>
		return -E_INVAL;
  80fefd:	83 c4 10             	add    $0x10,%esp
  80ff00:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  80ff05:	eb da                	jmp    80fee1 <ftruncate+0x56>
		return -E_NOT_SUPP;
  80ff07:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
  80ff0c:	eb d3                	jmp    80fee1 <ftruncate+0x56>

0080ff0e <fstat>:

int
fstat(int fdnum, struct Stat *stat)
{
  80ff0e:	f3 0f 1e fb          	endbr32 
  80ff12:	55                   	push   %ebp
  80ff13:	89 e5                	mov    %esp,%ebp
  80ff15:	53                   	push   %ebx
  80ff16:	83 ec 1c             	sub    $0x1c,%esp
  80ff19:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0
  80ff1c:	8d 45 f0             	lea    -0x10(%ebp),%eax
  80ff1f:	50                   	push   %eax
  80ff20:	ff 75 08             	pushl  0x8(%ebp)
  80ff23:	e8 52 fb ff ff       	call   80fa7a <fd_lookup>
  80ff28:	83 c4 10             	add    $0x10,%esp
  80ff2b:	85 c0                	test   %eax,%eax
  80ff2d:	78 4b                	js     80ff7a <fstat+0x6c>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  80ff2f:	83 ec 08             	sub    $0x8,%esp
  80ff32:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80ff35:	50                   	push   %eax
  80ff36:	8b 45 f0             	mov    -0x10(%ebp),%eax
  80ff39:	ff 30                	pushl  (%eax)
  80ff3b:	e8 8e fb ff ff       	call   80face <dev_lookup>
  80ff40:	83 c4 10             	add    $0x10,%esp
  80ff43:	85 c0                	test   %eax,%eax
  80ff45:	78 33                	js     80ff7a <fstat+0x6c>
		return r;
	if (!dev->dev_stat)
  80ff47:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80ff4a:	83 78 14 00          	cmpl   $0x0,0x14(%eax)
  80ff4e:	74 2f                	je     80ff7f <fstat+0x71>
		return -E_NOT_SUPP;
	stat->st_name[0] = 0;
  80ff50:	c6 03 00             	movb   $0x0,(%ebx)
	stat->st_size = 0;
  80ff53:	c7 83 80 00 00 00 00 	movl   $0x0,0x80(%ebx)
  80ff5a:	00 00 00 
	stat->st_isdir = 0;
  80ff5d:	c7 83 84 00 00 00 00 	movl   $0x0,0x84(%ebx)
  80ff64:	00 00 00 
	stat->st_dev = dev;
  80ff67:	89 83 88 00 00 00    	mov    %eax,0x88(%ebx)
	return (*dev->dev_stat)(fd, stat);
  80ff6d:	83 ec 08             	sub    $0x8,%esp
  80ff70:	53                   	push   %ebx
  80ff71:	ff 75 f0             	pushl  -0x10(%ebp)
  80ff74:	ff 50 14             	call   *0x14(%eax)
  80ff77:	83 c4 10             	add    $0x10,%esp
}
  80ff7a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80ff7d:	c9                   	leave  
  80ff7e:	c3                   	ret    
		return -E_NOT_SUPP;
  80ff7f:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
  80ff84:	eb f4                	jmp    80ff7a <fstat+0x6c>

0080ff86 <stat>:

int
stat(const char *path, struct Stat *stat)
{
  80ff86:	f3 0f 1e fb          	endbr32 
  80ff8a:	55                   	push   %ebp
  80ff8b:	89 e5                	mov    %esp,%ebp
  80ff8d:	56                   	push   %esi
  80ff8e:	53                   	push   %ebx
	int fd, r;

	if ((fd = open(path, O_RDONLY)) < 0)
  80ff8f:	83 ec 08             	sub    $0x8,%esp
  80ff92:	6a 00                	push   $0x0
  80ff94:	ff 75 08             	pushl  0x8(%ebp)
  80ff97:	e8 fb 01 00 00       	call   810197 <open>
  80ff9c:	89 c3                	mov    %eax,%ebx
  80ff9e:	83 c4 10             	add    $0x10,%esp
  80ffa1:	85 c0                	test   %eax,%eax
  80ffa3:	78 1b                	js     80ffc0 <stat+0x3a>
		return fd;
	r = fstat(fd, stat);
  80ffa5:	83 ec 08             	sub    $0x8,%esp
  80ffa8:	ff 75 0c             	pushl  0xc(%ebp)
  80ffab:	50                   	push   %eax
  80ffac:	e8 5d ff ff ff       	call   80ff0e <fstat>
  80ffb1:	89 c6                	mov    %eax,%esi
	close(fd);
  80ffb3:	89 1c 24             	mov    %ebx,(%esp)
  80ffb6:	e8 fd fb ff ff       	call   80fbb8 <close>
	return r;
  80ffbb:	83 c4 10             	add    $0x10,%esp
  80ffbe:	89 f3                	mov    %esi,%ebx
}
  80ffc0:	89 d8                	mov    %ebx,%eax
  80ffc2:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80ffc5:	5b                   	pop    %ebx
  80ffc6:	5e                   	pop    %esi
  80ffc7:	5d                   	pop    %ebp
  80ffc8:	c3                   	ret    

0080ffc9 <fsipc>:
// type: request code, passed as the simple integer IPC value.
// dstva: virtual address at which to receive reply page, 0 if none.
// Returns result from the file server.
static int
fsipc(unsigned type, void *dstva)
{
  80ffc9:	55                   	push   %ebp
  80ffca:	89 e5                	mov    %esp,%ebp
  80ffcc:	56                   	push   %esi
  80ffcd:	53                   	push   %ebx
  80ffce:	89 c6                	mov    %eax,%esi
  80ffd0:	89 d3                	mov    %edx,%ebx
	static envid_t fsenv;
	if (fsenv == 0)
  80ffd2:	83 3d cc b1 b3 00 00 	cmpl   $0x0,0xb3b1cc
  80ffd9:	74 27                	je     810002 <fsipc+0x39>
	static_assert(sizeof(fsipcbuf) == PGSIZE);

	if (debug)
		cprintf("[%08x] fsipc %d %08x\n", thisenv->env_id, type, *(uint32_t *)&fsipcbuf);

	ipc_send(fsenv, type, &fsipcbuf, PTE_P | PTE_W | PTE_U);
  80ffdb:	6a 07                	push   $0x7
  80ffdd:	68 00 c0 b3 00       	push   $0xb3c000
  80ffe2:	56                   	push   %esi
  80ffe3:	ff 35 cc b1 b3 00    	pushl  0xb3b1cc
  80ffe9:	e8 72 f9 ff ff       	call   80f960 <ipc_send>
	return ipc_recv(NULL, dstva, NULL);
  80ffee:	83 c4 0c             	add    $0xc,%esp
  80fff1:	6a 00                	push   $0x0
  80fff3:	53                   	push   %ebx
  80fff4:	6a 00                	push   $0x0
  80fff6:	e8 f1 f8 ff ff       	call   80f8ec <ipc_recv>
}
  80fffb:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80fffe:	5b                   	pop    %ebx
  80ffff:	5e                   	pop    %esi
  810000:	5d                   	pop    %ebp
  810001:	c3                   	ret    
		fsenv = ipc_find_env(ENV_TYPE_FS);
  810002:	83 ec 0c             	sub    $0xc,%esp
  810005:	6a 01                	push   $0x1
  810007:	e8 ac f9 ff ff       	call   80f9b8 <ipc_find_env>
  81000c:	a3 cc b1 b3 00       	mov    %eax,0xb3b1cc
  810011:	83 c4 10             	add    $0x10,%esp
  810014:	eb c5                	jmp    80ffdb <fsipc+0x12>

00810016 <devfile_trunc>:
}

// Truncate or extend an open file to 'size' bytes
static int
devfile_trunc(struct Fd *fd, off_t newsize)
{
  810016:	f3 0f 1e fb          	endbr32 
  81001a:	55                   	push   %ebp
  81001b:	89 e5                	mov    %esp,%ebp
  81001d:	83 ec 08             	sub    $0x8,%esp
	fsipcbuf.set_size.req_fileid = fd->fd_file.id;
  810020:	8b 45 08             	mov    0x8(%ebp),%eax
  810023:	8b 40 0c             	mov    0xc(%eax),%eax
  810026:	a3 00 c0 b3 00       	mov    %eax,0xb3c000
	fsipcbuf.set_size.req_size = newsize;
  81002b:	8b 45 0c             	mov    0xc(%ebp),%eax
  81002e:	a3 04 c0 b3 00       	mov    %eax,0xb3c004
	return fsipc(FSREQ_SET_SIZE, NULL);
  810033:	ba 00 00 00 00       	mov    $0x0,%edx
  810038:	b8 02 00 00 00       	mov    $0x2,%eax
  81003d:	e8 87 ff ff ff       	call   80ffc9 <fsipc>
}
  810042:	c9                   	leave  
  810043:	c3                   	ret    

00810044 <devfile_flush>:
{
  810044:	f3 0f 1e fb          	endbr32 
  810048:	55                   	push   %ebp
  810049:	89 e5                	mov    %esp,%ebp
  81004b:	83 ec 08             	sub    $0x8,%esp
	fsipcbuf.flush.req_fileid = fd->fd_file.id;
  81004e:	8b 45 08             	mov    0x8(%ebp),%eax
  810051:	8b 40 0c             	mov    0xc(%eax),%eax
  810054:	a3 00 c0 b3 00       	mov    %eax,0xb3c000
	return fsipc(FSREQ_FLUSH, NULL);
  810059:	ba 00 00 00 00       	mov    $0x0,%edx
  81005e:	b8 06 00 00 00       	mov    $0x6,%eax
  810063:	e8 61 ff ff ff       	call   80ffc9 <fsipc>
}
  810068:	c9                   	leave  
  810069:	c3                   	ret    

0081006a <devfile_stat>:
{
  81006a:	f3 0f 1e fb          	endbr32 
  81006e:	55                   	push   %ebp
  81006f:	89 e5                	mov    %esp,%ebp
  810071:	53                   	push   %ebx
  810072:	83 ec 04             	sub    $0x4,%esp
  810075:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	fsipcbuf.stat.req_fileid = fd->fd_file.id;
  810078:	8b 45 08             	mov    0x8(%ebp),%eax
  81007b:	8b 40 0c             	mov    0xc(%eax),%eax
  81007e:	a3 00 c0 b3 00       	mov    %eax,0xb3c000
	if ((r = fsipc(FSREQ_STAT, NULL)) < 0)
  810083:	ba 00 00 00 00       	mov    $0x0,%edx
  810088:	b8 05 00 00 00       	mov    $0x5,%eax
  81008d:	e8 37 ff ff ff       	call   80ffc9 <fsipc>
  810092:	85 c0                	test   %eax,%eax
  810094:	78 2c                	js     8100c2 <devfile_stat+0x58>
	strcpy(st->st_name, fsipcbuf.statRet.ret_name);
  810096:	83 ec 08             	sub    $0x8,%esp
  810099:	68 00 c0 b3 00       	push   $0xb3c000
  81009e:	53                   	push   %ebx
  81009f:	e8 94 ee ff ff       	call   80ef38 <strcpy>
	st->st_size = fsipcbuf.statRet.ret_size;
  8100a4:	a1 80 c0 b3 00       	mov    0xb3c080,%eax
  8100a9:	89 83 80 00 00 00    	mov    %eax,0x80(%ebx)
	st->st_isdir = fsipcbuf.statRet.ret_isdir;
  8100af:	a1 84 c0 b3 00       	mov    0xb3c084,%eax
  8100b4:	89 83 84 00 00 00    	mov    %eax,0x84(%ebx)
	return 0;
  8100ba:	83 c4 10             	add    $0x10,%esp
  8100bd:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8100c2:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  8100c5:	c9                   	leave  
  8100c6:	c3                   	ret    

008100c7 <devfile_write>:
{
  8100c7:	f3 0f 1e fb          	endbr32 
  8100cb:	55                   	push   %ebp
  8100cc:	89 e5                	mov    %esp,%ebp
  8100ce:	83 ec 0c             	sub    $0xc,%esp
  8100d1:	8b 45 10             	mov    0x10(%ebp),%eax
	fsipcbuf.write.req_fileid = fd->fd_file.id;
  8100d4:	8b 55 08             	mov    0x8(%ebp),%edx
  8100d7:	8b 52 0c             	mov    0xc(%edx),%edx
  8100da:	89 15 00 c0 b3 00    	mov    %edx,0xb3c000
    fsipcbuf.write.req_n = MIN(n, PGSIZE);
  8100e0:	3d 00 10 00 00       	cmp    $0x1000,%eax
  8100e5:	ba 00 10 00 00       	mov    $0x1000,%edx
  8100ea:	0f 47 c2             	cmova  %edx,%eax
  8100ed:	a3 04 c0 b3 00       	mov    %eax,0xb3c004
    memmove(fsipcbuf.write.req_buf, buf, fsipcbuf.write.req_n);
  8100f2:	50                   	push   %eax
  8100f3:	ff 75 0c             	pushl  0xc(%ebp)
  8100f6:	68 08 c0 b3 00       	push   $0xb3c008
  8100fb:	e8 ee ef ff ff       	call   80f0ee <memmove>
    int r = fsipc(FSREQ_WRITE, NULL);
  810100:	ba 00 00 00 00       	mov    $0x0,%edx
  810105:	b8 04 00 00 00       	mov    $0x4,%eax
  81010a:	e8 ba fe ff ff       	call   80ffc9 <fsipc>
}
  81010f:	c9                   	leave  
  810110:	c3                   	ret    

00810111 <devfile_read>:
{
  810111:	f3 0f 1e fb          	endbr32 
  810115:	55                   	push   %ebp
  810116:	89 e5                	mov    %esp,%ebp
  810118:	56                   	push   %esi
  810119:	53                   	push   %ebx
  81011a:	8b 75 10             	mov    0x10(%ebp),%esi
	fsipcbuf.read.req_fileid = fd->fd_file.id;
  81011d:	8b 45 08             	mov    0x8(%ebp),%eax
  810120:	8b 40 0c             	mov    0xc(%eax),%eax
  810123:	a3 00 c0 b3 00       	mov    %eax,0xb3c000
	fsipcbuf.read.req_n = n;
  810128:	89 35 04 c0 b3 00    	mov    %esi,0xb3c004
	if ((r = fsipc(FSREQ_READ, NULL)) < 0)
  81012e:	ba 00 00 00 00       	mov    $0x0,%edx
  810133:	b8 03 00 00 00       	mov    $0x3,%eax
  810138:	e8 8c fe ff ff       	call   80ffc9 <fsipc>
  81013d:	89 c3                	mov    %eax,%ebx
  81013f:	85 c0                	test   %eax,%eax
  810141:	78 1f                	js     810162 <devfile_read+0x51>
	assert(r <= n);
  810143:	39 f0                	cmp    %esi,%eax
  810145:	77 24                	ja     81016b <devfile_read+0x5a>
	assert(r <= PGSIZE);
  810147:	3d 00 10 00 00       	cmp    $0x1000,%eax
  81014c:	7f 33                	jg     810181 <devfile_read+0x70>
	memmove(buf, fsipcbuf.readRet.ret_buf, r);
  81014e:	83 ec 04             	sub    $0x4,%esp
  810151:	50                   	push   %eax
  810152:	68 00 c0 b3 00       	push   $0xb3c000
  810157:	ff 75 0c             	pushl  0xc(%ebp)
  81015a:	e8 8f ef ff ff       	call   80f0ee <memmove>
	return r;
  81015f:	83 c4 10             	add    $0x10,%esp
}
  810162:	89 d8                	mov    %ebx,%eax
  810164:	8d 65 f8             	lea    -0x8(%ebp),%esp
  810167:	5b                   	pop    %ebx
  810168:	5e                   	pop    %esi
  810169:	5d                   	pop    %ebp
  81016a:	c3                   	ret    
	assert(r <= n);
  81016b:	68 b8 3c 81 00       	push   $0x813cb8
  810170:	68 8b 29 81 00       	push   $0x81298b
  810175:	6a 7c                	push   $0x7c
  810177:	68 bf 3c 81 00       	push   $0x813cbf
  81017c:	e8 c6 e6 ff ff       	call   80e847 <_panic>
	assert(r <= PGSIZE);
  810181:	68 ca 3c 81 00       	push   $0x813cca
  810186:	68 8b 29 81 00       	push   $0x81298b
  81018b:	6a 7d                	push   $0x7d
  81018d:	68 bf 3c 81 00       	push   $0x813cbf
  810192:	e8 b0 e6 ff ff       	call   80e847 <_panic>

00810197 <open>:
{
  810197:	f3 0f 1e fb          	endbr32 
  81019b:	55                   	push   %ebp
  81019c:	89 e5                	mov    %esp,%ebp
  81019e:	56                   	push   %esi
  81019f:	53                   	push   %ebx
  8101a0:	83 ec 1c             	sub    $0x1c,%esp
  8101a3:	8b 75 08             	mov    0x8(%ebp),%esi
	if (strlen(path) >= MAXPATHLEN)
  8101a6:	56                   	push   %esi
  8101a7:	e8 49 ed ff ff       	call   80eef5 <strlen>
  8101ac:	83 c4 10             	add    $0x10,%esp
  8101af:	3d ff 03 00 00       	cmp    $0x3ff,%eax
  8101b4:	7f 6c                	jg     810222 <open+0x8b>
	if ((r = fd_alloc(&fd)) < 0)
  8101b6:	83 ec 0c             	sub    $0xc,%esp
  8101b9:	8d 45 f4             	lea    -0xc(%ebp),%eax
  8101bc:	50                   	push   %eax
  8101bd:	e8 62 f8 ff ff       	call   80fa24 <fd_alloc>
  8101c2:	89 c3                	mov    %eax,%ebx
  8101c4:	83 c4 10             	add    $0x10,%esp
  8101c7:	85 c0                	test   %eax,%eax
  8101c9:	78 3c                	js     810207 <open+0x70>
	strcpy(fsipcbuf.open.req_path, path);
  8101cb:	83 ec 08             	sub    $0x8,%esp
  8101ce:	56                   	push   %esi
  8101cf:	68 00 c0 b3 00       	push   $0xb3c000
  8101d4:	e8 5f ed ff ff       	call   80ef38 <strcpy>
	fsipcbuf.open.req_omode = mode;
  8101d9:	8b 45 0c             	mov    0xc(%ebp),%eax
  8101dc:	a3 00 c4 b3 00       	mov    %eax,0xb3c400
	if ((r = fsipc(FSREQ_OPEN, fd)) < 0) {
  8101e1:	8b 55 f4             	mov    -0xc(%ebp),%edx
  8101e4:	b8 01 00 00 00       	mov    $0x1,%eax
  8101e9:	e8 db fd ff ff       	call   80ffc9 <fsipc>
  8101ee:	89 c3                	mov    %eax,%ebx
  8101f0:	83 c4 10             	add    $0x10,%esp
  8101f3:	85 c0                	test   %eax,%eax
  8101f5:	78 19                	js     810210 <open+0x79>
	return fd2num(fd);
  8101f7:	83 ec 0c             	sub    $0xc,%esp
  8101fa:	ff 75 f4             	pushl  -0xc(%ebp)
  8101fd:	e8 f3 f7 ff ff       	call   80f9f5 <fd2num>
  810202:	89 c3                	mov    %eax,%ebx
  810204:	83 c4 10             	add    $0x10,%esp
}
  810207:	89 d8                	mov    %ebx,%eax
  810209:	8d 65 f8             	lea    -0x8(%ebp),%esp
  81020c:	5b                   	pop    %ebx
  81020d:	5e                   	pop    %esi
  81020e:	5d                   	pop    %ebp
  81020f:	c3                   	ret    
		fd_close(fd, 0);
  810210:	83 ec 08             	sub    $0x8,%esp
  810213:	6a 00                	push   $0x0
  810215:	ff 75 f4             	pushl  -0xc(%ebp)
  810218:	e8 10 f9 ff ff       	call   80fb2d <fd_close>
		return r;
  81021d:	83 c4 10             	add    $0x10,%esp
  810220:	eb e5                	jmp    810207 <open+0x70>
		return -E_BAD_PATH;
  810222:	bb f4 ff ff ff       	mov    $0xfffffff4,%ebx
  810227:	eb de                	jmp    810207 <open+0x70>

00810229 <sync>:


// Synchronize disk with buffer cache
int
sync(void)
{
  810229:	f3 0f 1e fb          	endbr32 
  81022d:	55                   	push   %ebp
  81022e:	89 e5                	mov    %esp,%ebp
  810230:	83 ec 08             	sub    $0x8,%esp
	// Ask the file server to update the disk
	// by writing any dirty blocks in the buffer cache.

	return fsipc(FSREQ_SYNC, NULL);
  810233:	ba 00 00 00 00       	mov    $0x0,%edx
  810238:	b8 08 00 00 00       	mov    $0x8,%eax
  81023d:	e8 87 fd ff ff       	call   80ffc9 <fsipc>
}
  810242:	c9                   	leave  
  810243:	c3                   	ret    

00810244 <devsock_stat>:
	return nsipc_send(fd->fd_sock.sockid, buf, n, 0);
}

static int
devsock_stat(struct Fd *fd, struct Stat *stat)
{
  810244:	f3 0f 1e fb          	endbr32 
  810248:	55                   	push   %ebp
  810249:	89 e5                	mov    %esp,%ebp
  81024b:	83 ec 10             	sub    $0x10,%esp
	strcpy(stat->st_name, "<sock>");
  81024e:	68 d6 3c 81 00       	push   $0x813cd6
  810253:	ff 75 0c             	pushl  0xc(%ebp)
  810256:	e8 dd ec ff ff       	call   80ef38 <strcpy>
	return 0;
}
  81025b:	b8 00 00 00 00       	mov    $0x0,%eax
  810260:	c9                   	leave  
  810261:	c3                   	ret    

00810262 <devsock_close>:
{
  810262:	f3 0f 1e fb          	endbr32 
  810266:	55                   	push   %ebp
  810267:	89 e5                	mov    %esp,%ebp
  810269:	53                   	push   %ebx
  81026a:	83 ec 10             	sub    $0x10,%esp
  81026d:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (pageref(fd) == 1)
  810270:	53                   	push   %ebx
  810271:	e8 cb 0c 00 00       	call   810f41 <pageref>
  810276:	89 c2                	mov    %eax,%edx
  810278:	83 c4 10             	add    $0x10,%esp
		return 0;
  81027b:	b8 00 00 00 00       	mov    $0x0,%eax
	if (pageref(fd) == 1)
  810280:	83 fa 01             	cmp    $0x1,%edx
  810283:	74 05                	je     81028a <devsock_close+0x28>
}
  810285:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  810288:	c9                   	leave  
  810289:	c3                   	ret    
		return nsipc_close(fd->fd_sock.sockid);
  81028a:	83 ec 0c             	sub    $0xc,%esp
  81028d:	ff 73 0c             	pushl  0xc(%ebx)
  810290:	e8 e3 02 00 00       	call   810578 <nsipc_close>
  810295:	83 c4 10             	add    $0x10,%esp
  810298:	eb eb                	jmp    810285 <devsock_close+0x23>

0081029a <devsock_write>:
{
  81029a:	f3 0f 1e fb          	endbr32 
  81029e:	55                   	push   %ebp
  81029f:	89 e5                	mov    %esp,%ebp
  8102a1:	83 ec 08             	sub    $0x8,%esp
	return nsipc_send(fd->fd_sock.sockid, buf, n, 0);
  8102a4:	6a 00                	push   $0x0
  8102a6:	ff 75 10             	pushl  0x10(%ebp)
  8102a9:	ff 75 0c             	pushl  0xc(%ebp)
  8102ac:	8b 45 08             	mov    0x8(%ebp),%eax
  8102af:	ff 70 0c             	pushl  0xc(%eax)
  8102b2:	e8 b5 03 00 00       	call   81066c <nsipc_send>
}
  8102b7:	c9                   	leave  
  8102b8:	c3                   	ret    

008102b9 <devsock_read>:
{
  8102b9:	f3 0f 1e fb          	endbr32 
  8102bd:	55                   	push   %ebp
  8102be:	89 e5                	mov    %esp,%ebp
  8102c0:	83 ec 08             	sub    $0x8,%esp
	return nsipc_recv(fd->fd_sock.sockid, buf, n, 0);
  8102c3:	6a 00                	push   $0x0
  8102c5:	ff 75 10             	pushl  0x10(%ebp)
  8102c8:	ff 75 0c             	pushl  0xc(%ebp)
  8102cb:	8b 45 08             	mov    0x8(%ebp),%eax
  8102ce:	ff 70 0c             	pushl  0xc(%eax)
  8102d1:	e8 1f 03 00 00       	call   8105f5 <nsipc_recv>
}
  8102d6:	c9                   	leave  
  8102d7:	c3                   	ret    

008102d8 <fd2sockid>:
{
  8102d8:	55                   	push   %ebp
  8102d9:	89 e5                	mov    %esp,%ebp
  8102db:	83 ec 20             	sub    $0x20,%esp
	if ((r = fd_lookup(fd, &sfd)) < 0)
  8102de:	8d 55 f4             	lea    -0xc(%ebp),%edx
  8102e1:	52                   	push   %edx
  8102e2:	50                   	push   %eax
  8102e3:	e8 92 f7 ff ff       	call   80fa7a <fd_lookup>
  8102e8:	83 c4 10             	add    $0x10,%esp
  8102eb:	85 c0                	test   %eax,%eax
  8102ed:	78 10                	js     8102ff <fd2sockid+0x27>
	if (sfd->fd_dev_id != devsock.dev_id)
  8102ef:	8b 45 f4             	mov    -0xc(%ebp),%eax
  8102f2:	8b 0d 08 43 81 00    	mov    0x814308,%ecx
  8102f8:	39 08                	cmp    %ecx,(%eax)
  8102fa:	75 05                	jne    810301 <fd2sockid+0x29>
	return sfd->fd_sock.sockid;
  8102fc:	8b 40 0c             	mov    0xc(%eax),%eax
}
  8102ff:	c9                   	leave  
  810300:	c3                   	ret    
		return -E_NOT_SUPP;
  810301:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
  810306:	eb f7                	jmp    8102ff <fd2sockid+0x27>

00810308 <alloc_sockfd>:
{
  810308:	55                   	push   %ebp
  810309:	89 e5                	mov    %esp,%ebp
  81030b:	56                   	push   %esi
  81030c:	53                   	push   %ebx
  81030d:	83 ec 1c             	sub    $0x1c,%esp
  810310:	89 c6                	mov    %eax,%esi
	if ((r = fd_alloc(&sfd)) < 0
  810312:	8d 45 f4             	lea    -0xc(%ebp),%eax
  810315:	50                   	push   %eax
  810316:	e8 09 f7 ff ff       	call   80fa24 <fd_alloc>
  81031b:	89 c3                	mov    %eax,%ebx
  81031d:	83 c4 10             	add    $0x10,%esp
  810320:	85 c0                	test   %eax,%eax
  810322:	78 43                	js     810367 <alloc_sockfd+0x5f>
	    || (r = sys_page_alloc(0, sfd, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0) {
  810324:	83 ec 04             	sub    $0x4,%esp
  810327:	68 07 04 00 00       	push   $0x407
  81032c:	ff 75 f4             	pushl  -0xc(%ebp)
  81032f:	6a 00                	push   $0x0
  810331:	e8 44 f0 ff ff       	call   80f37a <sys_page_alloc>
  810336:	89 c3                	mov    %eax,%ebx
  810338:	83 c4 10             	add    $0x10,%esp
  81033b:	85 c0                	test   %eax,%eax
  81033d:	78 28                	js     810367 <alloc_sockfd+0x5f>
	sfd->fd_dev_id = devsock.dev_id;
  81033f:	8b 45 f4             	mov    -0xc(%ebp),%eax
  810342:	8b 15 08 43 81 00    	mov    0x814308,%edx
  810348:	89 10                	mov    %edx,(%eax)
	sfd->fd_omode = O_RDWR;
  81034a:	8b 45 f4             	mov    -0xc(%ebp),%eax
  81034d:	c7 40 08 02 00 00 00 	movl   $0x2,0x8(%eax)
	sfd->fd_sock.sockid = sockid;
  810354:	89 70 0c             	mov    %esi,0xc(%eax)
	return fd2num(sfd);
  810357:	83 ec 0c             	sub    $0xc,%esp
  81035a:	50                   	push   %eax
  81035b:	e8 95 f6 ff ff       	call   80f9f5 <fd2num>
  810360:	89 c3                	mov    %eax,%ebx
  810362:	83 c4 10             	add    $0x10,%esp
  810365:	eb 0c                	jmp    810373 <alloc_sockfd+0x6b>
		nsipc_close(sockid);
  810367:	83 ec 0c             	sub    $0xc,%esp
  81036a:	56                   	push   %esi
  81036b:	e8 08 02 00 00       	call   810578 <nsipc_close>
		return r;
  810370:	83 c4 10             	add    $0x10,%esp
}
  810373:	89 d8                	mov    %ebx,%eax
  810375:	8d 65 f8             	lea    -0x8(%ebp),%esp
  810378:	5b                   	pop    %ebx
  810379:	5e                   	pop    %esi
  81037a:	5d                   	pop    %ebp
  81037b:	c3                   	ret    

0081037c <accept>:
{
  81037c:	f3 0f 1e fb          	endbr32 
  810380:	55                   	push   %ebp
  810381:	89 e5                	mov    %esp,%ebp
  810383:	83 ec 08             	sub    $0x8,%esp
	if ((r = fd2sockid(s)) < 0)
  810386:	8b 45 08             	mov    0x8(%ebp),%eax
  810389:	e8 4a ff ff ff       	call   8102d8 <fd2sockid>
  81038e:	85 c0                	test   %eax,%eax
  810390:	78 1b                	js     8103ad <accept+0x31>
	if ((r = nsipc_accept(r, addr, addrlen)) < 0)
  810392:	83 ec 04             	sub    $0x4,%esp
  810395:	ff 75 10             	pushl  0x10(%ebp)
  810398:	ff 75 0c             	pushl  0xc(%ebp)
  81039b:	50                   	push   %eax
  81039c:	e8 22 01 00 00       	call   8104c3 <nsipc_accept>
  8103a1:	83 c4 10             	add    $0x10,%esp
  8103a4:	85 c0                	test   %eax,%eax
  8103a6:	78 05                	js     8103ad <accept+0x31>
	return alloc_sockfd(r);
  8103a8:	e8 5b ff ff ff       	call   810308 <alloc_sockfd>
}
  8103ad:	c9                   	leave  
  8103ae:	c3                   	ret    

008103af <bind>:
{
  8103af:	f3 0f 1e fb          	endbr32 
  8103b3:	55                   	push   %ebp
  8103b4:	89 e5                	mov    %esp,%ebp
  8103b6:	83 ec 08             	sub    $0x8,%esp
	if ((r = fd2sockid(s)) < 0)
  8103b9:	8b 45 08             	mov    0x8(%ebp),%eax
  8103bc:	e8 17 ff ff ff       	call   8102d8 <fd2sockid>
  8103c1:	85 c0                	test   %eax,%eax
  8103c3:	78 12                	js     8103d7 <bind+0x28>
	return nsipc_bind(r, name, namelen);
  8103c5:	83 ec 04             	sub    $0x4,%esp
  8103c8:	ff 75 10             	pushl  0x10(%ebp)
  8103cb:	ff 75 0c             	pushl  0xc(%ebp)
  8103ce:	50                   	push   %eax
  8103cf:	e8 45 01 00 00       	call   810519 <nsipc_bind>
  8103d4:	83 c4 10             	add    $0x10,%esp
}
  8103d7:	c9                   	leave  
  8103d8:	c3                   	ret    

008103d9 <shutdown>:
{
  8103d9:	f3 0f 1e fb          	endbr32 
  8103dd:	55                   	push   %ebp
  8103de:	89 e5                	mov    %esp,%ebp
  8103e0:	83 ec 08             	sub    $0x8,%esp
	if ((r = fd2sockid(s)) < 0)
  8103e3:	8b 45 08             	mov    0x8(%ebp),%eax
  8103e6:	e8 ed fe ff ff       	call   8102d8 <fd2sockid>
  8103eb:	85 c0                	test   %eax,%eax
  8103ed:	78 0f                	js     8103fe <shutdown+0x25>
	return nsipc_shutdown(r, how);
  8103ef:	83 ec 08             	sub    $0x8,%esp
  8103f2:	ff 75 0c             	pushl  0xc(%ebp)
  8103f5:	50                   	push   %eax
  8103f6:	e8 57 01 00 00       	call   810552 <nsipc_shutdown>
  8103fb:	83 c4 10             	add    $0x10,%esp
}
  8103fe:	c9                   	leave  
  8103ff:	c3                   	ret    

00810400 <connect>:
{
  810400:	f3 0f 1e fb          	endbr32 
  810404:	55                   	push   %ebp
  810405:	89 e5                	mov    %esp,%ebp
  810407:	83 ec 08             	sub    $0x8,%esp
	if ((r = fd2sockid(s)) < 0)
  81040a:	8b 45 08             	mov    0x8(%ebp),%eax
  81040d:	e8 c6 fe ff ff       	call   8102d8 <fd2sockid>
  810412:	85 c0                	test   %eax,%eax
  810414:	78 12                	js     810428 <connect+0x28>
	return nsipc_connect(r, name, namelen);
  810416:	83 ec 04             	sub    $0x4,%esp
  810419:	ff 75 10             	pushl  0x10(%ebp)
  81041c:	ff 75 0c             	pushl  0xc(%ebp)
  81041f:	50                   	push   %eax
  810420:	e8 71 01 00 00       	call   810596 <nsipc_connect>
  810425:	83 c4 10             	add    $0x10,%esp
}
  810428:	c9                   	leave  
  810429:	c3                   	ret    

0081042a <listen>:
{
  81042a:	f3 0f 1e fb          	endbr32 
  81042e:	55                   	push   %ebp
  81042f:	89 e5                	mov    %esp,%ebp
  810431:	83 ec 08             	sub    $0x8,%esp
	if ((r = fd2sockid(s)) < 0)
  810434:	8b 45 08             	mov    0x8(%ebp),%eax
  810437:	e8 9c fe ff ff       	call   8102d8 <fd2sockid>
  81043c:	85 c0                	test   %eax,%eax
  81043e:	78 0f                	js     81044f <listen+0x25>
	return nsipc_listen(r, backlog);
  810440:	83 ec 08             	sub    $0x8,%esp
  810443:	ff 75 0c             	pushl  0xc(%ebp)
  810446:	50                   	push   %eax
  810447:	e8 83 01 00 00       	call   8105cf <nsipc_listen>
  81044c:	83 c4 10             	add    $0x10,%esp
}
  81044f:	c9                   	leave  
  810450:	c3                   	ret    

00810451 <socket>:

int
socket(int domain, int type, int protocol)
{
  810451:	f3 0f 1e fb          	endbr32 
  810455:	55                   	push   %ebp
  810456:	89 e5                	mov    %esp,%ebp
  810458:	83 ec 0c             	sub    $0xc,%esp
	int r;
	if ((r = nsipc_socket(domain, type, protocol)) < 0)
  81045b:	ff 75 10             	pushl  0x10(%ebp)
  81045e:	ff 75 0c             	pushl  0xc(%ebp)
  810461:	ff 75 08             	pushl  0x8(%ebp)
  810464:	e8 65 02 00 00       	call   8106ce <nsipc_socket>
  810469:	83 c4 10             	add    $0x10,%esp
  81046c:	85 c0                	test   %eax,%eax
  81046e:	78 05                	js     810475 <socket+0x24>
		return r;
	return alloc_sockfd(r);
  810470:	e8 93 fe ff ff       	call   810308 <alloc_sockfd>
}
  810475:	c9                   	leave  
  810476:	c3                   	ret    

00810477 <nsipc>:
// may be written back to nsipcbuf.
// type: request code, passed as the simple integer IPC value.
// Returns 0 if successful, < 0 on failure.
static int
nsipc(unsigned type)
{
  810477:	55                   	push   %ebp
  810478:	89 e5                	mov    %esp,%ebp
  81047a:	53                   	push   %ebx
  81047b:	83 ec 04             	sub    $0x4,%esp
  81047e:	89 c3                	mov    %eax,%ebx
	static envid_t nsenv;
	if (nsenv == 0)
  810480:	83 3d d0 b1 b3 00 00 	cmpl   $0x0,0xb3b1d0
  810487:	74 26                	je     8104af <nsipc+0x38>
	static_assert(sizeof(nsipcbuf) == PGSIZE);

	if (debug)
		cprintf("[%08x] nsipc %d\n", thisenv->env_id, type);

	ipc_send(nsenv, type, &nsipcbuf, PTE_P|PTE_W|PTE_U);
  810489:	6a 07                	push   $0x7
  81048b:	68 00 d0 b3 00       	push   $0xb3d000
  810490:	53                   	push   %ebx
  810491:	ff 35 d0 b1 b3 00    	pushl  0xb3b1d0
  810497:	e8 c4 f4 ff ff       	call   80f960 <ipc_send>
	return ipc_recv(NULL, NULL, NULL);
  81049c:	83 c4 0c             	add    $0xc,%esp
  81049f:	6a 00                	push   $0x0
  8104a1:	6a 00                	push   $0x0
  8104a3:	6a 00                	push   $0x0
  8104a5:	e8 42 f4 ff ff       	call   80f8ec <ipc_recv>
}
  8104aa:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  8104ad:	c9                   	leave  
  8104ae:	c3                   	ret    
		nsenv = ipc_find_env(ENV_TYPE_NS);
  8104af:	83 ec 0c             	sub    $0xc,%esp
  8104b2:	6a 02                	push   $0x2
  8104b4:	e8 ff f4 ff ff       	call   80f9b8 <ipc_find_env>
  8104b9:	a3 d0 b1 b3 00       	mov    %eax,0xb3b1d0
  8104be:	83 c4 10             	add    $0x10,%esp
  8104c1:	eb c6                	jmp    810489 <nsipc+0x12>

008104c3 <nsipc_accept>:

int
nsipc_accept(int s, struct sockaddr *addr, socklen_t *addrlen)
{
  8104c3:	f3 0f 1e fb          	endbr32 
  8104c7:	55                   	push   %ebp
  8104c8:	89 e5                	mov    %esp,%ebp
  8104ca:	56                   	push   %esi
  8104cb:	53                   	push   %ebx
  8104cc:	8b 75 10             	mov    0x10(%ebp),%esi
	int r;

	nsipcbuf.accept.req_s = s;
  8104cf:	8b 45 08             	mov    0x8(%ebp),%eax
  8104d2:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	nsipcbuf.accept.req_addrlen = *addrlen;
  8104d7:	8b 06                	mov    (%esi),%eax
  8104d9:	a3 04 d0 b3 00       	mov    %eax,0xb3d004
	if ((r = nsipc(NSREQ_ACCEPT)) >= 0) {
  8104de:	b8 01 00 00 00       	mov    $0x1,%eax
  8104e3:	e8 8f ff ff ff       	call   810477 <nsipc>
  8104e8:	89 c3                	mov    %eax,%ebx
  8104ea:	85 c0                	test   %eax,%eax
  8104ec:	79 09                	jns    8104f7 <nsipc_accept+0x34>
		struct Nsret_accept *ret = &nsipcbuf.acceptRet;
		memmove(addr, &ret->ret_addr, ret->ret_addrlen);
		*addrlen = ret->ret_addrlen;
	}
	return r;
}
  8104ee:	89 d8                	mov    %ebx,%eax
  8104f0:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8104f3:	5b                   	pop    %ebx
  8104f4:	5e                   	pop    %esi
  8104f5:	5d                   	pop    %ebp
  8104f6:	c3                   	ret    
		memmove(addr, &ret->ret_addr, ret->ret_addrlen);
  8104f7:	83 ec 04             	sub    $0x4,%esp
  8104fa:	ff 35 10 d0 b3 00    	pushl  0xb3d010
  810500:	68 00 d0 b3 00       	push   $0xb3d000
  810505:	ff 75 0c             	pushl  0xc(%ebp)
  810508:	e8 e1 eb ff ff       	call   80f0ee <memmove>
		*addrlen = ret->ret_addrlen;
  81050d:	a1 10 d0 b3 00       	mov    0xb3d010,%eax
  810512:	89 06                	mov    %eax,(%esi)
  810514:	83 c4 10             	add    $0x10,%esp
	return r;
  810517:	eb d5                	jmp    8104ee <nsipc_accept+0x2b>

00810519 <nsipc_bind>:

int
nsipc_bind(int s, struct sockaddr *name, socklen_t namelen)
{
  810519:	f3 0f 1e fb          	endbr32 
  81051d:	55                   	push   %ebp
  81051e:	89 e5                	mov    %esp,%ebp
  810520:	53                   	push   %ebx
  810521:	83 ec 08             	sub    $0x8,%esp
  810524:	8b 5d 10             	mov    0x10(%ebp),%ebx
	nsipcbuf.bind.req_s = s;
  810527:	8b 45 08             	mov    0x8(%ebp),%eax
  81052a:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	memmove(&nsipcbuf.bind.req_name, name, namelen);
  81052f:	53                   	push   %ebx
  810530:	ff 75 0c             	pushl  0xc(%ebp)
  810533:	68 04 d0 b3 00       	push   $0xb3d004
  810538:	e8 b1 eb ff ff       	call   80f0ee <memmove>
	nsipcbuf.bind.req_namelen = namelen;
  81053d:	89 1d 14 d0 b3 00    	mov    %ebx,0xb3d014
	return nsipc(NSREQ_BIND);
  810543:	b8 02 00 00 00       	mov    $0x2,%eax
  810548:	e8 2a ff ff ff       	call   810477 <nsipc>
}
  81054d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  810550:	c9                   	leave  
  810551:	c3                   	ret    

00810552 <nsipc_shutdown>:

int
nsipc_shutdown(int s, int how)
{
  810552:	f3 0f 1e fb          	endbr32 
  810556:	55                   	push   %ebp
  810557:	89 e5                	mov    %esp,%ebp
  810559:	83 ec 08             	sub    $0x8,%esp
	nsipcbuf.shutdown.req_s = s;
  81055c:	8b 45 08             	mov    0x8(%ebp),%eax
  81055f:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	nsipcbuf.shutdown.req_how = how;
  810564:	8b 45 0c             	mov    0xc(%ebp),%eax
  810567:	a3 04 d0 b3 00       	mov    %eax,0xb3d004
	return nsipc(NSREQ_SHUTDOWN);
  81056c:	b8 03 00 00 00       	mov    $0x3,%eax
  810571:	e8 01 ff ff ff       	call   810477 <nsipc>
}
  810576:	c9                   	leave  
  810577:	c3                   	ret    

00810578 <nsipc_close>:

int
nsipc_close(int s)
{
  810578:	f3 0f 1e fb          	endbr32 
  81057c:	55                   	push   %ebp
  81057d:	89 e5                	mov    %esp,%ebp
  81057f:	83 ec 08             	sub    $0x8,%esp
	nsipcbuf.close.req_s = s;
  810582:	8b 45 08             	mov    0x8(%ebp),%eax
  810585:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	return nsipc(NSREQ_CLOSE);
  81058a:	b8 04 00 00 00       	mov    $0x4,%eax
  81058f:	e8 e3 fe ff ff       	call   810477 <nsipc>
}
  810594:	c9                   	leave  
  810595:	c3                   	ret    

00810596 <nsipc_connect>:

int
nsipc_connect(int s, const struct sockaddr *name, socklen_t namelen)
{
  810596:	f3 0f 1e fb          	endbr32 
  81059a:	55                   	push   %ebp
  81059b:	89 e5                	mov    %esp,%ebp
  81059d:	53                   	push   %ebx
  81059e:	83 ec 08             	sub    $0x8,%esp
  8105a1:	8b 5d 10             	mov    0x10(%ebp),%ebx
	nsipcbuf.connect.req_s = s;
  8105a4:	8b 45 08             	mov    0x8(%ebp),%eax
  8105a7:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	memmove(&nsipcbuf.connect.req_name, name, namelen);
  8105ac:	53                   	push   %ebx
  8105ad:	ff 75 0c             	pushl  0xc(%ebp)
  8105b0:	68 04 d0 b3 00       	push   $0xb3d004
  8105b5:	e8 34 eb ff ff       	call   80f0ee <memmove>
	nsipcbuf.connect.req_namelen = namelen;
  8105ba:	89 1d 14 d0 b3 00    	mov    %ebx,0xb3d014
	return nsipc(NSREQ_CONNECT);
  8105c0:	b8 05 00 00 00       	mov    $0x5,%eax
  8105c5:	e8 ad fe ff ff       	call   810477 <nsipc>
}
  8105ca:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  8105cd:	c9                   	leave  
  8105ce:	c3                   	ret    

008105cf <nsipc_listen>:

int
nsipc_listen(int s, int backlog)
{
  8105cf:	f3 0f 1e fb          	endbr32 
  8105d3:	55                   	push   %ebp
  8105d4:	89 e5                	mov    %esp,%ebp
  8105d6:	83 ec 08             	sub    $0x8,%esp
	nsipcbuf.listen.req_s = s;
  8105d9:	8b 45 08             	mov    0x8(%ebp),%eax
  8105dc:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	nsipcbuf.listen.req_backlog = backlog;
  8105e1:	8b 45 0c             	mov    0xc(%ebp),%eax
  8105e4:	a3 04 d0 b3 00       	mov    %eax,0xb3d004
	return nsipc(NSREQ_LISTEN);
  8105e9:	b8 06 00 00 00       	mov    $0x6,%eax
  8105ee:	e8 84 fe ff ff       	call   810477 <nsipc>
}
  8105f3:	c9                   	leave  
  8105f4:	c3                   	ret    

008105f5 <nsipc_recv>:

int
nsipc_recv(int s, void *mem, int len, unsigned int flags)
{
  8105f5:	f3 0f 1e fb          	endbr32 
  8105f9:	55                   	push   %ebp
  8105fa:	89 e5                	mov    %esp,%ebp
  8105fc:	56                   	push   %esi
  8105fd:	53                   	push   %ebx
  8105fe:	8b 75 10             	mov    0x10(%ebp),%esi
	int r;

	nsipcbuf.recv.req_s = s;
  810601:	8b 45 08             	mov    0x8(%ebp),%eax
  810604:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	nsipcbuf.recv.req_len = len;
  810609:	89 35 04 d0 b3 00    	mov    %esi,0xb3d004
	nsipcbuf.recv.req_flags = flags;
  81060f:	8b 45 14             	mov    0x14(%ebp),%eax
  810612:	a3 08 d0 b3 00       	mov    %eax,0xb3d008

	if ((r = nsipc(NSREQ_RECV)) >= 0) {
  810617:	b8 07 00 00 00       	mov    $0x7,%eax
  81061c:	e8 56 fe ff ff       	call   810477 <nsipc>
  810621:	89 c3                	mov    %eax,%ebx
  810623:	85 c0                	test   %eax,%eax
  810625:	78 26                	js     81064d <nsipc_recv+0x58>
		assert(r < 1600 && r <= len);
  810627:	81 fe 3f 06 00 00    	cmp    $0x63f,%esi
  81062d:	b8 3f 06 00 00       	mov    $0x63f,%eax
  810632:	0f 4e c6             	cmovle %esi,%eax
  810635:	39 c3                	cmp    %eax,%ebx
  810637:	7f 1d                	jg     810656 <nsipc_recv+0x61>
		memmove(mem, nsipcbuf.recvRet.ret_buf, r);
  810639:	83 ec 04             	sub    $0x4,%esp
  81063c:	53                   	push   %ebx
  81063d:	68 00 d0 b3 00       	push   $0xb3d000
  810642:	ff 75 0c             	pushl  0xc(%ebp)
  810645:	e8 a4 ea ff ff       	call   80f0ee <memmove>
  81064a:	83 c4 10             	add    $0x10,%esp
	}

	return r;
}
  81064d:	89 d8                	mov    %ebx,%eax
  81064f:	8d 65 f8             	lea    -0x8(%ebp),%esp
  810652:	5b                   	pop    %ebx
  810653:	5e                   	pop    %esi
  810654:	5d                   	pop    %ebp
  810655:	c3                   	ret    
		assert(r < 1600 && r <= len);
  810656:	68 e2 3c 81 00       	push   $0x813ce2
  81065b:	68 8b 29 81 00       	push   $0x81298b
  810660:	6a 62                	push   $0x62
  810662:	68 f7 3c 81 00       	push   $0x813cf7
  810667:	e8 db e1 ff ff       	call   80e847 <_panic>

0081066c <nsipc_send>:

int
nsipc_send(int s, const void *buf, int size, unsigned int flags)
{
  81066c:	f3 0f 1e fb          	endbr32 
  810670:	55                   	push   %ebp
  810671:	89 e5                	mov    %esp,%ebp
  810673:	53                   	push   %ebx
  810674:	83 ec 04             	sub    $0x4,%esp
  810677:	8b 5d 10             	mov    0x10(%ebp),%ebx
	nsipcbuf.send.req_s = s;
  81067a:	8b 45 08             	mov    0x8(%ebp),%eax
  81067d:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	assert(size < 1600);
  810682:	81 fb 3f 06 00 00    	cmp    $0x63f,%ebx
  810688:	7f 2e                	jg     8106b8 <nsipc_send+0x4c>
	memmove(&nsipcbuf.send.req_buf, buf, size);
  81068a:	83 ec 04             	sub    $0x4,%esp
  81068d:	53                   	push   %ebx
  81068e:	ff 75 0c             	pushl  0xc(%ebp)
  810691:	68 0c d0 b3 00       	push   $0xb3d00c
  810696:	e8 53 ea ff ff       	call   80f0ee <memmove>
	nsipcbuf.send.req_size = size;
  81069b:	89 1d 04 d0 b3 00    	mov    %ebx,0xb3d004
	nsipcbuf.send.req_flags = flags;
  8106a1:	8b 45 14             	mov    0x14(%ebp),%eax
  8106a4:	a3 08 d0 b3 00       	mov    %eax,0xb3d008
	return nsipc(NSREQ_SEND);
  8106a9:	b8 08 00 00 00       	mov    $0x8,%eax
  8106ae:	e8 c4 fd ff ff       	call   810477 <nsipc>
}
  8106b3:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  8106b6:	c9                   	leave  
  8106b7:	c3                   	ret    
	assert(size < 1600);
  8106b8:	68 03 3d 81 00       	push   $0x813d03
  8106bd:	68 8b 29 81 00       	push   $0x81298b
  8106c2:	6a 6d                	push   $0x6d
  8106c4:	68 f7 3c 81 00       	push   $0x813cf7
  8106c9:	e8 79 e1 ff ff       	call   80e847 <_panic>

008106ce <nsipc_socket>:

int
nsipc_socket(int domain, int type, int protocol)
{
  8106ce:	f3 0f 1e fb          	endbr32 
  8106d2:	55                   	push   %ebp
  8106d3:	89 e5                	mov    %esp,%ebp
  8106d5:	83 ec 08             	sub    $0x8,%esp
	nsipcbuf.socket.req_domain = domain;
  8106d8:	8b 45 08             	mov    0x8(%ebp),%eax
  8106db:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	nsipcbuf.socket.req_type = type;
  8106e0:	8b 45 0c             	mov    0xc(%ebp),%eax
  8106e3:	a3 04 d0 b3 00       	mov    %eax,0xb3d004
	nsipcbuf.socket.req_protocol = protocol;
  8106e8:	8b 45 10             	mov    0x10(%ebp),%eax
  8106eb:	a3 08 d0 b3 00       	mov    %eax,0xb3d008
	return nsipc(NSREQ_SOCKET);
  8106f0:	b8 09 00 00 00       	mov    $0x9,%eax
  8106f5:	e8 7d fd ff ff       	call   810477 <nsipc>
}
  8106fa:	c9                   	leave  
  8106fb:	c3                   	ret    

008106fc <free>:
	return v;
}

void
free(void *v)
{
  8106fc:	f3 0f 1e fb          	endbr32 
  810700:	55                   	push   %ebp
  810701:	89 e5                	mov    %esp,%ebp
  810703:	53                   	push   %ebx
  810704:	83 ec 04             	sub    $0x4,%esp
  810707:	8b 5d 08             	mov    0x8(%ebp),%ebx
	uint8_t *c;
	uint32_t *ref;

	if (v == 0)
  81070a:	85 db                	test   %ebx,%ebx
  81070c:	0f 84 85 00 00 00    	je     810797 <free+0x9b>
		return;
	assert(mbegin <= (uint8_t*) v && (uint8_t*) v < mend);
  810712:	8d 83 00 00 00 f8    	lea    -0x8000000(%ebx),%eax
  810718:	3d ff ff ff 07       	cmp    $0x7ffffff,%eax
  81071d:	77 51                	ja     810770 <free+0x74>

	c = ROUNDDOWN(v, PGSIZE);
  81071f:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx

	while (uvpt[PGNUM(c)] & PTE_CONTINUED) {
  810725:	89 d8                	mov    %ebx,%eax
  810727:	c1 e8 0c             	shr    $0xc,%eax
  81072a:	8b 04 85 00 00 40 ef 	mov    -0x10c00000(,%eax,4),%eax
  810731:	f6 c4 02             	test   $0x2,%ah
  810734:	74 50                	je     810786 <free+0x8a>
		sys_page_unmap(0, c);
  810736:	83 ec 08             	sub    $0x8,%esp
  810739:	53                   	push   %ebx
  81073a:	6a 00                	push   $0x0
  81073c:	e8 c6 ec ff ff       	call   80f407 <sys_page_unmap>
		c += PGSIZE;
  810741:	81 c3 00 10 00 00    	add    $0x1000,%ebx
		assert(mbegin <= c && c < mend);
  810747:	8d 83 00 00 00 f8    	lea    -0x8000000(%ebx),%eax
  81074d:	83 c4 10             	add    $0x10,%esp
  810750:	3d ff ff ff 07       	cmp    $0x7ffffff,%eax
  810755:	76 ce                	jbe    810725 <free+0x29>
  810757:	68 4b 3d 81 00       	push   $0x813d4b
  81075c:	68 8b 29 81 00       	push   $0x81298b
  810761:	68 81 00 00 00       	push   $0x81
  810766:	68 3e 3d 81 00       	push   $0x813d3e
  81076b:	e8 d7 e0 ff ff       	call   80e847 <_panic>
	assert(mbegin <= (uint8_t*) v && (uint8_t*) v < mend);
  810770:	68 10 3d 81 00       	push   $0x813d10
  810775:	68 8b 29 81 00       	push   $0x81298b
  81077a:	6a 7a                	push   $0x7a
  81077c:	68 3e 3d 81 00       	push   $0x813d3e
  810781:	e8 c1 e0 ff ff       	call   80e847 <_panic>
	/*
	 * c is just a piece of this page, so dec the ref count
	 * and maybe free the page.
	 */
	ref = (uint32_t*) (c + PGSIZE - 4);
	if (--(*ref) == 0)
  810786:	8b 83 fc 0f 00 00    	mov    0xffc(%ebx),%eax
  81078c:	83 e8 01             	sub    $0x1,%eax
  81078f:	89 83 fc 0f 00 00    	mov    %eax,0xffc(%ebx)
  810795:	74 05                	je     81079c <free+0xa0>
		sys_page_unmap(0, c);
}
  810797:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  81079a:	c9                   	leave  
  81079b:	c3                   	ret    
		sys_page_unmap(0, c);
  81079c:	83 ec 08             	sub    $0x8,%esp
  81079f:	53                   	push   %ebx
  8107a0:	6a 00                	push   $0x0
  8107a2:	e8 60 ec ff ff       	call   80f407 <sys_page_unmap>
  8107a7:	83 c4 10             	add    $0x10,%esp
  8107aa:	eb eb                	jmp    810797 <free+0x9b>

008107ac <malloc>:
{
  8107ac:	f3 0f 1e fb          	endbr32 
  8107b0:	55                   	push   %ebp
  8107b1:	89 e5                	mov    %esp,%ebp
  8107b3:	57                   	push   %edi
  8107b4:	56                   	push   %esi
  8107b5:	53                   	push   %ebx
  8107b6:	83 ec 1c             	sub    $0x1c,%esp
	if (mptr == 0)
  8107b9:	a1 d4 b1 b3 00       	mov    0xb3b1d4,%eax
  8107be:	85 c0                	test   %eax,%eax
  8107c0:	74 74                	je     810836 <malloc+0x8a>
	n = ROUNDUP(n, 4);
  8107c2:	8b 4d 08             	mov    0x8(%ebp),%ecx
  8107c5:	8d 51 03             	lea    0x3(%ecx),%edx
  8107c8:	83 e2 fc             	and    $0xfffffffc,%edx
  8107cb:	89 d6                	mov    %edx,%esi
  8107cd:	89 55 dc             	mov    %edx,-0x24(%ebp)
	if (n >= MAXMALLOC)
  8107d0:	81 fa ff ff 0f 00    	cmp    $0xfffff,%edx
  8107d6:	0f 87 12 01 00 00    	ja     8108ee <malloc+0x142>
	if ((uintptr_t) mptr % PGSIZE){
  8107dc:	89 c1                	mov    %eax,%ecx
  8107de:	a9 ff 0f 00 00       	test   $0xfff,%eax
  8107e3:	74 30                	je     810815 <malloc+0x69>
		if ((uintptr_t) mptr / PGSIZE == (uintptr_t) (mptr + n - 1 + 4) / PGSIZE) {
  8107e5:	89 c3                	mov    %eax,%ebx
  8107e7:	c1 eb 0c             	shr    $0xc,%ebx
  8107ea:	8d 54 10 03          	lea    0x3(%eax,%edx,1),%edx
  8107ee:	c1 ea 0c             	shr    $0xc,%edx
  8107f1:	39 d3                	cmp    %edx,%ebx
  8107f3:	74 64                	je     810859 <malloc+0xad>
		free(mptr);	/* drop reference to this page */
  8107f5:	83 ec 0c             	sub    $0xc,%esp
  8107f8:	50                   	push   %eax
  8107f9:	e8 fe fe ff ff       	call   8106fc <free>
		mptr = ROUNDDOWN(mptr + PGSIZE, PGSIZE);
  8107fe:	a1 d4 b1 b3 00       	mov    0xb3b1d4,%eax
  810803:	05 00 10 00 00       	add    $0x1000,%eax
  810808:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  81080d:	a3 d4 b1 b3 00       	mov    %eax,0xb3b1d4
  810812:	83 c4 10             	add    $0x10,%esp
  810815:	8b 15 d4 b1 b3 00    	mov    0xb3b1d4,%edx
{
  81081b:	c7 45 d8 02 00 00 00 	movl   $0x2,-0x28(%ebp)
  810822:	be 00 00 00 00       	mov    $0x0,%esi
		if (isfree(mptr, n + 4))
  810827:	8b 45 dc             	mov    -0x24(%ebp),%eax
  81082a:	8d 78 04             	lea    0x4(%eax),%edi
  81082d:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
  810831:	e9 86 00 00 00       	jmp    8108bc <malloc+0x110>
		mptr = mbegin;
  810836:	c7 05 d4 b1 b3 00 00 	movl   $0x8000000,0xb3b1d4
  81083d:	00 00 08 
	n = ROUNDUP(n, 4);
  810840:	8b 4d 08             	mov    0x8(%ebp),%ecx
  810843:	8d 51 03             	lea    0x3(%ecx),%edx
  810846:	83 e2 fc             	and    $0xfffffffc,%edx
  810849:	89 55 dc             	mov    %edx,-0x24(%ebp)
	if (n >= MAXMALLOC)
  81084c:	81 fa ff ff 0f 00    	cmp    $0xfffff,%edx
  810852:	76 c1                	jbe    810815 <malloc+0x69>
  810854:	e9 fb 00 00 00       	jmp    810954 <malloc+0x1a8>
		ref = (uint32_t*) (ROUNDUP(mptr, PGSIZE) - 4);
  810859:	81 c1 ff 0f 00 00    	add    $0xfff,%ecx
  81085f:	81 e1 00 f0 ff ff    	and    $0xfffff000,%ecx
			(*ref)++;
  810865:	83 41 fc 01          	addl   $0x1,-0x4(%ecx)
			mptr += n;
  810869:	89 f2                	mov    %esi,%edx
  81086b:	01 c2                	add    %eax,%edx
  81086d:	89 15 d4 b1 b3 00    	mov    %edx,0xb3b1d4
			return v;
  810873:	e9 dc 00 00 00       	jmp    810954 <malloc+0x1a8>
	for (va = (uintptr_t) v; va < end_va; va += PGSIZE)
  810878:	05 00 10 00 00       	add    $0x1000,%eax
  81087d:	39 c1                	cmp    %eax,%ecx
  81087f:	76 74                	jbe    8108f5 <malloc+0x149>
		if (va >= (uintptr_t) mend
  810881:	3d ff ff ff 0f       	cmp    $0xfffffff,%eax
  810886:	77 22                	ja     8108aa <malloc+0xfe>
		    || ((uvpd[PDX(va)] & PTE_P) && (uvpt[PGNUM(va)] & PTE_P)))
  810888:	89 c3                	mov    %eax,%ebx
  81088a:	c1 eb 16             	shr    $0x16,%ebx
  81088d:	8b 1c 9d 00 d0 7b ef 	mov    -0x10843000(,%ebx,4),%ebx
  810894:	f6 c3 01             	test   $0x1,%bl
  810897:	74 df                	je     810878 <malloc+0xcc>
  810899:	89 c3                	mov    %eax,%ebx
  81089b:	c1 eb 0c             	shr    $0xc,%ebx
  81089e:	8b 1c 9d 00 00 40 ef 	mov    -0x10c00000(,%ebx,4),%ebx
  8108a5:	f6 c3 01             	test   $0x1,%bl
  8108a8:	74 ce                	je     810878 <malloc+0xcc>
  8108aa:	81 c2 00 10 00 00    	add    $0x1000,%edx
  8108b0:	0f b6 75 e3          	movzbl -0x1d(%ebp),%esi
		if (mptr == mend) {
  8108b4:	81 fa 00 00 00 10    	cmp    $0x10000000,%edx
  8108ba:	74 0a                	je     8108c6 <malloc+0x11a>
  8108bc:	89 55 e4             	mov    %edx,-0x1c(%ebp)
	for (va = (uintptr_t) v; va < end_va; va += PGSIZE)
  8108bf:	89 d0                	mov    %edx,%eax
  8108c1:	8d 0c 17             	lea    (%edi,%edx,1),%ecx
  8108c4:	eb b7                	jmp    81087d <malloc+0xd1>
			mptr = mbegin;
  8108c6:	ba 00 00 00 08       	mov    $0x8000000,%edx
  8108cb:	be 01 00 00 00       	mov    $0x1,%esi
			if (++nwrap == 2)
  8108d0:	83 6d d8 01          	subl   $0x1,-0x28(%ebp)
  8108d4:	75 e6                	jne    8108bc <malloc+0x110>
  8108d6:	c7 05 d4 b1 b3 00 00 	movl   $0x8000000,0xb3b1d4
  8108dd:	00 00 08 
				return 0;	/* out of address space */
  8108e0:	b8 00 00 00 00       	mov    $0x0,%eax
  8108e5:	eb 6d                	jmp    810954 <malloc+0x1a8>
			return 0;	/* out of physical memory */
  8108e7:	b8 00 00 00 00       	mov    $0x0,%eax
  8108ec:	eb 66                	jmp    810954 <malloc+0x1a8>
		return 0;
  8108ee:	b8 00 00 00 00       	mov    $0x0,%eax
  8108f3:	eb 5f                	jmp    810954 <malloc+0x1a8>
  8108f5:	89 f0                	mov    %esi,%eax
  8108f7:	84 c0                	test   %al,%al
  8108f9:	74 08                	je     810903 <malloc+0x157>
  8108fb:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8108fe:	a3 d4 b1 b3 00       	mov    %eax,0xb3b1d4
	for (i = 0; i < n + 4; i += PGSIZE){
  810903:	bb 00 00 00 00       	mov    $0x0,%ebx
  810908:	89 de                	mov    %ebx,%esi
  81090a:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
		cont = (i + PGSIZE < n + 4) ? PTE_CONTINUED : 0;
  81090d:	81 c3 00 10 00 00    	add    $0x1000,%ebx
  810913:	39 df                	cmp    %ebx,%edi
  810915:	76 45                	jbe    81095c <malloc+0x1b0>
		if (sys_page_alloc(0, mptr + i, PTE_P|PTE_U|PTE_W|cont) < 0){
  810917:	83 ec 04             	sub    $0x4,%esp
  81091a:	68 07 02 00 00       	push   $0x207
  81091f:	03 35 d4 b1 b3 00    	add    0xb3b1d4,%esi
  810925:	56                   	push   %esi
  810926:	6a 00                	push   $0x0
  810928:	e8 4d ea ff ff       	call   80f37a <sys_page_alloc>
  81092d:	83 c4 10             	add    $0x10,%esp
  810930:	85 c0                	test   %eax,%eax
  810932:	79 d4                	jns    810908 <malloc+0x15c>
  810934:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
  810937:	eb 42                	jmp    81097b <malloc+0x1cf>
	ref = (uint32_t*) (mptr + i - 4);
  810939:	a1 d4 b1 b3 00       	mov    0xb3b1d4,%eax
	*ref = 2;	/* reference for mptr, reference for returned block */
  81093e:	c7 84 30 fc 0f 00 00 	movl   $0x2,0xffc(%eax,%esi,1)
  810945:	02 00 00 00 
	mptr += n;
  810949:	8b 55 dc             	mov    -0x24(%ebp),%edx
  81094c:	01 c2                	add    %eax,%edx
  81094e:	89 15 d4 b1 b3 00    	mov    %edx,0xb3b1d4
}
  810954:	8d 65 f4             	lea    -0xc(%ebp),%esp
  810957:	5b                   	pop    %ebx
  810958:	5e                   	pop    %esi
  810959:	5f                   	pop    %edi
  81095a:	5d                   	pop    %ebp
  81095b:	c3                   	ret    
		if (sys_page_alloc(0, mptr + i, PTE_P|PTE_U|PTE_W|cont) < 0){
  81095c:	83 ec 04             	sub    $0x4,%esp
  81095f:	6a 07                	push   $0x7
  810961:	89 f0                	mov    %esi,%eax
  810963:	03 05 d4 b1 b3 00    	add    0xb3b1d4,%eax
  810969:	50                   	push   %eax
  81096a:	6a 00                	push   $0x0
  81096c:	e8 09 ea ff ff       	call   80f37a <sys_page_alloc>
  810971:	83 c4 10             	add    $0x10,%esp
  810974:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
  810977:	85 c0                	test   %eax,%eax
  810979:	79 be                	jns    810939 <malloc+0x18d>
			for (; i >= 0; i -= PGSIZE)
  81097b:	85 db                	test   %ebx,%ebx
  81097d:	0f 88 64 ff ff ff    	js     8108e7 <malloc+0x13b>
				sys_page_unmap(0, mptr + i);
  810983:	83 ec 08             	sub    $0x8,%esp
  810986:	89 d8                	mov    %ebx,%eax
  810988:	03 05 d4 b1 b3 00    	add    0xb3b1d4,%eax
  81098e:	50                   	push   %eax
  81098f:	6a 00                	push   $0x0
  810991:	e8 71 ea ff ff       	call   80f407 <sys_page_unmap>
			for (; i >= 0; i -= PGSIZE)
  810996:	81 eb 00 10 00 00    	sub    $0x1000,%ebx
  81099c:	83 c4 10             	add    $0x10,%esp
  81099f:	eb da                	jmp    81097b <malloc+0x1cf>

008109a1 <devpipe_stat>:
	return i;
}

static int
devpipe_stat(struct Fd *fd, struct Stat *stat)
{
  8109a1:	f3 0f 1e fb          	endbr32 
  8109a5:	55                   	push   %ebp
  8109a6:	89 e5                	mov    %esp,%ebp
  8109a8:	56                   	push   %esi
  8109a9:	53                   	push   %ebx
  8109aa:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	struct Pipe *p = (struct Pipe*) fd2data(fd);
  8109ad:	83 ec 0c             	sub    $0xc,%esp
  8109b0:	ff 75 08             	pushl  0x8(%ebp)
  8109b3:	e8 51 f0 ff ff       	call   80fa09 <fd2data>
  8109b8:	89 c6                	mov    %eax,%esi
	strcpy(stat->st_name, "<pipe>");
  8109ba:	83 c4 08             	add    $0x8,%esp
  8109bd:	68 63 3d 81 00       	push   $0x813d63
  8109c2:	53                   	push   %ebx
  8109c3:	e8 70 e5 ff ff       	call   80ef38 <strcpy>
	stat->st_size = p->p_wpos - p->p_rpos;
  8109c8:	8b 46 04             	mov    0x4(%esi),%eax
  8109cb:	2b 06                	sub    (%esi),%eax
  8109cd:	89 83 80 00 00 00    	mov    %eax,0x80(%ebx)
	stat->st_isdir = 0;
  8109d3:	c7 83 84 00 00 00 00 	movl   $0x0,0x84(%ebx)
  8109da:	00 00 00 
	stat->st_dev = &devpipe;
  8109dd:	c7 83 88 00 00 00 24 	movl   $0x814324,0x88(%ebx)
  8109e4:	43 81 00 
	return 0;
}
  8109e7:	b8 00 00 00 00       	mov    $0x0,%eax
  8109ec:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8109ef:	5b                   	pop    %ebx
  8109f0:	5e                   	pop    %esi
  8109f1:	5d                   	pop    %ebp
  8109f2:	c3                   	ret    

008109f3 <devpipe_close>:

static int
devpipe_close(struct Fd *fd)
{
  8109f3:	f3 0f 1e fb          	endbr32 
  8109f7:	55                   	push   %ebp
  8109f8:	89 e5                	mov    %esp,%ebp
  8109fa:	53                   	push   %ebx
  8109fb:	83 ec 0c             	sub    $0xc,%esp
  8109fe:	8b 5d 08             	mov    0x8(%ebp),%ebx
	(void) sys_page_unmap(0, fd);
  810a01:	53                   	push   %ebx
  810a02:	6a 00                	push   $0x0
  810a04:	e8 fe e9 ff ff       	call   80f407 <sys_page_unmap>
	return sys_page_unmap(0, fd2data(fd));
  810a09:	89 1c 24             	mov    %ebx,(%esp)
  810a0c:	e8 f8 ef ff ff       	call   80fa09 <fd2data>
  810a11:	83 c4 08             	add    $0x8,%esp
  810a14:	50                   	push   %eax
  810a15:	6a 00                	push   $0x0
  810a17:	e8 eb e9 ff ff       	call   80f407 <sys_page_unmap>
}
  810a1c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  810a1f:	c9                   	leave  
  810a20:	c3                   	ret    

00810a21 <_pipeisclosed>:
{
  810a21:	55                   	push   %ebp
  810a22:	89 e5                	mov    %esp,%ebp
  810a24:	57                   	push   %edi
  810a25:	56                   	push   %esi
  810a26:	53                   	push   %ebx
  810a27:	83 ec 1c             	sub    $0x1c,%esp
  810a2a:	89 c7                	mov    %eax,%edi
  810a2c:	89 d6                	mov    %edx,%esi
		n = thisenv->env_runs;
  810a2e:	a1 5c b2 b3 00       	mov    0xb3b25c,%eax
  810a33:	8b 58 58             	mov    0x58(%eax),%ebx
		ret = pageref(fd) == pageref(p);
  810a36:	83 ec 0c             	sub    $0xc,%esp
  810a39:	57                   	push   %edi
  810a3a:	e8 02 05 00 00       	call   810f41 <pageref>
  810a3f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  810a42:	89 34 24             	mov    %esi,(%esp)
  810a45:	e8 f7 04 00 00       	call   810f41 <pageref>
		nn = thisenv->env_runs;
  810a4a:	8b 15 5c b2 b3 00    	mov    0xb3b25c,%edx
  810a50:	8b 4a 58             	mov    0x58(%edx),%ecx
		if (n == nn)
  810a53:	83 c4 10             	add    $0x10,%esp
  810a56:	39 cb                	cmp    %ecx,%ebx
  810a58:	74 1b                	je     810a75 <_pipeisclosed+0x54>
		if (n != nn && ret == 1)
  810a5a:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
  810a5d:	75 cf                	jne    810a2e <_pipeisclosed+0xd>
			cprintf("pipe race avoided\n", n, thisenv->env_runs, ret);
  810a5f:	8b 42 58             	mov    0x58(%edx),%eax
  810a62:	6a 01                	push   $0x1
  810a64:	50                   	push   %eax
  810a65:	53                   	push   %ebx
  810a66:	68 6a 3d 81 00       	push   $0x813d6a
  810a6b:	e8 be de ff ff       	call   80e92e <cprintf>
  810a70:	83 c4 10             	add    $0x10,%esp
  810a73:	eb b9                	jmp    810a2e <_pipeisclosed+0xd>
		ret = pageref(fd) == pageref(p);
  810a75:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
  810a78:	0f 94 c0             	sete   %al
  810a7b:	0f b6 c0             	movzbl %al,%eax
}
  810a7e:	8d 65 f4             	lea    -0xc(%ebp),%esp
  810a81:	5b                   	pop    %ebx
  810a82:	5e                   	pop    %esi
  810a83:	5f                   	pop    %edi
  810a84:	5d                   	pop    %ebp
  810a85:	c3                   	ret    

00810a86 <devpipe_write>:
{
  810a86:	f3 0f 1e fb          	endbr32 
  810a8a:	55                   	push   %ebp
  810a8b:	89 e5                	mov    %esp,%ebp
  810a8d:	57                   	push   %edi
  810a8e:	56                   	push   %esi
  810a8f:	53                   	push   %ebx
  810a90:	83 ec 28             	sub    $0x28,%esp
  810a93:	8b 75 08             	mov    0x8(%ebp),%esi
	p = (struct Pipe*) fd2data(fd);
  810a96:	56                   	push   %esi
  810a97:	e8 6d ef ff ff       	call   80fa09 <fd2data>
  810a9c:	89 c3                	mov    %eax,%ebx
	for (i = 0; i < n; i++) {
  810a9e:	83 c4 10             	add    $0x10,%esp
  810aa1:	bf 00 00 00 00       	mov    $0x0,%edi
  810aa6:	3b 7d 10             	cmp    0x10(%ebp),%edi
  810aa9:	74 4f                	je     810afa <devpipe_write+0x74>
		while (p->p_wpos >= p->p_rpos + sizeof(p->p_buf)) {
  810aab:	8b 43 04             	mov    0x4(%ebx),%eax
  810aae:	8b 0b                	mov    (%ebx),%ecx
  810ab0:	8d 51 20             	lea    0x20(%ecx),%edx
  810ab3:	39 d0                	cmp    %edx,%eax
  810ab5:	72 14                	jb     810acb <devpipe_write+0x45>
			if (_pipeisclosed(fd, p))
  810ab7:	89 da                	mov    %ebx,%edx
  810ab9:	89 f0                	mov    %esi,%eax
  810abb:	e8 61 ff ff ff       	call   810a21 <_pipeisclosed>
  810ac0:	85 c0                	test   %eax,%eax
  810ac2:	75 3b                	jne    810aff <devpipe_write+0x79>
			sys_yield();
  810ac4:	e8 8e e8 ff ff       	call   80f357 <sys_yield>
  810ac9:	eb e0                	jmp    810aab <devpipe_write+0x25>
		p->p_buf[p->p_wpos % PIPEBUFSIZ] = buf[i];
  810acb:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  810ace:	0f b6 0c 39          	movzbl (%ecx,%edi,1),%ecx
  810ad2:	88 4d e7             	mov    %cl,-0x19(%ebp)
  810ad5:	89 c2                	mov    %eax,%edx
  810ad7:	c1 fa 1f             	sar    $0x1f,%edx
  810ada:	89 d1                	mov    %edx,%ecx
  810adc:	c1 e9 1b             	shr    $0x1b,%ecx
  810adf:	8d 14 08             	lea    (%eax,%ecx,1),%edx
  810ae2:	83 e2 1f             	and    $0x1f,%edx
  810ae5:	29 ca                	sub    %ecx,%edx
  810ae7:	0f b6 4d e7          	movzbl -0x19(%ebp),%ecx
  810aeb:	88 4c 13 08          	mov    %cl,0x8(%ebx,%edx,1)
		p->p_wpos++;
  810aef:	83 c0 01             	add    $0x1,%eax
  810af2:	89 43 04             	mov    %eax,0x4(%ebx)
	for (i = 0; i < n; i++) {
  810af5:	83 c7 01             	add    $0x1,%edi
  810af8:	eb ac                	jmp    810aa6 <devpipe_write+0x20>
	return i;
  810afa:	8b 45 10             	mov    0x10(%ebp),%eax
  810afd:	eb 05                	jmp    810b04 <devpipe_write+0x7e>
				return 0;
  810aff:	b8 00 00 00 00       	mov    $0x0,%eax
}
  810b04:	8d 65 f4             	lea    -0xc(%ebp),%esp
  810b07:	5b                   	pop    %ebx
  810b08:	5e                   	pop    %esi
  810b09:	5f                   	pop    %edi
  810b0a:	5d                   	pop    %ebp
  810b0b:	c3                   	ret    

00810b0c <devpipe_read>:
{
  810b0c:	f3 0f 1e fb          	endbr32 
  810b10:	55                   	push   %ebp
  810b11:	89 e5                	mov    %esp,%ebp
  810b13:	57                   	push   %edi
  810b14:	56                   	push   %esi
  810b15:	53                   	push   %ebx
  810b16:	83 ec 18             	sub    $0x18,%esp
  810b19:	8b 7d 08             	mov    0x8(%ebp),%edi
	p = (struct Pipe*)fd2data(fd);
  810b1c:	57                   	push   %edi
  810b1d:	e8 e7 ee ff ff       	call   80fa09 <fd2data>
  810b22:	89 c3                	mov    %eax,%ebx
	for (i = 0; i < n; i++) {
  810b24:	83 c4 10             	add    $0x10,%esp
  810b27:	be 00 00 00 00       	mov    $0x0,%esi
  810b2c:	3b 75 10             	cmp    0x10(%ebp),%esi
  810b2f:	75 14                	jne    810b45 <devpipe_read+0x39>
	return i;
  810b31:	8b 45 10             	mov    0x10(%ebp),%eax
  810b34:	eb 02                	jmp    810b38 <devpipe_read+0x2c>
				return i;
  810b36:	89 f0                	mov    %esi,%eax
}
  810b38:	8d 65 f4             	lea    -0xc(%ebp),%esp
  810b3b:	5b                   	pop    %ebx
  810b3c:	5e                   	pop    %esi
  810b3d:	5f                   	pop    %edi
  810b3e:	5d                   	pop    %ebp
  810b3f:	c3                   	ret    
			sys_yield();
  810b40:	e8 12 e8 ff ff       	call   80f357 <sys_yield>
		while (p->p_rpos == p->p_wpos) {
  810b45:	8b 03                	mov    (%ebx),%eax
  810b47:	3b 43 04             	cmp    0x4(%ebx),%eax
  810b4a:	75 18                	jne    810b64 <devpipe_read+0x58>
			if (i > 0)
  810b4c:	85 f6                	test   %esi,%esi
  810b4e:	75 e6                	jne    810b36 <devpipe_read+0x2a>
			if (_pipeisclosed(fd, p))
  810b50:	89 da                	mov    %ebx,%edx
  810b52:	89 f8                	mov    %edi,%eax
  810b54:	e8 c8 fe ff ff       	call   810a21 <_pipeisclosed>
  810b59:	85 c0                	test   %eax,%eax
  810b5b:	74 e3                	je     810b40 <devpipe_read+0x34>
				return 0;
  810b5d:	b8 00 00 00 00       	mov    $0x0,%eax
  810b62:	eb d4                	jmp    810b38 <devpipe_read+0x2c>
		buf[i] = p->p_buf[p->p_rpos % PIPEBUFSIZ];
  810b64:	99                   	cltd   
  810b65:	c1 ea 1b             	shr    $0x1b,%edx
  810b68:	01 d0                	add    %edx,%eax
  810b6a:	83 e0 1f             	and    $0x1f,%eax
  810b6d:	29 d0                	sub    %edx,%eax
  810b6f:	0f b6 44 03 08       	movzbl 0x8(%ebx,%eax,1),%eax
  810b74:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  810b77:	88 04 31             	mov    %al,(%ecx,%esi,1)
		p->p_rpos++;
  810b7a:	83 03 01             	addl   $0x1,(%ebx)
	for (i = 0; i < n; i++) {
  810b7d:	83 c6 01             	add    $0x1,%esi
  810b80:	eb aa                	jmp    810b2c <devpipe_read+0x20>

00810b82 <pipe>:
{
  810b82:	f3 0f 1e fb          	endbr32 
  810b86:	55                   	push   %ebp
  810b87:	89 e5                	mov    %esp,%ebp
  810b89:	56                   	push   %esi
  810b8a:	53                   	push   %ebx
  810b8b:	83 ec 1c             	sub    $0x1c,%esp
	if ((r = fd_alloc(&fd0)) < 0
  810b8e:	8d 45 f4             	lea    -0xc(%ebp),%eax
  810b91:	50                   	push   %eax
  810b92:	e8 8d ee ff ff       	call   80fa24 <fd_alloc>
  810b97:	89 c3                	mov    %eax,%ebx
  810b99:	83 c4 10             	add    $0x10,%esp
  810b9c:	85 c0                	test   %eax,%eax
  810b9e:	0f 88 23 01 00 00    	js     810cc7 <pipe+0x145>
	    || (r = sys_page_alloc(0, fd0, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
  810ba4:	83 ec 04             	sub    $0x4,%esp
  810ba7:	68 07 04 00 00       	push   $0x407
  810bac:	ff 75 f4             	pushl  -0xc(%ebp)
  810baf:	6a 00                	push   $0x0
  810bb1:	e8 c4 e7 ff ff       	call   80f37a <sys_page_alloc>
  810bb6:	89 c3                	mov    %eax,%ebx
  810bb8:	83 c4 10             	add    $0x10,%esp
  810bbb:	85 c0                	test   %eax,%eax
  810bbd:	0f 88 04 01 00 00    	js     810cc7 <pipe+0x145>
	if ((r = fd_alloc(&fd1)) < 0
  810bc3:	83 ec 0c             	sub    $0xc,%esp
  810bc6:	8d 45 f0             	lea    -0x10(%ebp),%eax
  810bc9:	50                   	push   %eax
  810bca:	e8 55 ee ff ff       	call   80fa24 <fd_alloc>
  810bcf:	89 c3                	mov    %eax,%ebx
  810bd1:	83 c4 10             	add    $0x10,%esp
  810bd4:	85 c0                	test   %eax,%eax
  810bd6:	0f 88 db 00 00 00    	js     810cb7 <pipe+0x135>
	    || (r = sys_page_alloc(0, fd1, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
  810bdc:	83 ec 04             	sub    $0x4,%esp
  810bdf:	68 07 04 00 00       	push   $0x407
  810be4:	ff 75 f0             	pushl  -0x10(%ebp)
  810be7:	6a 00                	push   $0x0
  810be9:	e8 8c e7 ff ff       	call   80f37a <sys_page_alloc>
  810bee:	89 c3                	mov    %eax,%ebx
  810bf0:	83 c4 10             	add    $0x10,%esp
  810bf3:	85 c0                	test   %eax,%eax
  810bf5:	0f 88 bc 00 00 00    	js     810cb7 <pipe+0x135>
	va = fd2data(fd0);
  810bfb:	83 ec 0c             	sub    $0xc,%esp
  810bfe:	ff 75 f4             	pushl  -0xc(%ebp)
  810c01:	e8 03 ee ff ff       	call   80fa09 <fd2data>
  810c06:	89 c6                	mov    %eax,%esi
	if ((r = sys_page_alloc(0, va, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
  810c08:	83 c4 0c             	add    $0xc,%esp
  810c0b:	68 07 04 00 00       	push   $0x407
  810c10:	50                   	push   %eax
  810c11:	6a 00                	push   $0x0
  810c13:	e8 62 e7 ff ff       	call   80f37a <sys_page_alloc>
  810c18:	89 c3                	mov    %eax,%ebx
  810c1a:	83 c4 10             	add    $0x10,%esp
  810c1d:	85 c0                	test   %eax,%eax
  810c1f:	0f 88 82 00 00 00    	js     810ca7 <pipe+0x125>
	if ((r = sys_page_map(0, va, 0, fd2data(fd1), PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
  810c25:	83 ec 0c             	sub    $0xc,%esp
  810c28:	ff 75 f0             	pushl  -0x10(%ebp)
  810c2b:	e8 d9 ed ff ff       	call   80fa09 <fd2data>
  810c30:	c7 04 24 07 04 00 00 	movl   $0x407,(%esp)
  810c37:	50                   	push   %eax
  810c38:	6a 00                	push   $0x0
  810c3a:	56                   	push   %esi
  810c3b:	6a 00                	push   $0x0
  810c3d:	e8 7f e7 ff ff       	call   80f3c1 <sys_page_map>
  810c42:	89 c3                	mov    %eax,%ebx
  810c44:	83 c4 20             	add    $0x20,%esp
  810c47:	85 c0                	test   %eax,%eax
  810c49:	78 4e                	js     810c99 <pipe+0x117>
	fd0->fd_dev_id = devpipe.dev_id;
  810c4b:	a1 24 43 81 00       	mov    0x814324,%eax
  810c50:	8b 55 f4             	mov    -0xc(%ebp),%edx
  810c53:	89 02                	mov    %eax,(%edx)
	fd0->fd_omode = O_RDONLY;
  810c55:	8b 55 f4             	mov    -0xc(%ebp),%edx
  810c58:	c7 42 08 00 00 00 00 	movl   $0x0,0x8(%edx)
	fd1->fd_dev_id = devpipe.dev_id;
  810c5f:	8b 55 f0             	mov    -0x10(%ebp),%edx
  810c62:	89 02                	mov    %eax,(%edx)
	fd1->fd_omode = O_WRONLY;
  810c64:	8b 45 f0             	mov    -0x10(%ebp),%eax
  810c67:	c7 40 08 01 00 00 00 	movl   $0x1,0x8(%eax)
	pfd[0] = fd2num(fd0);
  810c6e:	83 ec 0c             	sub    $0xc,%esp
  810c71:	ff 75 f4             	pushl  -0xc(%ebp)
  810c74:	e8 7c ed ff ff       	call   80f9f5 <fd2num>
  810c79:	8b 4d 08             	mov    0x8(%ebp),%ecx
  810c7c:	89 01                	mov    %eax,(%ecx)
	pfd[1] = fd2num(fd1);
  810c7e:	83 c4 04             	add    $0x4,%esp
  810c81:	ff 75 f0             	pushl  -0x10(%ebp)
  810c84:	e8 6c ed ff ff       	call   80f9f5 <fd2num>
  810c89:	8b 4d 08             	mov    0x8(%ebp),%ecx
  810c8c:	89 41 04             	mov    %eax,0x4(%ecx)
	return 0;
  810c8f:	83 c4 10             	add    $0x10,%esp
  810c92:	bb 00 00 00 00       	mov    $0x0,%ebx
  810c97:	eb 2e                	jmp    810cc7 <pipe+0x145>
	sys_page_unmap(0, va);
  810c99:	83 ec 08             	sub    $0x8,%esp
  810c9c:	56                   	push   %esi
  810c9d:	6a 00                	push   $0x0
  810c9f:	e8 63 e7 ff ff       	call   80f407 <sys_page_unmap>
  810ca4:	83 c4 10             	add    $0x10,%esp
	sys_page_unmap(0, fd1);
  810ca7:	83 ec 08             	sub    $0x8,%esp
  810caa:	ff 75 f0             	pushl  -0x10(%ebp)
  810cad:	6a 00                	push   $0x0
  810caf:	e8 53 e7 ff ff       	call   80f407 <sys_page_unmap>
  810cb4:	83 c4 10             	add    $0x10,%esp
	sys_page_unmap(0, fd0);
  810cb7:	83 ec 08             	sub    $0x8,%esp
  810cba:	ff 75 f4             	pushl  -0xc(%ebp)
  810cbd:	6a 00                	push   $0x0
  810cbf:	e8 43 e7 ff ff       	call   80f407 <sys_page_unmap>
  810cc4:	83 c4 10             	add    $0x10,%esp
}
  810cc7:	89 d8                	mov    %ebx,%eax
  810cc9:	8d 65 f8             	lea    -0x8(%ebp),%esp
  810ccc:	5b                   	pop    %ebx
  810ccd:	5e                   	pop    %esi
  810cce:	5d                   	pop    %ebp
  810ccf:	c3                   	ret    

00810cd0 <pipeisclosed>:
{
  810cd0:	f3 0f 1e fb          	endbr32 
  810cd4:	55                   	push   %ebp
  810cd5:	89 e5                	mov    %esp,%ebp
  810cd7:	83 ec 20             	sub    $0x20,%esp
	if ((r = fd_lookup(fdnum, &fd)) < 0)
  810cda:	8d 45 f4             	lea    -0xc(%ebp),%eax
  810cdd:	50                   	push   %eax
  810cde:	ff 75 08             	pushl  0x8(%ebp)
  810ce1:	e8 94 ed ff ff       	call   80fa7a <fd_lookup>
  810ce6:	83 c4 10             	add    $0x10,%esp
  810ce9:	85 c0                	test   %eax,%eax
  810ceb:	78 18                	js     810d05 <pipeisclosed+0x35>
	p = (struct Pipe*) fd2data(fd);
  810ced:	83 ec 0c             	sub    $0xc,%esp
  810cf0:	ff 75 f4             	pushl  -0xc(%ebp)
  810cf3:	e8 11 ed ff ff       	call   80fa09 <fd2data>
  810cf8:	89 c2                	mov    %eax,%edx
	return _pipeisclosed(fd, p);
  810cfa:	8b 45 f4             	mov    -0xc(%ebp),%eax
  810cfd:	e8 1f fd ff ff       	call   810a21 <_pipeisclosed>
  810d02:	83 c4 10             	add    $0x10,%esp
}
  810d05:	c9                   	leave  
  810d06:	c3                   	ret    

00810d07 <devcons_close>:
	return tot;
}

static int
devcons_close(struct Fd *fd)
{
  810d07:	f3 0f 1e fb          	endbr32 
	USED(fd);

	return 0;
}
  810d0b:	b8 00 00 00 00       	mov    $0x0,%eax
  810d10:	c3                   	ret    

00810d11 <devcons_stat>:

static int
devcons_stat(struct Fd *fd, struct Stat *stat)
{
  810d11:	f3 0f 1e fb          	endbr32 
  810d15:	55                   	push   %ebp
  810d16:	89 e5                	mov    %esp,%ebp
  810d18:	83 ec 10             	sub    $0x10,%esp
	strcpy(stat->st_name, "<cons>");
  810d1b:	68 82 3d 81 00       	push   $0x813d82
  810d20:	ff 75 0c             	pushl  0xc(%ebp)
  810d23:	e8 10 e2 ff ff       	call   80ef38 <strcpy>
	return 0;
}
  810d28:	b8 00 00 00 00       	mov    $0x0,%eax
  810d2d:	c9                   	leave  
  810d2e:	c3                   	ret    

00810d2f <devcons_write>:
{
  810d2f:	f3 0f 1e fb          	endbr32 
  810d33:	55                   	push   %ebp
  810d34:	89 e5                	mov    %esp,%ebp
  810d36:	57                   	push   %edi
  810d37:	56                   	push   %esi
  810d38:	53                   	push   %ebx
  810d39:	81 ec 8c 00 00 00    	sub    $0x8c,%esp
	for (tot = 0; tot < n; tot += m) {
  810d3f:	be 00 00 00 00       	mov    $0x0,%esi
		memmove(buf, (char*)vbuf + tot, m);
  810d44:	8d bd 68 ff ff ff    	lea    -0x98(%ebp),%edi
	for (tot = 0; tot < n; tot += m) {
  810d4a:	3b 75 10             	cmp    0x10(%ebp),%esi
  810d4d:	73 31                	jae    810d80 <devcons_write+0x51>
		m = n - tot;
  810d4f:	8b 5d 10             	mov    0x10(%ebp),%ebx
  810d52:	29 f3                	sub    %esi,%ebx
  810d54:	83 fb 7f             	cmp    $0x7f,%ebx
  810d57:	b8 7f 00 00 00       	mov    $0x7f,%eax
  810d5c:	0f 47 d8             	cmova  %eax,%ebx
		memmove(buf, (char*)vbuf + tot, m);
  810d5f:	83 ec 04             	sub    $0x4,%esp
  810d62:	53                   	push   %ebx
  810d63:	89 f0                	mov    %esi,%eax
  810d65:	03 45 0c             	add    0xc(%ebp),%eax
  810d68:	50                   	push   %eax
  810d69:	57                   	push   %edi
  810d6a:	e8 7f e3 ff ff       	call   80f0ee <memmove>
		sys_cputs(buf, m);
  810d6f:	83 c4 08             	add    $0x8,%esp
  810d72:	53                   	push   %ebx
  810d73:	57                   	push   %edi
  810d74:	e8 31 e5 ff ff       	call   80f2aa <sys_cputs>
	for (tot = 0; tot < n; tot += m) {
  810d79:	01 de                	add    %ebx,%esi
  810d7b:	83 c4 10             	add    $0x10,%esp
  810d7e:	eb ca                	jmp    810d4a <devcons_write+0x1b>
}
  810d80:	89 f0                	mov    %esi,%eax
  810d82:	8d 65 f4             	lea    -0xc(%ebp),%esp
  810d85:	5b                   	pop    %ebx
  810d86:	5e                   	pop    %esi
  810d87:	5f                   	pop    %edi
  810d88:	5d                   	pop    %ebp
  810d89:	c3                   	ret    

00810d8a <devcons_read>:
{
  810d8a:	f3 0f 1e fb          	endbr32 
  810d8e:	55                   	push   %ebp
  810d8f:	89 e5                	mov    %esp,%ebp
  810d91:	83 ec 08             	sub    $0x8,%esp
  810d94:	b8 00 00 00 00       	mov    $0x0,%eax
	if (n == 0)
  810d99:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  810d9d:	74 21                	je     810dc0 <devcons_read+0x36>
	while ((c = sys_cgetc()) == 0)
  810d9f:	e8 28 e5 ff ff       	call   80f2cc <sys_cgetc>
  810da4:	85 c0                	test   %eax,%eax
  810da6:	75 07                	jne    810daf <devcons_read+0x25>
		sys_yield();
  810da8:	e8 aa e5 ff ff       	call   80f357 <sys_yield>
  810dad:	eb f0                	jmp    810d9f <devcons_read+0x15>
	if (c < 0)
  810daf:	78 0f                	js     810dc0 <devcons_read+0x36>
	if (c == 0x04)	// ctl-d is eof
  810db1:	83 f8 04             	cmp    $0x4,%eax
  810db4:	74 0c                	je     810dc2 <devcons_read+0x38>
	*(char*)vbuf = c;
  810db6:	8b 55 0c             	mov    0xc(%ebp),%edx
  810db9:	88 02                	mov    %al,(%edx)
	return 1;
  810dbb:	b8 01 00 00 00       	mov    $0x1,%eax
}
  810dc0:	c9                   	leave  
  810dc1:	c3                   	ret    
		return 0;
  810dc2:	b8 00 00 00 00       	mov    $0x0,%eax
  810dc7:	eb f7                	jmp    810dc0 <devcons_read+0x36>

00810dc9 <cputchar>:
{
  810dc9:	f3 0f 1e fb          	endbr32 
  810dcd:	55                   	push   %ebp
  810dce:	89 e5                	mov    %esp,%ebp
  810dd0:	83 ec 20             	sub    $0x20,%esp
	char c = ch;
  810dd3:	8b 45 08             	mov    0x8(%ebp),%eax
  810dd6:	88 45 f7             	mov    %al,-0x9(%ebp)
	sys_cputs(&c, 1);
  810dd9:	6a 01                	push   $0x1
  810ddb:	8d 45 f7             	lea    -0x9(%ebp),%eax
  810dde:	50                   	push   %eax
  810ddf:	e8 c6 e4 ff ff       	call   80f2aa <sys_cputs>
}
  810de4:	83 c4 10             	add    $0x10,%esp
  810de7:	c9                   	leave  
  810de8:	c3                   	ret    

00810de9 <getchar>:
{
  810de9:	f3 0f 1e fb          	endbr32 
  810ded:	55                   	push   %ebp
  810dee:	89 e5                	mov    %esp,%ebp
  810df0:	83 ec 1c             	sub    $0x1c,%esp
	r = read(0, &c, 1);
  810df3:	6a 01                	push   $0x1
  810df5:	8d 45 f7             	lea    -0x9(%ebp),%eax
  810df8:	50                   	push   %eax
  810df9:	6a 00                	push   $0x0
  810dfb:	e8 02 ef ff ff       	call   80fd02 <read>
	if (r < 0)
  810e00:	83 c4 10             	add    $0x10,%esp
  810e03:	85 c0                	test   %eax,%eax
  810e05:	78 06                	js     810e0d <getchar+0x24>
	if (r < 1)
  810e07:	74 06                	je     810e0f <getchar+0x26>
	return c;
  810e09:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
}
  810e0d:	c9                   	leave  
  810e0e:	c3                   	ret    
		return -E_EOF;
  810e0f:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
  810e14:	eb f7                	jmp    810e0d <getchar+0x24>

00810e16 <iscons>:
{
  810e16:	f3 0f 1e fb          	endbr32 
  810e1a:	55                   	push   %ebp
  810e1b:	89 e5                	mov    %esp,%ebp
  810e1d:	83 ec 20             	sub    $0x20,%esp
	if ((r = fd_lookup(fdnum, &fd)) < 0)
  810e20:	8d 45 f4             	lea    -0xc(%ebp),%eax
  810e23:	50                   	push   %eax
  810e24:	ff 75 08             	pushl  0x8(%ebp)
  810e27:	e8 4e ec ff ff       	call   80fa7a <fd_lookup>
  810e2c:	83 c4 10             	add    $0x10,%esp
  810e2f:	85 c0                	test   %eax,%eax
  810e31:	78 11                	js     810e44 <iscons+0x2e>
	return fd->fd_dev_id == devcons.dev_id;
  810e33:	8b 45 f4             	mov    -0xc(%ebp),%eax
  810e36:	8b 15 40 43 81 00    	mov    0x814340,%edx
  810e3c:	39 10                	cmp    %edx,(%eax)
  810e3e:	0f 94 c0             	sete   %al
  810e41:	0f b6 c0             	movzbl %al,%eax
}
  810e44:	c9                   	leave  
  810e45:	c3                   	ret    

00810e46 <opencons>:
{
  810e46:	f3 0f 1e fb          	endbr32 
  810e4a:	55                   	push   %ebp
  810e4b:	89 e5                	mov    %esp,%ebp
  810e4d:	83 ec 24             	sub    $0x24,%esp
	if ((r = fd_alloc(&fd)) < 0)
  810e50:	8d 45 f4             	lea    -0xc(%ebp),%eax
  810e53:	50                   	push   %eax
  810e54:	e8 cb eb ff ff       	call   80fa24 <fd_alloc>
  810e59:	83 c4 10             	add    $0x10,%esp
  810e5c:	85 c0                	test   %eax,%eax
  810e5e:	78 3a                	js     810e9a <opencons+0x54>
	if ((r = sys_page_alloc(0, fd, PTE_P|PTE_U|PTE_W|PTE_SHARE)) < 0)
  810e60:	83 ec 04             	sub    $0x4,%esp
  810e63:	68 07 04 00 00       	push   $0x407
  810e68:	ff 75 f4             	pushl  -0xc(%ebp)
  810e6b:	6a 00                	push   $0x0
  810e6d:	e8 08 e5 ff ff       	call   80f37a <sys_page_alloc>
  810e72:	83 c4 10             	add    $0x10,%esp
  810e75:	85 c0                	test   %eax,%eax
  810e77:	78 21                	js     810e9a <opencons+0x54>
	fd->fd_dev_id = devcons.dev_id;
  810e79:	8b 45 f4             	mov    -0xc(%ebp),%eax
  810e7c:	8b 15 40 43 81 00    	mov    0x814340,%edx
  810e82:	89 10                	mov    %edx,(%eax)
	fd->fd_omode = O_RDWR;
  810e84:	8b 45 f4             	mov    -0xc(%ebp),%eax
  810e87:	c7 40 08 02 00 00 00 	movl   $0x2,0x8(%eax)
	return fd2num(fd);
  810e8e:	83 ec 0c             	sub    $0xc,%esp
  810e91:	50                   	push   %eax
  810e92:	e8 5e eb ff ff       	call   80f9f5 <fd2num>
  810e97:	83 c4 10             	add    $0x10,%esp
}
  810e9a:	c9                   	leave  
  810e9b:	c3                   	ret    

00810e9c <set_pgfault_handler>:
// at UXSTACKTOP), and tell the kernel to call the assembly-language
// _pgfault_upcall routine when a page fault occurs.
//
void
set_pgfault_handler(void (*handler)(struct UTrapframe *utf))
{
  810e9c:	f3 0f 1e fb          	endbr32 
  810ea0:	55                   	push   %ebp
  810ea1:	89 e5                	mov    %esp,%ebp
  810ea3:	83 ec 08             	sub    $0x8,%esp
	int r;

	if (_pgfault_handler == 0) {
  810ea6:	83 3d 00 e0 b3 00 00 	cmpl   $0x0,0xb3e000
  810ead:	74 0a                	je     810eb9 <set_pgfault_handler+0x1d>
			panic("set_pgfault_handler set_pgfault_upcall failed");
		}
	}

	// Save handler pointer for assembly to call.
	_pgfault_handler = handler;
  810eaf:	8b 45 08             	mov    0x8(%ebp),%eax
  810eb2:	a3 00 e0 b3 00       	mov    %eax,0xb3e000
}
  810eb7:	c9                   	leave  
  810eb8:	c3                   	ret    
		if(sys_page_alloc(thisenv->env_id, (void *)(UXSTACKTOP - PGSIZE), PTE_W | PTE_U | PTE_P)){
  810eb9:	a1 5c b2 b3 00       	mov    0xb3b25c,%eax
  810ebe:	8b 40 48             	mov    0x48(%eax),%eax
  810ec1:	83 ec 04             	sub    $0x4,%esp
  810ec4:	6a 07                	push   $0x7
  810ec6:	68 00 f0 bf ee       	push   $0xeebff000
  810ecb:	50                   	push   %eax
  810ecc:	e8 a9 e4 ff ff       	call   80f37a <sys_page_alloc>
  810ed1:	83 c4 10             	add    $0x10,%esp
  810ed4:	85 c0                	test   %eax,%eax
  810ed6:	75 31                	jne    810f09 <set_pgfault_handler+0x6d>
		if(sys_env_set_pgfault_upcall(thisenv->env_id, _pgfault_upcall)){
  810ed8:	a1 5c b2 b3 00       	mov    0xb3b25c,%eax
  810edd:	8b 40 48             	mov    0x48(%eax),%eax
  810ee0:	83 ec 08             	sub    $0x8,%esp
  810ee3:	68 1d 0f 81 00       	push   $0x810f1d
  810ee8:	50                   	push   %eax
  810ee9:	e8 eb e5 ff ff       	call   80f4d9 <sys_env_set_pgfault_upcall>
  810eee:	83 c4 10             	add    $0x10,%esp
  810ef1:	85 c0                	test   %eax,%eax
  810ef3:	74 ba                	je     810eaf <set_pgfault_handler+0x13>
			panic("set_pgfault_handler set_pgfault_upcall failed");
  810ef5:	83 ec 04             	sub    $0x4,%esp
  810ef8:	68 b8 3d 81 00       	push   $0x813db8
  810efd:	6a 24                	push   $0x24
  810eff:	68 e6 3d 81 00       	push   $0x813de6
  810f04:	e8 3e d9 ff ff       	call   80e847 <_panic>
			panic("set_pgfault_handler page_alloc failed");
  810f09:	83 ec 04             	sub    $0x4,%esp
  810f0c:	68 90 3d 81 00       	push   $0x813d90
  810f11:	6a 21                	push   $0x21
  810f13:	68 e6 3d 81 00       	push   $0x813de6
  810f18:	e8 2a d9 ff ff       	call   80e847 <_panic>

00810f1d <_pgfault_upcall>:

.text
.globl _pgfault_upcall
_pgfault_upcall:
	// Call the C page fault handler.
	pushl %esp			// function argument: pointer to UTF
  810f1d:	54                   	push   %esp
	movl _pgfault_handler, %eax
  810f1e:	a1 00 e0 b3 00       	mov    0xb3e000,%eax
	call *%eax
  810f23:	ff d0                	call   *%eax
	addl $4, %esp			// pop function argument
  810f25:	83 c4 04             	add    $0x4,%esp
	// may find that you have to rearrange your code in non-obvious
	// ways as registers become unavailable as scratch space.
	//
	// LAB 4: Your code here.

    movl 0x28(%esp), %ebx  # trap-time eip
  810f28:	8b 5c 24 28          	mov    0x28(%esp),%ebx
    subl $0x4, 0x30(%esp)  # trap-time esp minus 4
  810f2c:	83 6c 24 30 04       	subl   $0x4,0x30(%esp)
    movl 0x30(%esp), %eax 
  810f31:	8b 44 24 30          	mov    0x30(%esp),%eax
    movl %ebx, (%eax)      # trap-time esp store trap-time eip
  810f35:	89 18                	mov    %ebx,(%eax)
    addl $0x8, %esp 
  810f37:	83 c4 08             	add    $0x8,%esp

	// Restore the trap-time registers.  After you do this, you
	// can no longer modify any general-purpose registers.
	// LAB 4: Your code here.

	popal
  810f3a:	61                   	popa   
	// Restore eflags from the stack.  After you do this, you can
	// no longer use arithmetic operations or anything else that
	// modifies eflags.
	// LAB 4: Your code here.

	addl $0x4, %esp
  810f3b:	83 c4 04             	add    $0x4,%esp
    popfl
  810f3e:	9d                   	popf   

	// Switch back to the adjusted trap-time stack.
	// LAB 4: Your code here.

	popl %esp
  810f3f:	5c                   	pop    %esp

	// Return to re-execute the instruction that faulted.
	// LAB 4: Your code here.

  810f40:	c3                   	ret    

00810f41 <pageref>:
#include <inc/lib.h>

int
pageref(void *v)
{
  810f41:	f3 0f 1e fb          	endbr32 
  810f45:	55                   	push   %ebp
  810f46:	89 e5                	mov    %esp,%ebp
  810f48:	8b 45 08             	mov    0x8(%ebp),%eax
	pte_t pte;

	if (!(uvpd[PDX(v)] & PTE_P))
  810f4b:	89 c2                	mov    %eax,%edx
  810f4d:	c1 ea 16             	shr    $0x16,%edx
  810f50:	8b 0c 95 00 d0 7b ef 	mov    -0x10843000(,%edx,4),%ecx
		return 0;
  810f57:	ba 00 00 00 00       	mov    $0x0,%edx
	if (!(uvpd[PDX(v)] & PTE_P))
  810f5c:	f6 c1 01             	test   $0x1,%cl
  810f5f:	74 1c                	je     810f7d <pageref+0x3c>
	pte = uvpt[PGNUM(v)];
  810f61:	c1 e8 0c             	shr    $0xc,%eax
  810f64:	8b 04 85 00 00 40 ef 	mov    -0x10c00000(,%eax,4),%eax
	if (!(pte & PTE_P))
  810f6b:	a8 01                	test   $0x1,%al
  810f6d:	74 0e                	je     810f7d <pageref+0x3c>
		return 0;
	return pages[PGNUM(pte)].pp_ref;
  810f6f:	c1 e8 0c             	shr    $0xc,%eax
  810f72:	0f b7 14 c5 04 00 00 	movzwl -0x10fffffc(,%eax,8),%edx
  810f79:	ef 
  810f7a:	0f b7 d2             	movzwl %dx,%edx
}
  810f7d:	89 d0                	mov    %edx,%eax
  810f7f:	5d                   	pop    %ebp
  810f80:	c3                   	ret    
  810f81:	66 90                	xchg   %ax,%ax
  810f83:	66 90                	xchg   %ax,%ax
  810f85:	66 90                	xchg   %ax,%ax
  810f87:	66 90                	xchg   %ax,%ax
  810f89:	66 90                	xchg   %ax,%ax
  810f8b:	66 90                	xchg   %ax,%ax
  810f8d:	66 90                	xchg   %ax,%ax
  810f8f:	90                   	nop

00810f90 <__udivdi3>:
  810f90:	f3 0f 1e fb          	endbr32 
  810f94:	55                   	push   %ebp
  810f95:	57                   	push   %edi
  810f96:	56                   	push   %esi
  810f97:	53                   	push   %ebx
  810f98:	83 ec 1c             	sub    $0x1c,%esp
  810f9b:	8b 54 24 3c          	mov    0x3c(%esp),%edx
  810f9f:	8b 6c 24 30          	mov    0x30(%esp),%ebp
  810fa3:	8b 74 24 34          	mov    0x34(%esp),%esi
  810fa7:	8b 5c 24 38          	mov    0x38(%esp),%ebx
  810fab:	85 d2                	test   %edx,%edx
  810fad:	75 19                	jne    810fc8 <__udivdi3+0x38>
  810faf:	39 f3                	cmp    %esi,%ebx
  810fb1:	76 4d                	jbe    811000 <__udivdi3+0x70>
  810fb3:	31 ff                	xor    %edi,%edi
  810fb5:	89 e8                	mov    %ebp,%eax
  810fb7:	89 f2                	mov    %esi,%edx
  810fb9:	f7 f3                	div    %ebx
  810fbb:	89 fa                	mov    %edi,%edx
  810fbd:	83 c4 1c             	add    $0x1c,%esp
  810fc0:	5b                   	pop    %ebx
  810fc1:	5e                   	pop    %esi
  810fc2:	5f                   	pop    %edi
  810fc3:	5d                   	pop    %ebp
  810fc4:	c3                   	ret    
  810fc5:	8d 76 00             	lea    0x0(%esi),%esi
  810fc8:	39 f2                	cmp    %esi,%edx
  810fca:	76 14                	jbe    810fe0 <__udivdi3+0x50>
  810fcc:	31 ff                	xor    %edi,%edi
  810fce:	31 c0                	xor    %eax,%eax
  810fd0:	89 fa                	mov    %edi,%edx
  810fd2:	83 c4 1c             	add    $0x1c,%esp
  810fd5:	5b                   	pop    %ebx
  810fd6:	5e                   	pop    %esi
  810fd7:	5f                   	pop    %edi
  810fd8:	5d                   	pop    %ebp
  810fd9:	c3                   	ret    
  810fda:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  810fe0:	0f bd fa             	bsr    %edx,%edi
  810fe3:	83 f7 1f             	xor    $0x1f,%edi
  810fe6:	75 48                	jne    811030 <__udivdi3+0xa0>
  810fe8:	39 f2                	cmp    %esi,%edx
  810fea:	72 06                	jb     810ff2 <__udivdi3+0x62>
  810fec:	31 c0                	xor    %eax,%eax
  810fee:	39 eb                	cmp    %ebp,%ebx
  810ff0:	77 de                	ja     810fd0 <__udivdi3+0x40>
  810ff2:	b8 01 00 00 00       	mov    $0x1,%eax
  810ff7:	eb d7                	jmp    810fd0 <__udivdi3+0x40>
  810ff9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  811000:	89 d9                	mov    %ebx,%ecx
  811002:	85 db                	test   %ebx,%ebx
  811004:	75 0b                	jne    811011 <__udivdi3+0x81>
  811006:	b8 01 00 00 00       	mov    $0x1,%eax
  81100b:	31 d2                	xor    %edx,%edx
  81100d:	f7 f3                	div    %ebx
  81100f:	89 c1                	mov    %eax,%ecx
  811011:	31 d2                	xor    %edx,%edx
  811013:	89 f0                	mov    %esi,%eax
  811015:	f7 f1                	div    %ecx
  811017:	89 c6                	mov    %eax,%esi
  811019:	89 e8                	mov    %ebp,%eax
  81101b:	89 f7                	mov    %esi,%edi
  81101d:	f7 f1                	div    %ecx
  81101f:	89 fa                	mov    %edi,%edx
  811021:	83 c4 1c             	add    $0x1c,%esp
  811024:	5b                   	pop    %ebx
  811025:	5e                   	pop    %esi
  811026:	5f                   	pop    %edi
  811027:	5d                   	pop    %ebp
  811028:	c3                   	ret    
  811029:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  811030:	89 f9                	mov    %edi,%ecx
  811032:	b8 20 00 00 00       	mov    $0x20,%eax
  811037:	29 f8                	sub    %edi,%eax
  811039:	d3 e2                	shl    %cl,%edx
  81103b:	89 54 24 08          	mov    %edx,0x8(%esp)
  81103f:	89 c1                	mov    %eax,%ecx
  811041:	89 da                	mov    %ebx,%edx
  811043:	d3 ea                	shr    %cl,%edx
  811045:	8b 4c 24 08          	mov    0x8(%esp),%ecx
  811049:	09 d1                	or     %edx,%ecx
  81104b:	89 f2                	mov    %esi,%edx
  81104d:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  811051:	89 f9                	mov    %edi,%ecx
  811053:	d3 e3                	shl    %cl,%ebx
  811055:	89 c1                	mov    %eax,%ecx
  811057:	d3 ea                	shr    %cl,%edx
  811059:	89 f9                	mov    %edi,%ecx
  81105b:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
  81105f:	89 eb                	mov    %ebp,%ebx
  811061:	d3 e6                	shl    %cl,%esi
  811063:	89 c1                	mov    %eax,%ecx
  811065:	d3 eb                	shr    %cl,%ebx
  811067:	09 de                	or     %ebx,%esi
  811069:	89 f0                	mov    %esi,%eax
  81106b:	f7 74 24 08          	divl   0x8(%esp)
  81106f:	89 d6                	mov    %edx,%esi
  811071:	89 c3                	mov    %eax,%ebx
  811073:	f7 64 24 0c          	mull   0xc(%esp)
  811077:	39 d6                	cmp    %edx,%esi
  811079:	72 15                	jb     811090 <__udivdi3+0x100>
  81107b:	89 f9                	mov    %edi,%ecx
  81107d:	d3 e5                	shl    %cl,%ebp
  81107f:	39 c5                	cmp    %eax,%ebp
  811081:	73 04                	jae    811087 <__udivdi3+0xf7>
  811083:	39 d6                	cmp    %edx,%esi
  811085:	74 09                	je     811090 <__udivdi3+0x100>
  811087:	89 d8                	mov    %ebx,%eax
  811089:	31 ff                	xor    %edi,%edi
  81108b:	e9 40 ff ff ff       	jmp    810fd0 <__udivdi3+0x40>
  811090:	8d 43 ff             	lea    -0x1(%ebx),%eax
  811093:	31 ff                	xor    %edi,%edi
  811095:	e9 36 ff ff ff       	jmp    810fd0 <__udivdi3+0x40>
  81109a:	66 90                	xchg   %ax,%ax
  81109c:	66 90                	xchg   %ax,%ax
  81109e:	66 90                	xchg   %ax,%ax

008110a0 <__umoddi3>:
  8110a0:	f3 0f 1e fb          	endbr32 
  8110a4:	55                   	push   %ebp
  8110a5:	57                   	push   %edi
  8110a6:	56                   	push   %esi
  8110a7:	53                   	push   %ebx
  8110a8:	83 ec 1c             	sub    $0x1c,%esp
  8110ab:	8b 44 24 3c          	mov    0x3c(%esp),%eax
  8110af:	8b 74 24 30          	mov    0x30(%esp),%esi
  8110b3:	8b 5c 24 34          	mov    0x34(%esp),%ebx
  8110b7:	8b 7c 24 38          	mov    0x38(%esp),%edi
  8110bb:	85 c0                	test   %eax,%eax
  8110bd:	75 19                	jne    8110d8 <__umoddi3+0x38>
  8110bf:	39 df                	cmp    %ebx,%edi
  8110c1:	76 5d                	jbe    811120 <__umoddi3+0x80>
  8110c3:	89 f0                	mov    %esi,%eax
  8110c5:	89 da                	mov    %ebx,%edx
  8110c7:	f7 f7                	div    %edi
  8110c9:	89 d0                	mov    %edx,%eax
  8110cb:	31 d2                	xor    %edx,%edx
  8110cd:	83 c4 1c             	add    $0x1c,%esp
  8110d0:	5b                   	pop    %ebx
  8110d1:	5e                   	pop    %esi
  8110d2:	5f                   	pop    %edi
  8110d3:	5d                   	pop    %ebp
  8110d4:	c3                   	ret    
  8110d5:	8d 76 00             	lea    0x0(%esi),%esi
  8110d8:	89 f2                	mov    %esi,%edx
  8110da:	39 d8                	cmp    %ebx,%eax
  8110dc:	76 12                	jbe    8110f0 <__umoddi3+0x50>
  8110de:	89 f0                	mov    %esi,%eax
  8110e0:	89 da                	mov    %ebx,%edx
  8110e2:	83 c4 1c             	add    $0x1c,%esp
  8110e5:	5b                   	pop    %ebx
  8110e6:	5e                   	pop    %esi
  8110e7:	5f                   	pop    %edi
  8110e8:	5d                   	pop    %ebp
  8110e9:	c3                   	ret    
  8110ea:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  8110f0:	0f bd e8             	bsr    %eax,%ebp
  8110f3:	83 f5 1f             	xor    $0x1f,%ebp
  8110f6:	75 50                	jne    811148 <__umoddi3+0xa8>
  8110f8:	39 d8                	cmp    %ebx,%eax
  8110fa:	0f 82 e0 00 00 00    	jb     8111e0 <__umoddi3+0x140>
  811100:	89 d9                	mov    %ebx,%ecx
  811102:	39 f7                	cmp    %esi,%edi
  811104:	0f 86 d6 00 00 00    	jbe    8111e0 <__umoddi3+0x140>
  81110a:	89 d0                	mov    %edx,%eax
  81110c:	89 ca                	mov    %ecx,%edx
  81110e:	83 c4 1c             	add    $0x1c,%esp
  811111:	5b                   	pop    %ebx
  811112:	5e                   	pop    %esi
  811113:	5f                   	pop    %edi
  811114:	5d                   	pop    %ebp
  811115:	c3                   	ret    
  811116:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  81111d:	8d 76 00             	lea    0x0(%esi),%esi
  811120:	89 fd                	mov    %edi,%ebp
  811122:	85 ff                	test   %edi,%edi
  811124:	75 0b                	jne    811131 <__umoddi3+0x91>
  811126:	b8 01 00 00 00       	mov    $0x1,%eax
  81112b:	31 d2                	xor    %edx,%edx
  81112d:	f7 f7                	div    %edi
  81112f:	89 c5                	mov    %eax,%ebp
  811131:	89 d8                	mov    %ebx,%eax
  811133:	31 d2                	xor    %edx,%edx
  811135:	f7 f5                	div    %ebp
  811137:	89 f0                	mov    %esi,%eax
  811139:	f7 f5                	div    %ebp
  81113b:	89 d0                	mov    %edx,%eax
  81113d:	31 d2                	xor    %edx,%edx
  81113f:	eb 8c                	jmp    8110cd <__umoddi3+0x2d>
  811141:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  811148:	89 e9                	mov    %ebp,%ecx
  81114a:	ba 20 00 00 00       	mov    $0x20,%edx
  81114f:	29 ea                	sub    %ebp,%edx
  811151:	d3 e0                	shl    %cl,%eax
  811153:	89 44 24 08          	mov    %eax,0x8(%esp)
  811157:	89 d1                	mov    %edx,%ecx
  811159:	89 f8                	mov    %edi,%eax
  81115b:	d3 e8                	shr    %cl,%eax
  81115d:	8b 4c 24 08          	mov    0x8(%esp),%ecx
  811161:	89 54 24 04          	mov    %edx,0x4(%esp)
  811165:	8b 54 24 04          	mov    0x4(%esp),%edx
  811169:	09 c1                	or     %eax,%ecx
  81116b:	89 d8                	mov    %ebx,%eax
  81116d:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  811171:	89 e9                	mov    %ebp,%ecx
  811173:	d3 e7                	shl    %cl,%edi
  811175:	89 d1                	mov    %edx,%ecx
  811177:	d3 e8                	shr    %cl,%eax
  811179:	89 e9                	mov    %ebp,%ecx
  81117b:	89 7c 24 0c          	mov    %edi,0xc(%esp)
  81117f:	d3 e3                	shl    %cl,%ebx
  811181:	89 c7                	mov    %eax,%edi
  811183:	89 d1                	mov    %edx,%ecx
  811185:	89 f0                	mov    %esi,%eax
  811187:	d3 e8                	shr    %cl,%eax
  811189:	89 e9                	mov    %ebp,%ecx
  81118b:	89 fa                	mov    %edi,%edx
  81118d:	d3 e6                	shl    %cl,%esi
  81118f:	09 d8                	or     %ebx,%eax
  811191:	f7 74 24 08          	divl   0x8(%esp)
  811195:	89 d1                	mov    %edx,%ecx
  811197:	89 f3                	mov    %esi,%ebx
  811199:	f7 64 24 0c          	mull   0xc(%esp)
  81119d:	89 c6                	mov    %eax,%esi
  81119f:	89 d7                	mov    %edx,%edi
  8111a1:	39 d1                	cmp    %edx,%ecx
  8111a3:	72 06                	jb     8111ab <__umoddi3+0x10b>
  8111a5:	75 10                	jne    8111b7 <__umoddi3+0x117>
  8111a7:	39 c3                	cmp    %eax,%ebx
  8111a9:	73 0c                	jae    8111b7 <__umoddi3+0x117>
  8111ab:	2b 44 24 0c          	sub    0xc(%esp),%eax
  8111af:	1b 54 24 08          	sbb    0x8(%esp),%edx
  8111b3:	89 d7                	mov    %edx,%edi
  8111b5:	89 c6                	mov    %eax,%esi
  8111b7:	89 ca                	mov    %ecx,%edx
  8111b9:	0f b6 4c 24 04       	movzbl 0x4(%esp),%ecx
  8111be:	29 f3                	sub    %esi,%ebx
  8111c0:	19 fa                	sbb    %edi,%edx
  8111c2:	89 d0                	mov    %edx,%eax
  8111c4:	d3 e0                	shl    %cl,%eax
  8111c6:	89 e9                	mov    %ebp,%ecx
  8111c8:	d3 eb                	shr    %cl,%ebx
  8111ca:	d3 ea                	shr    %cl,%edx
  8111cc:	09 d8                	or     %ebx,%eax
  8111ce:	83 c4 1c             	add    $0x1c,%esp
  8111d1:	5b                   	pop    %ebx
  8111d2:	5e                   	pop    %esi
  8111d3:	5f                   	pop    %edi
  8111d4:	5d                   	pop    %ebp
  8111d5:	c3                   	ret    
  8111d6:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  8111dd:	8d 76 00             	lea    0x0(%esi),%esi
  8111e0:	29 fe                	sub    %edi,%esi
  8111e2:	19 c3                	sbb    %eax,%ebx
  8111e4:	89 f2                	mov    %esi,%edx
  8111e6:	89 d9                	mov    %ebx,%ecx
  8111e8:	e9 1d ff ff ff       	jmp    81110a <__umoddi3+0x6a>
